<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › chelsio › cxgb4vf › cxgb4vf_main.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>cxgb4vf_main.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is part of the Chelsio T4 PCI-E SR-IOV Virtual Function Ethernet</span>
<span class="cm"> * driver for Linux.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2009-2010 Chelsio Communications, Inc. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This software is available to you under a choice of one of two</span>
<span class="cm"> * licenses.  You may choose to be licensed under the terms of the GNU</span>
<span class="cm"> * General Public License (GPL) Version 2, available from the file</span>
<span class="cm"> * COPYING in the main directory of this source tree, or the</span>
<span class="cm"> * OpenIB.org BSD license below:</span>
<span class="cm"> *</span>
<span class="cm"> *     Redistribution and use in source and binary forms, with or</span>
<span class="cm"> *     without modification, are permitted provided that the following</span>
<span class="cm"> *     conditions are met:</span>
<span class="cm"> *</span>
<span class="cm"> *      - Redistributions of source code must retain the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer.</span>
<span class="cm"> *</span>
<span class="cm"> *      - Redistributions in binary form must reproduce the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer in the documentation and/or other materials</span>
<span class="cm"> *        provided with the distribution.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="cm"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="cm"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS</span>
<span class="cm"> * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN</span>
<span class="cm"> * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span>
<span class="cm"> * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="cm"> * SOFTWARE.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>

<span class="cp">#include &quot;t4vf_common.h&quot;</span>
<span class="cp">#include &quot;t4vf_defs.h&quot;</span>

<span class="cp">#include &quot;../cxgb4/t4_regs.h&quot;</span>
<span class="cp">#include &quot;../cxgb4/t4_msg.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Generic information about the driver.</span>
<span class="cm"> */</span>
<span class="cp">#define DRV_VERSION &quot;1.0.0&quot;</span>
<span class="cp">#define DRV_DESC &quot;Chelsio T4 Virtual Function (VF) Network Driver&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Module Parameters.</span>
<span class="cm"> * ==================</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Default ethtool &quot;message level&quot; for adapters.</span>
<span class="cm"> */</span>
<span class="cp">#define DFLT_MSG_ENABLE (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK | \</span>
<span class="cp">			 NETIF_MSG_TIMER | NETIF_MSG_IFDOWN | NETIF_MSG_IFUP |\</span>
<span class="cp">			 NETIF_MSG_RX_ERR | NETIF_MSG_TX_ERR)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">dflt_msg_enable</span> <span class="o">=</span> <span class="n">DFLT_MSG_ENABLE</span><span class="p">;</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">dflt_msg_enable</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">dflt_msg_enable</span><span class="p">,</span>
		 <span class="s">&quot;default adapter ethtool message level bitmap&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The driver uses the best interrupt scheme available on a platform in the</span>
<span class="cm"> * order MSI-X then MSI.  This parameter determines which of these schemes the</span>
<span class="cm"> * driver may consider as follows:</span>
<span class="cm"> *</span>
<span class="cm"> *     msi = 2: choose from among MSI-X and MSI</span>
<span class="cm"> *     msi = 1: only consider MSI interrupts</span>
<span class="cm"> *</span>
<span class="cm"> * Note that unlike the Physical Function driver, this Virtual Function driver</span>
<span class="cm"> * does _not_ support legacy INTx interrupts (this limitation is mandated by</span>
<span class="cm"> * the PCI-E SR-IOV standard).</span>
<span class="cm"> */</span>
<span class="cp">#define MSI_MSIX	2</span>
<span class="cp">#define MSI_MSI		1</span>
<span class="cp">#define MSI_DEFAULT	MSI_MSIX</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">msi</span> <span class="o">=</span> <span class="n">MSI_DEFAULT</span><span class="p">;</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">msi</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">msi</span><span class="p">,</span> <span class="s">&quot;whether to use MSI-X or MSI&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Fundamental constants.</span>
<span class="cm"> * ======================</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">MAX_TXQ_ENTRIES</span>		<span class="o">=</span> <span class="mi">16384</span><span class="p">,</span>
	<span class="n">MAX_RSPQ_ENTRIES</span>	<span class="o">=</span> <span class="mi">16384</span><span class="p">,</span>
	<span class="n">MAX_RX_BUFFERS</span>		<span class="o">=</span> <span class="mi">16384</span><span class="p">,</span>

	<span class="n">MIN_TXQ_ENTRIES</span>		<span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
	<span class="n">MIN_RSPQ_ENTRIES</span>	<span class="o">=</span> <span class="mi">128</span><span class="p">,</span>
	<span class="n">MIN_FL_ENTRIES</span>		<span class="o">=</span> <span class="mi">16</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * For purposes of manipulating the Free List size we need to</span>
<span class="cm">	 * recognize that Free Lists are actually Egress Queues (the host</span>
<span class="cm">	 * produces free buffers which the hardware consumes), Egress Queues</span>
<span class="cm">	 * indices are all in units of Egress Context Units bytes, and free</span>
<span class="cm">	 * list entries are 64-bit PCI DMA addresses.  And since the state of</span>
<span class="cm">	 * the Producer Index == the Consumer Index implies an EMPTY list, we</span>
<span class="cm">	 * always have at least one Egress Unit&#39;s worth of Free List entries</span>
<span class="cm">	 * unused.  See sge.c for more details ...</span>
<span class="cm">	 */</span>
	<span class="n">EQ_UNIT</span> <span class="o">=</span> <span class="n">SGE_EQ_IDXSIZE</span><span class="p">,</span>
	<span class="n">FL_PER_EQ_UNIT</span> <span class="o">=</span> <span class="n">EQ_UNIT</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__be64</span><span class="p">),</span>
	<span class="n">MIN_FL_RESID</span> <span class="o">=</span> <span class="n">FL_PER_EQ_UNIT</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Global driver state.</span>
<span class="cm"> * ====================</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">cxgb4vf_debugfs_root</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * OS &quot;Callback&quot; functions.</span>
<span class="cm"> * ========================</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The link status has changed on the indicated &quot;port&quot; (Virtual Interface).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">t4vf_os_link_changed</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pidx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">link_ok</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">pidx</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the port is disabled or the current recorded &quot;link up&quot;</span>
<span class="cm">	 * status matches the new status, just return.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">||</span> <span class="n">link_ok</span> <span class="o">==</span> <span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Tell the OS that the link status has changed and print a short</span>
<span class="cm">	 * informative message on the console about the event.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">link_ok</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fc</span><span class="p">;</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">link_cfg</span><span class="p">.</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SPEED_10000</span>:
			<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;10Gbps&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SPEED_1000</span>:
			<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;1000Mbps&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SPEED_100</span>:
			<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;100Mbps&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">link_cfg</span><span class="p">.</span><span class="n">fc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">PAUSE_RX</span>:
			<span class="n">fc</span> <span class="o">=</span> <span class="s">&quot;RX&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">PAUSE_TX</span>:
			<span class="n">fc</span> <span class="o">=</span> <span class="s">&quot;TX&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">PAUSE_RX</span><span class="o">|</span><span class="n">PAUSE_TX</span>:
			<span class="n">fc</span> <span class="o">=</span> <span class="s">&quot;RX/TX&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">fc</span> <span class="o">=</span> <span class="s">&quot;no&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: link up, %s, full-duplex, %s PAUSE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: link down</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Net device operations.</span>
<span class="cm"> * ======================</span>
<span class="cm"> */</span>




<span class="cm">/*</span>
<span class="cm"> * Perform the MAC and PHY actions needed to enable a &quot;port&quot; (Virtual</span>
<span class="cm"> * Interface).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">link_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We do not set address filters and promiscuity here, the stack does</span>
<span class="cm">	 * that step explicitly. Enable vlan accel.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">t4vf_set_rxmode</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">viid</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			      <span class="nb">true</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">t4vf_change_mac</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">viid</span><span class="p">,</span>
				      <span class="n">pi</span><span class="o">-&gt;</span><span class="n">xact_addr_filt</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pi</span><span class="o">-&gt;</span><span class="n">xact_addr_filt</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t need to actually &quot;start the link&quot; itself since the</span>
<span class="cm">	 * firmware will do that for us when the first Virtual Interface</span>
<span class="cm">	 * is enabled on a port.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">t4vf_enable_vi</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">viid</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Name the MSI-X interrupts.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">name_msix_vecs</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">namelen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_info</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">desc</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pidx</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Firmware events.</span>
<span class="cm">	 */</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_info</span><span class="p">[</span><span class="n">MSIX_FW</span><span class="p">].</span><span class="n">desc</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span>
		 <span class="s">&quot;%s-FWeventq&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_info</span><span class="p">[</span><span class="n">MSIX_FW</span><span class="p">].</span><span class="n">desc</span><span class="p">[</span><span class="n">namelen</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ethernet queues.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_port</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pidx</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">pidx</span><span class="p">];</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">qs</span><span class="p">,</span> <span class="n">msi</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">qs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">msi</span> <span class="o">=</span> <span class="n">MSIX_IQFLINT</span><span class="p">;</span> <span class="n">qs</span> <span class="o">&lt;</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">nqsets</span><span class="p">;</span> <span class="n">qs</span><span class="o">++</span><span class="p">,</span> <span class="n">msi</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snprintf</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_info</span><span class="p">[</span><span class="n">msi</span><span class="p">].</span><span class="n">desc</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span>
				 <span class="s">&quot;%s-%d&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">qs</span><span class="p">);</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_info</span><span class="p">[</span><span class="n">msi</span><span class="p">].</span><span class="n">desc</span><span class="p">[</span><span class="n">namelen</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Request all of our MSI-X resources.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">request_msix_queue_irqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rxq</span><span class="p">,</span> <span class="n">msi</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Firmware events.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_info</span><span class="p">[</span><span class="n">MSIX_FW</span><span class="p">].</span><span class="n">vec</span><span class="p">,</span> <span class="n">t4vf_sge_intr_msix</span><span class="p">,</span>
			  <span class="mi">0</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_info</span><span class="p">[</span><span class="n">MSIX_FW</span><span class="p">].</span><span class="n">desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">fw_evtq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ethernet queues.</span>
<span class="cm">	 */</span>
	<span class="n">msi</span> <span class="o">=</span> <span class="n">MSIX_IQFLINT</span><span class="p">;</span>
	<span class="n">for_each_ethrxq</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">rxq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_info</span><span class="p">[</span><span class="n">msi</span><span class="p">].</span><span class="n">vec</span><span class="p">,</span>
				  <span class="n">t4vf_sge_intr_msix</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				  <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_info</span><span class="p">[</span><span class="n">msi</span><span class="p">].</span><span class="n">desc</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ethrxq</span><span class="p">[</span><span class="n">rxq</span><span class="p">].</span><span class="n">rspq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_free_irqs</span><span class="p">;</span>
		<span class="n">msi</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_free_irqs:</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">rxq</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_info</span><span class="p">[</span><span class="o">--</span><span class="n">msi</span><span class="p">].</span><span class="n">vec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ethrxq</span><span class="p">[</span><span class="n">rxq</span><span class="p">].</span><span class="n">rspq</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_info</span><span class="p">[</span><span class="n">MSIX_FW</span><span class="p">].</span><span class="n">vec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">fw_evtq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free our MSI-X resources.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_msix_queue_irqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rxq</span><span class="p">,</span> <span class="n">msi</span><span class="p">;</span>

	<span class="n">free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_info</span><span class="p">[</span><span class="n">MSIX_FW</span><span class="p">].</span><span class="n">vec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">fw_evtq</span><span class="p">);</span>
	<span class="n">msi</span> <span class="o">=</span> <span class="n">MSIX_IQFLINT</span><span class="p">;</span>
	<span class="n">for_each_ethrxq</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">rxq</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_info</span><span class="p">[</span><span class="n">msi</span><span class="o">++</span><span class="p">].</span><span class="n">vec</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ethrxq</span><span class="p">[</span><span class="n">rxq</span><span class="p">].</span><span class="n">rspq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Turn on NAPI and start up interrupts on a response queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qenable</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">rspq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rspq</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * 0-increment the Going To Sleep register to start the timer and</span>
<span class="cm">	 * enable interrupts.</span>
<span class="cm">	 */</span>
	<span class="n">t4_write_reg</span><span class="p">(</span><span class="n">rspq</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">T4VF_SGE_BASE_ADDR</span> <span class="o">+</span> <span class="n">SGE_VF_GTS</span><span class="p">,</span>
		     <span class="n">CIDXINC</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
		     <span class="n">SEINTARM</span><span class="p">(</span><span class="n">rspq</span><span class="o">-&gt;</span><span class="n">intr_params</span><span class="p">)</span> <span class="o">|</span>
		     <span class="n">INGRESSQID</span><span class="p">(</span><span class="n">rspq</span><span class="o">-&gt;</span><span class="n">cntxt_id</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Enable NAPI scheduling and interrupt generation for all Receive Queues.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">enable_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rxq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">;</span>

	<span class="n">for_each_ethrxq</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">rxq</span><span class="p">)</span>
		<span class="n">qenable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ethrxq</span><span class="p">[</span><span class="n">rxq</span><span class="p">].</span><span class="n">rspq</span><span class="p">);</span>
	<span class="n">qenable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">fw_evtq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The interrupt queue doesn&#39;t use NAPI so we do the 0-increment of</span>
<span class="cm">	 * its Going To Sleep register here to get it started.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">USING_MSI</span><span class="p">)</span>
		<span class="n">t4_write_reg</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">T4VF_SGE_BASE_ADDR</span> <span class="o">+</span> <span class="n">SGE_VF_GTS</span><span class="p">,</span>
			     <span class="n">CIDXINC</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
			     <span class="n">SEINTARM</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">intrq</span><span class="p">.</span><span class="n">intr_params</span><span class="p">)</span> <span class="o">|</span>
			     <span class="n">INGRESSQID</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">intrq</span><span class="p">.</span><span class="n">cntxt_id</span><span class="p">));</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wait until all NAPI handlers are descheduled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">quiesce_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rxq</span><span class="p">;</span>

	<span class="n">for_each_ethrxq</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">rxq</span><span class="p">)</span>
		<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ethrxq</span><span class="p">[</span><span class="n">rxq</span><span class="p">].</span><span class="n">rspq</span><span class="p">.</span><span class="n">napi</span><span class="p">);</span>
	<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">fw_evtq</span><span class="p">.</span><span class="n">napi</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Response queue handler for the firmware event queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fwevtq_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">rspq</span><span class="p">,</span> <span class="k">const</span> <span class="n">__be64</span> <span class="o">*</span><span class="n">rsp</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">pkt_gl</span> <span class="o">*</span><span class="n">gl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Extract response opcode and get pointer to CPL message body.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">rspq</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">opcode</span> <span class="o">=</span> <span class="p">((</span><span class="k">const</span> <span class="k">struct</span> <span class="n">rss_header</span> <span class="o">*</span><span class="p">)</span><span class="n">rsp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cpl</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">opcode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPL_FW6_MSG</span>: <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We&#39;ve received an asynchronous message from the firmware.</span>
<span class="cm">		 */</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">cpl_fw6_msg</span> <span class="o">*</span><span class="n">fw_msg</span> <span class="o">=</span> <span class="n">cpl</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fw_msg</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">FW6_TYPE_CMD_RPL</span><span class="p">)</span>
			<span class="n">t4vf_handle_fw_rpl</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">fw_msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">case</span> <span class="n">CPL_SGE_EGR_UPDATE</span>: <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We&#39;ve received an Egress Queue Status Update message.  We</span>
<span class="cm">		 * get these, if the SGE is configured to send these when the</span>
<span class="cm">		 * firmware passes certain points in processing our TX</span>
<span class="cm">		 * Ethernet Queue or if we make an explicit request for one.</span>
<span class="cm">		 * We use these updates to determine when we may need to</span>
<span class="cm">		 * restart a TX Ethernet Queue which was stopped for lack of</span>
<span class="cm">		 * free TX Queue Descriptors ...</span>
<span class="cm">		 */</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">cpl_sge_egr_update</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">cpl</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">qid</span> <span class="o">=</span> <span class="n">EGR_QID</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">opcode_qid</span><span class="p">));</span>
		<span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sge_txq</span> <span class="o">*</span><span class="n">tq</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sge_eth_txq</span> <span class="o">*</span><span class="n">txq</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">eq_idx</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Perform sanity checking on the Queue ID to make sure it</span>
<span class="cm">		 * really refers to one of our TX Ethernet Egress Queues which</span>
<span class="cm">		 * is active and matches the queue&#39;s ID.  None of these error</span>
<span class="cm">		 * conditions should ever happen so we may want to either make</span>
<span class="cm">		 * them fatal and/or conditionalized under DEBUG.</span>
<span class="cm">		 */</span>
		<span class="n">eq_idx</span> <span class="o">=</span> <span class="n">EQ_IDX</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">qid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">eq_idx</span> <span class="o">&gt;=</span> <span class="n">MAX_EGRQ</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev_dev</span><span class="p">,</span>
				<span class="s">&quot;Egress Update QID %d out of range</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">qid</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tq</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">egr_map</span><span class="p">[</span><span class="n">eq_idx</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tq</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev_dev</span><span class="p">,</span>
				<span class="s">&quot;Egress Update QID %d TXQ=NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">qid</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">txq</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">tq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_eth_txq</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">abs_id</span> <span class="o">!=</span> <span class="n">qid</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev_dev</span><span class="p">,</span>
				<span class="s">&quot;Egress Update QID %d refers to TXQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">qid</span><span class="p">,</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">abs_id</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Restart a stopped TX Queue which has less than half of its</span>
<span class="cm">		 * TX ring in use ...</span>
<span class="cm">		 */</span>
		<span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">restarts</span><span class="o">++</span><span class="p">;</span>
		<span class="n">netif_tx_wake_queue</span><span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="nl">default:</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev_dev</span><span class="p">,</span>
			<span class="s">&quot;unexpected CPL %#x on FW event queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">opcode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate SGE TX/RX response queues.  Determine how many sets of SGE queues</span>
<span class="cm"> * to use and initializes them.  We support multiple &quot;Queue Sets&quot; per port if</span>
<span class="cm"> * we have MSI-X, otherwise just one queue set per port.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">setup_sge_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">pidx</span><span class="p">,</span> <span class="n">msix</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear &quot;Queue Set&quot; Free List Starving and TX Queue Mapping Error</span>
<span class="cm">	 * state.</span>
<span class="cm">	 */</span>
	<span class="n">bitmap_zero</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">starving_fl</span><span class="p">,</span> <span class="n">MAX_EGRQ</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re using MSI interrupt mode we need to set up a &quot;forwarded</span>
<span class="cm">	 * interrupt&quot; queue which we&#39;ll set up with our MSI vector.  The rest</span>
<span class="cm">	 * of the ingress queues will be set up to forward their interrupts to</span>
<span class="cm">	 * this queue ...  This must be first since t4vf_sge_alloc_rxq() uses</span>
<span class="cm">	 * the intrq&#39;s queue ID as the interrupt forwarding queue for the</span>
<span class="cm">	 * subsequent calls ...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">USING_MSI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">t4vf_sge_alloc_rxq</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">intrq</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span>
					 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_free_queues</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate our ingress queue for asynchronous firmware messages.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">t4vf_sge_alloc_rxq</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">fw_evtq</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				 <span class="n">MSIX_FW</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">fwevtq_handler</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_free_queues</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate each &quot;port&quot;&#39;s initial Queue Sets.  These can be changed</span>
<span class="cm">	 * later on ... up to the point where any interface on the adapter is</span>
<span class="cm">	 * brought up at which point lots of things get nailed down</span>
<span class="cm">	 * permanently ...</span>
<span class="cm">	 */</span>
	<span class="n">msix</span> <span class="o">=</span> <span class="n">MSIX_IQFLINT</span><span class="p">;</span>
	<span class="n">for_each_port</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pidx</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">pidx</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">sge_eth_rxq</span> <span class="o">*</span><span class="n">rxq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ethrxq</span><span class="p">[</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">first_qset</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">sge_eth_txq</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ethtxq</span><span class="p">[</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">first_qset</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">qs</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">qs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">qs</span> <span class="o">&lt;</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">nqsets</span><span class="p">;</span> <span class="n">qs</span><span class="o">++</span><span class="p">,</span> <span class="n">rxq</span><span class="o">++</span><span class="p">,</span> <span class="n">txq</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">t4vf_sge_alloc_rxq</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span>
						 <span class="n">dev</span><span class="p">,</span> <span class="n">msix</span><span class="o">++</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">,</span> <span class="n">t4vf_ethrx_handler</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err_free_queues</span><span class="p">;</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">t4vf_sge_alloc_eth_txq</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">txq</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
					     <span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">qs</span><span class="p">),</span>
					     <span class="n">s</span><span class="o">-&gt;</span><span class="n">fw_evtq</span><span class="p">.</span><span class="n">cntxt_id</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err_free_queues</span><span class="p">;</span>

			<span class="n">rxq</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">qs</span><span class="p">;</span>
			<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Create the reverse mappings for the queues.</span>
<span class="cm">	 */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">egr_base</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">ethtxq</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">q</span><span class="p">.</span><span class="n">abs_id</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">ethtxq</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">q</span><span class="p">.</span><span class="n">cntxt_id</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">ingr_base</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">ethrxq</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rspq</span><span class="p">.</span><span class="n">abs_id</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">ethrxq</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rspq</span><span class="p">.</span><span class="n">cntxt_id</span><span class="p">;</span>
	<span class="n">IQ_MAP</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">fw_evtq</span><span class="p">.</span><span class="n">abs_id</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">fw_evtq</span><span class="p">;</span>
	<span class="n">for_each_port</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pidx</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">pidx</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">sge_eth_rxq</span> <span class="o">*</span><span class="n">rxq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ethrxq</span><span class="p">[</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">first_qset</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">sge_eth_txq</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ethtxq</span><span class="p">[</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">first_qset</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">qs</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">qs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">qs</span> <span class="o">&lt;</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">nqsets</span><span class="p">;</span> <span class="n">qs</span><span class="o">++</span><span class="p">,</span> <span class="n">rxq</span><span class="o">++</span><span class="p">,</span> <span class="n">txq</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IQ_MAP</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">rxq</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">abs_id</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">;</span>
			<span class="n">EQ_MAP</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">abs_id</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * The FW_IQ_CMD doesn&#39;t return the Absolute Queue IDs</span>
<span class="cm">			 * for Free Lists but since all of the Egress Queues</span>
<span class="cm">			 * (including Free Lists) have Relative Queue IDs</span>
<span class="cm">			 * which are computed as Absolute - Base Queue ID, we</span>
<span class="cm">			 * can synthesize the Absolute Queue IDs for the Free</span>
<span class="cm">			 * Lists.  This is useful for debugging purposes when</span>
<span class="cm">			 * we want to dump Queue Contexts via the PF Driver.</span>
<span class="cm">			 */</span>
			<span class="n">rxq</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">.</span><span class="n">abs_id</span> <span class="o">=</span> <span class="n">rxq</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">.</span><span class="n">cntxt_id</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">egr_base</span><span class="p">;</span>
			<span class="n">EQ_MAP</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">rxq</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">.</span><span class="n">abs_id</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_free_queues:</span>
	<span class="n">t4vf_free_sge_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set up Receive Side Scaling (RSS) to distribute packets to multiple receive</span>
<span class="cm"> * queues.  We configure the RSS CPU lookup table to distribute to the number</span>
<span class="cm"> * of HW receive queues, and the response queue lookup table to narrow that</span>
<span class="cm"> * down to the response queues actually configured for each &quot;port&quot; (Virtual</span>
<span class="cm"> * Interface).  We always configure the RSS mapping for all ports since the</span>
<span class="cm"> * mapping table has plenty of entries.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">setup_rss</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pidx</span><span class="p">;</span>

	<span class="n">for_each_port</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pidx</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">adap2pinfo</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pidx</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">sge_eth_rxq</span> <span class="o">*</span><span class="n">rxq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">ethrxq</span><span class="p">[</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">first_qset</span><span class="p">];</span>
		<span class="n">u16</span> <span class="n">rss</span><span class="p">[</span><span class="n">MAX_PORT_QSETS</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">qs</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">qs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">qs</span> <span class="o">&lt;</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">nqsets</span><span class="p">;</span> <span class="n">qs</span><span class="o">++</span><span class="p">)</span>
			<span class="n">rss</span><span class="p">[</span><span class="n">qs</span><span class="p">]</span> <span class="o">=</span> <span class="n">rxq</span><span class="p">[</span><span class="n">qs</span><span class="p">].</span><span class="n">rspq</span><span class="p">.</span><span class="n">abs_id</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">t4vf_config_rss_range</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">viid</span><span class="p">,</span>
					    <span class="mi">0</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">rss_size</span><span class="p">,</span> <span class="n">rss</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">nqsets</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Perform Global RSS Mode-specific initialization.</span>
<span class="cm">		 */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">rss</span><span class="p">.</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">FW_RSS_GLB_CONFIG_CMD_MODE_BASICVIRTUAL</span>:
			<span class="cm">/*</span>
<span class="cm">			 * If Tunnel All Lookup isn&#39;t specified in the global</span>
<span class="cm">			 * RSS Configuration, then we need to specify a</span>
<span class="cm">			 * default Ingress Queue for any ingress packets which</span>
<span class="cm">			 * aren&#39;t hashed.  We&#39;ll use our first ingress queue</span>
<span class="cm">			 * ...</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">rss</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">basicvirtual</span><span class="p">.</span><span class="n">tnlalllookup</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">union</span> <span class="n">rss_vi_config</span> <span class="n">config</span><span class="p">;</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">t4vf_read_rss_vi_config</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
							      <span class="n">pi</span><span class="o">-&gt;</span><span class="n">viid</span><span class="p">,</span>
							      <span class="o">&amp;</span><span class="n">config</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
				<span class="n">config</span><span class="p">.</span><span class="n">basicvirtual</span><span class="p">.</span><span class="n">defaultq</span> <span class="o">=</span>
					<span class="n">rxq</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rspq</span><span class="p">.</span><span class="n">abs_id</span><span class="p">;</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">t4vf_write_rss_vi_config</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
							       <span class="n">pi</span><span class="o">-&gt;</span><span class="n">viid</span><span class="p">,</span>
							       <span class="o">&amp;</span><span class="n">config</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Bring the adapter up.  Called whenever we go from no &quot;ports&quot; open to having</span>
<span class="cm"> * one open.  This function performs the actions necessary to make an adapter</span>
<span class="cm"> * operational, such as completing the initialization of HW modules, and</span>
<span class="cm"> * enabling interrupts.  Must be called with the rtnl lock held.  (Note that</span>
<span class="cm"> * this is called &quot;cxgb_up&quot; in the PF Driver.)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">adapter_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is the first time we&#39;ve been called, perform basic</span>
<span class="cm">	 * adapter setup.  Once we&#39;ve done this, many of our adapter</span>
<span class="cm">	 * parameters can no longer be changed ...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FULL_INIT_DONE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">setup_sge_queues</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">setup_rss</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">t4vf_free_sge_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">USING_MSIX</span><span class="p">)</span>
			<span class="n">name_msix_vecs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FULL_INIT_DONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Acquire our interrupt resources.  We only support MSI-X and MSI.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">USING_MSIX</span><span class="o">|</span><span class="n">USING_MSI</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">USING_MSIX</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">request_msix_queue_irqs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span>
				  <span class="n">t4vf_intr_handler</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				  <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev_dev</span><span class="p">,</span> <span class="s">&quot;request_irq failed, err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enable NAPI ingress processing and return success.</span>
<span class="cm">	 */</span>
	<span class="n">enable_rx</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">t4vf_sge_start</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Bring the adapter down.  Called whenever the last &quot;port&quot; (Virtual</span>
<span class="cm"> * Interface) closed.  (Note that this routine is called &quot;cxgb_down&quot; in the PF</span>
<span class="cm"> * Driver.)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">adapter_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Free interrupt resources.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">USING_MSIX</span><span class="p">)</span>
		<span class="n">free_msix_queue_irqs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait for NAPI handlers to finish.</span>
<span class="cm">	 */</span>
	<span class="n">quiesce_rx</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Start up a net device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cxgb4vf_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is the first interface that we&#39;re opening on the &quot;adapter&quot;,</span>
<span class="cm">	 * bring the &quot;adapter&quot; up now.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">open_device_map</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">adapter_up</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note that this interface is up and start everything up ...</span>
<span class="cm">	 */</span>
	<span class="n">netif_set_real_num_tx_queues</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">nqsets</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">netif_set_real_num_rx_queues</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">nqsets</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_unwind</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">link_start</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_unwind</span><span class="p">;</span>

	<span class="n">netif_tx_start_all_queues</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">open_device_map</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_unwind:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">open_device_map</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">adapter_down</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Shut down a net device.  This routine is called &quot;cxgb_close&quot; in the PF</span>
<span class="cm"> * Driver ...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cxgb4vf_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>

	<span class="n">netif_tx_stop_all_queues</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">t4vf_enable_vi</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">viid</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">pi</span><span class="o">-&gt;</span><span class="n">link_cfg</span><span class="p">.</span><span class="n">link_ok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">open_device_map</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">open_device_map</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">adapter_down</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Translate our basic statistics into the standard &quot;ifconfig&quot; statistics.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="nf">cxgb4vf_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">t4vf_port_stats</span> <span class="n">stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev2pinfo</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">t4vf_get_port_stats</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">pidx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stats</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ns</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ns</span><span class="p">;</span>

	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bcast_bytes</span> <span class="o">+</span> <span class="n">stats</span><span class="p">.</span><span class="n">tx_mcast_bytes</span> <span class="o">+</span>
			<span class="n">stats</span><span class="p">.</span><span class="n">tx_ucast_bytes</span> <span class="o">+</span> <span class="n">stats</span><span class="p">.</span><span class="n">tx_offload_bytes</span><span class="p">);</span>
	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">tx_packets</span> <span class="o">=</span> <span class="p">(</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bcast_frames</span> <span class="o">+</span> <span class="n">stats</span><span class="p">.</span><span class="n">tx_mcast_frames</span> <span class="o">+</span>
			  <span class="n">stats</span><span class="p">.</span><span class="n">tx_ucast_frames</span> <span class="o">+</span> <span class="n">stats</span><span class="p">.</span><span class="n">tx_offload_frames</span><span class="p">);</span>
	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">rx_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bcast_bytes</span> <span class="o">+</span> <span class="n">stats</span><span class="p">.</span><span class="n">rx_mcast_bytes</span> <span class="o">+</span>
			<span class="n">stats</span><span class="p">.</span><span class="n">rx_ucast_bytes</span><span class="p">);</span>
	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">rx_packets</span> <span class="o">=</span> <span class="p">(</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bcast_frames</span> <span class="o">+</span> <span class="n">stats</span><span class="p">.</span><span class="n">rx_mcast_frames</span> <span class="o">+</span>
			  <span class="n">stats</span><span class="p">.</span><span class="n">rx_ucast_frames</span><span class="p">);</span>
	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">multicast</span> <span class="o">=</span> <span class="n">stats</span><span class="p">.</span><span class="n">rx_mcast_frames</span><span class="p">;</span>
	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">tx_errors</span> <span class="o">=</span> <span class="n">stats</span><span class="p">.</span><span class="n">tx_drop_frames</span><span class="p">;</span>
	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">rx_errors</span> <span class="o">=</span> <span class="n">stats</span><span class="p">.</span><span class="n">rx_err_frames</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ns</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Collect up to maxaddrs worth of a netdevice&#39;s unicast addresses, starting</span>
<span class="cm"> * at a specified offset within the list, into an array of addrss pointers and</span>
<span class="cm"> * return the number collected.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">collect_netdev_uc_list_addrs</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
							<span class="k">const</span> <span class="n">u8</span> <span class="o">**</span><span class="n">addr</span><span class="p">,</span>
							<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
							<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxaddrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">naddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>

	<span class="n">for_each_dev_addr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ha</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span><span class="o">++</span> <span class="o">&gt;=</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">addr</span><span class="p">[</span><span class="n">naddr</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">naddr</span> <span class="o">&gt;=</span> <span class="n">maxaddrs</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">return</span> <span class="n">naddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Collect up to maxaddrs worth of a netdevice&#39;s multicast addresses, starting</span>
<span class="cm"> * at a specified offset within the list, into an array of addrss pointers and</span>
<span class="cm"> * return the number collected.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">collect_netdev_mc_list_addrs</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
							<span class="k">const</span> <span class="n">u8</span> <span class="o">**</span><span class="n">addr</span><span class="p">,</span>
							<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
							<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxaddrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">naddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>

	<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span><span class="o">++</span> <span class="o">&gt;=</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">addr</span><span class="p">[</span><span class="n">naddr</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">naddr</span> <span class="o">&gt;=</span> <span class="n">maxaddrs</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">return</span> <span class="n">naddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Configure the exact and hash address filters to handle a port&#39;s multicast</span>
<span class="cm"> * and secondary unicast MAC addresses.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_addr_filters</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">sleep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">mhash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">uhash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">free</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">naddr</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* first do the secondary unicast addresses */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="n">offset</span> <span class="o">+=</span> <span class="n">naddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">naddr</span> <span class="o">=</span> <span class="n">collect_netdev_uc_list_addrs</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
						     <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">naddr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">t4vf_alloc_mac_filt</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">viid</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span>
					  <span class="n">naddr</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uhash</span><span class="p">,</span> <span class="n">sleep</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">free</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* next set up the multicast addresses */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="n">offset</span> <span class="o">+=</span> <span class="n">naddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">naddr</span> <span class="o">=</span> <span class="n">collect_netdev_mc_list_addrs</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
						     <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">naddr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">t4vf_alloc_mac_filt</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">viid</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span>
					  <span class="n">naddr</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mhash</span><span class="p">,</span> <span class="n">sleep</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">free</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">t4vf_set_addr_hash</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">viid</span><span class="p">,</span> <span class="n">uhash</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
				  <span class="n">uhash</span> <span class="o">|</span> <span class="n">mhash</span><span class="p">,</span> <span class="n">sleep</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set RX properties of a port, such as promiscruity, address filters, and MTU.</span>
<span class="cm"> * If @mtu is -1 it is left unchanged.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_rxmode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mtu</span><span class="p">,</span> <span class="n">bool</span> <span class="n">sleep_ok</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">set_addr_filters</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sleep_ok</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">t4vf_set_rxmode</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">viid</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
				      <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
				      <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
				      <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">sleep_ok</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the current receive modes on the device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cxgb4vf_set_rxmode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* unfortunately we can&#39;t return errors to the stack */</span>
	<span class="n">set_rxmode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find the entry in the interrupt holdoff timer value array which comes</span>
<span class="cm"> * closest to the specified interrupt holdoff value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">closest_timer</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">timer_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">min_delta</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">timer_val</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">us</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">timer_val</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">delta</span> <span class="o">=</span> <span class="o">-</span><span class="n">delta</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="n">min_delta</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">min_delta</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>
			<span class="n">timer_idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">timer_idx</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">closest_thres</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">thres</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">pktcnt_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">min_delta</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">counter_val</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">thres</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">counter_val</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">delta</span> <span class="o">=</span> <span class="o">-</span><span class="n">delta</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="n">min_delta</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">min_delta</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>
			<span class="n">pktcnt_idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">pktcnt_idx</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return a queue&#39;s interrupt hold-off time in us.  0 means no timer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">qtimer_val</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">rspq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timer_idx</span> <span class="o">=</span> <span class="n">QINTR_TIMER_IDX_GET</span><span class="p">(</span><span class="n">rspq</span><span class="o">-&gt;</span><span class="n">intr_params</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">timer_idx</span> <span class="o">&lt;</span> <span class="n">SGE_NTIMERS</span>
		<span class="o">?</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">timer_val</span><span class="p">[</span><span class="n">timer_idx</span><span class="p">]</span>
		<span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	set_rxq_intr_params - set a queue&#39;s interrupt holdoff parameters</span>
<span class="cm"> *	@adapter: the adapter</span>
<span class="cm"> *	@rspq: the RX response queue</span>
<span class="cm"> *	@us: the hold-off time in us, or 0 to disable timer</span>
<span class="cm"> *	@cnt: the hold-off packet count, or 0 to disable counter</span>
<span class="cm"> *</span>
<span class="cm"> *	Sets an RX response queue&#39;s interrupt hold-off time and packet count.</span>
<span class="cm"> *	At least one of the two needs to be enabled for the queue to generate</span>
<span class="cm"> *	interrupts.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_rxq_intr_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">rspq</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">us</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timer_idx</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If both the interrupt holdoff timer and count are specified as</span>
<span class="cm">	 * zero, default to a holdoff count of 1 ...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">us</span> <span class="o">|</span> <span class="n">cnt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If an interrupt holdoff count has been specified, then find the</span>
<span class="cm">	 * closest configured holdoff count and use that.  If the response</span>
<span class="cm">	 * queue has already been created, then update its queue context</span>
<span class="cm">	 * parameters ...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">v</span><span class="p">,</span> <span class="n">pktcnt_idx</span><span class="p">;</span>

		<span class="n">pktcnt_idx</span> <span class="o">=</span> <span class="n">closest_thres</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rspq</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">&amp;&amp;</span> <span class="n">rspq</span><span class="o">-&gt;</span><span class="n">pktcnt_idx</span> <span class="o">!=</span> <span class="n">pktcnt_idx</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">FW_PARAMS_MNEM</span><span class="p">(</span><span class="n">FW_PARAMS_MNEM_DMAQ</span><span class="p">)</span> <span class="o">|</span>
			    <span class="n">FW_PARAMS_PARAM_X</span><span class="p">(</span>
					<span class="n">FW_PARAMS_PARAM_DMAQ_IQ_INTCNTTHRESH</span><span class="p">)</span> <span class="o">|</span>
			    <span class="n">FW_PARAMS_PARAM_YZ</span><span class="p">(</span><span class="n">rspq</span><span class="o">-&gt;</span><span class="n">cntxt_id</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">t4vf_set_params</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pktcnt_idx</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rspq</span><span class="o">-&gt;</span><span class="n">pktcnt_idx</span> <span class="o">=</span> <span class="n">pktcnt_idx</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compute the closest holdoff timer index from the supplied holdoff</span>
<span class="cm">	 * timer value.</span>
<span class="cm">	 */</span>
	<span class="n">timer_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">us</span> <span class="o">==</span> <span class="mi">0</span>
		     <span class="o">?</span> <span class="n">SGE_TIMER_RSTRT_CNTR</span>
		     <span class="o">:</span> <span class="n">closest_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">,</span> <span class="n">us</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update the response queue&#39;s interrupt coalescing parameters and</span>
<span class="cm">	 * return success.</span>
<span class="cm">	 */</span>
	<span class="n">rspq</span><span class="o">-&gt;</span><span class="n">intr_params</span> <span class="o">=</span> <span class="p">(</span><span class="n">QINTR_TIMER_IDX</span><span class="p">(</span><span class="n">timer_idx</span><span class="p">)</span> <span class="o">|</span>
			     <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">QINTR_CNT_EN</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return a version number to identify the type of adapter.  The scheme is:</span>
<span class="cm"> * - bits 0..9: chip version</span>
<span class="cm"> * - bits 10..15: chip revision</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">mk_adap_vers</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Chip version 4, revision 0x3f (cxgb4vf).</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">4</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0x3f</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Execute the specified ioctl command.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cxgb4vf_do_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	    <span class="cm">/*</span>
<span class="cm">	     * The VF Driver doesn&#39;t have access to any of the other</span>
<span class="cm">	     * common Ethernet device ioctl()&#39;s (like reading/writing</span>
<span class="cm">	     * PHY registers, etc.</span>
<span class="cm">	     */</span>

	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Change the device&#39;s MTU.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cxgb4vf_change_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* accommodate SACK */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_mtu</span> <span class="o">&lt;</span> <span class="mi">81</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">t4vf_set_rxmode</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">viid</span><span class="p">,</span> <span class="n">new_mtu</span><span class="p">,</span>
			      <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">new_mtu</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">netdev_features_t</span> <span class="nf">cxgb4vf_fix_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Since there is no support for separate rx/tx vlan accel</span>
<span class="cm">	 * enable/disable make sure tx flag is always in same state as rx.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_HW_VLAN_RX</span><span class="p">)</span>
		<span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_HW_VLAN_TX</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NETIF_F_HW_VLAN_TX</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">features</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cxgb4vf_set_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">netdev_features_t</span> <span class="n">changed</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">^</span> <span class="n">features</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">changed</span> <span class="o">&amp;</span> <span class="n">NETIF_F_HW_VLAN_RX</span><span class="p">)</span>
		<span class="n">t4vf_set_rxmode</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">viid</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
				<span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_HW_VLAN_TX</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Change the devices MAC address.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cxgb4vf_set_mac_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">t4vf_change_mac</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">viid</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">xact_addr_filt</span><span class="p">,</span>
			      <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="n">pi</span><span class="o">-&gt;</span><span class="n">xact_addr_filt</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<span class="cm">/*</span>
<span class="cm"> * Poll all of our receive queues.  This is called outside of normal interrupt</span>
<span class="cm"> * context.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cxgb4vf_poll_controller</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">USING_MSIX</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sge_eth_rxq</span> <span class="o">*</span><span class="n">rxq</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">nqsets</span><span class="p">;</span>

		<span class="n">rxq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">ethrxq</span><span class="p">[</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">first_qset</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">nqsets</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">nqsets</span><span class="p">;</span> <span class="n">nqsets</span><span class="p">;</span> <span class="n">nqsets</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">t4vf_sge_intr_msix</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">);</span>
			<span class="n">rxq</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">t4vf_intr_handler</span><span class="p">(</span><span class="n">adapter</span><span class="p">)(</span><span class="mi">0</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Ethtool operations.</span>
<span class="cm"> * ===================</span>
<span class="cm"> *</span>
<span class="cm"> * Note that we don&#39;t support any ethtool operations which change the physical</span>
<span class="cm"> * state of the port to which we&#39;re linked.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Return current port link settings.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cxgb4vf_get_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">supported</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">link_cfg</span><span class="p">.</span><span class="n">supported</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">link_cfg</span><span class="p">.</span><span class="n">advertising</span><span class="p">;</span>
	<span class="n">ethtool_cmd_speed_set</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span>
			      <span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">?</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">link_cfg</span><span class="p">.</span><span class="n">speed</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">=</span> <span class="n">DUPLEX_FULL</span><span class="p">;</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">=</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">supported</span> <span class="o">&amp;</span> <span class="n">SUPPORTED_TP</span><span class="p">)</span> <span class="o">?</span> <span class="n">PORT_TP</span> <span class="o">:</span> <span class="n">PORT_FIBRE</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">phy_address</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transceiver</span> <span class="o">=</span> <span class="n">XCVR_EXTERNAL</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">link_cfg</span><span class="p">.</span><span class="n">autoneg</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">maxtxpkt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">maxrxpkt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return our driver information.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cxgb4vf_get_drvinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ethtool_drvinfo</span> <span class="o">*</span><span class="n">drvinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev2adap</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">strlcpy</span><span class="p">(</span><span class="n">drvinfo</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="n">KBUILD_MODNAME</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">drvinfo</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">));</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">drvinfo</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">DRV_VERSION</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">drvinfo</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">));</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">drvinfo</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">)),</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">drvinfo</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">));</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">drvinfo</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">drvinfo</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">),</span>
		 <span class="s">&quot;%u.%u.%u.%u, TP %u.%u.%u.%u&quot;</span><span class="p">,</span>
		 <span class="n">FW_HDR_FW_VER_MAJOR_GET</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">fwrev</span><span class="p">),</span>
		 <span class="n">FW_HDR_FW_VER_MINOR_GET</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">fwrev</span><span class="p">),</span>
		 <span class="n">FW_HDR_FW_VER_MICRO_GET</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">fwrev</span><span class="p">),</span>
		 <span class="n">FW_HDR_FW_VER_BUILD_GET</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">fwrev</span><span class="p">),</span>
		 <span class="n">FW_HDR_FW_VER_MAJOR_GET</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">tprev</span><span class="p">),</span>
		 <span class="n">FW_HDR_FW_VER_MINOR_GET</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">tprev</span><span class="p">),</span>
		 <span class="n">FW_HDR_FW_VER_MICRO_GET</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">tprev</span><span class="p">),</span>
		 <span class="n">FW_HDR_FW_VER_BUILD_GET</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">tprev</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return current adapter message level.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">cxgb4vf_get_msglevel</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">netdev2adap</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">msg_enable</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set current adapter message level.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cxgb4vf_set_msglevel</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msglevel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netdev2adap</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">msglevel</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the device&#39;s current Queue Set ring size parameters along with the</span>
<span class="cm"> * allowed maximum values.  Since ethtool doesn&#39;t understand the concept of</span>
<span class="cm"> * multi-queue devices, we just return the current values associated with the</span>
<span class="cm"> * first Queue Set.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cxgb4vf_get_ringparam</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ethtool_ringparam</span> <span class="o">*</span><span class="n">rp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">;</span>

	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_max_pending</span> <span class="o">=</span> <span class="n">MAX_RX_BUFFERS</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_mini_max_pending</span> <span class="o">=</span> <span class="n">MAX_RSPQ_ENTRIES</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_jumbo_max_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_max_pending</span> <span class="o">=</span> <span class="n">MAX_TXQ_ENTRIES</span><span class="p">;</span>

	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_pending</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">ethrxq</span><span class="p">[</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">first_qset</span><span class="p">].</span><span class="n">fl</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">MIN_FL_RESID</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_mini_pending</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">ethrxq</span><span class="p">[</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">first_qset</span><span class="p">].</span><span class="n">rspq</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_jumbo_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_pending</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">ethtxq</span><span class="p">[</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">first_qset</span><span class="p">].</span><span class="n">q</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the Queue Set ring size parameters for the device.  Again, since</span>
<span class="cm"> * ethtool doesn&#39;t allow for the concept of multiple queues per device, we&#39;ll</span>
<span class="cm"> * apply these new values across all of the Queue Sets associated with the</span>
<span class="cm"> * device -- after vetting them of course!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cxgb4vf_set_ringparam</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ethtool_ringparam</span> <span class="o">*</span><span class="n">rp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">qs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_pending</span> <span class="o">&gt;</span> <span class="n">MAX_RX_BUFFERS</span> <span class="o">||</span>
	    <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_jumbo_pending</span> <span class="o">||</span>
	    <span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_pending</span> <span class="o">&gt;</span> <span class="n">MAX_TXQ_ENTRIES</span> <span class="o">||</span>
	    <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_mini_pending</span> <span class="o">&gt;</span> <span class="n">MAX_RSPQ_ENTRIES</span> <span class="o">||</span>
	    <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_mini_pending</span> <span class="o">&lt;</span> <span class="n">MIN_RSPQ_ENTRIES</span> <span class="o">||</span>
	    <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_pending</span> <span class="o">&lt;</span> <span class="n">MIN_FL_ENTRIES</span> <span class="o">||</span>
	    <span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_pending</span> <span class="o">&lt;</span> <span class="n">MIN_TXQ_ENTRIES</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FULL_INIT_DONE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">qs</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">first_qset</span><span class="p">;</span> <span class="n">qs</span> <span class="o">&lt;</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">first_qset</span> <span class="o">+</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">nqsets</span><span class="p">;</span> <span class="n">qs</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">ethrxq</span><span class="p">[</span><span class="n">qs</span><span class="p">].</span><span class="n">fl</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_pending</span> <span class="o">+</span> <span class="n">MIN_FL_RESID</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">ethrxq</span><span class="p">[</span><span class="n">qs</span><span class="p">].</span><span class="n">rspq</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_mini_pending</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">ethtxq</span><span class="p">[</span><span class="n">qs</span><span class="p">].</span><span class="n">q</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_pending</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the interrupt holdoff timer and count for the first Queue Set on the</span>
<span class="cm"> * device.  Our extension ioctl() (the cxgbtool interface) allows the</span>
<span class="cm"> * interrupt holdoff timer to be read on all of the device&#39;s Queue Sets.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cxgb4vf_get_coalesce</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ethtool_coalesce</span> <span class="o">*</span><span class="n">coalesce</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">rspq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">ethrxq</span><span class="p">[</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">first_qset</span><span class="p">].</span><span class="n">rspq</span><span class="p">;</span>

	<span class="n">coalesce</span><span class="o">-&gt;</span><span class="n">rx_coalesce_usecs</span> <span class="o">=</span> <span class="n">qtimer_val</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">rspq</span><span class="p">);</span>
	<span class="n">coalesce</span><span class="o">-&gt;</span><span class="n">rx_max_coalesced_frames</span> <span class="o">=</span>
		<span class="p">((</span><span class="n">rspq</span><span class="o">-&gt;</span><span class="n">intr_params</span> <span class="o">&amp;</span> <span class="n">QINTR_CNT_EN</span><span class="p">)</span>
		 <span class="o">?</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">counter_val</span><span class="p">[</span><span class="n">rspq</span><span class="o">-&gt;</span><span class="n">pktcnt_idx</span><span class="p">]</span>
		 <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the RX interrupt holdoff timer and count for the first Queue Set on the</span>
<span class="cm"> * interface.  Our extension ioctl() (the cxgbtool interface) allows us to set</span>
<span class="cm"> * the interrupt holdoff timer on any of the device&#39;s Queue Sets.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cxgb4vf_set_coalesce</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ethtool_coalesce</span> <span class="o">*</span><span class="n">coalesce</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">set_rxq_intr_params</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">ethrxq</span><span class="p">[</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">first_qset</span><span class="p">].</span><span class="n">rspq</span><span class="p">,</span>
				   <span class="n">coalesce</span><span class="o">-&gt;</span><span class="n">rx_coalesce_usecs</span><span class="p">,</span>
				   <span class="n">coalesce</span><span class="o">-&gt;</span><span class="n">rx_max_coalesced_frames</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Report current port link pause parameter settings.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cxgb4vf_get_pauseparam</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">ethtool_pauseparam</span> <span class="o">*</span><span class="n">pauseparam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">pauseparam</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">=</span> <span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">link_cfg</span><span class="p">.</span><span class="n">requested_fc</span> <span class="o">&amp;</span> <span class="n">PAUSE_AUTONEG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pauseparam</span><span class="o">-&gt;</span><span class="n">rx_pause</span> <span class="o">=</span> <span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">link_cfg</span><span class="p">.</span><span class="n">fc</span> <span class="o">&amp;</span> <span class="n">PAUSE_RX</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pauseparam</span><span class="o">-&gt;</span><span class="n">tx_pause</span> <span class="o">=</span> <span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">link_cfg</span><span class="p">.</span><span class="n">fc</span> <span class="o">&amp;</span> <span class="n">PAUSE_TX</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Identify the port by blinking the port&#39;s LED.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cxgb4vf_phys_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="k">enum</span> <span class="n">ethtool_phys_id_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">ETHTOOL_ID_ACTIVE</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">ETHTOOL_ID_INACTIVE</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">t4vf_identify_port</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">viid</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Port stats maintained per queue of the port.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">queue_port_stats</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">tso</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_csum</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_csum</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">vlan_ex</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">vlan_ins</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">lro_pkts</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">lro_merged</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Strings for the ETH_SS_STATS statistics set (&quot;ethtool -S&quot;).  Note that</span>
<span class="cm"> * these need to match the order of statistics returned by</span>
<span class="cm"> * t4vf_get_port_stats().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">stats_strings</span><span class="p">[][</span><span class="n">ETH_GSTRING_LEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * These must match the layout of the t4vf_port_stats structure.</span>
<span class="cm">	 */</span>
	<span class="s">&quot;TxBroadcastBytes  &quot;</span><span class="p">,</span>
	<span class="s">&quot;TxBroadcastFrames &quot;</span><span class="p">,</span>
	<span class="s">&quot;TxMulticastBytes  &quot;</span><span class="p">,</span>
	<span class="s">&quot;TxMulticastFrames &quot;</span><span class="p">,</span>
	<span class="s">&quot;TxUnicastBytes    &quot;</span><span class="p">,</span>
	<span class="s">&quot;TxUnicastFrames   &quot;</span><span class="p">,</span>
	<span class="s">&quot;TxDroppedFrames   &quot;</span><span class="p">,</span>
	<span class="s">&quot;TxOffloadBytes    &quot;</span><span class="p">,</span>
	<span class="s">&quot;TxOffloadFrames   &quot;</span><span class="p">,</span>
	<span class="s">&quot;RxBroadcastBytes  &quot;</span><span class="p">,</span>
	<span class="s">&quot;RxBroadcastFrames &quot;</span><span class="p">,</span>
	<span class="s">&quot;RxMulticastBytes  &quot;</span><span class="p">,</span>
	<span class="s">&quot;RxMulticastFrames &quot;</span><span class="p">,</span>
	<span class="s">&quot;RxUnicastBytes    &quot;</span><span class="p">,</span>
	<span class="s">&quot;RxUnicastFrames   &quot;</span><span class="p">,</span>
	<span class="s">&quot;RxErrorFrames     &quot;</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * These are accumulated per-queue statistics and must match the</span>
<span class="cm">	 * order of the fields in the queue_port_stats structure.</span>
<span class="cm">	 */</span>
	<span class="s">&quot;TSO               &quot;</span><span class="p">,</span>
	<span class="s">&quot;TxCsumOffload     &quot;</span><span class="p">,</span>
	<span class="s">&quot;RxCsumGood        &quot;</span><span class="p">,</span>
	<span class="s">&quot;VLANextractions   &quot;</span><span class="p">,</span>
	<span class="s">&quot;VLANinsertions    &quot;</span><span class="p">,</span>
	<span class="s">&quot;GROPackets        &quot;</span><span class="p">,</span>
	<span class="s">&quot;GROMerged         &quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Return the number of statistics in the specified statistics set.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cxgb4vf_get_sset_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">sset</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ETH_SS_STATS</span>:
		<span class="k">return</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">stats_strings</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*NOTREACHED*/</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the strings for the specified statistics set.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cxgb4vf_get_strings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">sset</span><span class="p">,</span>
				<span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">sset</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ETH_SS_STATS</span>:
		<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">stats_strings</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">stats_strings</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Small utility routine to accumulate queue statistics across the queues of</span>
<span class="cm"> * a &quot;port&quot;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">collect_sge_port_stats</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">queue_port_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sge_eth_txq</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">ethtxq</span><span class="p">[</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">first_qset</span><span class="p">];</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sge_eth_rxq</span> <span class="o">*</span><span class="n">rxq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">ethrxq</span><span class="p">[</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">first_qset</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">qs</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">stats</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">qs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">qs</span> <span class="o">&lt;</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">nqsets</span><span class="p">;</span> <span class="n">qs</span><span class="o">++</span><span class="p">,</span> <span class="n">rxq</span><span class="o">++</span><span class="p">,</span> <span class="n">txq</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tso</span> <span class="o">+=</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">tso</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_csum</span> <span class="o">+=</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">tx_cso</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_csum</span> <span class="o">+=</span> <span class="n">rxq</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_cso</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">vlan_ex</span> <span class="o">+=</span> <span class="n">rxq</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">vlan_ex</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">vlan_ins</span> <span class="o">+=</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">vlan_ins</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">lro_pkts</span> <span class="o">+=</span> <span class="n">rxq</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">lro_pkts</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">lro_merged</span> <span class="o">+=</span> <span class="n">rxq</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">lro_merged</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the ETH_SS_STATS statistics set.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cxgb4vf_get_ethtool_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ethtool_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">,</span>
				      <span class="n">u64</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev2pinfo</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">t4vf_get_port_stats</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">pidx</span><span class="p">,</span>
				      <span class="p">(</span><span class="k">struct</span> <span class="n">t4vf_port_stats</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">t4vf_port_stats</span><span class="p">));</span>

	<span class="n">data</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">t4vf_port_stats</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span>
	<span class="n">collect_sge_port_stats</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">queue_port_stats</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the size of our register map.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cxgb4vf_get_regs_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">T4VF_REGMAP_SIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Dump a block of registers, start to end inclusive, into a buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">reg_block_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">regbuf</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">regbuf</span> <span class="o">+</span> <span class="n">start</span> <span class="o">-</span> <span class="n">T4VF_REGMAP_START</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">;</span> <span class="n">start</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Avoid reading the Mailbox Control register since that</span>
<span class="cm">		 * can trigger a Mailbox Ownership Arbitration cycle and</span>
<span class="cm">		 * interfere with communication with the firmware.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">T4VF_CIM_BASE_ADDR</span> <span class="o">+</span> <span class="n">CIM_VF_EXT_MAILBOX_CTRL</span><span class="p">)</span>
			<span class="o">*</span><span class="n">bp</span><span class="o">++</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">bp</span><span class="o">++</span> <span class="o">=</span> <span class="n">t4_read_reg</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Copy our entire register map into the provided buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cxgb4vf_get_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ethtool_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
			     <span class="kt">void</span> <span class="o">*</span><span class="n">regbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev2adap</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="n">mk_adap_vers</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fill in register buffer with our register map.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">regbuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">T4VF_REGMAP_SIZE</span><span class="p">);</span>

	<span class="n">reg_block_dump</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">regbuf</span><span class="p">,</span>
		       <span class="n">T4VF_SGE_BASE_ADDR</span> <span class="o">+</span> <span class="n">T4VF_MOD_MAP_SGE_FIRST</span><span class="p">,</span>
		       <span class="n">T4VF_SGE_BASE_ADDR</span> <span class="o">+</span> <span class="n">T4VF_MOD_MAP_SGE_LAST</span><span class="p">);</span>
	<span class="n">reg_block_dump</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">regbuf</span><span class="p">,</span>
		       <span class="n">T4VF_MPS_BASE_ADDR</span> <span class="o">+</span> <span class="n">T4VF_MOD_MAP_MPS_FIRST</span><span class="p">,</span>
		       <span class="n">T4VF_MPS_BASE_ADDR</span> <span class="o">+</span> <span class="n">T4VF_MOD_MAP_MPS_LAST</span><span class="p">);</span>
	<span class="n">reg_block_dump</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">regbuf</span><span class="p">,</span>
		       <span class="n">T4VF_PL_BASE_ADDR</span> <span class="o">+</span> <span class="n">T4VF_MOD_MAP_PL_FIRST</span><span class="p">,</span>
		       <span class="n">T4VF_PL_BASE_ADDR</span> <span class="o">+</span> <span class="n">T4VF_MOD_MAP_PL_LAST</span><span class="p">);</span>
	<span class="n">reg_block_dump</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">regbuf</span><span class="p">,</span>
		       <span class="n">T4VF_CIM_BASE_ADDR</span> <span class="o">+</span> <span class="n">T4VF_MOD_MAP_CIM_FIRST</span><span class="p">,</span>
		       <span class="n">T4VF_CIM_BASE_ADDR</span> <span class="o">+</span> <span class="n">T4VF_MOD_MAP_CIM_LAST</span><span class="p">);</span>

	<span class="n">reg_block_dump</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">regbuf</span><span class="p">,</span>
		       <span class="n">T4VF_MBDATA_BASE_ADDR</span> <span class="o">+</span> <span class="n">T4VF_MBDATA_FIRST</span><span class="p">,</span>
		       <span class="n">T4VF_MBDATA_BASE_ADDR</span> <span class="o">+</span> <span class="n">T4VF_MBDATA_LAST</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Report current Wake On LAN settings.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cxgb4vf_get_wol</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ethtool_wolinfo</span> <span class="o">*</span><span class="n">wol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wol</span><span class="o">-&gt;</span><span class="n">supported</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wol</span><span class="o">-&gt;</span><span class="n">wolopts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wol</span><span class="o">-&gt;</span><span class="n">sopass</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">wol</span><span class="o">-&gt;</span><span class="n">sopass</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * TCP Segmentation Offload flags which we support.</span>
<span class="cm"> */</span>
<span class="cp">#define TSO_FLAGS (NETIF_F_TSO | NETIF_F_TSO6 | NETIF_F_TSO_ECN)</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ethtool_ops</span> <span class="n">cxgb4vf_ethtool_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_settings</span>		<span class="o">=</span> <span class="n">cxgb4vf_get_settings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_drvinfo</span>		<span class="o">=</span> <span class="n">cxgb4vf_get_drvinfo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_msglevel</span>		<span class="o">=</span> <span class="n">cxgb4vf_get_msglevel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_msglevel</span>		<span class="o">=</span> <span class="n">cxgb4vf_set_msglevel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_ringparam</span>		<span class="o">=</span> <span class="n">cxgb4vf_get_ringparam</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_ringparam</span>		<span class="o">=</span> <span class="n">cxgb4vf_set_ringparam</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_coalesce</span>		<span class="o">=</span> <span class="n">cxgb4vf_get_coalesce</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_coalesce</span>		<span class="o">=</span> <span class="n">cxgb4vf_set_coalesce</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_pauseparam</span>		<span class="o">=</span> <span class="n">cxgb4vf_get_pauseparam</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_link</span>		<span class="o">=</span> <span class="n">ethtool_op_get_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_strings</span>		<span class="o">=</span> <span class="n">cxgb4vf_get_strings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_phys_id</span>		<span class="o">=</span> <span class="n">cxgb4vf_phys_id</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_sset_count</span>		<span class="o">=</span> <span class="n">cxgb4vf_get_sset_count</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_ethtool_stats</span>	<span class="o">=</span> <span class="n">cxgb4vf_get_ethtool_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_regs_len</span>		<span class="o">=</span> <span class="n">cxgb4vf_get_regs_len</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_regs</span>		<span class="o">=</span> <span class="n">cxgb4vf_get_regs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_wol</span>		<span class="o">=</span> <span class="n">cxgb4vf_get_wol</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * /sys/kernel/debug/cxgb4vf support code and data.</span>
<span class="cm"> * ================================================</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Show SGE Queue Set information.  We display QPL Queues Sets per line.</span>
<span class="cm"> */</span>
<span class="cp">#define QPL	4</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sge_qinfo_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">eth_entries</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">ethqsets</span><span class="p">,</span> <span class="n">QPL</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">qs</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="n">seq_putc</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>

	<span class="cp">#define S3(fmt_spec, s, v) \</span>
<span class="cp">		do {\</span>
<span class="cp">			seq_printf(seq, &quot;%-12s&quot;, s); \</span>
<span class="cp">			for (qs = 0; qs &lt; n; ++qs) \</span>
<span class="cp">				seq_printf(seq, &quot; %16&quot; fmt_spec, v); \</span>
<span class="cp">			seq_putc(seq, &#39;\n&#39;); \</span>
<span class="cp">		} while (0)</span>
	<span class="cp">#define S(s, v)		S3(&quot;s&quot;, s, v)</span>
	<span class="cp">#define T(s, v)		S3(&quot;u&quot;, s, txq[qs].v)</span>
	<span class="cp">#define R(s, v)		S3(&quot;u&quot;, s, rxq[qs].v)</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">eth_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">sge_eth_rxq</span> <span class="o">*</span><span class="n">rxq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">ethrxq</span><span class="p">[</span><span class="n">r</span> <span class="o">*</span> <span class="n">QPL</span><span class="p">];</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">sge_eth_txq</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">ethtxq</span><span class="p">[</span><span class="n">r</span> <span class="o">*</span> <span class="n">QPL</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">QPL</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">ethqsets</span> <span class="o">-</span> <span class="n">QPL</span> <span class="o">*</span> <span class="n">r</span><span class="p">);</span>

		<span class="n">S</span><span class="p">(</span><span class="s">&quot;QType:&quot;</span><span class="p">,</span> <span class="s">&quot;Ethernet&quot;</span><span class="p">);</span>
		<span class="n">S</span><span class="p">(</span><span class="s">&quot;Interface:&quot;</span><span class="p">,</span>
		  <span class="p">(</span><span class="n">rxq</span><span class="p">[</span><span class="n">qs</span><span class="p">].</span><span class="n">rspq</span><span class="p">.</span><span class="n">netdev</span>
		   <span class="o">?</span> <span class="n">rxq</span><span class="p">[</span><span class="n">qs</span><span class="p">].</span><span class="n">rspq</span><span class="p">.</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span>
		   <span class="o">:</span> <span class="s">&quot;N/A&quot;</span><span class="p">));</span>
		<span class="n">S3</span><span class="p">(</span><span class="s">&quot;d&quot;</span><span class="p">,</span> <span class="s">&quot;Port:&quot;</span><span class="p">,</span>
		   <span class="p">(</span><span class="n">rxq</span><span class="p">[</span><span class="n">qs</span><span class="p">].</span><span class="n">rspq</span><span class="p">.</span><span class="n">netdev</span>
		    <span class="o">?</span> <span class="p">((</span><span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="p">)</span>
		       <span class="n">netdev_priv</span><span class="p">(</span><span class="n">rxq</span><span class="p">[</span><span class="n">qs</span><span class="p">].</span><span class="n">rspq</span><span class="p">.</span><span class="n">netdev</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">port_id</span>
		    <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">));</span>
		<span class="n">T</span><span class="p">(</span><span class="s">&quot;TxQ ID:&quot;</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">abs_id</span><span class="p">);</span>
		<span class="n">T</span><span class="p">(</span><span class="s">&quot;TxQ size:&quot;</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
		<span class="n">T</span><span class="p">(</span><span class="s">&quot;TxQ inuse:&quot;</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">in_use</span><span class="p">);</span>
		<span class="n">T</span><span class="p">(</span><span class="s">&quot;TxQ PIdx:&quot;</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">pidx</span><span class="p">);</span>
		<span class="n">T</span><span class="p">(</span><span class="s">&quot;TxQ CIdx:&quot;</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">cidx</span><span class="p">);</span>
		<span class="n">R</span><span class="p">(</span><span class="s">&quot;RspQ ID:&quot;</span><span class="p">,</span> <span class="n">rspq</span><span class="p">.</span><span class="n">abs_id</span><span class="p">);</span>
		<span class="n">R</span><span class="p">(</span><span class="s">&quot;RspQ size:&quot;</span><span class="p">,</span> <span class="n">rspq</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
		<span class="n">R</span><span class="p">(</span><span class="s">&quot;RspQE size:&quot;</span><span class="p">,</span> <span class="n">rspq</span><span class="p">.</span><span class="n">iqe_len</span><span class="p">);</span>
		<span class="n">S3</span><span class="p">(</span><span class="s">&quot;u&quot;</span><span class="p">,</span> <span class="s">&quot;Intr delay:&quot;</span><span class="p">,</span> <span class="n">qtimer_val</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxq</span><span class="p">[</span><span class="n">qs</span><span class="p">].</span><span class="n">rspq</span><span class="p">));</span>
		<span class="n">S3</span><span class="p">(</span><span class="s">&quot;u&quot;</span><span class="p">,</span> <span class="s">&quot;Intr pktcnt:&quot;</span><span class="p">,</span>
		   <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">counter_val</span><span class="p">[</span><span class="n">rxq</span><span class="p">[</span><span class="n">qs</span><span class="p">].</span><span class="n">rspq</span><span class="p">.</span><span class="n">pktcnt_idx</span><span class="p">]);</span>
		<span class="n">R</span><span class="p">(</span><span class="s">&quot;RspQ CIdx:&quot;</span><span class="p">,</span> <span class="n">rspq</span><span class="p">.</span><span class="n">cidx</span><span class="p">);</span>
		<span class="n">R</span><span class="p">(</span><span class="s">&quot;RspQ Gen:&quot;</span><span class="p">,</span> <span class="n">rspq</span><span class="p">.</span><span class="n">gen</span><span class="p">);</span>
		<span class="n">R</span><span class="p">(</span><span class="s">&quot;FL ID:&quot;</span><span class="p">,</span> <span class="n">fl</span><span class="p">.</span><span class="n">abs_id</span><span class="p">);</span>
		<span class="n">R</span><span class="p">(</span><span class="s">&quot;FL size:&quot;</span><span class="p">,</span> <span class="n">fl</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">MIN_FL_RESID</span><span class="p">);</span>
		<span class="n">R</span><span class="p">(</span><span class="s">&quot;FL avail:&quot;</span><span class="p">,</span> <span class="n">fl</span><span class="p">.</span><span class="n">avail</span><span class="p">);</span>
		<span class="n">R</span><span class="p">(</span><span class="s">&quot;FL PIdx:&quot;</span><span class="p">,</span> <span class="n">fl</span><span class="p">.</span><span class="n">pidx</span><span class="p">);</span>
		<span class="n">R</span><span class="p">(</span><span class="s">&quot;FL CIdx:&quot;</span><span class="p">,</span> <span class="n">fl</span><span class="p">.</span><span class="n">cidx</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">-=</span> <span class="n">eth_entries</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">evtq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">fw_evtq</span><span class="p">;</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%-12s %16s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;QType:&quot;</span><span class="p">,</span> <span class="s">&quot;FW event queue&quot;</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%-12s %16u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;RspQ ID:&quot;</span><span class="p">,</span> <span class="n">evtq</span><span class="o">-&gt;</span><span class="n">abs_id</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%-12s %16u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;Intr delay:&quot;</span><span class="p">,</span>
			   <span class="n">qtimer_val</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">evtq</span><span class="p">));</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%-12s %16u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;Intr pktcnt:&quot;</span><span class="p">,</span>
			   <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">counter_val</span><span class="p">[</span><span class="n">evtq</span><span class="o">-&gt;</span><span class="n">pktcnt_idx</span><span class="p">]);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%-12s %16u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;RspQ Cidx:&quot;</span><span class="p">,</span> <span class="n">evtq</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%-12s %16u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;RspQ Gen:&quot;</span><span class="p">,</span> <span class="n">evtq</span><span class="o">-&gt;</span><span class="n">gen</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">intrq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">intrq</span><span class="p">;</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%-12s %16s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;QType:&quot;</span><span class="p">,</span> <span class="s">&quot;Interrupt Queue&quot;</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%-12s %16u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;RspQ ID:&quot;</span><span class="p">,</span> <span class="n">intrq</span><span class="o">-&gt;</span><span class="n">abs_id</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%-12s %16u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;Intr delay:&quot;</span><span class="p">,</span>
			   <span class="n">qtimer_val</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">intrq</span><span class="p">));</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%-12s %16u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;Intr pktcnt:&quot;</span><span class="p">,</span>
			   <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">counter_val</span><span class="p">[</span><span class="n">intrq</span><span class="o">-&gt;</span><span class="n">pktcnt_idx</span><span class="p">]);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%-12s %16u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;RspQ Cidx:&quot;</span><span class="p">,</span> <span class="n">intrq</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%-12s %16u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;RspQ Gen:&quot;</span><span class="p">,</span> <span class="n">intrq</span><span class="o">-&gt;</span><span class="n">gen</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cp">#undef R</span>
	<span class="cp">#undef T</span>
	<span class="cp">#undef S</span>
	<span class="cp">#undef S3</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the number of &quot;entries&quot; in our &quot;file&quot;.  We group the multi-Queue</span>
<span class="cm"> * sections with QPL Queue Sets per &quot;entry&quot;.  The sections of the output are:</span>
<span class="cm"> *</span>
<span class="cm"> *     Ethernet RX/TX Queue Sets</span>
<span class="cm"> *     Firmware Event Queue</span>
<span class="cm"> *     Forwarded Interrupt Queue (if in MSI mode)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sge_queue_entries</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">ethqsets</span><span class="p">,</span> <span class="n">QPL</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span>
		<span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">USING_MSI</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">sge_queue_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">entries</span> <span class="o">=</span> <span class="n">sge_queue_entries</span><span class="p">(</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">*</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">entries</span> <span class="o">?</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">*</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sge_queue_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">sge_queue_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">entries</span> <span class="o">=</span> <span class="n">sge_queue_entries</span><span class="p">(</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>

	<span class="o">++*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">entries</span> <span class="o">?</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">*</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">sge_qinfo_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">sge_queue_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>  <span class="o">=</span> <span class="n">sge_queue_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>  <span class="o">=</span> <span class="n">sge_queue_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>  <span class="o">=</span> <span class="n">sge_qinfo_show</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sge_qinfo_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sge_qinfo_seq_ops</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
		<span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">sge_qinfo_debugfs_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>   <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>    <span class="o">=</span> <span class="n">sge_qinfo_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>    <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>  <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Show SGE Queue Set statistics.  We display QPL Queues Sets per line.</span>
<span class="cm"> */</span>
<span class="cp">#define QPL	4</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sge_qstats_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">eth_entries</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">ethqsets</span><span class="p">,</span> <span class="n">QPL</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">qs</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="n">seq_putc</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>

	<span class="cp">#define S3(fmt, s, v) \</span>
<span class="cp">		do { \</span>
<span class="cp">			seq_printf(seq, &quot;%-16s&quot;, s); \</span>
<span class="cp">			for (qs = 0; qs &lt; n; ++qs) \</span>
<span class="cp">				seq_printf(seq, &quot; %8&quot; fmt, v); \</span>
<span class="cp">			seq_putc(seq, &#39;\n&#39;); \</span>
<span class="cp">		} while (0)</span>
	<span class="cp">#define S(s, v)		S3(&quot;s&quot;, s, v)</span>

	<span class="cp">#define T3(fmt, s, v)	S3(fmt, s, txq[qs].v)</span>
	<span class="cp">#define T(s, v)		T3(&quot;lu&quot;, s, v)</span>

	<span class="cp">#define R3(fmt, s, v)	S3(fmt, s, rxq[qs].v)</span>
	<span class="cp">#define R(s, v)		R3(&quot;lu&quot;, s, v)</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">eth_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">sge_eth_rxq</span> <span class="o">*</span><span class="n">rxq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">ethrxq</span><span class="p">[</span><span class="n">r</span> <span class="o">*</span> <span class="n">QPL</span><span class="p">];</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">sge_eth_txq</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">ethtxq</span><span class="p">[</span><span class="n">r</span> <span class="o">*</span> <span class="n">QPL</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">QPL</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">ethqsets</span> <span class="o">-</span> <span class="n">QPL</span> <span class="o">*</span> <span class="n">r</span><span class="p">);</span>

		<span class="n">S</span><span class="p">(</span><span class="s">&quot;QType:&quot;</span><span class="p">,</span> <span class="s">&quot;Ethernet&quot;</span><span class="p">);</span>
		<span class="n">S</span><span class="p">(</span><span class="s">&quot;Interface:&quot;</span><span class="p">,</span>
		  <span class="p">(</span><span class="n">rxq</span><span class="p">[</span><span class="n">qs</span><span class="p">].</span><span class="n">rspq</span><span class="p">.</span><span class="n">netdev</span>
		   <span class="o">?</span> <span class="n">rxq</span><span class="p">[</span><span class="n">qs</span><span class="p">].</span><span class="n">rspq</span><span class="p">.</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span>
		   <span class="o">:</span> <span class="s">&quot;N/A&quot;</span><span class="p">));</span>
		<span class="n">R3</span><span class="p">(</span><span class="s">&quot;u&quot;</span><span class="p">,</span> <span class="s">&quot;RspQNullInts:&quot;</span><span class="p">,</span> <span class="n">rspq</span><span class="p">.</span><span class="n">unhandled_irqs</span><span class="p">);</span>
		<span class="n">R</span><span class="p">(</span><span class="s">&quot;RxPackets:&quot;</span><span class="p">,</span> <span class="n">stats</span><span class="p">.</span><span class="n">pkts</span><span class="p">);</span>
		<span class="n">R</span><span class="p">(</span><span class="s">&quot;RxCSO:&quot;</span><span class="p">,</span> <span class="n">stats</span><span class="p">.</span><span class="n">rx_cso</span><span class="p">);</span>
		<span class="n">R</span><span class="p">(</span><span class="s">&quot;VLANxtract:&quot;</span><span class="p">,</span> <span class="n">stats</span><span class="p">.</span><span class="n">vlan_ex</span><span class="p">);</span>
		<span class="n">R</span><span class="p">(</span><span class="s">&quot;LROmerged:&quot;</span><span class="p">,</span> <span class="n">stats</span><span class="p">.</span><span class="n">lro_merged</span><span class="p">);</span>
		<span class="n">R</span><span class="p">(</span><span class="s">&quot;LROpackets:&quot;</span><span class="p">,</span> <span class="n">stats</span><span class="p">.</span><span class="n">lro_pkts</span><span class="p">);</span>
		<span class="n">R</span><span class="p">(</span><span class="s">&quot;RxDrops:&quot;</span><span class="p">,</span> <span class="n">stats</span><span class="p">.</span><span class="n">rx_drops</span><span class="p">);</span>
		<span class="n">T</span><span class="p">(</span><span class="s">&quot;TSO:&quot;</span><span class="p">,</span> <span class="n">tso</span><span class="p">);</span>
		<span class="n">T</span><span class="p">(</span><span class="s">&quot;TxCSO:&quot;</span><span class="p">,</span> <span class="n">tx_cso</span><span class="p">);</span>
		<span class="n">T</span><span class="p">(</span><span class="s">&quot;VLANins:&quot;</span><span class="p">,</span> <span class="n">vlan_ins</span><span class="p">);</span>
		<span class="n">T</span><span class="p">(</span><span class="s">&quot;TxQFull:&quot;</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">stops</span><span class="p">);</span>
		<span class="n">T</span><span class="p">(</span><span class="s">&quot;TxQRestarts:&quot;</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">restarts</span><span class="p">);</span>
		<span class="n">T</span><span class="p">(</span><span class="s">&quot;TxMapErr:&quot;</span><span class="p">,</span> <span class="n">mapping_err</span><span class="p">);</span>
		<span class="n">R</span><span class="p">(</span><span class="s">&quot;FLAllocErr:&quot;</span><span class="p">,</span> <span class="n">fl</span><span class="p">.</span><span class="n">alloc_failed</span><span class="p">);</span>
		<span class="n">R</span><span class="p">(</span><span class="s">&quot;FLLrgAlcErr:&quot;</span><span class="p">,</span> <span class="n">fl</span><span class="p">.</span><span class="n">large_alloc_failed</span><span class="p">);</span>
		<span class="n">R</span><span class="p">(</span><span class="s">&quot;FLStarving:&quot;</span><span class="p">,</span> <span class="n">fl</span><span class="p">.</span><span class="n">starving</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">-=</span> <span class="n">eth_entries</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">evtq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">fw_evtq</span><span class="p">;</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%-8s %16s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;QType:&quot;</span><span class="p">,</span> <span class="s">&quot;FW event queue&quot;</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%-16s %8u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;RspQNullInts:&quot;</span><span class="p">,</span>
			   <span class="n">evtq</span><span class="o">-&gt;</span><span class="n">unhandled_irqs</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%-16s %8u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;RspQ CIdx:&quot;</span><span class="p">,</span> <span class="n">evtq</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%-16s %8u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;RspQ Gen:&quot;</span><span class="p">,</span> <span class="n">evtq</span><span class="o">-&gt;</span><span class="n">gen</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">intrq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">intrq</span><span class="p">;</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%-8s %16s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;QType:&quot;</span><span class="p">,</span> <span class="s">&quot;Interrupt Queue&quot;</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%-16s %8u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;RspQNullInts:&quot;</span><span class="p">,</span>
			   <span class="n">intrq</span><span class="o">-&gt;</span><span class="n">unhandled_irqs</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%-16s %8u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;RspQ CIdx:&quot;</span><span class="p">,</span> <span class="n">intrq</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%-16s %8u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;RspQ Gen:&quot;</span><span class="p">,</span> <span class="n">intrq</span><span class="o">-&gt;</span><span class="n">gen</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cp">#undef R</span>
	<span class="cp">#undef T</span>
	<span class="cp">#undef S</span>
	<span class="cp">#undef R3</span>
	<span class="cp">#undef T3</span>
	<span class="cp">#undef S3</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the number of &quot;entries&quot; in our &quot;file&quot;.  We group the multi-Queue</span>
<span class="cm"> * sections with QPL Queue Sets per &quot;entry&quot;.  The sections of the output are:</span>
<span class="cm"> *</span>
<span class="cm"> *     Ethernet RX/TX Queue Sets</span>
<span class="cm"> *     Firmware Event Queue</span>
<span class="cm"> *     Forwarded Interrupt Queue (if in MSI mode)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sge_qstats_entries</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">ethqsets</span><span class="p">,</span> <span class="n">QPL</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span>
		<span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">USING_MSI</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">sge_qstats_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">entries</span> <span class="o">=</span> <span class="n">sge_qstats_entries</span><span class="p">(</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">*</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">entries</span> <span class="o">?</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">*</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sge_qstats_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">sge_qstats_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">entries</span> <span class="o">=</span> <span class="n">sge_qstats_entries</span><span class="p">(</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>

	<span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">entries</span> <span class="o">?</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">*</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">sge_qstats_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">sge_qstats_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>  <span class="o">=</span> <span class="n">sge_qstats_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>  <span class="o">=</span> <span class="n">sge_qstats_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>  <span class="o">=</span> <span class="n">sge_qstats_show</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sge_qstats_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sge_qstats_seq_ops</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
		<span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">sge_qstats_proc_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>   <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>    <span class="o">=</span> <span class="n">sge_qstats_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>    <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>  <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Show PCI-E SR-IOV Virtual Function Resource Limits.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">resources_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vf_resources</span> <span class="o">*</span><span class="n">vfres</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">vfres</span><span class="p">;</span>

	<span class="cp">#define S(desc, fmt, var) \</span>
<span class="cp">		seq_printf(seq, &quot;%-60s &quot; fmt &quot;\n&quot;, \</span>
<span class="cp">			   desc &quot; (&quot; #var &quot;):&quot;, vfres-&gt;var)</span>

	<span class="n">S</span><span class="p">(</span><span class="s">&quot;Virtual Interfaces&quot;</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">nvi</span><span class="p">);</span>
	<span class="n">S</span><span class="p">(</span><span class="s">&quot;Egress Queues&quot;</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">neq</span><span class="p">);</span>
	<span class="n">S</span><span class="p">(</span><span class="s">&quot;Ethernet Control&quot;</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">nethctrl</span><span class="p">);</span>
	<span class="n">S</span><span class="p">(</span><span class="s">&quot;Ingress Queues/w Free Lists/Interrupts&quot;</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">niqflint</span><span class="p">);</span>
	<span class="n">S</span><span class="p">(</span><span class="s">&quot;Ingress Queues&quot;</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">niq</span><span class="p">);</span>
	<span class="n">S</span><span class="p">(</span><span class="s">&quot;Traffic Class&quot;</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">tc</span><span class="p">);</span>
	<span class="n">S</span><span class="p">(</span><span class="s">&quot;Port Access Rights Mask&quot;</span><span class="p">,</span> <span class="s">&quot;%#x&quot;</span><span class="p">,</span> <span class="n">pmask</span><span class="p">);</span>
	<span class="n">S</span><span class="p">(</span><span class="s">&quot;MAC Address Filters&quot;</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">nexactf</span><span class="p">);</span>
	<span class="n">S</span><span class="p">(</span><span class="s">&quot;Firmware Command Read Capabilities&quot;</span><span class="p">,</span> <span class="s">&quot;%#x&quot;</span><span class="p">,</span> <span class="n">r_caps</span><span class="p">);</span>
	<span class="n">S</span><span class="p">(</span><span class="s">&quot;Firmware Command Write/Execute Capabilities&quot;</span><span class="p">,</span> <span class="s">&quot;%#x&quot;</span><span class="p">,</span> <span class="n">wx_caps</span><span class="p">);</span>

	<span class="cp">#undef S</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">resources_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">resources_show</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">resources_proc_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>   <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>    <span class="o">=</span> <span class="n">resources_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>    <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>  <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Show Virtual Interfaces.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">interfaces_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">SEQ_START_TOKEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;Interface  Port   VIID</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">pidx</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">v</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">pidx</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%9s  %4d  %#5x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">viid</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">interfaces_get_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pos</span> <span class="o">&lt;=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">nports</span>
		<span class="o">?</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">uintptr_t</span><span class="p">)(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">interfaces_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">pos</span>
		<span class="o">?</span> <span class="n">interfaces_get_idx</span><span class="p">(</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
		<span class="o">:</span> <span class="n">SEQ_START_TOKEN</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">interfaces_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">interfaces_get_idx</span><span class="p">(</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">interfaces_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">interfaces_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">interfaces_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>  <span class="o">=</span> <span class="n">interfaces_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>  <span class="o">=</span> <span class="n">interfaces_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>  <span class="o">=</span> <span class="n">interfaces_show</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">interfaces_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">interfaces_seq_ops</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
		<span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">interfaces_proc_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>   <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>    <span class="o">=</span> <span class="n">interfaces_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>    <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>  <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * /sys/kernel/debugfs/cxgb4vf/ files list.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cxgb4vf_debugfs_entry</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>		<span class="cm">/* name of debugfs node */</span>
	<span class="n">umode_t</span> <span class="n">mode</span><span class="p">;</span>			<span class="cm">/* file system mode */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">fops</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cxgb4vf_debugfs_entry</span> <span class="n">debugfs_files</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="s">&quot;sge_qinfo&quot;</span><span class="p">,</span>  <span class="n">S_IRUGO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sge_qinfo_debugfs_fops</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;sge_qstats&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sge_qstats_proc_fops</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;resources&quot;</span><span class="p">,</span>  <span class="n">S_IRUGO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">resources_proc_fops</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;interfaces&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">interfaces_proc_fops</span> <span class="p">},</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Module and device initialization and cleanup code.</span>
<span class="cm"> * ==================================================</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Set up out /sys/kernel/debug/cxgb4vf sub-nodes.  We assume that the</span>
<span class="cm"> * directory (debugfs_root) has already been set up.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">setup_debugfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">debugfs_root</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Debugfs support is best effort.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">debugfs_files</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">debugfs_create_file</span><span class="p">(</span><span class="n">debugfs_files</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span>
				  <span class="n">debugfs_files</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mode</span><span class="p">,</span>
				  <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">debugfs_root</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="p">,</span>
				  <span class="n">debugfs_files</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">fops</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Tear down the /sys/kernel/debug/cxgb4vf sub-nodes created above.  We leave</span>
<span class="cm"> * it to our caller to tear down the directory (debugfs_root).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cleanup_debugfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">debugfs_root</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unlike our sister routine cleanup_proc(), we don&#39;t need to remove</span>
<span class="cm">	 * individual entries because a call will be made to</span>
<span class="cm">	 * debugfs_remove_recursive().  We just need to clean up any ancillary</span>
<span class="cm">	 * persistent state.</span>
<span class="cm">	 */</span>
	<span class="cm">/* nothing to do */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Perform early &quot;adapter&quot; initialization.  This is where we discover what</span>
<span class="cm"> * adapter parameters we&#39;re going to be using and initialize basic adapter</span>
<span class="cm"> * hardware support.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">adap_init0</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vf_resources</span> <span class="o">*</span><span class="n">vfres</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">vfres</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge_params</span> <span class="o">*</span><span class="n">sge_params</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">sge</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ethqsets</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait for the device to become ready before proceeding ...</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">t4vf_wait_dev_ready</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev_dev</span><span class="p">,</span> <span class="s">&quot;device didn&#39;t become ready:&quot;</span>
			<span class="s">&quot; err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some environments do not properly handle PCIE FLRs -- e.g. in Linux</span>
<span class="cm">	 * 2.6.31 and later we can&#39;t call pci_reset_function() in order to</span>
<span class="cm">	 * issue an FLR because of a self- deadlock on the device semaphore.</span>
<span class="cm">	 * Meanwhile, the OS infrastructure doesn&#39;t issue FLRs in all the</span>
<span class="cm">	 * cases where they&#39;re needed -- for instance, some versions of KVM</span>
<span class="cm">	 * fail to reset &quot;Assigned Devices&quot; when the VM reboots.  Therefore we</span>
<span class="cm">	 * use the firmware based reset in order to reset any per function</span>
<span class="cm">	 * state.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">t4vf_fw_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev_dev</span><span class="p">,</span> <span class="s">&quot;FW reset failed: err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Grab basic operational parameters.  These will predominantly have</span>
<span class="cm">	 * been set up by the Physical Function Driver or will be hard coded</span>
<span class="cm">	 * into the adapter.  We just have to live with them ...  Note that</span>
<span class="cm">	 * we _must_ get our VPD parameters before our SGE parameters because</span>
<span class="cm">	 * we need to know the adapter&#39;s core clock from the VPD in order to</span>
<span class="cm">	 * properly decode the SGE Timer Values.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">t4vf_get_dev_params</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev_dev</span><span class="p">,</span> <span class="s">&quot;unable to retrieve adapter&quot;</span>
			<span class="s">&quot; device parameters: err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">t4vf_get_vpd_params</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev_dev</span><span class="p">,</span> <span class="s">&quot;unable to retrieve adapter&quot;</span>
			<span class="s">&quot; VPD parameters: err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">t4vf_get_sge_params</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev_dev</span><span class="p">,</span> <span class="s">&quot;unable to retrieve adapter&quot;</span>
			<span class="s">&quot; SGE parameters: err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">t4vf_get_rss_glb_config</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev_dev</span><span class="p">,</span> <span class="s">&quot;unable to retrieve adapter&quot;</span>
			<span class="s">&quot; RSS parameters: err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">rss</span><span class="p">.</span><span class="n">mode</span> <span class="o">!=</span>
	    <span class="n">FW_RSS_GLB_CONFIG_CMD_MODE_BASICVIRTUAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev_dev</span><span class="p">,</span> <span class="s">&quot;unable to operate with global RSS&quot;</span>
			<span class="s">&quot; mode %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">rss</span><span class="p">.</span><span class="n">mode</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">t4vf_sge_init</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev_dev</span><span class="p">,</span> <span class="s">&quot;unable to use adapter parameters:&quot;</span>
			<span class="s">&quot; err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Retrieve our RX interrupt holdoff timer values and counter</span>
<span class="cm">	 * threshold values from the SGE parameters.</span>
<span class="cm">	 */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">timer_val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">core_ticks_to_us</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
		<span class="n">TIMERVALUE0_GET</span><span class="p">(</span><span class="n">sge_params</span><span class="o">-&gt;</span><span class="n">sge_timer_value_0_and_1</span><span class="p">));</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">timer_val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">core_ticks_to_us</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
		<span class="n">TIMERVALUE1_GET</span><span class="p">(</span><span class="n">sge_params</span><span class="o">-&gt;</span><span class="n">sge_timer_value_0_and_1</span><span class="p">));</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">timer_val</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">core_ticks_to_us</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
		<span class="n">TIMERVALUE0_GET</span><span class="p">(</span><span class="n">sge_params</span><span class="o">-&gt;</span><span class="n">sge_timer_value_2_and_3</span><span class="p">));</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">timer_val</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">core_ticks_to_us</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
		<span class="n">TIMERVALUE1_GET</span><span class="p">(</span><span class="n">sge_params</span><span class="o">-&gt;</span><span class="n">sge_timer_value_2_and_3</span><span class="p">));</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">timer_val</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">core_ticks_to_us</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
		<span class="n">TIMERVALUE0_GET</span><span class="p">(</span><span class="n">sge_params</span><span class="o">-&gt;</span><span class="n">sge_timer_value_4_and_5</span><span class="p">));</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">timer_val</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">core_ticks_to_us</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
		<span class="n">TIMERVALUE1_GET</span><span class="p">(</span><span class="n">sge_params</span><span class="o">-&gt;</span><span class="n">sge_timer_value_4_and_5</span><span class="p">));</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">counter_val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">THRESHOLD_0_GET</span><span class="p">(</span><span class="n">sge_params</span><span class="o">-&gt;</span><span class="n">sge_ingress_rx_threshold</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">counter_val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">THRESHOLD_1_GET</span><span class="p">(</span><span class="n">sge_params</span><span class="o">-&gt;</span><span class="n">sge_ingress_rx_threshold</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">counter_val</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">THRESHOLD_2_GET</span><span class="p">(</span><span class="n">sge_params</span><span class="o">-&gt;</span><span class="n">sge_ingress_rx_threshold</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">counter_val</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">THRESHOLD_3_GET</span><span class="p">(</span><span class="n">sge_params</span><span class="o">-&gt;</span><span class="n">sge_ingress_rx_threshold</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Grab our Virtual Interface resource allocation, extract the</span>
<span class="cm">	 * features that we&#39;re interested in and do a bit of sanity testing on</span>
<span class="cm">	 * what we discover.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">t4vf_get_vfres</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev_dev</span><span class="p">,</span> <span class="s">&quot;unable to get virtual interface&quot;</span>
			<span class="s">&quot; resources: err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The number of &quot;ports&quot; which we support is equal to the number of</span>
<span class="cm">	 * Virtual Interfaces with which we&#39;ve been provisioned.</span>
<span class="cm">	 */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">nports</span> <span class="o">=</span> <span class="n">vfres</span><span class="o">-&gt;</span><span class="n">nvi</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">nports</span> <span class="o">&gt;</span> <span class="n">MAX_NPORTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev_dev</span><span class="p">,</span> <span class="s">&quot;only using %d of %d allowed&quot;</span>
			 <span class="s">&quot; virtual interfaces</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MAX_NPORTS</span><span class="p">,</span>
			 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">nports</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">nports</span> <span class="o">=</span> <span class="n">MAX_NPORTS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to reserve a number of the ingress queues with Free List</span>
<span class="cm">	 * and Interrupt capabilities for special interrupt purposes (like</span>
<span class="cm">	 * asynchronous firmware messages, or forwarded interrupts if we&#39;re</span>
<span class="cm">	 * using MSI).  The rest of the FL/Intr-capable ingress queues will be</span>
<span class="cm">	 * matched up one-for-one with Ethernet/Control egress queues in order</span>
<span class="cm">	 * to form &quot;Queue Sets&quot; which will be aportioned between the &quot;ports&quot;.</span>
<span class="cm">	 * For each Queue Set, we&#39;ll need the ability to allocate two Egress</span>
<span class="cm">	 * Contexts -- one for the Ingress Queue Free List and one for the TX</span>
<span class="cm">	 * Ethernet Queue.</span>
<span class="cm">	 */</span>
	<span class="n">ethqsets</span> <span class="o">=</span> <span class="n">vfres</span><span class="o">-&gt;</span><span class="n">niqflint</span> <span class="o">-</span> <span class="n">INGQ_EXTRAS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vfres</span><span class="o">-&gt;</span><span class="n">nethctrl</span> <span class="o">!=</span> <span class="n">ethqsets</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev_dev</span><span class="p">,</span> <span class="s">&quot;unequal number of [available]&quot;</span>
			 <span class="s">&quot; ingress/egress queues (%d/%d); using minimum for&quot;</span>
			 <span class="s">&quot; number of Queue Sets</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ethqsets</span><span class="p">,</span> <span class="n">vfres</span><span class="o">-&gt;</span><span class="n">nethctrl</span><span class="p">);</span>
		<span class="n">ethqsets</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">vfres</span><span class="o">-&gt;</span><span class="n">nethctrl</span><span class="p">,</span> <span class="n">ethqsets</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vfres</span><span class="o">-&gt;</span><span class="n">neq</span> <span class="o">&lt;</span> <span class="n">ethqsets</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev_dev</span><span class="p">,</span> <span class="s">&quot;Not enough Egress Contexts (%d)&quot;</span>
			 <span class="s">&quot; to support Queue Sets (%d); reducing allowed Queue&quot;</span>
			 <span class="s">&quot; Sets</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vfres</span><span class="o">-&gt;</span><span class="n">neq</span><span class="p">,</span> <span class="n">ethqsets</span><span class="p">);</span>
		<span class="n">ethqsets</span> <span class="o">=</span> <span class="n">vfres</span><span class="o">-&gt;</span><span class="n">neq</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ethqsets</span> <span class="o">&gt;</span> <span class="n">MAX_ETH_QSETS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev_dev</span><span class="p">,</span> <span class="s">&quot;only using %d of %d allowed Queue&quot;</span>
			 <span class="s">&quot; Sets</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MAX_ETH_QSETS</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">max_ethqsets</span><span class="p">);</span>
		<span class="n">ethqsets</span> <span class="o">=</span> <span class="n">MAX_ETH_QSETS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vfres</span><span class="o">-&gt;</span><span class="n">niq</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">vfres</span><span class="o">-&gt;</span><span class="n">neq</span> <span class="o">&gt;</span> <span class="n">ethqsets</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev_dev</span><span class="p">,</span> <span class="s">&quot;unused resources niq/neq (%d/%d)&quot;</span>
			 <span class="s">&quot; ignored</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vfres</span><span class="o">-&gt;</span><span class="n">niq</span><span class="p">,</span> <span class="n">vfres</span><span class="o">-&gt;</span><span class="n">neq</span> <span class="o">-</span> <span class="n">ethqsets</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">max_ethqsets</span> <span class="o">=</span> <span class="n">ethqsets</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for various parameter sanity issues.  Most checks simply</span>
<span class="cm">	 * result in us using fewer resources than our provissioning but we</span>
<span class="cm">	 * do need at least  one &quot;port&quot; with which to work ...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">max_ethqsets</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">nports</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev_dev</span><span class="p">,</span> <span class="s">&quot;only using %d of %d available&quot;</span>
			 <span class="s">&quot; virtual interfaces (too few Queue Sets)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">max_ethqsets</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">nports</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">nports</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">max_ethqsets</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">nports</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev_dev</span><span class="p">,</span> <span class="s">&quot;no virtual interfaces configured/&quot;</span>
			<span class="s">&quot;usable!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">init_rspq</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">rspq</span><span class="p">,</span> <span class="n">u8</span> <span class="n">timer_idx</span><span class="p">,</span>
			     <span class="n">u8</span> <span class="n">pkt_cnt_idx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">iqe_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rspq</span><span class="o">-&gt;</span><span class="n">intr_params</span> <span class="o">=</span> <span class="p">(</span><span class="n">QINTR_TIMER_IDX</span><span class="p">(</span><span class="n">timer_idx</span><span class="p">)</span> <span class="o">|</span>
			     <span class="p">(</span><span class="n">pkt_cnt_idx</span> <span class="o">&lt;</span> <span class="n">SGE_NCOUNTERS</span> <span class="o">?</span> <span class="n">QINTR_CNT_EN</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
	<span class="n">rspq</span><span class="o">-&gt;</span><span class="n">pktcnt_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">pkt_cnt_idx</span> <span class="o">&lt;</span> <span class="n">SGE_NCOUNTERS</span>
			    <span class="o">?</span> <span class="n">pkt_cnt_idx</span>
			    <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">rspq</span><span class="o">-&gt;</span><span class="n">iqe_len</span> <span class="o">=</span> <span class="n">iqe_size</span><span class="p">;</span>
	<span class="n">rspq</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Perform default configuration of DMA queues depending on the number and</span>
<span class="cm"> * type of ports we found and the number of available CPUs.  Most settings can</span>
<span class="cm"> * be modified by the admin via ethtool and cxgbtool prior to the adapter</span>
<span class="cm"> * being brought up for the first time.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">cfg_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">q10g</span><span class="p">,</span> <span class="n">n10g</span><span class="p">,</span> <span class="n">qidx</span><span class="p">,</span> <span class="n">pidx</span><span class="p">,</span> <span class="n">qs</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">iqe_size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We should not be called till we know how many Queue Sets we can</span>
<span class="cm">	 * support.  In particular, this means that we need to know what kind</span>
<span class="cm">	 * of interrupts we&#39;ll be using ...</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">USING_MSIX</span><span class="o">|</span><span class="n">USING_MSI</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Count the number of 10GbE Virtual Interfaces that we have.</span>
<span class="cm">	 */</span>
	<span class="n">n10g</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">for_each_port</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pidx</span><span class="p">)</span>
		<span class="n">n10g</span> <span class="o">+=</span> <span class="n">is_10g_port</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap2pinfo</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pidx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">link_cfg</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We default to 1 queue per non-10G port and up to # of cores queues</span>
<span class="cm">	 * per 10G port.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n10g</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">q10g</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">n1g</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">nports</span> <span class="o">-</span> <span class="n">n10g</span><span class="p">);</span>
		<span class="n">q10g</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">max_ethqsets</span> <span class="o">-</span> <span class="n">n1g</span><span class="p">)</span> <span class="o">/</span> <span class="n">n10g</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q10g</span> <span class="o">&gt;</span> <span class="n">num_online_cpus</span><span class="p">())</span>
			<span class="n">q10g</span> <span class="o">=</span> <span class="n">num_online_cpus</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate the &quot;Queue Sets&quot; to the various Virtual Interfaces.</span>
<span class="cm">	 * The layout will be established in setup_sge_queues() when the</span>
<span class="cm">	 * adapter is brough up for the first time.</span>
<span class="cm">	 */</span>
	<span class="n">qidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">for_each_port</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pidx</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">adap2pinfo</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pidx</span><span class="p">);</span>

		<span class="n">pi</span><span class="o">-&gt;</span><span class="n">first_qset</span> <span class="o">=</span> <span class="n">qidx</span><span class="p">;</span>
		<span class="n">pi</span><span class="o">-&gt;</span><span class="n">nqsets</span> <span class="o">=</span> <span class="n">is_10g_port</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">link_cfg</span><span class="p">)</span> <span class="o">?</span> <span class="n">q10g</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">qidx</span> <span class="o">+=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">nqsets</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">ethqsets</span> <span class="o">=</span> <span class="n">qidx</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The Ingress Queue Entry Size for our various Response Queues needs</span>
<span class="cm">	 * to be big enough to accommodate the largest message we can receive</span>
<span class="cm">	 * from the chip/firmware; which is 64 bytes ...</span>
<span class="cm">	 */</span>
	<span class="n">iqe_size</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up default Queue Set parameters ...  Start off with the</span>
<span class="cm">	 * shortest interrupt holdoff timer.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">qs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">qs</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">max_ethqsets</span><span class="p">;</span> <span class="n">qs</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sge_eth_rxq</span> <span class="o">*</span><span class="n">rxq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ethrxq</span><span class="p">[</span><span class="n">qs</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">sge_eth_txq</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ethtxq</span><span class="p">[</span><span class="n">qs</span><span class="p">];</span>

		<span class="n">init_rspq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">iqe_size</span><span class="p">);</span>
		<span class="n">rxq</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">72</span><span class="p">;</span>
		<span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The firmware event queue is used for link state changes and</span>
<span class="cm">	 * notifications of TX DMA completions.</span>
<span class="cm">	 */</span>
	<span class="n">init_rspq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">fw_evtq</span><span class="p">,</span> <span class="n">SGE_TIMER_RSTRT_CNTR</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="n">iqe_size</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The forwarded interrupt queue is used when we&#39;re in MSI interrupt</span>
<span class="cm">	 * mode.  In this mode all interrupts associated with RX queues will</span>
<span class="cm">	 * be forwarded to a single queue which we&#39;ll associate with our MSI</span>
<span class="cm">	 * interrupt vector.  The messages dropped in the forwarded interrupt</span>
<span class="cm">	 * queue will indicate which ingress queue needs servicing ...  This</span>
<span class="cm">	 * queue needs to be large enough to accommodate all of the ingress</span>
<span class="cm">	 * queues which are forwarding their interrupt (+1 to prevent the PIDX</span>
<span class="cm">	 * from equalling the CIDX if every ingress queue has an outstanding</span>
<span class="cm">	 * interrupt).  The queue doesn&#39;t need to be any larger because no</span>
<span class="cm">	 * ingress queue will ever have more than one outstanding interrupt at</span>
<span class="cm">	 * any time ...</span>
<span class="cm">	 */</span>
	<span class="n">init_rspq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">intrq</span><span class="p">,</span> <span class="n">SGE_TIMER_RSTRT_CNTR</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MSIX_ENTRIES</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
		  <span class="n">iqe_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reduce the number of Ethernet queues across all ports to at most n.</span>
<span class="cm"> * n provides at least one queue per port.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">reduce_ethqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * While we have too many active Ether Queue Sets, interate across the</span>
<span class="cm">	 * &quot;ports&quot; and reduce their individual Queue Set allocations.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">nports</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">ethqsets</span><span class="p">)</span>
		<span class="n">for_each_port</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pi</span> <span class="o">=</span> <span class="n">adap2pinfo</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nqsets</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pi</span><span class="o">-&gt;</span><span class="n">nqsets</span><span class="o">--</span><span class="p">;</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">ethqsets</span><span class="o">--</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">ethqsets</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reassign the starting Queue Sets for each of the &quot;ports&quot; ...</span>
<span class="cm">	 */</span>
	<span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">for_each_port</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pi</span> <span class="o">=</span> <span class="n">adap2pinfo</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">pi</span><span class="o">-&gt;</span><span class="n">first_qset</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">n</span> <span class="o">+=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">nqsets</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We need to grab enough MSI-X vectors to cover our interrupt needs.  Ideally</span>
<span class="cm"> * we get a separate MSI-X vector for every &quot;Queue Set&quot; plus any extras we</span>
<span class="cm"> * need.  Minimally we need one for every Virtual Interface plus those needed</span>
<span class="cm"> * for our &quot;extras&quot;.  Note that this process may lower the maximum number of</span>
<span class="cm"> * allowed Queue Sets ...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">enable_msix</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">want</span><span class="p">,</span> <span class="n">need</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msix_entry</span> <span class="n">entries</span><span class="p">[</span><span class="n">MSIX_ENTRIES</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MSIX_ENTRIES</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">entry</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We _want_ enough MSI-X interrupts to cover all of our &quot;Queue Sets&quot;</span>
<span class="cm">	 * plus those needed for our &quot;extras&quot; (for example, the firmware</span>
<span class="cm">	 * message queue).  We _need_ at least one &quot;Queue Set&quot; per Virtual</span>
<span class="cm">	 * Interface plus those needed for our &quot;extras&quot;.  So now we get to see</span>
<span class="cm">	 * if the song is right ...</span>
<span class="cm">	 */</span>
	<span class="n">want</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">max_ethqsets</span> <span class="o">+</span> <span class="n">MSIX_EXTRAS</span><span class="p">;</span>
	<span class="n">need</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">nports</span> <span class="o">+</span> <span class="n">MSIX_EXTRAS</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_msix</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="n">want</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="n">need</span><span class="p">)</span>
		<span class="n">want</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">nqsets</span> <span class="o">=</span> <span class="n">want</span> <span class="o">-</span> <span class="n">MSIX_EXTRAS</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nqsets</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">max_ethqsets</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev_dev</span><span class="p">,</span> <span class="s">&quot;only enough MSI-X vectors&quot;</span>
				 <span class="s">&quot; for %d Queue Sets</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nqsets</span><span class="p">);</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">max_ethqsets</span> <span class="o">=</span> <span class="n">nqsets</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nqsets</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">ethqsets</span><span class="p">)</span>
				<span class="n">reduce_ethqs</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">nqsets</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">want</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vec</span> <span class="o">=</span> <span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev_dev</span><span class="p">,</span> <span class="s">&quot;only %d MSI-X vectors left,&quot;</span>
			 <span class="s">&quot; not using MSI-X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">cxgb4vf_netdev_ops</span>	<span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>		<span class="o">=</span> <span class="n">cxgb4vf_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">cxgb4vf_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">t4vf_eth_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_stats</span>		<span class="o">=</span> <span class="n">cxgb4vf_get_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">cxgb4vf_set_rxmode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span>	<span class="o">=</span> <span class="n">cxgb4vf_set_mac_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_validate_addr</span>	<span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span>		<span class="o">=</span> <span class="n">cxgb4vf_do_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>		<span class="o">=</span> <span class="n">cxgb4vf_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_fix_features</span>	<span class="o">=</span> <span class="n">cxgb4vf_fix_features</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_features</span>	<span class="o">=</span> <span class="n">cxgb4vf_set_features</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
	<span class="p">.</span><span class="n">ndo_poll_controller</span>	<span class="o">=</span> <span class="n">cxgb4vf_poll_controller</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * &quot;Probe&quot; a device: initialize a device and construct all kernel and driver</span>
<span class="cm"> * state needed to manage the device.  This routine is called &quot;init_one&quot; in</span>
<span class="cm"> * the PF Driver ...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">cxgb4vf_pci_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">version_printed</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">pci_using_dac</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">pidx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pmask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Print our driver banner the first time we&#39;re called to initialize a</span>
<span class="cm">	 * device.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">version_printed</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s - version %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">DRV_DESC</span><span class="p">,</span> <span class="n">DRV_VERSION</span><span class="p">);</span>
		<span class="n">version_printed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize generic PCI device state.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot enable PCI device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reserve PCI resources for the device.  If we can&#39;t get them some</span>
<span class="cm">	 * other driver may have already claimed the device ...</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_request_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">KBUILD_MODNAME</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot obtain PCI resources</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_disable_device</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up our DMA mask: try for 64-bit address masking first and</span>
<span class="cm">	 * fall back to 32-bit if we can&#39;t get 64 bits ...</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to obtain 64-bit DMA for&quot;</span>
				<span class="s">&quot; coherent allocations</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_release_regions</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pci_using_dac</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no usable DMA configuration</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_release_regions</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pci_using_dac</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enable bus mastering for the device ...</span>
<span class="cm">	 */</span>
	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate our adapter data structure and attach it to the device.</span>
<span class="cm">	 */</span>
	<span class="n">adapter</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">adapter</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_release_regions</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev_dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize SMP data synchronization resources.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Map our I/O registers in BAR0.</span>
<span class="cm">	 */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">=</span> <span class="n">pci_ioremap_bar</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot map device registers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_free_adapter</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize adapter level features.</span>
<span class="cm">	 */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">dflt_msg_enable</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">adap_init0</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_unmap_bar</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate our &quot;adapter ports&quot; and stitch everything together.</span>
<span class="cm">	 */</span>
	<span class="n">pmask</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">vfres</span><span class="p">.</span><span class="n">pmask</span><span class="p">;</span>
	<span class="n">for_each_port</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pidx</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">port_id</span><span class="p">,</span> <span class="n">viid</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We simplistically allocate our virtual interfaces</span>
<span class="cm">		 * sequentially across the port numbers to which we have</span>
<span class="cm">		 * access rights.  This should be configurable in some manner</span>
<span class="cm">		 * ...</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">port_id</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">(</span><span class="n">pmask</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pmask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">port_id</span><span class="p">);</span>
		<span class="n">viid</span> <span class="o">=</span> <span class="n">t4vf_alloc_vi</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">port_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">viid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot allocate VI for port %d:&quot;</span>
				<span class="s">&quot; err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port_id</span><span class="p">,</span> <span class="n">viid</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">viid</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_free_dev</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Allocate our network device and stitch things together.</span>
<span class="cm">		 */</span>
		<span class="n">netdev</span> <span class="o">=</span> <span class="n">alloc_etherdev_mq</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">port_info</span><span class="p">),</span>
					   <span class="n">MAX_PORT_QSETS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">t4vf_free_vi</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">viid</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_free_dev</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">pidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">netdev</span><span class="p">;</span>
		<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="n">pi</span><span class="o">-&gt;</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">adapter</span><span class="p">;</span>
		<span class="n">pi</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">=</span> <span class="n">pidx</span><span class="p">;</span>
		<span class="n">pi</span><span class="o">-&gt;</span><span class="n">port_id</span> <span class="o">=</span> <span class="n">port_id</span><span class="p">;</span>
		<span class="n">pi</span><span class="o">-&gt;</span><span class="n">viid</span> <span class="o">=</span> <span class="n">viid</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Initialize the starting state of our &quot;port&quot; and register</span>
<span class="cm">		 * it.</span>
<span class="cm">		 */</span>
		<span class="n">pi</span><span class="o">-&gt;</span><span class="n">xact_addr_filt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>

		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">=</span> <span class="n">NETIF_F_SG</span> <span class="o">|</span> <span class="n">TSO_FLAGS</span> <span class="o">|</span>
			<span class="n">NETIF_F_IP_CSUM</span> <span class="o">|</span> <span class="n">NETIF_F_IPV6_CSUM</span> <span class="o">|</span>
			<span class="n">NETIF_F_HW_VLAN_RX</span> <span class="o">|</span> <span class="n">NETIF_F_RXCSUM</span><span class="p">;</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">vlan_features</span> <span class="o">=</span> <span class="n">NETIF_F_SG</span> <span class="o">|</span> <span class="n">TSO_FLAGS</span> <span class="o">|</span>
			<span class="n">NETIF_F_IP_CSUM</span> <span class="o">|</span> <span class="n">NETIF_F_IPV6_CSUM</span> <span class="o">|</span>
			<span class="n">NETIF_F_HIGHDMA</span><span class="p">;</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">|</span> <span class="n">NETIF_F_HW_VLAN_TX</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_using_dac</span><span class="p">)</span>
			<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_HIGHDMA</span><span class="p">;</span>

		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">|=</span> <span class="n">IFF_UNICAST_FLT</span><span class="p">;</span>

		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cxgb4vf_netdev_ops</span><span class="p">;</span>
		<span class="n">SET_ETHTOOL_OPS</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cxgb4vf_ethtool_ops</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Initialize the hardware/software state for the port.</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">t4vf_port_init</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pidx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot initialize port %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pidx</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_free_dev</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The &quot;card&quot; is now ready to go.  If any errors occur during device</span>
<span class="cm">	 * registration we do not fail the whole &quot;card&quot; but rather proceed</span>
<span class="cm">	 * only with the ports we manage to register successfully.  However we</span>
<span class="cm">	 * must register at least one net device.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_port</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pidx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">pidx</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot register net device %s,&quot;</span>
				 <span class="s">&quot; skipping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">set_bit</span><span class="p">(</span><span class="n">pidx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">registered_device_map</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">registered_device_map</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not register any net devices</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_free_dev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up our debugfs entries.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">cxgb4vf_debugfs_root</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">debugfs_root</span> <span class="o">=</span>
			<span class="n">debugfs_create_dir</span><span class="p">(</span><span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">),</span>
					   <span class="n">cxgb4vf_debugfs_root</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">debugfs_root</span><span class="p">))</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not create debugfs&quot;</span>
				 <span class="s">&quot; directory&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">setup_debugfs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * See what interrupts we&#39;ll be using.  If we&#39;ve been configured to</span>
<span class="cm">	 * use MSI-X interrupts, try to enable them but fall back to using</span>
<span class="cm">	 * MSI interrupts if we can&#39;t enable MSI-X interrupts.  If we can&#39;t</span>
<span class="cm">	 * get MSI interrupts we bail with the error.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msi</span> <span class="o">==</span> <span class="n">MSI_MSIX</span> <span class="o">&amp;&amp;</span> <span class="n">enable_msix</span><span class="p">(</span><span class="n">adapter</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">USING_MSIX</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_msi</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to allocate %s interrupts;&quot;</span>
				<span class="s">&quot; err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">msi</span> <span class="o">==</span> <span class="n">MSI_MSIX</span> <span class="o">?</span> <span class="s">&quot;MSI-X or MSI&quot;</span> <span class="o">:</span> <span class="s">&quot;MSI&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_free_debugfs</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">USING_MSI</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now that we know how many &quot;ports&quot; we have and what their types are,</span>
<span class="cm">	 * and how many Queue Sets we can support, we can configure our queue</span>
<span class="cm">	 * resources.</span>
<span class="cm">	 */</span>
	<span class="n">cfg_queues</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Print a short notice on the existence and configuration of the new</span>
<span class="cm">	 * VF network device ...</span>
<span class="cm">	 */</span>
	<span class="n">for_each_port</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pidx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev_dev</span><span class="p">,</span> <span class="s">&quot;%s: Chelsio VF NIC PCIe %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">pidx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">USING_MSIX</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;MSI-X&quot;</span> <span class="o">:</span>
			 <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">USING_MSI</span><span class="p">)</span>  <span class="o">?</span> <span class="s">&quot;MSI&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Return success!</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Error recovery and exit code.  Unwind state that&#39;s been created</span>
<span class="cm">	 * so far and return the error.</span>
<span class="cm">	 */</span>

<span class="nl">err_free_debugfs:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">debugfs_root</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cleanup_debugfs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">debugfs_remove_recursive</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">debugfs_root</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">err_free_dev:</span>
	<span class="n">for_each_port</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pidx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">pidx</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="n">t4vf_free_vi</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">viid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">pidx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">registered_device_map</span><span class="p">))</span>
			<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="n">free_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">err_unmap_bar:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>

<span class="nl">err_free_adapter:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="nl">err_release_regions:</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">pci_clear_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

<span class="nl">err_disable_device:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * &quot;Remove&quot; a device: tear down all kernel and driver state created in the</span>
<span class="cm"> * &quot;probe&quot; routine and quiesce the device (disable interrupts, etc.).  (Note</span>
<span class="cm"> * that this is called &quot;remove_one&quot; in the PF Driver.)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">cxgb4vf_pci_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Tear down driver state associated with device.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">pidx</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Stop all of our activity.  Unregister network port,</span>
<span class="cm">		 * disable interrupts, etc.</span>
<span class="cm">		 */</span>
		<span class="n">for_each_port</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pidx</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">pidx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">registered_device_map</span><span class="p">))</span>
				<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">pidx</span><span class="p">]);</span>
		<span class="n">t4vf_sge_stop</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">USING_MSIX</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">USING_MSIX</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">USING_MSI</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">USING_MSI</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Tear down our debugfs entries.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">debugfs_root</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cleanup_debugfs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
			<span class="n">debugfs_remove_recursive</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">debugfs_root</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Free all of the various resources which we&#39;ve acquired ...</span>
<span class="cm">		 */</span>
		<span class="n">t4vf_free_sge_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">for_each_port</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pidx</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">pidx</span><span class="p">];</span>
			<span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
			<span class="n">t4vf_free_vi</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">viid</span><span class="p">);</span>
			<span class="n">free_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable the device and release its PCI resources.</span>
<span class="cm">	 */</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_clear_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * &quot;Shutdown&quot; quiesce the device, stopping Ingress Packet and Interrupt</span>
<span class="cm"> * delivery.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">cxgb4vf_pci_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pidx</span><span class="p">;</span>

	<span class="n">adapter</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable all Virtual Interfaces.  This will shut down the</span>
<span class="cm">	 * delivery of all ingress packets into the chip for these</span>
<span class="cm">	 * Virtual Interfaces.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_port</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pidx</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">pidx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">registered_device_map</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">pidx</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netdev</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="n">t4vf_enable_vi</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">viid</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Free up all Queues which will prevent further DMA and</span>
<span class="cm">	 * Interrupts allowing various internal pathways to drain.</span>
<span class="cm">	 */</span>
	<span class="n">t4vf_free_sge_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * PCI Device registration data structures.</span>
<span class="cm"> */</span>
<span class="cp">#define CH_DEVICE(devid, idx) \</span>
<span class="cp">	{ PCI_VENDOR_ID_CHELSIO, devid, PCI_ANY_ID, PCI_ANY_ID, 0, 0, idx }</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">cxgb4vf_pci_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">CH_DEVICE</span><span class="p">(</span><span class="mh">0xb000</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>	<span class="cm">/* PE10K FPGA */</span>
	<span class="n">CH_DEVICE</span><span class="p">(</span><span class="mh">0x4800</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>	<span class="cm">/* T440-dbg */</span>
	<span class="n">CH_DEVICE</span><span class="p">(</span><span class="mh">0x4801</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>	<span class="cm">/* T420-cr */</span>
	<span class="n">CH_DEVICE</span><span class="p">(</span><span class="mh">0x4802</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>	<span class="cm">/* T422-cr */</span>
	<span class="n">CH_DEVICE</span><span class="p">(</span><span class="mh">0x4803</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>	<span class="cm">/* T440-cr */</span>
	<span class="n">CH_DEVICE</span><span class="p">(</span><span class="mh">0x4804</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>	<span class="cm">/* T420-bch */</span>
	<span class="n">CH_DEVICE</span><span class="p">(</span><span class="mh">0x4805</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>   <span class="cm">/* T440-bch */</span>
	<span class="n">CH_DEVICE</span><span class="p">(</span><span class="mh">0x4806</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>	<span class="cm">/* T460-ch */</span>
	<span class="n">CH_DEVICE</span><span class="p">(</span><span class="mh">0x4807</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>	<span class="cm">/* T420-so */</span>
	<span class="n">CH_DEVICE</span><span class="p">(</span><span class="mh">0x4808</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>	<span class="cm">/* T420-cx */</span>
	<span class="n">CH_DEVICE</span><span class="p">(</span><span class="mh">0x4809</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>	<span class="cm">/* T420-bt */</span>
	<span class="n">CH_DEVICE</span><span class="p">(</span><span class="mh">0x480a</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>   <span class="cm">/* T404-bt */</span>
	<span class="n">CH_DEVICE</span><span class="p">(</span><span class="mh">0x480d</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>   <span class="cm">/* T480-cr */</span>
	<span class="n">CH_DEVICE</span><span class="p">(</span><span class="mh">0x480e</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>   <span class="cm">/* T440-lp-cr */</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">DRV_DESC</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Chelsio Communications&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;Dual BSD/GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">DRV_VERSION</span><span class="p">);</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">cxgb4vf_pci_tbl</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">cxgb4vf_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">KBUILD_MODNAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">cxgb4vf_pci_tbl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">cxgb4vf_pci_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">cxgb4vf_pci_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">shutdown</span>	<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">cxgb4vf_pci_shutdown</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize global driver state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">cxgb4vf_module_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Vet our module parameters.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msi</span> <span class="o">!=</span> <span class="n">MSI_MSIX</span> <span class="o">&amp;&amp;</span> <span class="n">msi</span> <span class="o">!=</span> <span class="n">MSI_MSI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">KBUILD_MODNAME</span>
		       <span class="s">&quot;: bad module parameter msi=%d; must be %d&quot;</span>
		       <span class="s">&quot; (MSI-X or MSI) or %d (MSI)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">msi</span><span class="p">,</span> <span class="n">MSI_MSIX</span><span class="p">,</span> <span class="n">MSI_MSI</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Debugfs support is optional, just warn if this fails */</span>
	<span class="n">cxgb4vf_debugfs_root</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="n">KBUILD_MODNAME</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">cxgb4vf_debugfs_root</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">KBUILD_MODNAME</span> <span class="s">&quot;: could not create&quot;</span>
		       <span class="s">&quot; debugfs entry, continuing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cxgb4vf_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">cxgb4vf_debugfs_root</span><span class="p">))</span>
		<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">cxgb4vf_debugfs_root</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Tear down global driver state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">cxgb4vf_module_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cxgb4vf_driver</span><span class="p">);</span>
	<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">cxgb4vf_debugfs_root</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">cxgb4vf_module_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">cxgb4vf_module_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
