<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › chelsio › cxgb4vf › adapter.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>adapter.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is part of the Chelsio T4 PCI-E SR-IOV Virtual Function Ethernet</span>
<span class="cm"> * driver for Linux.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2009-2010 Chelsio Communications, Inc. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This software is available to you under a choice of one of two</span>
<span class="cm"> * licenses.  You may choose to be licensed under the terms of the GNU</span>
<span class="cm"> * General Public License (GPL) Version 2, available from the file</span>
<span class="cm"> * COPYING in the main directory of this source tree, or the</span>
<span class="cm"> * OpenIB.org BSD license below:</span>
<span class="cm"> *</span>
<span class="cm"> *     Redistribution and use in source and binary forms, with or</span>
<span class="cm"> *     without modification, are permitted provided that the following</span>
<span class="cm"> *     conditions are met:</span>
<span class="cm"> *</span>
<span class="cm"> *      - Redistributions of source code must retain the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer.</span>
<span class="cm"> *</span>
<span class="cm"> *      - Redistributions in binary form must reproduce the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer in the documentation and/or other materials</span>
<span class="cm"> *        provided with the distribution.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="cm"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="cm"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS</span>
<span class="cm"> * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN</span>
<span class="cm"> * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span>
<span class="cm"> * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="cm"> * SOFTWARE.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This file should not be included directly.  Include t4vf_common.h instead.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __CXGB4VF_ADAPTER_H__</span>
<span class="cp">#define __CXGB4VF_ADAPTER_H__</span>

<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/if_ether.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>

<span class="cp">#include &quot;../cxgb4/t4_hw.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Constants of the implementation.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">MAX_NPORTS</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>		<span class="cm">/* max # of &quot;ports&quot; */</span>
	<span class="n">MAX_PORT_QSETS</span>	<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>		<span class="cm">/* max # of Queue Sets / &quot;port&quot; */</span>
	<span class="n">MAX_ETH_QSETS</span>	<span class="o">=</span> <span class="n">MAX_NPORTS</span><span class="o">*</span><span class="n">MAX_PORT_QSETS</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * MSI-X interrupt index usage.</span>
<span class="cm">	 */</span>
	<span class="n">MSIX_FW</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>		<span class="cm">/* MSI-X index for firmware Q */</span>
	<span class="n">MSIX_IQFLINT</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>		<span class="cm">/* MSI-X index base for Ingress Qs */</span>
	<span class="n">MSIX_EXTRAS</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">MSIX_ENTRIES</span>	<span class="o">=</span> <span class="n">MAX_ETH_QSETS</span> <span class="o">+</span> <span class="n">MSIX_EXTRAS</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * The maximum number of Ingress and Egress Queues is determined by</span>
<span class="cm">	 * the maximum number of &quot;Queue Sets&quot; which we support plus any</span>
<span class="cm">	 * ancillary queues.  Each &quot;Queue Set&quot; requires one Ingress Queue</span>
<span class="cm">	 * for RX Packet Ingress Event notifications and two Egress Queues for</span>
<span class="cm">	 * a Free List and an Ethernet TX list.</span>
<span class="cm">	 */</span>
	<span class="n">INGQ_EXTRAS</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>		<span class="cm">/* firmware event queue and */</span>
					<span class="cm">/*   forwarded interrupts */</span>
	<span class="n">MAX_INGQ</span>	<span class="o">=</span> <span class="n">MAX_ETH_QSETS</span><span class="o">+</span><span class="n">INGQ_EXTRAS</span><span class="p">,</span>
	<span class="n">MAX_EGRQ</span>	<span class="o">=</span> <span class="n">MAX_ETH_QSETS</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Forward structure definition references.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">adapter</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sge_eth_rxq</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sge_rspq</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Per-&quot;port&quot; information.  This is really per-Virtual Interface information</span>
<span class="cm"> * but the use of the &quot;port&quot; nomanclature makes it easier to go back and forth</span>
<span class="cm"> * between the PF and VF drivers ...</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">port_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>	<span class="cm">/* our adapter */</span>
	<span class="n">u16</span> <span class="n">viid</span><span class="p">;</span>			<span class="cm">/* virtual interface ID */</span>
	<span class="n">s16</span> <span class="n">xact_addr_filt</span><span class="p">;</span>		<span class="cm">/* index of our MAC address filter */</span>
	<span class="n">u16</span> <span class="n">rss_size</span><span class="p">;</span>			<span class="cm">/* size of VI&#39;s RSS table slice */</span>
	<span class="n">u8</span> <span class="n">pidx</span><span class="p">;</span>			<span class="cm">/* index into adapter port[] */</span>
	<span class="n">u8</span> <span class="n">port_id</span><span class="p">;</span>			<span class="cm">/* physical port ID */</span>
	<span class="n">u8</span> <span class="n">nqsets</span><span class="p">;</span>			<span class="cm">/* # of &quot;Queue Sets&quot; */</span>
	<span class="n">u8</span> <span class="n">first_qset</span><span class="p">;</span>			<span class="cm">/* index of first &quot;Queue Set&quot; */</span>
	<span class="k">struct</span> <span class="n">link_config</span> <span class="n">link_cfg</span><span class="p">;</span>	<span class="cm">/* physical port configuration */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Scatter Gather Engine resources for the &quot;adapter&quot;.  Our ingress and egress</span>
<span class="cm"> * queues are organized into &quot;Queue Sets&quot; with one ingress and one egress</span>
<span class="cm"> * queue per Queue Set.  These Queue Sets are aportionable between the &quot;ports&quot;</span>
<span class="cm"> * (Virtual Interfaces).  One extra ingress queue is used to receive</span>
<span class="cm"> * asynchronous messages from the firmware.  Note that the &quot;Queue IDs&quot; that we</span>
<span class="cm"> * use here are really &quot;Relative Queue IDs&quot; which are returned as part of the</span>
<span class="cm"> * firmware command to allocate queues.  These queue IDs are relative to the</span>
<span class="cm"> * absolute Queue ID base of the section of the Queue ID space allocated to</span>
<span class="cm"> * the PF/VF.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * SGE free-list queue state.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rx_sw_desc</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sge_fl</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">avail</span><span class="p">;</span>		<span class="cm">/* # of available RX buffers */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pend_cred</span><span class="p">;</span>		<span class="cm">/* new buffers since last FL DB ring */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cidx</span><span class="p">;</span>		<span class="cm">/* consumer index */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pidx</span><span class="p">;</span>		<span class="cm">/* producer index */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">alloc_failed</span><span class="p">;</span>	<span class="cm">/* # of buffer allocation failures */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">large_alloc_failed</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">starving</span><span class="p">;</span>		<span class="cm">/* # of times FL was found starving */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write-once/infrequently fields.</span>
<span class="cm">	 * -------------------------------</span>
<span class="cm">	 */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cntxt_id</span><span class="p">;</span>		<span class="cm">/* SGE relative QID for the free list */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">abs_id</span><span class="p">;</span>		<span class="cm">/* SGE absolute QID for the free list */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>		<span class="cm">/* capacity of free list */</span>
	<span class="k">struct</span> <span class="n">rx_sw_desc</span> <span class="o">*</span><span class="n">sdesc</span><span class="p">;</span>	<span class="cm">/* address of SW RX descriptor ring */</span>
	<span class="n">__be64</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>			<span class="cm">/* address of HW RX descriptor ring */</span>
	<span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">;</span>		<span class="cm">/* PCI bus address of hardware ring */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * An ingress packet gather list.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pkt_gl</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">page_frag</span> <span class="n">frags</span><span class="p">[</span><span class="n">MAX_SKB_FRAGS</span><span class="p">];</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">;</span>			<span class="cm">/* virtual address of first byte */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nfrags</span><span class="p">;</span>		<span class="cm">/* # of fragments */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tot_len</span><span class="p">;</span>		<span class="cm">/* total length of fragments */</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rspq_handler_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">__be64</span> <span class="o">*</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">pkt_gl</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * State for an SGE Response Queue.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sge_rspq</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">napi_struct</span> <span class="n">napi</span><span class="p">;</span>	<span class="cm">/* NAPI scheduling control */</span>
	<span class="k">const</span> <span class="n">__be64</span> <span class="o">*</span><span class="n">cur_desc</span><span class="p">;</span>		<span class="cm">/* current descriptor in queue */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cidx</span><span class="p">;</span>		<span class="cm">/* consumer index */</span>
	<span class="n">u8</span> <span class="n">gen</span><span class="p">;</span>				<span class="cm">/* current generation bit */</span>
	<span class="n">u8</span> <span class="n">next_intr_params</span><span class="p">;</span>		<span class="cm">/* holdoff params for next interrupt */</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>			<span class="cm">/* offset into current FL buffer */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">unhandled_irqs</span><span class="p">;</span>	<span class="cm">/* bogus interrupts */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write-once/infrequently fields.</span>
<span class="cm">	 * -------------------------------</span>
<span class="cm">	 */</span>

	<span class="n">u8</span> <span class="n">intr_params</span><span class="p">;</span>			<span class="cm">/* interrupt holdoff parameters */</span>
	<span class="n">u8</span> <span class="n">pktcnt_idx</span><span class="p">;</span>			<span class="cm">/* interrupt packet threshold */</span>
	<span class="n">u8</span> <span class="n">idx</span><span class="p">;</span>				<span class="cm">/* queue index within its group */</span>
	<span class="n">u16</span> <span class="n">cntxt_id</span><span class="p">;</span>			<span class="cm">/* SGE rel QID for the response Q */</span>
	<span class="n">u16</span> <span class="n">abs_id</span><span class="p">;</span>			<span class="cm">/* SGE abs QID for the response Q */</span>
	<span class="n">__be64</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>			<span class="cm">/* address of hardware response ring */</span>
	<span class="n">dma_addr_t</span> <span class="n">phys_addr</span><span class="p">;</span>		<span class="cm">/* PCI bus address of ring */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">iqe_len</span><span class="p">;</span>		<span class="cm">/* entry size */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>		<span class="cm">/* capcity of response Q */</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>	<span class="cm">/* our adapter */</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>	<span class="cm">/* associated net device */</span>
	<span class="n">rspq_handler_t</span> <span class="n">handler</span><span class="p">;</span>		<span class="cm">/* the handler for this response Q */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Ethernet queue statistics</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sge_eth_stats</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pkts</span><span class="p">;</span>		<span class="cm">/* # of ethernet packets */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lro_pkts</span><span class="p">;</span>		<span class="cm">/* # of LRO super packets */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lro_merged</span><span class="p">;</span>	<span class="cm">/* # of wire packets merged by LRO */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rx_cso</span><span class="p">;</span>		<span class="cm">/* # of Rx checksum offloads */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vlan_ex</span><span class="p">;</span>		<span class="cm">/* # of Rx VLAN extractions */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rx_drops</span><span class="p">;</span>		<span class="cm">/* # of packets dropped due to no mem */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * State for an Ethernet Receive Queue.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sge_eth_rxq</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sge_rspq</span> <span class="n">rspq</span><span class="p">;</span>		<span class="cm">/* Response Queue */</span>
	<span class="k">struct</span> <span class="n">sge_fl</span> <span class="n">fl</span><span class="p">;</span>		<span class="cm">/* Free List */</span>
	<span class="k">struct</span> <span class="n">sge_eth_stats</span> <span class="n">stats</span><span class="p">;</span>	<span class="cm">/* receive statistics */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * SGE Transmit Queue state.  This contains all of the resources associated</span>
<span class="cm"> * with the hardware status of a TX Queue which is a circular ring of hardware</span>
<span class="cm"> * TX Descriptors.  For convenience, it also contains a pointer to a parallel</span>
<span class="cm"> * &quot;Software Descriptor&quot; array but we don&#39;t know anything about it here other</span>
<span class="cm"> * than its type name.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tx_desc</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Egress Queues are measured in units of SGE_EQ_IDXSIZE by the</span>
<span class="cm">	 * hardware: Sizes, Producer and Consumer indices, etc.</span>
<span class="cm">	 */</span>
	<span class="n">__be64</span> <span class="n">flit</span><span class="p">[</span><span class="n">SGE_EQ_IDXSIZE</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">__be64</span><span class="p">)];</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">tx_sw_desc</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sge_txq</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">in_use</span><span class="p">;</span>		<span class="cm">/* # of in-use TX descriptors */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>		<span class="cm">/* # of descriptors */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cidx</span><span class="p">;</span>		<span class="cm">/* SW consumer index */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pidx</span><span class="p">;</span>		<span class="cm">/* producer index */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stops</span><span class="p">;</span>		<span class="cm">/* # of times queue has been stopped */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">restarts</span><span class="p">;</span>		<span class="cm">/* # of queue restarts */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write-once/infrequently fields.</span>
<span class="cm">	 * -------------------------------</span>
<span class="cm">	 */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cntxt_id</span><span class="p">;</span>		<span class="cm">/* SGE relative QID for the TX Q */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">abs_id</span><span class="p">;</span>		<span class="cm">/* SGE absolute QID for the TX Q */</span>
	<span class="k">struct</span> <span class="n">tx_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>		<span class="cm">/* address of HW TX descriptor ring */</span>
	<span class="k">struct</span> <span class="n">tx_sw_desc</span> <span class="o">*</span><span class="n">sdesc</span><span class="p">;</span>	<span class="cm">/* address of SW TX descriptor ring */</span>
	<span class="k">struct</span> <span class="n">sge_qstat</span> <span class="o">*</span><span class="n">stat</span><span class="p">;</span>		<span class="cm">/* queue status entry */</span>
	<span class="n">dma_addr_t</span> <span class="n">phys_addr</span><span class="p">;</span>		<span class="cm">/* PCI bus address of hardware ring */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * State for an Ethernet Transmit Queue.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sge_eth_txq</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sge_txq</span> <span class="n">q</span><span class="p">;</span>		<span class="cm">/* SGE TX Queue */</span>
	<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">;</span>	<span class="cm">/* associated netdev TX queue */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tso</span><span class="p">;</span>		<span class="cm">/* # of TSO requests */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tx_cso</span><span class="p">;</span>		<span class="cm">/* # of TX checksum offloads */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vlan_ins</span><span class="p">;</span>		<span class="cm">/* # of TX VLAN insertions */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mapping_err</span><span class="p">;</span>	<span class="cm">/* # of I/O MMU packet mapping errors */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The complete set of Scatter/Gather Engine resources.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sge</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Our &quot;Queue Sets&quot; ...</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">sge_eth_txq</span> <span class="n">ethtxq</span><span class="p">[</span><span class="n">MAX_ETH_QSETS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sge_eth_rxq</span> <span class="n">ethrxq</span><span class="p">[</span><span class="n">MAX_ETH_QSETS</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Extra ingress queues for asynchronous firmware events and</span>
<span class="cm">	 * forwarded interrupts (when in MSI mode).</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">sge_rspq</span> <span class="n">fw_evtq</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sge_rspq</span> <span class="n">intrq</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">intrq_lock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * State for managing &quot;starving Free Lists&quot; -- Free Lists which have</span>
<span class="cm">	 * fallen below a certain threshold of buffers available to the</span>
<span class="cm">	 * hardware and attempts to refill them up to that threshold have</span>
<span class="cm">	 * failed.  We have a regular &quot;slow tick&quot; timer process which will</span>
<span class="cm">	 * make periodic attempts to refill these starving Free Lists ...</span>
<span class="cm">	 */</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">starving_fl</span><span class="p">,</span> <span class="n">MAX_EGRQ</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">rx_timer</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * State for cleaning up completed TX descriptors.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">tx_timer</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write-once/infrequently fields.</span>
<span class="cm">	 * -------------------------------</span>
<span class="cm">	 */</span>

	<span class="n">u16</span> <span class="n">max_ethqsets</span><span class="p">;</span>		<span class="cm">/* # of available Ethernet queue sets */</span>
	<span class="n">u16</span> <span class="n">ethqsets</span><span class="p">;</span>			<span class="cm">/* # of active Ethernet queue sets */</span>
	<span class="n">u16</span> <span class="n">ethtxq_rover</span><span class="p">;</span>		<span class="cm">/* Tx queue to clean up next */</span>
	<span class="n">u16</span> <span class="n">timer_val</span><span class="p">[</span><span class="n">SGE_NTIMERS</span><span class="p">];</span>	<span class="cm">/* interrupt holdoff timer array */</span>
	<span class="n">u8</span> <span class="n">counter_val</span><span class="p">[</span><span class="n">SGE_NCOUNTERS</span><span class="p">];</span>	<span class="cm">/* interrupt RX threshold array */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reverse maps from Absolute Queue IDs to associated queue pointers.</span>
<span class="cm">	 * The absolute Queue IDs are in a compact range which start at a</span>
<span class="cm">	 * [potentially large] Base Queue ID.  We perform the reverse map by</span>
<span class="cm">	 * first converting the Absolute Queue ID into a Relative Queue ID by</span>
<span class="cm">	 * subtracting off the Base Queue ID and then use a Relative Queue ID</span>
<span class="cm">	 * indexed table to get the pointer to the corresponding software</span>
<span class="cm">	 * queue structure.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">egr_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ingr_base</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">egr_map</span><span class="p">[</span><span class="n">MAX_EGRQ</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">ingr_map</span><span class="p">[</span><span class="n">MAX_INGQ</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Utility macros to convert Absolute- to Relative-Queue indices and Egress-</span>
<span class="cm"> * and Ingress-Queues.  The EQ_MAP() and IQ_MAP() macros which provide</span>
<span class="cm"> * pointers to Ingress- and Egress-Queues can be used as both L- and R-values</span>
<span class="cm"> */</span>
<span class="cp">#define EQ_IDX(s, abs_id) ((unsigned int)((abs_id) - (s)-&gt;egr_base))</span>
<span class="cp">#define IQ_IDX(s, abs_id) ((unsigned int)((abs_id) - (s)-&gt;ingr_base))</span>

<span class="cp">#define EQ_MAP(s, abs_id) ((s)-&gt;egr_map[EQ_IDX(s, abs_id)])</span>
<span class="cp">#define IQ_MAP(s, abs_id) ((s)-&gt;ingr_map[IQ_IDX(s, abs_id)])</span>

<span class="cm">/*</span>
<span class="cm"> * Macro to iterate across Queue Sets (&quot;rxq&quot; is a historic misnomer).</span>
<span class="cm"> */</span>
<span class="cp">#define for_each_ethrxq(sge, iter) \</span>
<span class="cp">	for (iter = 0; iter &lt; (sge)-&gt;ethqsets; iter++)</span>

<span class="cm">/*</span>
<span class="cm"> * Per-&quot;adapter&quot; (Virtual Function) information.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">adapter</span> <span class="p">{</span>
	<span class="cm">/* PCI resources */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">pdev_dev</span><span class="p">;</span>

	<span class="cm">/* &quot;adapter&quot; resources */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">registered_device_map</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">open_device_map</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">adapter_params</span> <span class="n">params</span><span class="p">;</span>

	<span class="cm">/* queue and interrupt resources */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">vec</span><span class="p">;</span>
		<span class="kt">char</span> <span class="n">desc</span><span class="p">[</span><span class="mi">22</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">msix_info</span><span class="p">[</span><span class="n">MSIX_ENTRIES</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sge</span> <span class="n">sge</span><span class="p">;</span>

	<span class="cm">/* Linux network device resources */</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">port</span><span class="p">[</span><span class="n">MAX_NPORTS</span><span class="p">];</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msg_enable</span><span class="p">;</span>

	<span class="cm">/* debugfs resources */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfs_root</span><span class="p">;</span>

	<span class="cm">/* various locks */</span>
	<span class="n">spinlock_t</span> <span class="n">stats_lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span> <span class="cm">/* adapter flags */</span>
	<span class="n">FULL_INIT_DONE</span>     <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">USING_MSI</span>          <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">USING_MSIX</span>         <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
	<span class="n">QUEUES_BOUND</span>       <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The following register read/write routine definitions are required by</span>
<span class="cm"> * the common code.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * t4_read_reg - read a HW register</span>
<span class="cm"> * @adapter: the adapter</span>
<span class="cm"> * @reg_addr: the register address</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the 32-bit value of the given HW register.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">t4_read_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">reg_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * t4_write_reg - write a HW register</span>
<span class="cm"> * @adapter: the adapter</span>
<span class="cm"> * @reg_addr: the register address</span>
<span class="cm"> * @val: the value to write</span>
<span class="cm"> *</span>
<span class="cm"> * Write a 32-bit value into the given HW register.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">t4_write_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">reg_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifndef readq</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">readq</span><span class="p">(</span><span class="k">const</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">readl</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">writeq</span><span class="p">(</span><span class="n">u64</span> <span class="n">val</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * t4_read_reg64 - read a 64-bit HW register</span>
<span class="cm"> * @adapter: the adapter</span>
<span class="cm"> * @reg_addr: the register address</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the 64-bit value of the given HW register.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">t4_read_reg64</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">reg_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * t4_write_reg64 - write a 64-bit HW register</span>
<span class="cm"> * @adapter: the adapter</span>
<span class="cm"> * @reg_addr: the register address</span>
<span class="cm"> * @val: the value to write</span>
<span class="cm"> *</span>
<span class="cm"> * Write a 64-bit value into the given HW register.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">t4_write_reg64</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg_addr</span><span class="p">,</span>
				  <span class="n">u64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writeq</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">reg_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * port_name - return the string name of a port</span>
<span class="cm"> * @adapter: the adapter</span>
<span class="cm"> * @pidx: the port index</span>
<span class="cm"> *</span>
<span class="cm"> * Return the string name of the selected port.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">port_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pidx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">pidx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * t4_os_set_hw_addr - store a port&#39;s MAC address in SW</span>
<span class="cm"> * @adapter: the adapter</span>
<span class="cm"> * @pidx: the port index</span>
<span class="cm"> * @hw_addr: the Ethernet address</span>
<span class="cm"> *</span>
<span class="cm"> * Store the Ethernet address of the given port in SW.  Called by the common</span>
<span class="cm"> * code when it retrieves a port&#39;s Ethernet address from EEPROM.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">t4_os_set_hw_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pidx</span><span class="p">,</span>
				     <span class="n">u8</span> <span class="n">hw_addr</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">pidx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">hw_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">pidx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">,</span> <span class="n">hw_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev2pinfo - return the port_info structure associated with a net_device</span>
<span class="cm"> * @dev: the netdev</span>
<span class="cm"> *</span>
<span class="cm"> * Return the struct port_info associated with a net_device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="nf">netdev2pinfo</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * adap2pinfo - return the port_info of a port</span>
<span class="cm"> * @adap: the adapter</span>
<span class="cm"> * @pidx: the port index</span>
<span class="cm"> *</span>
<span class="cm"> * Return the port_info structure for the adapter.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="nf">adap2pinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pidx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">pidx</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev2adap - return the adapter structure associated with a net_device</span>
<span class="cm"> * @dev: the netdev</span>
<span class="cm"> *</span>
<span class="cm"> * Return the struct adapter associated with a net_device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="nf">netdev2adap</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">netdev2pinfo</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * OS &quot;Callback&quot; function declarations.  These are functions that the OS code</span>
<span class="cm"> * is &quot;contracted&quot; to provide for the common code.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">t4vf_os_link_changed</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * SGE function prototype declarations.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">t4vf_sge_alloc_rxq</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">sge_fl</span> <span class="o">*</span><span class="p">,</span> <span class="n">rspq_handler_t</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">t4vf_sge_alloc_eth_txq</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_eth_txq</span> <span class="o">*</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">t4vf_free_sge_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">t4vf_eth_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">t4vf_ethrx_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">__be64</span> <span class="o">*</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">pkt_gl</span> <span class="o">*</span><span class="p">);</span>

<span class="n">irq_handler_t</span> <span class="n">t4vf_intr_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="n">irqreturn_t</span> <span class="n">t4vf_sge_intr_msix</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">t4vf_sge_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">t4vf_sge_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">t4vf_sge_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __CXGB4VF_ADAPTER_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
