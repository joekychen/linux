<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › chelsio › cxgb3 › sge.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>sge.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2005-2008 Chelsio, Inc. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This software is available to you under a choice of one of two</span>
<span class="cm"> * licenses.  You may choose to be licensed under the terms of the GNU</span>
<span class="cm"> * General Public License (GPL) Version 2, available from the file</span>
<span class="cm"> * COPYING in the main directory of this source tree, or the</span>
<span class="cm"> * OpenIB.org BSD license below:</span>
<span class="cm"> *</span>
<span class="cm"> *     Redistribution and use in source and binary forms, with or</span>
<span class="cm"> *     without modification, are permitted provided that the following</span>
<span class="cm"> *     conditions are met:</span>
<span class="cm"> *</span>
<span class="cm"> *      - Redistributions of source code must retain the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer.</span>
<span class="cm"> *</span>
<span class="cm"> *      - Redistributions in binary form must reproduce the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer in the documentation and/or other materials</span>
<span class="cm"> *        provided with the distribution.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="cm"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="cm"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS</span>
<span class="cm"> * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN</span>
<span class="cm"> * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span>
<span class="cm"> * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="cm"> * SOFTWARE.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/if_vlan.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/tcp.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/prefetch.h&gt;</span>
<span class="cp">#include &lt;net/arp.h&gt;</span>
<span class="cp">#include &quot;common.h&quot;</span>
<span class="cp">#include &quot;regs.h&quot;</span>
<span class="cp">#include &quot;sge_defs.h&quot;</span>
<span class="cp">#include &quot;t3_cpl.h&quot;</span>
<span class="cp">#include &quot;firmware_exports.h&quot;</span>
<span class="cp">#include &quot;cxgb3_offload.h&quot;</span>

<span class="cp">#define USE_GTS 0</span>

<span class="cp">#define SGE_RX_SM_BUF_SIZE 1536</span>

<span class="cp">#define SGE_RX_COPY_THRES  256</span>
<span class="cp">#define SGE_RX_PULL_LEN    128</span>

<span class="cp">#define SGE_PG_RSVD SMP_CACHE_BYTES</span>
<span class="cm">/*</span>
<span class="cm"> * Page chunk size for FL0 buffers if FL0 is to be populated with page chunks.</span>
<span class="cm"> * It must be a divisor of PAGE_SIZE.  If set to 0 FL0 will use sk_buffs</span>
<span class="cm"> * directly.</span>
<span class="cm"> */</span>
<span class="cp">#define FL0_PG_CHUNK_SIZE  2048</span>
<span class="cp">#define FL0_PG_ORDER 0</span>
<span class="cp">#define FL0_PG_ALLOC_SIZE (PAGE_SIZE &lt;&lt; FL0_PG_ORDER)</span>
<span class="cp">#define FL1_PG_CHUNK_SIZE (PAGE_SIZE &gt; 8192 ? 16384 : 8192)</span>
<span class="cp">#define FL1_PG_ORDER (PAGE_SIZE &gt; 8192 ? 0 : 1)</span>
<span class="cp">#define FL1_PG_ALLOC_SIZE (PAGE_SIZE &lt;&lt; FL1_PG_ORDER)</span>

<span class="cp">#define SGE_RX_DROP_THRES 16</span>
<span class="cp">#define RX_RECLAIM_PERIOD (HZ/4)</span>

<span class="cm">/*</span>
<span class="cm"> * Max number of Rx buffers we replenish at a time.</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_RX_REFILL 16U</span>
<span class="cm">/*</span>
<span class="cm"> * Period of the Tx buffer reclaim timer.  This timer does not need to run</span>
<span class="cm"> * frequently as Tx buffers are usually reclaimed by new Tx packets.</span>
<span class="cm"> */</span>
<span class="cp">#define TX_RECLAIM_PERIOD (HZ / 4)</span>
<span class="cp">#define TX_RECLAIM_TIMER_CHUNK 64U</span>
<span class="cp">#define TX_RECLAIM_CHUNK 16U</span>

<span class="cm">/* WR size in bytes */</span>
<span class="cp">#define WR_LEN (WR_FLITS * 8)</span>

<span class="cm">/*</span>
<span class="cm"> * Types of Tx queues in each queue set.  Order here matters, do not change.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span> <span class="n">TXQ_ETH</span><span class="p">,</span> <span class="n">TXQ_OFLD</span><span class="p">,</span> <span class="n">TXQ_CTRL</span> <span class="p">};</span>

<span class="cm">/* Values for sge_txq.flags */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">TXQ_RUNNING</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* fetch engine is running */</span>
	<span class="n">TXQ_LAST_PKT_DB</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* last packet rang the doorbell */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">tx_desc</span> <span class="p">{</span>
	<span class="n">__be64</span> <span class="n">flit</span><span class="p">[</span><span class="n">TX_DESC_FLITS</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">rx_desc</span> <span class="p">{</span>
	<span class="n">__be32</span> <span class="n">addr_lo</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">len_gen</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">gen2</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">addr_hi</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">tx_sw_desc</span> <span class="p">{</span>		<span class="cm">/* SW state per Tx descriptor */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">eop</span><span class="p">;</span>       <span class="cm">/* set if last descriptor for packet */</span>
	<span class="n">u8</span> <span class="n">addr_idx</span><span class="p">;</span>  <span class="cm">/* buffer index of first SGL entry in descriptor */</span>
	<span class="n">u8</span> <span class="n">fragidx</span><span class="p">;</span>   <span class="cm">/* first page fragment associated with descriptor */</span>
	<span class="n">s8</span> <span class="n">sflit</span><span class="p">;</span>     <span class="cm">/* start flit of first SGL entry in descriptor */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">rx_sw_desc</span> <span class="p">{</span>                <span class="cm">/* SW state per Rx descriptor */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">fl_pg_chunk</span> <span class="n">pg_chunk</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="n">DEFINE_DMA_UNMAP_ADDR</span><span class="p">(</span><span class="n">dma_addr</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">rsp_desc</span> <span class="p">{</span>		<span class="cm">/* response queue descriptor */</span>
	<span class="k">struct</span> <span class="n">rss_header</span> <span class="n">rss_hdr</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">len_cq</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">imm_data</span><span class="p">[</span><span class="mi">47</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">intr_gen</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Holds unmapping information for Tx packets that need deferred unmapping.</span>
<span class="cm"> * This structure lives at skb-&gt;head and must be allocated by callers.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">deferred_unmap_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">[</span><span class="n">MAX_SKB_FRAGS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Maps a number of flits to the number of Tx descriptors that can hold them.</span>
<span class="cm"> * The formula is</span>
<span class="cm"> *</span>
<span class="cm"> * desc = 1 + (flits - 2) / (WR_FLITS - 1).</span>
<span class="cm"> *</span>
<span class="cm"> * HW allows up to 4 descriptors to be combined into a WR.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="n">flit_desc_map</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">0</span><span class="p">,</span>
<span class="cp">#if SGE_NUM_GENBITS == 1</span>
	<span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
	<span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
	<span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
	<span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span>
<span class="cp">#elif SGE_NUM_GENBITS == 2</span>
	<span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
	<span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
	<span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
	<span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>
<span class="cp">#else</span>
<span class="cp"># error &quot;SGE_NUM_GENBITS must be 1 or 2&quot;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="nf">fl_to_qset</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sge_fl</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">qidx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_qset</span><span class="p">,</span> <span class="n">fl</span><span class="p">[</span><span class="n">qidx</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="nf">rspq_to_qset</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_qset</span><span class="p">,</span> <span class="n">rspq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="nf">txq_to_qset</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sge_txq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">qidx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_qset</span><span class="p">,</span> <span class="n">txq</span><span class="p">[</span><span class="n">qidx</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	refill_rspq - replenish an SGE response queue</span>
<span class="cm"> *	@adapter: the adapter</span>
<span class="cm"> *	@q: the response queue to replenish</span>
<span class="cm"> *	@credits: how many new responses to make available</span>
<span class="cm"> *</span>
<span class="cm"> *	Replenishes a response queue by making the supplied number of responses</span>
<span class="cm"> *	available to HW.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">refill_rspq</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">credits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rmb</span><span class="p">();</span>
	<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">A_SG_RSPQ_CREDIT_RETURN</span><span class="p">,</span>
		     <span class="n">V_RSPQ</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cntxt_id</span><span class="p">)</span> <span class="o">|</span> <span class="n">V_CREDITS</span><span class="p">(</span><span class="n">credits</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	need_skb_unmap - does the platform need unmapping of sk_buffs?</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns true if the platform needs sk_buff unmapping.  The compiler</span>
<span class="cm"> *	optimizes away unnecessary code if this returns true.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">need_skb_unmap</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_NEED_DMA_MAP_STATE</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	unmap_skb - unmap a packet main body and its page fragments</span>
<span class="cm"> *	@skb: the packet</span>
<span class="cm"> *	@q: the Tx queue containing Tx descriptors for the packet</span>
<span class="cm"> *	@cidx: index of Tx descriptor</span>
<span class="cm"> *	@pdev: the PCI device</span>
<span class="cm"> *</span>
<span class="cm"> *	Unmap the main body of an sk_buff and its page fragments, if any.</span>
<span class="cm"> *	Because of the fairly complicated structure of our SGLs and the desire</span>
<span class="cm"> *	to conserve space for metadata, the information necessary to unmap an</span>
<span class="cm"> *	sk_buff is spread across the sk_buff itself (buffer lengths), the HW Tx</span>
<span class="cm"> *	descriptors (the physical addresses of the various data buffers), and</span>
<span class="cm"> *	the SW descriptor state (assorted indices).  The send functions</span>
<span class="cm"> *	initialize the indices for the first packet descriptor so we can unmap</span>
<span class="cm"> *	the buffers held in the first Tx descriptor here, and we have enough</span>
<span class="cm"> *	information at this point to set the state for the next Tx descriptor.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note that it is possible to clean up the first descriptor of a packet</span>
<span class="cm"> *	before the send routines have written the next descriptors, but this</span>
<span class="cm"> *	race does not cause any problem.  We just end up writing the unmapping</span>
<span class="cm"> *	info for the descriptor first.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unmap_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_txq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cidx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sg_ent</span> <span class="o">*</span><span class="n">sgp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tx_sw_desc</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sdesc</span><span class="p">[</span><span class="n">cidx</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">nfrags</span><span class="p">,</span> <span class="n">frag_idx</span><span class="p">,</span> <span class="n">curflit</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">addr_idx</span><span class="p">;</span>

	<span class="n">sgp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sg_ent</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">[</span><span class="n">cidx</span><span class="p">].</span><span class="n">flit</span><span class="p">[</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sflit</span><span class="p">];</span>
	<span class="n">frag_idx</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">fragidx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">frag_idx</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
				 <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
		<span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">curflit</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sflit</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">nfrags</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">frag_idx</span> <span class="o">&lt;</span> <span class="n">nfrags</span> <span class="o">&amp;&amp;</span> <span class="n">curflit</span> <span class="o">&lt;</span> <span class="n">WR_FLITS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_unmap_page</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span>
			       <span class="n">skb_frag_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">frag_idx</span><span class="p">]),</span>
			       <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
		<span class="n">j</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sgp</span><span class="o">++</span><span class="p">;</span>
			<span class="n">curflit</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">curflit</span><span class="o">++</span><span class="p">;</span>
		<span class="n">frag_idx</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">frag_idx</span> <span class="o">&lt;</span> <span class="n">nfrags</span><span class="p">)</span> <span class="p">{</span>   <span class="cm">/* SGL continues into next Tx descriptor */</span>
		<span class="n">d</span> <span class="o">=</span> <span class="n">cidx</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">?</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">sdesc</span> <span class="o">:</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">fragidx</span> <span class="o">=</span> <span class="n">frag_idx</span><span class="p">;</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">addr_idx</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">sflit</span> <span class="o">=</span> <span class="n">curflit</span> <span class="o">-</span> <span class="n">WR_FLITS</span> <span class="o">-</span> <span class="n">j</span><span class="p">;</span> <span class="cm">/* sflit can be -1 */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	free_tx_desc - reclaims Tx descriptors and their buffers</span>
<span class="cm"> *	@adapter: the adapter</span>
<span class="cm"> *	@q: the Tx queue to reclaim descriptors from</span>
<span class="cm"> *	@n: the number of descriptors to reclaim</span>
<span class="cm"> *</span>
<span class="cm"> *	Reclaims Tx descriptors from an SGE Tx queue and frees the associated</span>
<span class="cm"> *	Tx buffers.  Called with the Tx queue lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_tx_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_txq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tx_sw_desc</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cidx</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">;</span>

	<span class="k">const</span> <span class="kt">int</span> <span class="n">need_unmap</span> <span class="o">=</span> <span class="n">need_skb_unmap</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
			       <span class="n">q</span><span class="o">-&gt;</span><span class="n">cntxt_id</span> <span class="o">&gt;=</span> <span class="n">FW_TUNNEL_SGEEC_START</span><span class="p">;</span>

	<span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sdesc</span><span class="p">[</span><span class="n">cidx</span><span class="p">];</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* an SGL is present */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">need_unmap</span><span class="p">)</span>
				<span class="n">unmap_skb</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">cidx</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">eop</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree_skb</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
				<span class="n">d</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="o">++</span><span class="n">d</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">cidx</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">d</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">sdesc</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">cidx</span> <span class="o">=</span> <span class="n">cidx</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	reclaim_completed_tx - reclaims completed Tx descriptors</span>
<span class="cm"> *	@adapter: the adapter</span>
<span class="cm"> *	@q: the Tx queue to reclaim completed descriptors from</span>
<span class="cm"> *	@chunk: maximum number of descriptors to reclaim</span>
<span class="cm"> *</span>
<span class="cm"> *	Reclaims Tx descriptors that the SGE has indicated it has processed,</span>
<span class="cm"> *	and frees the associated buffers if possible.  Called with the Tx</span>
<span class="cm"> *	queue&#39;s lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">reclaim_completed_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">sge_txq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reclaim</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">processed</span> <span class="o">-</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">cleaned</span><span class="p">;</span>

	<span class="n">reclaim</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">reclaim</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reclaim</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_tx_desc</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">reclaim</span><span class="p">);</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">cleaned</span> <span class="o">+=</span> <span class="n">reclaim</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">-=</span> <span class="n">reclaim</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">processed</span> <span class="o">-</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">cleaned</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	should_restart_tx - are there enough resources to restart a Tx queue?</span>
<span class="cm"> *	@q: the Tx queue</span>
<span class="cm"> *</span>
<span class="cm"> *	Checks if there are enough descriptors to restart a suspended Tx queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">should_restart_tx</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sge_txq</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">processed</span> <span class="o">-</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">cleaned</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">-</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_rx_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sge_fl</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">rx_sw_desc</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">use_pages</span> <span class="o">&amp;&amp;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">p_cnt</span><span class="p">)</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">p_cnt</span><span class="p">)</span>
			<span class="n">pci_unmap_page</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
				       <span class="n">d</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">mapping</span><span class="p">,</span>
				       <span class="n">q</span><span class="o">-&gt;</span><span class="n">alloc_size</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>

		<span class="n">put_page</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">page</span><span class="p">);</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dma_unmap_addr</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">),</span>
				 <span class="n">q</span><span class="o">-&gt;</span><span class="n">buf_size</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	free_rx_bufs - free the Rx buffers on an SGE free list</span>
<span class="cm"> *	@pdev: the PCI device associated with the adapter</span>
<span class="cm"> *	@rxq: the SGE free list to clean up</span>
<span class="cm"> *</span>
<span class="cm"> *	Release the buffers on an SGE free-buffer Rx queue.  HW fetching from</span>
<span class="cm"> *	this queue should be stopped before calling this function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_rx_bufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_fl</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cidx</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">credits</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rx_sw_desc</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sdesc</span><span class="p">[</span><span class="n">cidx</span><span class="p">];</span>


		<span class="n">clear_rx_desc</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">cidx</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
			<span class="n">cidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__free_pages</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">page</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">);</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	add_one_rx_buf - add a packet buffer to a free-buffer list</span>
<span class="cm"> *	@va:  buffer start VA</span>
<span class="cm"> *	@len: the buffer length</span>
<span class="cm"> *	@d: the HW Rx descriptor to write</span>
<span class="cm"> *	@sd: the SW Rx descriptor to write</span>
<span class="cm"> *	@gen: the generation bit value</span>
<span class="cm"> *	@pdev: the PCI device associated with the adapter</span>
<span class="cm"> *</span>
<span class="cm"> *	Add a buffer of the given length to the supplied HW and SW Rx</span>
<span class="cm"> *	descriptors.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">add_one_rx_buf</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">rx_desc</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rx_sw_desc</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gen</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">mapping</span><span class="p">;</span>

	<span class="n">mapping</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pci_dma_mapping_error</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">mapping</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">dma_unmap_addr_set</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">,</span> <span class="n">mapping</span><span class="p">);</span>

	<span class="n">d</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span> <span class="n">mapping</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">len_gen</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">V_FLD_GEN1</span><span class="p">(</span><span class="n">gen</span><span class="p">));</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">gen2</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">V_FLD_GEN2</span><span class="p">(</span><span class="n">gen</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">add_one_rx_chunk</span><span class="p">(</span><span class="n">dma_addr_t</span> <span class="n">mapping</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rx_desc</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span> <span class="n">mapping</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">len_gen</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">V_FLD_GEN1</span><span class="p">(</span><span class="n">gen</span><span class="p">));</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">gen2</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">V_FLD_GEN2</span><span class="p">(</span><span class="n">gen</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_pg_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_fl</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">rx_sw_desc</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_addr_t</span> <span class="n">mapping</span><span class="p">;</span>

		<span class="n">q</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">page</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">va</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">page</span><span class="p">);</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">p_cnt</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">va</span> <span class="o">+</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">)</span> <span class="o">-</span>
				    <span class="n">SGE_PG_RSVD</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mapping</span> <span class="o">=</span> <span class="n">pci_map_page</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">page</span><span class="p">,</span>
				       <span class="mi">0</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">alloc_size</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">pg_chunk</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">;</span>

	<span class="n">prefetch</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">p_cnt</span><span class="p">);</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">buf_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">offset</span> <span class="o">==</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">))</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">va</span> <span class="o">+=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">buf_size</span><span class="p">;</span>
		<span class="n">get_page</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">*</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">p_cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">p_cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ring_fl_db</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_fl</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pend_cred</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">credits</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">pend_cred</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">wmb</span><span class="p">();</span>
		<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_KDOORBELL</span><span class="p">,</span> <span class="n">V_EGRCNTX</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cntxt_id</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	refill_fl - refill an SGE free-buffer list</span>
<span class="cm"> *	@adapter: the adapter</span>
<span class="cm"> *	@q: the free-list to refill</span>
<span class="cm"> *	@n: the number of new buffers to allocate</span>
<span class="cm"> *	@gfp: the gfp flags for allocating new buffers</span>
<span class="cm"> *</span>
<span class="cm"> *	(Re)populate an SGE free-buffer list with up to @n new packet buffers,</span>
<span class="cm"> *	allocated with the supplied gfp flags.  The caller must assure that</span>
<span class="cm"> *	@n does not exceed the queue&#39;s capacity.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">refill_fl</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_fl</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rx_sw_desc</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sdesc</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">rx_desc</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_addr_t</span> <span class="n">mapping</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">use_pages</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">alloc_pg_chunk</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">gfp</span><span class="p">,</span>
						    <span class="n">q</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">)))</span> <span class="p">{</span>
<span class="nl">nomem:</span>				<span class="n">q</span><span class="o">-&gt;</span><span class="n">alloc_failed</span><span class="o">++</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">mapping</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">mapping</span> <span class="o">+</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
			<span class="n">dma_unmap_addr_set</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">,</span> <span class="n">mapping</span><span class="p">);</span>

			<span class="n">add_one_rx_chunk</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">gen</span><span class="p">);</span>
			<span class="n">pci_dma_sync_single_for_device</span><span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span>
						<span class="n">q</span><span class="o">-&gt;</span><span class="n">buf_size</span> <span class="o">-</span> <span class="n">SGE_PG_RSVD</span><span class="p">,</span>
						<span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">buf_start</span><span class="p">;</span>

			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">buf_size</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

			<span class="n">sd</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
			<span class="n">buf_start</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">add_one_rx_buf</span><span class="p">(</span><span class="n">buf_start</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">buf_size</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span>
					     <span class="n">q</span><span class="o">-&gt;</span><span class="n">gen</span><span class="p">,</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">clear_rx_desc</span><span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">sd</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">d</span><span class="o">++</span><span class="p">;</span>
		<span class="n">sd</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">sd</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">sdesc</span><span class="p">;</span>
			<span class="n">d</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">credits</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">pend_cred</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">ring_fl_db</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__refill_fl</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_fl</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">refill_fl</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="n">MAX_RX_REFILL</span><span class="p">,</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">credits</span><span class="p">),</span>
		  <span class="n">GFP_ATOMIC</span> <span class="o">|</span> <span class="n">__GFP_COMP</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	recycle_rx_buf - recycle a receive buffer</span>
<span class="cm"> *	@adapter: the adapter</span>
<span class="cm"> *	@q: the SGE free list</span>
<span class="cm"> *	@idx: index of buffer to recycle</span>
<span class="cm"> *</span>
<span class="cm"> *	Recycles the specified buffer on the given free list by adding it at</span>
<span class="cm"> *	the next available slot on the list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">recycle_rx_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_fl</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rx_desc</span> <span class="o">*</span><span class="n">from</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">rx_desc</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span><span class="p">];</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">sdesc</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">sdesc</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">addr_lo</span><span class="p">;</span>	<span class="cm">/* already big endian */</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">addr_hi</span><span class="p">;</span>	<span class="cm">/* likewise */</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">len_gen</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">V_FLD_GEN1</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">gen</span><span class="p">));</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">gen2</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">V_FLD_GEN2</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">gen</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">credits</span><span class="o">++</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">pend_cred</span><span class="o">++</span><span class="p">;</span>
	<span class="n">ring_fl_db</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	alloc_ring - allocate resources for an SGE descriptor ring</span>
<span class="cm"> *	@pdev: the PCI device</span>
<span class="cm"> *	@nelem: the number of descriptors</span>
<span class="cm"> *	@elem_size: the size of each descriptor</span>
<span class="cm"> *	@sw_size: the size of the SW state associated with each ring element</span>
<span class="cm"> *	@phys: the physical address of the allocated ring</span>
<span class="cm"> *	@metadata: address of the array holding the SW state for the ring</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocates resources for an SGE descriptor ring, such as Tx queues,</span>
<span class="cm"> *	free buffer lists, or response queues.  Each SGE ring requires</span>
<span class="cm"> *	space for its HW descriptors plus, optionally, space for the SW state</span>
<span class="cm"> *	associated with each HW entry (the metadata).  The function returns</span>
<span class="cm"> *	three values: the virtual address for the HW ring (the return value</span>
<span class="cm"> *	of the function), the physical address of the HW ring, and the address</span>
<span class="cm"> *	of the SW ring.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">alloc_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nelem</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">elem_size</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">sw_size</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="o">*</span> <span class="n">phys</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">metadata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">nelem</span> <span class="o">*</span> <span class="n">elem_size</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">phys</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sw_size</span> <span class="o">&amp;&amp;</span> <span class="n">metadata</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">nelem</span><span class="p">,</span> <span class="n">sw_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">phys</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	t3_reset_qset - reset a sge qset</span>
<span class="cm"> *	@q: the queue set</span>
<span class="cm"> *</span>
<span class="cm"> *	Reset the qset structure.</span>
<span class="cm"> *	the NAPI structure is preserved in the event of</span>
<span class="cm"> *	the qset&#39;s reincarnation, for example during EEH recovery.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">t3_reset_qset</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">adap</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NAPI_INIT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">adap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge_fl</span><span class="p">)</span> <span class="o">*</span> <span class="n">SGE_RXQ_PER_SET</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge_txq</span><span class="p">)</span> <span class="o">*</span> <span class="n">SGE_TXQ_PER_SET</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">txq_stopped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">tx_reclaim_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* for t3_stop_sge_timers() */</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">rx_reclaim_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">nomem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">napi_free_frags</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *	free_qset - free the resources of an SGE queue set</span>
<span class="cm"> *	@adapter: the adapter owning the queue set</span>
<span class="cm"> *	@q: the queue set</span>
<span class="cm"> *</span>
<span class="cm"> *	Release the HW and SW resources associated with an SGE queue set, such</span>
<span class="cm"> *	as HW contexts, packet buffers, and descriptor rings.  Traffic to the</span>
<span class="cm"> *	queue set must be quiesced prior to calling this.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">t3_free_qset</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SGE_RXQ_PER_SET</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">reg_lock</span><span class="p">);</span>
			<span class="n">t3_sge_disable_fl</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cntxt_id</span><span class="p">);</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">reg_lock</span><span class="p">);</span>
			<span class="n">free_rx_bufs</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sdesc</span><span class="p">);</span>
			<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					  <span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">*</span>
					  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rx_desc</span><span class="p">),</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span><span class="p">,</span>
					  <span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SGE_TXQ_PER_SET</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">reg_lock</span><span class="p">);</span>
			<span class="n">t3_sge_enable_ecntxt</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cntxt_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">reg_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sdesc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">free_tx_desc</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					     <span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">in_use</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sdesc</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					  <span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">*</span>
					  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tx_desc</span><span class="p">),</span>
					  <span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">);</span>
			<span class="n">__skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sendq</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">reg_lock</span><span class="p">);</span>
		<span class="n">t3_sge_disable_rspcntxt</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">cntxt_id</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">reg_lock</span><span class="p">);</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				  <span class="n">q</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rsp_desc</span><span class="p">),</span>
				  <span class="n">q</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">desc</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">phys_addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">t3_reset_qset</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	init_qset_cntxt - initialize an SGE queue set context info</span>
<span class="cm"> *	@qs: the queue set</span>
<span class="cm"> *	@id: the queue set id</span>
<span class="cm"> *</span>
<span class="cm"> *	Initializes the TIDs and context ids for the queues of a queue set.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_qset_cntxt</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">qs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">qs</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">cntxt_id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">qs</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cntxt_id</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">qs</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">cntxt_id</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_ETH</span><span class="p">].</span><span class="n">cntxt_id</span> <span class="o">=</span> <span class="n">FW_TUNNEL_SGEEC_START</span> <span class="o">+</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_ETH</span><span class="p">].</span><span class="n">token</span> <span class="o">=</span> <span class="n">FW_TUNNEL_TID_START</span> <span class="o">+</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_OFLD</span><span class="p">].</span><span class="n">cntxt_id</span> <span class="o">=</span> <span class="n">FW_OFLD_SGEEC_START</span> <span class="o">+</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_CTRL</span><span class="p">].</span><span class="n">cntxt_id</span> <span class="o">=</span> <span class="n">FW_CTRL_SGEEC_START</span> <span class="o">+</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_CTRL</span><span class="p">].</span><span class="n">token</span> <span class="o">=</span> <span class="n">FW_CTRL_TID_START</span> <span class="o">+</span> <span class="n">id</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sgl_len - calculates the size of an SGL of the given capacity</span>
<span class="cm"> *	@n: the number of SGL entries</span>
<span class="cm"> *</span>
<span class="cm"> *	Calculates the number of flits needed for a scatter/gather list that</span>
<span class="cm"> *	can hold the given number of entries.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">sgl_len</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* alternatively: 3 * (n / 2) + 2 * (n &amp; 1) */</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	flits_to_desc - returns the num of Tx descriptors for the given flits</span>
<span class="cm"> *	@n: the number of flits</span>
<span class="cm"> *</span>
<span class="cm"> *	Calculates the number of Tx descriptors needed for the supplied number</span>
<span class="cm"> *	of flits.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">flits_to_desc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">flit_desc_map</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">flit_desc_map</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	get_packet - return the next ingress packet buffer from a free list</span>
<span class="cm"> *	@adap: the adapter that received the packet</span>
<span class="cm"> *	@fl: the SGE free list holding the packet</span>
<span class="cm"> *	@len: the packet length including any SGE padding</span>
<span class="cm"> *	@drop_thres: # of remaining buffers before we start dropping packets</span>
<span class="cm"> *</span>
<span class="cm"> *	Get the next packet from a free list and complete setup of the</span>
<span class="cm"> *	sk_buff.  If the packet is small we make a copy and recycle the</span>
<span class="cm"> *	original buffer, otherwise we use the original buffer itself.  If a</span>
<span class="cm"> *	positive drop threshold is supplied packets are dropped and their</span>
<span class="cm"> *	buffers recycled if (a) the number of remaining buffers is under the</span>
<span class="cm"> *	threshold and the packet is too big to copy, or (b) the packet should</span>
<span class="cm"> *	be copied but there is no memory for the copy.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">get_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_fl</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">drop_thres</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rx_sw_desc</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">sdesc</span><span class="p">[</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">];</span>

	<span class="n">prefetch</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">credits</span><span class="o">--</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">SGE_RX_COPY_THRES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">pci_dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
					    <span class="n">dma_unmap_addr</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">),</span> <span class="n">len</span><span class="p">,</span>
					    <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">pci_dma_sync_single_for_device</span><span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
					    <span class="n">dma_unmap_addr</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">),</span> <span class="n">len</span><span class="p">,</span>
					    <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drop_thres</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">use_orig_buf</span><span class="p">;</span>
<span class="nl">recycle:</span>
		<span class="n">recycle_rx_buf</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">credits</span> <span class="o">&lt;</span> <span class="n">drop_thres</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">refill_fl</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="n">MAX_RX_REFILL</span><span class="p">,</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">credits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
		      <span class="n">GFP_ATOMIC</span> <span class="o">|</span> <span class="n">__GFP_COMP</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">recycle</span><span class="p">;</span>

<span class="nl">use_orig_buf:</span>
	<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dma_unmap_addr</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">),</span>
			 <span class="n">fl</span><span class="o">-&gt;</span><span class="n">buf_size</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">__refill_fl</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">fl</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	get_packet_pg - return the next ingress packet buffer from a free list</span>
<span class="cm"> *	@adap: the adapter that received the packet</span>
<span class="cm"> *	@fl: the SGE free list holding the packet</span>
<span class="cm"> *	@len: the packet length including any SGE padding</span>
<span class="cm"> *	@drop_thres: # of remaining buffers before we start dropping packets</span>
<span class="cm"> *</span>
<span class="cm"> *	Get the next packet from a free list populated with page chunks.</span>
<span class="cm"> *	If the packet is small we make a copy and recycle the original buffer,</span>
<span class="cm"> *	otherwise we attach the original buffer as a page fragment to a fresh</span>
<span class="cm"> *	sk_buff.  If a positive drop threshold is supplied packets are dropped</span>
<span class="cm"> *	and their buffers recycled if (a) the number of remaining buffers is</span>
<span class="cm"> *	under the threshold and the packet is too big to copy, or (b) there&#39;s</span>
<span class="cm"> *	no system memory.</span>
<span class="cm"> *</span>
<span class="cm"> * 	Note: this function is similar to @get_packet but deals with Rx buffers</span>
<span class="cm"> * 	that are page chunks rather than sk_buffs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">get_packet_pg</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_fl</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">drop_thres</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">newskb</span><span class="p">,</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rx_sw_desc</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">sdesc</span><span class="p">[</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">];</span>

	<span class="n">dma_addr_t</span> <span class="n">dma_addr</span> <span class="o">=</span> <span class="n">dma_unmap_addr</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">);</span>

	<span class="n">newskb</span> <span class="o">=</span> <span class="n">skb</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">pg_skb</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">SGE_RX_COPY_THRES</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">newskb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">newskb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__skb_put</span><span class="p">(</span><span class="n">newskb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">pci_dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
					    <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">newskb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">va</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">pci_dma_sync_single_for_device</span><span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">,</span>
						       <span class="n">len</span><span class="p">,</span>
						       <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drop_thres</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">recycle:</span>
		<span class="n">fl</span><span class="o">-&gt;</span><span class="n">credits</span><span class="o">--</span><span class="p">;</span>
		<span class="n">recycle_rx_buf</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">);</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">rx_recycle_buf</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">newskb</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rx_recycle_buf</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span> <span class="o">&amp;&amp;</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">credits</span> <span class="o">&lt;=</span> <span class="n">drop_thres</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">recycle</span><span class="p">;</span>

	<span class="n">prefetch</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">p_cnt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="n">newskb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">SGE_RX_PULL_LEN</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">newskb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drop_thres</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">recycle</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
				    <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
	<span class="p">(</span><span class="o">*</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">p_cnt</span><span class="p">)</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">p_cnt</span> <span class="o">&amp;&amp;</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">page</span> <span class="o">!=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">page</span><span class="p">)</span>
		<span class="n">pci_unmap_page</span><span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
			       <span class="n">sd</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">mapping</span><span class="p">,</span>
			       <span class="n">fl</span><span class="o">-&gt;</span><span class="n">alloc_size</span><span class="p">,</span>
			       <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__skb_put</span><span class="p">(</span><span class="n">newskb</span><span class="p">,</span> <span class="n">SGE_RX_PULL_LEN</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">newskb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">va</span><span class="p">,</span> <span class="n">SGE_RX_PULL_LEN</span><span class="p">);</span>
		<span class="n">skb_fill_page_desc</span><span class="p">(</span><span class="n">newskb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">page</span><span class="p">,</span>
				   <span class="n">sd</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span> <span class="n">SGE_RX_PULL_LEN</span><span class="p">,</span>
				   <span class="n">len</span> <span class="o">-</span> <span class="n">SGE_RX_PULL_LEN</span><span class="p">);</span>
		<span class="n">newskb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">newskb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">SGE_RX_PULL_LEN</span><span class="p">;</span>
		<span class="n">newskb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">newskb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">skb_fill_page_desc</span><span class="p">(</span><span class="n">newskb</span><span class="p">,</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">newskb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">,</span>
				   <span class="n">sd</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">page</span><span class="p">,</span>
				   <span class="n">sd</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">newskb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">newskb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">newskb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">credits</span><span class="o">--</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We do not refill FLs here, we let the caller do it to overlap a</span>
<span class="cm">	 * prefetch.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">newskb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	get_imm_packet - return the next ingress packet buffer from a response</span>
<span class="cm"> *	@resp: the response descriptor containing the packet data</span>
<span class="cm"> *</span>
<span class="cm"> *	Return a packet containing the immediate data of the given response.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">get_imm_packet</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">rsp_desc</span> <span class="o">*</span><span class="n">resp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">IMMED_PKT_SIZE</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IMMED_PKT_SIZE</span><span class="p">);</span>
		<span class="n">skb_copy_to_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">resp</span><span class="o">-&gt;</span><span class="n">imm_data</span><span class="p">,</span> <span class="n">IMMED_PKT_SIZE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	calc_tx_descs - calculate the number of Tx descriptors for a packet</span>
<span class="cm"> *	@skb: the packet</span>
<span class="cm"> *</span>
<span class="cm"> * 	Returns the number of Tx descriptors needed for the given Ethernet</span>
<span class="cm"> * 	packet.  Ethernet packets require addition of WR and CPL headers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">calc_tx_descs</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flits</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">WR_LEN</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpl_tx_pkt</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">flits</span> <span class="o">=</span> <span class="n">sgl_len</span><span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">)</span>
		<span class="n">flits</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">flits_to_desc</span><span class="p">(</span><span class="n">flits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	make_sgl - populate a scatter/gather list for a packet</span>
<span class="cm"> *	@skb: the packet</span>
<span class="cm"> *	@sgp: the SGL to populate</span>
<span class="cm"> *	@start: start address of skb main body data to include in the SGL</span>
<span class="cm"> *	@len: length of skb main body data to include in the SGL</span>
<span class="cm"> *	@pdev: the PCI device</span>
<span class="cm"> *</span>
<span class="cm"> *	Generates a scatter/gather list for the buffers that make up a packet</span>
<span class="cm"> *	and returns the SGL size in 8-byte words.  The caller must size the SGL</span>
<span class="cm"> *	appropriately.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">make_sgl</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sg_ent</span> <span class="o">*</span><span class="n">sgp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">mapping</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nfrags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mapping</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
		<span class="n">sgp</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
		<span class="n">sgp</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
		<span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nfrags</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nfrags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">mapping</span> <span class="o">=</span> <span class="n">skb_frag_dma_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">frag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">),</span>
					   <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="n">sgp</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">));</span>
		<span class="n">sgp</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
		<span class="n">j</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="o">++</span><span class="n">sgp</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">j</span><span class="p">)</span>
		<span class="n">sgp</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">nfrags</span> <span class="o">+</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	check_ring_tx_db - check and potentially ring a Tx queue&#39;s doorbell</span>
<span class="cm"> *	@adap: the adapter</span>
<span class="cm"> *	@q: the Tx queue</span>
<span class="cm"> *</span>
<span class="cm"> *	Ring the doorbel if a Tx queue is asleep.  There is a natural race,</span>
<span class="cm"> *	where the HW is going to sleep just after we checked, however,</span>
<span class="cm"> *	then the interrupt handler will detect the outstanding TX packet</span>
<span class="cm"> *	and ring the doorbell for us.</span>
<span class="cm"> *</span>
<span class="cm"> *	When GTS is disabled we unconditionally ring the doorbell.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">check_ring_tx_db</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_txq</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if USE_GTS</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">TXQ_LAST_PKT_DB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">TXQ_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">TXQ_LAST_PKT_DB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_KDOORBELL</span><span class="p">,</span>
			     <span class="n">F_SELEGRCNTX</span> <span class="o">|</span> <span class="n">V_EGRCNTX</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cntxt_id</span><span class="p">));</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="n">wmb</span><span class="p">();</span>			<span class="cm">/* write descriptors before telling HW */</span>
	<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_KDOORBELL</span><span class="p">,</span>
		     <span class="n">F_SELEGRCNTX</span> <span class="o">|</span> <span class="n">V_EGRCNTX</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cntxt_id</span><span class="p">));</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wr_gen2</span><span class="p">(</span><span class="k">struct</span> <span class="n">tx_desc</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gen</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if SGE_NUM_GENBITS == 2</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">flit</span><span class="p">[</span><span class="n">TX_DESC_FLITS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">gen</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	write_wr_hdr_sgl - write a WR header and, optionally, SGL</span>
<span class="cm"> *	@ndesc: number of Tx descriptors spanned by the SGL</span>
<span class="cm"> *	@skb: the packet corresponding to the WR</span>
<span class="cm"> *	@d: first Tx descriptor to be written</span>
<span class="cm"> *	@pidx: index of above descriptors</span>
<span class="cm"> *	@q: the SGE Tx queue</span>
<span class="cm"> *	@sgl: the SGL</span>
<span class="cm"> *	@flits: number of flits to the start of the SGL in the first descriptor</span>
<span class="cm"> *	@sgl_flits: the SGL size in flits</span>
<span class="cm"> *	@gen: the Tx descriptor generation</span>
<span class="cm"> *	@wr_hi: top 32 bits of WR header based on WR type (big endian)</span>
<span class="cm"> *	@wr_lo: low 32 bits of WR header based on WR type (big endian)</span>
<span class="cm"> *</span>
<span class="cm"> *	Write a work request header and an associated SGL.  If the SGL is</span>
<span class="cm"> *	small enough to fit into one Tx descriptor it has already been written</span>
<span class="cm"> *	and we just need to write the WR header.  Otherwise we distribute the</span>
<span class="cm"> *	SGL across the number of descriptors it spans.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">write_wr_hdr_sgl</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ndesc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">tx_desc</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pidx</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">sge_txq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">sg_ent</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flits</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sgl_flits</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gen</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">wr_hi</span><span class="p">,</span>
			     <span class="n">__be32</span> <span class="n">wr_lo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_request_hdr</span> <span class="o">*</span><span class="n">wrp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">work_request_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">d</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tx_sw_desc</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sdesc</span><span class="p">[</span><span class="n">pidx</span><span class="p">];</span>

	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_skb_unmap</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">fragidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">addr_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">sflit</span> <span class="o">=</span> <span class="n">flits</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ndesc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">eop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">wrp</span><span class="o">-&gt;</span><span class="n">wr_hi</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">F_WR_SOP</span> <span class="o">|</span> <span class="n">F_WR_EOP</span> <span class="o">|</span> <span class="n">V_WR_DATATYPE</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
				   <span class="n">V_WR_SGLSFLT</span><span class="p">(</span><span class="n">flits</span><span class="p">))</span> <span class="o">|</span> <span class="n">wr_hi</span><span class="p">;</span>
		<span class="n">wmb</span><span class="p">();</span>
		<span class="n">wrp</span><span class="o">-&gt;</span><span class="n">wr_lo</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">V_WR_LEN</span><span class="p">(</span><span class="n">flits</span> <span class="o">+</span> <span class="n">sgl_flits</span><span class="p">)</span> <span class="o">|</span>
				   <span class="n">V_WR_GEN</span><span class="p">(</span><span class="n">gen</span><span class="p">))</span> <span class="o">|</span> <span class="n">wr_lo</span><span class="p">;</span>
		<span class="n">wr_gen2</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">gen</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ogen</span> <span class="o">=</span> <span class="n">gen</span><span class="p">;</span>
		<span class="k">const</span> <span class="n">u64</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">sgl</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">work_request_hdr</span> <span class="o">*</span><span class="n">wp</span> <span class="o">=</span> <span class="n">wrp</span><span class="p">;</span>

		<span class="n">wrp</span><span class="o">-&gt;</span><span class="n">wr_hi</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">F_WR_SOP</span> <span class="o">|</span> <span class="n">V_WR_DATATYPE</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
				   <span class="n">V_WR_SGLSFLT</span><span class="p">(</span><span class="n">flits</span><span class="p">))</span> <span class="o">|</span> <span class="n">wr_hi</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">sgl_flits</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">avail</span> <span class="o">=</span> <span class="n">WR_FLITS</span> <span class="o">-</span> <span class="n">flits</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">avail</span> <span class="o">&gt;</span> <span class="n">sgl_flits</span><span class="p">)</span>
				<span class="n">avail</span> <span class="o">=</span> <span class="n">sgl_flits</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">flit</span><span class="p">[</span><span class="n">flits</span><span class="p">],</span> <span class="n">fp</span><span class="p">,</span> <span class="n">avail</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">));</span>
			<span class="n">sgl_flits</span> <span class="o">-=</span> <span class="n">avail</span><span class="p">;</span>
			<span class="n">ndesc</span><span class="o">--</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sgl_flits</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">fp</span> <span class="o">+=</span> <span class="n">avail</span><span class="p">;</span>
			<span class="n">d</span><span class="o">++</span><span class="p">;</span>
			<span class="n">sd</span><span class="o">-&gt;</span><span class="n">eop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">sd</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">pidx</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">gen</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">d</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">;</span>
				<span class="n">sd</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">sdesc</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">sd</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
			<span class="n">wrp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">work_request_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">d</span><span class="p">;</span>
			<span class="n">wrp</span><span class="o">-&gt;</span><span class="n">wr_hi</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">V_WR_DATATYPE</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
					   <span class="n">V_WR_SGLSFLT</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">|</span> <span class="n">wr_hi</span><span class="p">;</span>
			<span class="n">wrp</span><span class="o">-&gt;</span><span class="n">wr_lo</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">V_WR_LEN</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">WR_FLITS</span><span class="p">,</span>
							<span class="n">sgl_flits</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">|</span>
					   <span class="n">V_WR_GEN</span><span class="p">(</span><span class="n">gen</span><span class="p">))</span> <span class="o">|</span> <span class="n">wr_lo</span><span class="p">;</span>
			<span class="n">wr_gen2</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">gen</span><span class="p">);</span>
			<span class="n">flits</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">eop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">wrp</span><span class="o">-&gt;</span><span class="n">wr_hi</span> <span class="o">|=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">F_WR_EOP</span><span class="p">);</span>
		<span class="n">wmb</span><span class="p">();</span>
		<span class="n">wp</span><span class="o">-&gt;</span><span class="n">wr_lo</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">V_WR_LEN</span><span class="p">(</span><span class="n">WR_FLITS</span><span class="p">)</span> <span class="o">|</span> <span class="n">V_WR_GEN</span><span class="p">(</span><span class="n">ogen</span><span class="p">))</span> <span class="o">|</span> <span class="n">wr_lo</span><span class="p">;</span>
		<span class="n">wr_gen2</span><span class="p">((</span><span class="k">struct</span> <span class="n">tx_desc</span> <span class="o">*</span><span class="p">)</span><span class="n">wp</span><span class="p">,</span> <span class="n">ogen</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ndesc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	write_tx_pkt_wr - write a TX_PKT work request</span>
<span class="cm"> *	@adap: the adapter</span>
<span class="cm"> *	@skb: the packet to send</span>
<span class="cm"> *	@pi: the egress interface</span>
<span class="cm"> *	@pidx: index of the first Tx descriptor to write</span>
<span class="cm"> *	@gen: the generation value to use</span>
<span class="cm"> *	@q: the Tx queue</span>
<span class="cm"> *	@ndesc: number of descriptors the packet will occupy</span>
<span class="cm"> *	@compl: the value of the COMPL bit to use</span>
<span class="cm"> *</span>
<span class="cm"> *	Generate a TX_PKT work request to send the supplied packet.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">write_tx_pkt_wr</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pidx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gen</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">sge_txq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ndesc</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">compl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flits</span><span class="p">,</span> <span class="n">sgl_flits</span><span class="p">,</span> <span class="n">cntrl</span><span class="p">,</span> <span class="n">tso_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sg_ent</span> <span class="o">*</span><span class="n">sgp</span><span class="p">,</span> <span class="n">sgl</span><span class="p">[</span><span class="n">MAX_SKB_FRAGS</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">tx_desc</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">[</span><span class="n">pidx</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">cpl_tx_pkt</span> <span class="o">*</span><span class="n">cpl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cpl_tx_pkt</span> <span class="o">*</span><span class="p">)</span><span class="n">d</span><span class="p">;</span>

	<span class="n">cpl</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">cntrl</span> <span class="o">=</span> <span class="n">V_TXPKT_INTF</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vlan_tx_tag_present</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="n">cntrl</span> <span class="o">|=</span> <span class="n">F_TXPKT_VLAN_VLD</span> <span class="o">|</span> <span class="n">V_TXPKT_VLAN</span><span class="p">(</span><span class="n">vlan_tx_tag_get</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

	<span class="n">tso_info</span> <span class="o">=</span> <span class="n">V_LSO_MSS</span><span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tso_info</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">eth_type</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cpl_tx_pkt_lso</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cpl_tx_pkt_lso</span> <span class="o">*</span><span class="p">)</span><span class="n">cpl</span><span class="p">;</span>

		<span class="n">d</span><span class="o">-&gt;</span><span class="n">flit</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cntrl</span> <span class="o">|=</span> <span class="n">V_TXPKT_OPCODE</span><span class="p">(</span><span class="n">CPL_TX_PKT_LSO</span><span class="p">);</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">cntrl</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">cntrl</span><span class="p">);</span>
		<span class="n">eth_type</span> <span class="o">=</span> <span class="n">skb_network_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">==</span> <span class="n">ETH_HLEN</span> <span class="o">?</span>
		    <span class="n">CPL_ETH_II</span> <span class="o">:</span> <span class="n">CPL_ETH_II_VLAN</span><span class="p">;</span>
		<span class="n">tso_info</span> <span class="o">|=</span> <span class="n">V_LSO_ETH_TYPE</span><span class="p">(</span><span class="n">eth_type</span><span class="p">)</span> <span class="o">|</span>
		    <span class="n">V_LSO_IPHDR_WORDS</span><span class="p">(</span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ihl</span><span class="p">)</span> <span class="o">|</span>
		    <span class="n">V_LSO_TCPHDR_WORDS</span><span class="p">(</span><span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">doff</span><span class="p">);</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">lso_info</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">tso_info</span><span class="p">);</span>
		<span class="n">flits</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cntrl</span> <span class="o">|=</span> <span class="n">V_TXPKT_OPCODE</span><span class="p">(</span><span class="n">CPL_TX_PKT</span><span class="p">);</span>
		<span class="n">cntrl</span> <span class="o">|=</span> <span class="n">F_TXPKT_IPCSUM_DIS</span><span class="p">;</span>	<span class="cm">/* SW calculates IP csum */</span>
		<span class="n">cntrl</span> <span class="o">|=</span> <span class="n">V_TXPKT_L4CSUM_DIS</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">!=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">);</span>
		<span class="n">cpl</span><span class="o">-&gt;</span><span class="n">cntrl</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">cntrl</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">WR_LEN</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cpl</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">sdesc</span><span class="p">[</span><span class="n">pidx</span><span class="p">].</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">)</span>
				<span class="n">skb_copy_from_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">flit</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
							  <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">skb_copy_bits</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">flit</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

			<span class="n">flits</span> <span class="o">=</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">cpl</span><span class="o">-&gt;</span><span class="n">wr</span><span class="p">.</span><span class="n">wr_hi</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">V_WR_BCNTLFLT</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">|</span>
					      <span class="n">V_WR_OP</span><span class="p">(</span><span class="n">FW_WROPCODE_TUNNEL_TX_PKT</span><span class="p">)</span>
					      <span class="o">|</span> <span class="n">F_WR_SOP</span> <span class="o">|</span> <span class="n">F_WR_EOP</span> <span class="o">|</span> <span class="n">compl</span><span class="p">);</span>
			<span class="n">wmb</span><span class="p">();</span>
			<span class="n">cpl</span><span class="o">-&gt;</span><span class="n">wr</span><span class="p">.</span><span class="n">wr_lo</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">V_WR_LEN</span><span class="p">(</span><span class="n">flits</span><span class="p">)</span> <span class="o">|</span> <span class="n">V_WR_GEN</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span> <span class="o">|</span>
					      <span class="n">V_WR_TID</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">token</span><span class="p">));</span>
			<span class="n">wr_gen2</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">gen</span><span class="p">);</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">flits</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sgp</span> <span class="o">=</span> <span class="n">ndesc</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sg_ent</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">flit</span><span class="p">[</span><span class="n">flits</span><span class="p">]</span> <span class="o">:</span> <span class="n">sgl</span><span class="p">;</span>
	<span class="n">sgl_flits</span> <span class="o">=</span> <span class="n">make_sgl</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sgp</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">write_wr_hdr_sgl</span><span class="p">(</span><span class="n">ndesc</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">pidx</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="n">flits</span><span class="p">,</span> <span class="n">sgl_flits</span><span class="p">,</span> <span class="n">gen</span><span class="p">,</span>
			 <span class="n">htonl</span><span class="p">(</span><span class="n">V_WR_OP</span><span class="p">(</span><span class="n">FW_WROPCODE_TUNNEL_TX_PKT</span><span class="p">)</span> <span class="o">|</span> <span class="n">compl</span><span class="p">),</span>
			 <span class="n">htonl</span><span class="p">(</span><span class="n">V_WR_TID</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">token</span><span class="p">)));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">t3_stop_tx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">qs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_txq</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netif_tx_stop_queue</span><span class="p">(</span><span class="n">txq</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">TXQ_ETH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq_stopped</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">stops</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	eth_xmit - add a packet to the Ethernet Tx queue</span>
<span class="cm"> *	@skb: the packet</span>
<span class="cm"> *	@dev: the egress net device</span>
<span class="cm"> *</span>
<span class="cm"> *	Add a packet to an SGE Tx queue.  Runs with softirqs disabled.</span>
<span class="cm"> */</span>
<span class="n">netdev_tx_t</span> <span class="nf">t3_eth_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">qidx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ndesc</span><span class="p">,</span> <span class="n">pidx</span><span class="p">,</span> <span class="n">credits</span><span class="p">,</span> <span class="n">gen</span><span class="p">,</span> <span class="n">compl</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">qs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge_txq</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The chip min packet length is 9 octets but play safe and reject</span>
<span class="cm">	 * anything shorter than an Ethernet header.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">ETH_HLEN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">qidx</span> <span class="o">=</span> <span class="n">skb_get_queue_mapping</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">qs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">qs</span><span class="p">[</span><span class="n">qidx</span><span class="p">];</span>
	<span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_ETH</span><span class="p">];</span>
	<span class="n">txq</span> <span class="o">=</span> <span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">qidx</span><span class="p">);</span>

	<span class="n">reclaim_completed_tx</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">TX_RECLAIM_CHUNK</span><span class="p">);</span>

	<span class="n">credits</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">in_use</span><span class="p">;</span>
	<span class="n">ndesc</span> <span class="o">=</span> <span class="n">calc_tx_descs</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">credits</span> <span class="o">&lt;</span> <span class="n">ndesc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">t3_stop_tx_queue</span><span class="p">(</span><span class="n">txq</span><span class="p">,</span> <span class="n">qs</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s: Tx ring %u full while queue awake!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">cntxt_id</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">+=</span> <span class="n">ndesc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">credits</span> <span class="o">-</span> <span class="n">ndesc</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">stop_thres</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">t3_stop_tx_queue</span><span class="p">(</span><span class="n">txq</span><span class="p">,</span> <span class="n">qs</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">should_restart_tx</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">TXQ_ETH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq_stopped</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">restarts</span><span class="o">++</span><span class="p">;</span>
			<span class="n">netif_tx_start_queue</span><span class="p">(</span><span class="n">txq</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">gen</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">gen</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">unacked</span> <span class="o">+=</span> <span class="n">ndesc</span><span class="p">;</span>
	<span class="n">compl</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">unacked</span> <span class="o">&amp;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">S_WR_COMPL</span> <span class="o">-</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">unacked</span> <span class="o">&amp;=</span> <span class="mi">7</span><span class="p">;</span>
	<span class="n">pidx</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">+=</span> <span class="n">ndesc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">-=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* update port statistics */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_COMPLETE</span><span class="p">)</span>
		<span class="n">qs</span><span class="o">-&gt;</span><span class="n">port_stats</span><span class="p">[</span><span class="n">SGE_PSTAT_TX_CSUM</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">)</span>
		<span class="n">qs</span><span class="o">-&gt;</span><span class="n">port_stats</span><span class="p">[</span><span class="n">SGE_PSTAT_TSO</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vlan_tx_tag_present</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="n">qs</span><span class="o">-&gt;</span><span class="n">port_stats</span><span class="p">[</span><span class="n">SGE_PSTAT_VLANINS</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We do not use Tx completion interrupts to free DMAd Tx packets.</span>
<span class="cm">	 * This is good for performance but means that we rely on new Tx</span>
<span class="cm">	 * packets arriving to run the destructors of completed packets,</span>
<span class="cm">	 * which open up space in their sockets&#39; send queues.  Sometimes</span>
<span class="cm">	 * we do not get such new packets causing Tx to stall.  A single</span>
<span class="cm">	 * UDP transmitter is a good example of this situation.  We have</span>
<span class="cm">	 * a clean up timer that periodically reclaims completed packets</span>
<span class="cm">	 * but it doesn&#39;t run often enough (nor do we want it to) to prevent</span>
<span class="cm">	 * lengthy stalls.  A solution to this problem is to run the</span>
<span class="cm">	 * destructor early, after the packet is queued but before it&#39;s DMAd.</span>
<span class="cm">	 * A cons is that we lie to socket memory accounting, but the amount</span>
<span class="cm">	 * of extra memory is reasonable (limited by the number of Tx</span>
<span class="cm">	 * descriptors), the packets do actually get freed quickly by new</span>
<span class="cm">	 * packets almost always, and for protocols like TCP that wait for</span>
<span class="cm">	 * acks to really free up the data the extra memory is even less.</span>
<span class="cm">	 * On the positive side we run the destructors on the sending CPU</span>
<span class="cm">	 * rather than on a potentially different completing CPU, usually a</span>
<span class="cm">	 * good thing.  We also run them without holding our Tx queue lock,</span>
<span class="cm">	 * unlike what reclaim_completed_tx() would otherwise do.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Run the destructor before telling the DMA engine about the packet</span>
<span class="cm">	 * to make sure it doesn&#39;t complete and get freed prematurely.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">skb_shared</span><span class="p">(</span><span class="n">skb</span><span class="p">)))</span>
		<span class="n">skb_orphan</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">write_tx_pkt_wr</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">pidx</span><span class="p">,</span> <span class="n">gen</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">ndesc</span><span class="p">,</span> <span class="n">compl</span><span class="p">);</span>
	<span class="n">check_ring_tx_db</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	write_imm - write a packet into a Tx descriptor as immediate data</span>
<span class="cm"> *	@d: the Tx descriptor to write</span>
<span class="cm"> *	@skb: the packet</span>
<span class="cm"> *	@len: the length of packet data to write as immediate data</span>
<span class="cm"> *	@gen: the generation bit value to write</span>
<span class="cm"> *</span>
<span class="cm"> *	Writes a packet as immediate data into a Tx descriptor.  The packet</span>
<span class="cm"> *	contains a work request at its beginning.  We must write the packet</span>
<span class="cm"> *	carefully so the SGE doesn&#39;t read it accidentally before it&#39;s written</span>
<span class="cm"> *	in its entirety.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">write_imm</span><span class="p">(</span><span class="k">struct</span> <span class="n">tx_desc</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_request_hdr</span> <span class="o">*</span><span class="n">from</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">work_request_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_request_hdr</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">work_request_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">d</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">))</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">from</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">len</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">from</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">skb_copy_bits</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">from</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">to</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">len</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">from</span><span class="p">));</span>

	<span class="n">to</span><span class="o">-&gt;</span><span class="n">wr_hi</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">wr_hi</span> <span class="o">|</span> <span class="n">htonl</span><span class="p">(</span><span class="n">F_WR_SOP</span> <span class="o">|</span> <span class="n">F_WR_EOP</span> <span class="o">|</span>
					<span class="n">V_WR_BCNTLFLT</span><span class="p">(</span><span class="n">len</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">));</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">wr_lo</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">wr_lo</span> <span class="o">|</span> <span class="n">htonl</span><span class="p">(</span><span class="n">V_WR_GEN</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">V_WR_LEN</span><span class="p">((</span><span class="n">len</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">));</span>
	<span class="n">wr_gen2</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">gen</span><span class="p">);</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	check_desc_avail - check descriptor availability on a send queue</span>
<span class="cm"> *	@adap: the adapter</span>
<span class="cm"> *	@q: the send queue</span>
<span class="cm"> *	@skb: the packet needing the descriptors</span>
<span class="cm"> *	@ndesc: the number of Tx descriptors needed</span>
<span class="cm"> *	@qid: the Tx queue number in its queue set (TXQ_OFLD or TXQ_CTRL)</span>
<span class="cm"> *</span>
<span class="cm"> *	Checks if the requested number of Tx descriptors is available on an</span>
<span class="cm"> *	SGE send queue.  If the queue is already suspended or not enough</span>
<span class="cm"> *	descriptors are available the packet is queued for later transmission.</span>
<span class="cm"> *	Must be called with the Tx queue locked.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 if enough descriptors are available, 1 if there aren&#39;t</span>
<span class="cm"> *	enough descriptors and the packet has been queued, and 2 if the caller</span>
<span class="cm"> *	needs to retry because there weren&#39;t enough descriptors at the</span>
<span class="cm"> *	beginning of the call but some freed up in the mean time.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">check_desc_avail</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_txq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ndesc</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">qid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sendq</span><span class="p">)))</span> <span class="p">{</span>
	      <span class="nl">addq_exit:</span><span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sendq</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">&lt;</span> <span class="n">ndesc</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">qs</span> <span class="o">=</span> <span class="n">txq_to_qset</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">qid</span><span class="p">);</span>

		<span class="n">set_bit</span><span class="p">(</span><span class="n">qid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq_stopped</span><span class="p">);</span>
		<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">should_restart_tx</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">qid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq_stopped</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>

		<span class="n">q</span><span class="o">-&gt;</span><span class="n">stops</span><span class="o">++</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">addq_exit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	reclaim_completed_tx_imm - reclaim completed control-queue Tx descs</span>
<span class="cm"> *	@q: the SGE control Tx queue</span>
<span class="cm"> *</span>
<span class="cm"> *	This is a variant of reclaim_completed_tx() that is used for Tx queues</span>
<span class="cm"> *	that send only immediate data (presently just the control queues) and</span>
<span class="cm"> *	thus do not have any sk_buffs to release.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">reclaim_completed_tx_imm</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge_txq</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reclaim</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">processed</span> <span class="o">-</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">cleaned</span><span class="p">;</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">-=</span> <span class="n">reclaim</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">cleaned</span> <span class="o">+=</span> <span class="n">reclaim</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">immediate</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">WR_LEN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ctrl_xmit - send a packet through an SGE control Tx queue</span>
<span class="cm"> *	@adap: the adapter</span>
<span class="cm"> *	@q: the control queue</span>
<span class="cm"> *	@skb: the packet</span>
<span class="cm"> *</span>
<span class="cm"> *	Send a packet through an SGE control Tx queue.  Packets sent through</span>
<span class="cm"> *	a control queue must fit entirely as immediate data in a single Tx</span>
<span class="cm"> *	descriptor and have no page fragments.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ctrl_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_txq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_request_hdr</span> <span class="o">*</span><span class="n">wrp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">work_request_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">immediate</span><span class="p">(</span><span class="n">skb</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NET_XMIT_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">wrp</span><span class="o">-&gt;</span><span class="n">wr_hi</span> <span class="o">|=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">F_WR_SOP</span> <span class="o">|</span> <span class="n">F_WR_EOP</span><span class="p">);</span>
	<span class="n">wrp</span><span class="o">-&gt;</span><span class="n">wr_lo</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">V_WR_TID</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">token</span><span class="p">));</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
      <span class="nl">again:</span><span class="n">reclaim_completed_tx_imm</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">check_desc_avail</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">TXQ_CTRL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NET_XMIT_CN</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">write_imm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span><span class="p">],</span> <span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">gen</span><span class="p">);</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">in_use</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_KDOORBELL</span><span class="p">,</span>
		     <span class="n">F_SELEGRCNTX</span> <span class="o">|</span> <span class="n">V_EGRCNTX</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cntxt_id</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">NET_XMIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	restart_ctrlq - restart a suspended control queue</span>
<span class="cm"> *	@qs: the queue set cotaining the control queue</span>
<span class="cm"> *</span>
<span class="cm"> *	Resumes transmission on a suspended Tx control queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">restart_ctrlq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">qs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge_txq</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_CTRL</span><span class="p">];</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
      <span class="nl">again:</span><span class="n">reclaim_completed_tx_imm</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="n">skb</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sendq</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">write_imm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span><span class="p">],</span> <span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">gen</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">in_use</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sendq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">TXQ_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq_stopped</span><span class="p">);</span>
		<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">should_restart_tx</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">TXQ_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq_stopped</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">stops</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_KDOORBELL</span><span class="p">,</span>
		     <span class="n">F_SELEGRCNTX</span> <span class="o">|</span> <span class="n">V_EGRCNTX</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cntxt_id</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Send a management message through control queue 0</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">t3_mgmt_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ctrl_xmit</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_CTRL</span><span class="p">],</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	deferred_unmap_destructor - unmap a packet when it is freed</span>
<span class="cm"> *	@skb: the packet</span>
<span class="cm"> *</span>
<span class="cm"> *	This is the packet destructor used for Tx packets that need to remain</span>
<span class="cm"> *	mapped until they are freed rather than until their Tx descriptors are</span>
<span class="cm"> *	freed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">deferred_unmap_destructor</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">skb_shared_info</span> <span class="o">*</span><span class="n">si</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">deferred_unmap_info</span> <span class="o">*</span><span class="n">dui</span><span class="p">;</span>

	<span class="n">dui</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">deferred_unmap_info</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">dui</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">transport_header</span><span class="p">)</span>
		<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">dui</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">,</span>
				 <span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">transport_header</span><span class="p">,</span>
				 <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>

	<span class="n">si</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pci_unmap_page</span><span class="p">(</span><span class="n">dui</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">,</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
			       <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_deferred_unmapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sg_ent</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sgl_flits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">deferred_unmap_info</span> <span class="o">*</span><span class="n">dui</span><span class="p">;</span>

	<span class="n">dui</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">deferred_unmap_info</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
	<span class="n">dui</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">dui</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span> <span class="n">sgl_flits</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">sgl</span><span class="o">++</span><span class="p">,</span> <span class="n">sgl_flits</span> <span class="o">-=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sgl_flits</span><span class="p">)</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	write_ofld_wr - write an offload work request</span>
<span class="cm"> *	@adap: the adapter</span>
<span class="cm"> *	@skb: the packet to send</span>
<span class="cm"> *	@q: the Tx queue</span>
<span class="cm"> *	@pidx: index of the first Tx descriptor to write</span>
<span class="cm"> *	@gen: the generation value to use</span>
<span class="cm"> *	@ndesc: number of descriptors the packet will occupy</span>
<span class="cm"> *</span>
<span class="cm"> *	Write an offload work request to send the supplied packet.  The packet</span>
<span class="cm"> *	data already carry the work request with most fields populated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">write_ofld_wr</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">sge_txq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pidx</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gen</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ndesc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sgl_flits</span><span class="p">,</span> <span class="n">flits</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_request_hdr</span> <span class="o">*</span><span class="n">from</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sg_ent</span> <span class="o">*</span><span class="n">sgp</span><span class="p">,</span> <span class="n">sgl</span><span class="p">[</span><span class="n">MAX_SKB_FRAGS</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">tx_desc</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">[</span><span class="n">pidx</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">immediate</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">sdesc</span><span class="p">[</span><span class="n">pidx</span><span class="p">].</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">write_imm</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">gen</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Only TX_DATA builds SGLs */</span>

	<span class="n">from</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">work_request_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">flit</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">from</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
	       <span class="n">skb_transport_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">from</span><span class="p">));</span>

	<span class="n">flits</span> <span class="o">=</span> <span class="n">skb_transport_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">sgp</span> <span class="o">=</span> <span class="n">ndesc</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sg_ent</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">flit</span><span class="p">[</span><span class="n">flits</span><span class="p">]</span> <span class="o">:</span> <span class="n">sgl</span><span class="p">;</span>
	<span class="n">sgl_flits</span> <span class="o">=</span> <span class="n">make_sgl</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sgp</span><span class="p">,</span> <span class="n">skb_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span>
			     <span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">transport_header</span><span class="p">,</span>
			     <span class="n">adap</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_skb_unmap</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">setup_deferred_unmapping</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">sgp</span><span class="p">,</span> <span class="n">sgl_flits</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">destructor</span> <span class="o">=</span> <span class="n">deferred_unmap_destructor</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">write_wr_hdr_sgl</span><span class="p">(</span><span class="n">ndesc</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">pidx</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="n">flits</span><span class="p">,</span> <span class="n">sgl_flits</span><span class="p">,</span>
			 <span class="n">gen</span><span class="p">,</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">wr_hi</span><span class="p">,</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">wr_lo</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	calc_tx_descs_ofld - calculate # of Tx descriptors for an offload packet</span>
<span class="cm"> *	@skb: the packet</span>
<span class="cm"> *</span>
<span class="cm"> * 	Returns the number of Tx descriptors needed for the given offload</span>
<span class="cm"> * 	packet.  These packets are already fully constructed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">calc_tx_descs_ofld</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flits</span><span class="p">,</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">WR_LEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* packet fits as immediate data */</span>

	<span class="n">flits</span> <span class="o">=</span> <span class="n">skb_transport_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>	<span class="cm">/* headers */</span>
	<span class="n">cnt</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">!=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">transport_header</span><span class="p">)</span>
		<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">flits_to_desc</span><span class="p">(</span><span class="n">flits</span> <span class="o">+</span> <span class="n">sgl_len</span><span class="p">(</span><span class="n">cnt</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ofld_xmit - send a packet through an offload queue</span>
<span class="cm"> *	@adap: the adapter</span>
<span class="cm"> *	@q: the Tx offload queue</span>
<span class="cm"> *	@skb: the packet</span>
<span class="cm"> *</span>
<span class="cm"> *	Send an offload packet through an SGE offload queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ofld_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_txq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ndesc</span> <span class="o">=</span> <span class="n">calc_tx_descs_ofld</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">pidx</span><span class="p">,</span> <span class="n">gen</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">again:</span>	<span class="n">reclaim_completed_tx</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">TX_RECLAIM_CHUNK</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">check_desc_avail</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">ndesc</span><span class="p">,</span> <span class="n">TXQ_OFLD</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">ndesc</span><span class="p">;</span>	<span class="cm">/* save for restart */</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NET_XMIT_CN</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">gen</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">gen</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">+=</span> <span class="n">ndesc</span><span class="p">;</span>
	<span class="n">pidx</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">+=</span> <span class="n">ndesc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">-=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">write_ofld_wr</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">pidx</span><span class="p">,</span> <span class="n">gen</span><span class="p">,</span> <span class="n">ndesc</span><span class="p">);</span>
	<span class="n">check_ring_tx_db</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NET_XMIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	restart_offloadq - restart a suspended offload queue</span>
<span class="cm"> *	@qs: the queue set cotaining the offload queue</span>
<span class="cm"> *</span>
<span class="cm"> *	Resumes transmission on a suspended Tx offload queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">restart_offloadq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">qs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge_txq</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_OFLD</span><span class="p">];</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">again:</span>	<span class="n">reclaim_completed_tx</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">TX_RECLAIM_CHUNK</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sendq</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gen</span><span class="p">,</span> <span class="n">pidx</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ndesc</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">&lt;</span> <span class="n">ndesc</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">TXQ_OFLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq_stopped</span><span class="p">);</span>
			<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">should_restart_tx</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">TXQ_OFLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq_stopped</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">stops</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">gen</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">gen</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">+=</span> <span class="n">ndesc</span><span class="p">;</span>
		<span class="n">pidx</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">+=</span> <span class="n">ndesc</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">-=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sendq</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">write_ofld_wr</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">pidx</span><span class="p">,</span> <span class="n">gen</span><span class="p">,</span> <span class="n">ndesc</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

<span class="cp">#if USE_GTS</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">TXQ_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">TXQ_LAST_PKT_DB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_KDOORBELL</span><span class="p">,</span>
		     <span class="n">F_SELEGRCNTX</span> <span class="o">|</span> <span class="n">V_EGRCNTX</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cntxt_id</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	queue_set - return the queue set a packet should use</span>
<span class="cm"> *	@skb: the packet</span>
<span class="cm"> *</span>
<span class="cm"> *	Maps a packet to the SGE queue set it should use.  The desired queue</span>
<span class="cm"> *	set is carried in bits 1-3 in the packet&#39;s priority.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">queue_set</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	is_ctrl_pkt - return whether an offload packet is a control packet</span>
<span class="cm"> *	@skb: the packet</span>
<span class="cm"> *</span>
<span class="cm"> *	Determines whether an offload packet should use an OFLD or a CTRL</span>
<span class="cm"> *	Tx queue.  This is indicated by bit 0 in the packet&#39;s priority.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_ctrl_pkt</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	t3_offload_tx - send an offload packet</span>
<span class="cm"> *	@tdev: the offload device to send to</span>
<span class="cm"> *	@skb: the packet</span>
<span class="cm"> *</span>
<span class="cm"> *	Sends an offload packet.  We use the packet priority to select the</span>
<span class="cm"> *	appropriate Tx queue as follows: bit 0 indicates whether the packet</span>
<span class="cm"> *	should be sent as regular or control, bits 1-3 select the queue set.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">t3_offload_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">t3cdev</span> <span class="o">*</span><span class="n">tdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span> <span class="o">=</span> <span class="n">tdev2adap</span><span class="p">(</span><span class="n">tdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">qs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">qs</span><span class="p">[</span><span class="n">queue_set</span><span class="p">(</span><span class="n">skb</span><span class="p">)];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_ctrl_pkt</span><span class="p">(</span><span class="n">skb</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">ctrl_xmit</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_CTRL</span><span class="p">],</span> <span class="n">skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ofld_xmit</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_OFLD</span><span class="p">],</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	offload_enqueue - add an offload packet to an SGE offload receive queue</span>
<span class="cm"> *	@q: the SGE response queue</span>
<span class="cm"> *	@skb: the packet</span>
<span class="cm"> *</span>
<span class="cm"> *	Add a new offload packet to an SGE response queue&#39;s offload packet</span>
<span class="cm"> *	queue.  If the packet is the first on the queue it schedules the RX</span>
<span class="cm"> *	softirq to process the queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">offload_enqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">was_empty</span> <span class="o">=</span> <span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">);</span>

	<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">was_empty</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">qs</span> <span class="o">=</span> <span class="n">rspq_to_qset</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

		<span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	deliver_partial_bundle - deliver a (partial) bundle of Rx offload pkts</span>
<span class="cm"> *	@tdev: the offload device that will be receiving the packets</span>
<span class="cm"> *	@q: the SGE response queue that assembled the bundle</span>
<span class="cm"> *	@skbs: the partial bundle</span>
<span class="cm"> *	@n: the number of packets in the bundle</span>
<span class="cm"> *</span>
<span class="cm"> *	Delivers a (partial) bundle of Rx offload packets to an offload device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">deliver_partial_bundle</span><span class="p">(</span><span class="k">struct</span> <span class="n">t3cdev</span> <span class="o">*</span><span class="n">tdev</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skbs</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">offload_bundles</span><span class="o">++</span><span class="p">;</span>
		<span class="n">tdev</span><span class="o">-&gt;</span><span class="n">recv</span><span class="p">(</span><span class="n">tdev</span><span class="p">,</span> <span class="n">skbs</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ofld_poll - NAPI handler for offload packets in interrupt mode</span>
<span class="cm"> *	@dev: the network device doing the polling</span>
<span class="cm"> *	@budget: polling budget</span>
<span class="cm"> *</span>
<span class="cm"> *	The NAPI handler for offload packets when a response queue is serviced</span>
<span class="cm"> *	by the hard interrupt handler, i.e., when it&#39;s operating in non-polling</span>
<span class="cm"> *	mode.  Creates small packet batches and sends them through the offload</span>
<span class="cm"> *	receive handler.  Batches need to be of modest size as we do prefetches</span>
<span class="cm"> *	on the packets in each.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ofld_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">qs</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_qset</span><span class="p">,</span> <span class="n">napi</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">qs</span><span class="o">-&gt;</span><span class="n">adap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">work_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">work_done</span> <span class="o">&lt;</span> <span class="n">budget</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">skbs</span><span class="p">[</span><span class="n">RX_BUNDLE_SIZE</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">queue</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ngathered</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">__skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>
		<span class="n">skb_queue_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">work_done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">ngathered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">skb_queue_walk_safe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">work_done</span> <span class="o">&gt;=</span> <span class="n">budget</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">work_done</span><span class="o">++</span><span class="p">;</span>

			<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>
			<span class="n">prefetch</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
			<span class="n">skbs</span><span class="p">[</span><span class="n">ngathered</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">ngathered</span> <span class="o">==</span> <span class="n">RX_BUNDLE_SIZE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">q</span><span class="o">-&gt;</span><span class="n">offload_bundles</span><span class="o">++</span><span class="p">;</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tdev</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tdev</span><span class="p">,</span> <span class="n">skbs</span><span class="p">,</span>
						   <span class="n">ngathered</span><span class="p">);</span>
				<span class="n">ngathered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* splice remaining packets back onto Rx queue */</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">skb_queue_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">);</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">deliver_partial_bundle</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tdev</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">skbs</span><span class="p">,</span> <span class="n">ngathered</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">work_done</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	rx_offload - process a received offload packet</span>
<span class="cm"> *	@tdev: the offload device receiving the packet</span>
<span class="cm"> *	@rq: the response queue that received the packet</span>
<span class="cm"> *	@skb: the packet</span>
<span class="cm"> *	@rx_gather: a gather list of packets if we are building a bundle</span>
<span class="cm"> *	@gather_idx: index of the next available slot in the bundle</span>
<span class="cm"> *</span>
<span class="cm"> *	Process an ingress offload pakcet and add it to the offload ingress</span>
<span class="cm"> *	queue. 	Returns the index of the next available slot in the bundle.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">rx_offload</span><span class="p">(</span><span class="k">struct</span> <span class="n">t3cdev</span> <span class="o">*</span><span class="n">tdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">rx_gather</span><span class="p">[],</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gather_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb_reset_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb_reset_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">polling</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rx_gather</span><span class="p">[</span><span class="n">gather_idx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gather_idx</span> <span class="o">==</span> <span class="n">RX_BUNDLE_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tdev</span><span class="o">-&gt;</span><span class="n">recv</span><span class="p">(</span><span class="n">tdev</span><span class="p">,</span> <span class="n">rx_gather</span><span class="p">,</span> <span class="n">RX_BUNDLE_SIZE</span><span class="p">);</span>
			<span class="n">gather_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">rq</span><span class="o">-&gt;</span><span class="n">offload_bundles</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">offload_enqueue</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">gather_idx</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	restart_tx - check whether to restart suspended Tx queues</span>
<span class="cm"> *	@qs: the queue set to resume</span>
<span class="cm"> *</span>
<span class="cm"> *	Restarts suspended Tx queues of an SGE queue set if they have enough</span>
<span class="cm"> *	free resources to resume operation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">restart_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">qs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">TXQ_ETH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq_stopped</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">should_restart_tx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_ETH</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
	    <span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">TXQ_ETH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq_stopped</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_ETH</span><span class="p">].</span><span class="n">restarts</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">))</span>
			<span class="n">netif_tx_wake_queue</span><span class="p">(</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">tx_q</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">TXQ_OFLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq_stopped</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">should_restart_tx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_OFLD</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
	    <span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">TXQ_OFLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq_stopped</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_OFLD</span><span class="p">].</span><span class="n">restarts</span><span class="o">++</span><span class="p">;</span>
		<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_OFLD</span><span class="p">].</span><span class="n">qresume_tsk</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">TXQ_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq_stopped</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">should_restart_tx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_CTRL</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
	    <span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">TXQ_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq_stopped</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_CTRL</span><span class="p">].</span><span class="n">restarts</span><span class="o">++</span><span class="p">;</span>
		<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_CTRL</span><span class="p">].</span><span class="n">qresume_tsk</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	cxgb3_arp_process - process an ARP request probing a private IP address</span>
<span class="cm"> *	@adapter: the adapter</span>
<span class="cm"> *	@skb: the skbuff containing the ARP request</span>
<span class="cm"> *</span>
<span class="cm"> *	Check if the ARP request is probing the private IP address</span>
<span class="cm"> *	dedicated to iSCSI, generate an ARP reply if so.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cxgb3_arp_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">arphdr</span> <span class="o">*</span><span class="n">arp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arp_ptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sha</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">sip</span><span class="p">,</span> <span class="n">tip</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">skb_reset_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">arp</span> <span class="o">=</span> <span class="n">arp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_op</span> <span class="o">!=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ARPOP_REQUEST</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">arp_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">arp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">sha</span> <span class="o">=</span> <span class="n">arp_ptr</span><span class="p">;</span>
	<span class="n">arp_ptr</span> <span class="o">+=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sip</span><span class="p">,</span> <span class="n">arp_ptr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sip</span><span class="p">));</span>
	<span class="n">arp_ptr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sip</span><span class="p">);</span>
	<span class="n">arp_ptr</span> <span class="o">+=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tip</span><span class="p">,</span> <span class="n">arp_ptr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tip</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tip</span> <span class="o">!=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">iscsi_ipv4addr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">arp_send</span><span class="p">(</span><span class="n">ARPOP_REPLY</span><span class="p">,</span> <span class="n">ETH_P_ARP</span><span class="p">,</span> <span class="n">sip</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">tip</span><span class="p">,</span> <span class="n">sha</span><span class="p">,</span>
		 <span class="n">pi</span><span class="o">-&gt;</span><span class="n">iscsic</span><span class="p">.</span><span class="n">mac_addr</span><span class="p">,</span> <span class="n">sha</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_arp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_ARP</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cxgb3_process_iscsi_prov_pack</span><span class="p">(</span><span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_arp</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cxgb3_arp_process</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">iscsic</span><span class="p">.</span><span class="n">recv</span><span class="p">)</span>
		<span class="n">pi</span><span class="o">-&gt;</span><span class="n">iscsic</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	rx_eth - process an ingress ethernet packet</span>
<span class="cm"> *	@adap: the adapter</span>
<span class="cm"> *	@rq: the response queue that received the packet</span>
<span class="cm"> *	@skb: the packet</span>
<span class="cm"> *	@pad: amount of padding at the start of the buffer</span>
<span class="cm"> *</span>
<span class="cm"> *	Process an ingress ethernet pakcet and deliver it to the stack.</span>
<span class="cm"> *	The padding is 2 if the packet was delivered in an Rx buffer and 0</span>
<span class="cm"> *	if it was immediate data in a response.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rx_eth</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pad</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lro</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpl_rx_pkt</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cpl_rx_pkt</span> <span class="o">*</span><span class="p">)(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">pad</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">qs</span> <span class="o">=</span> <span class="n">rspq_to_qset</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span><span class="p">;</span>

	<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">pad</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">iff</span><span class="p">]);</span>
	<span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXCSUM</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">csum_valid</span> <span class="o">&amp;&amp;</span>
	    <span class="n">p</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="mh">0xffff</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fragment</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qs</span><span class="o">-&gt;</span><span class="n">port_stats</span><span class="p">[</span><span class="n">SGE_PSTAT_RX_CSUM_GOOD</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_UNNECESSARY</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">skb_checksum_none_assert</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb_record_rx_queue</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">qs</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">qs</span><span class="p">[</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">first_qset</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">vlan_valid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qs</span><span class="o">-&gt;</span><span class="n">port_stats</span><span class="p">[</span><span class="n">SGE_PSTAT_VLANEX</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="n">__vlan_hwaccel_put_tag</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">vlan</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">polling</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lro</span><span class="p">)</span>
			<span class="n">napi_gro_receive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">iscsic</span><span class="p">.</span><span class="n">flags</span><span class="p">))</span>
				<span class="n">cxgb3_process_iscsi_prov_pack</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="n">netif_receive_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_eth_tcp</span><span class="p">(</span><span class="n">u32</span> <span class="n">rss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">G_HASHTYPE</span><span class="p">(</span><span class="n">ntohl</span><span class="p">(</span><span class="n">rss</span><span class="p">))</span> <span class="o">==</span> <span class="n">RSS_HASH_4_TUPLE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	lro_add_page - add a page chunk to an LRO session</span>
<span class="cm"> *	@adap: the adapter</span>
<span class="cm"> *	@qs: the associated queue set</span>
<span class="cm"> *	@fl: the free list containing the page chunk to add</span>
<span class="cm"> *	@len: packet length</span>
<span class="cm"> *	@complete: Indicates the last fragment of a frame</span>
<span class="cm"> *</span>
<span class="cm"> *	Add a received packet contained in a page chunk to an existing LRO</span>
<span class="cm"> *	session.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lro_add_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">qs</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">sge_fl</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">complete</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rx_sw_desc</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">sdesc</span><span class="p">[</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpl_rx_pkt</span> <span class="o">*</span><span class="n">cpl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">skb_frag_struct</span> <span class="o">*</span><span class="n">rx_frag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_frags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">nomem</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">napi_get_frags</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
		<span class="n">qs</span><span class="o">-&gt;</span><span class="n">nomem</span> <span class="o">=</span> <span class="o">!</span><span class="n">skb</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">credits</span><span class="o">--</span><span class="p">;</span>

	<span class="n">pci_dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
				    <span class="n">dma_unmap_addr</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">),</span>
				    <span class="n">fl</span><span class="o">-&gt;</span><span class="n">buf_size</span> <span class="o">-</span> <span class="n">SGE_PG_RSVD</span><span class="p">,</span>
				    <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>

	<span class="p">(</span><span class="o">*</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">p_cnt</span><span class="p">)</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">p_cnt</span> <span class="o">&amp;&amp;</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">page</span> <span class="o">!=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">page</span><span class="p">)</span>
		<span class="n">pci_unmap_page</span><span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
			       <span class="n">sd</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">mapping</span><span class="p">,</span>
			       <span class="n">fl</span><span class="o">-&gt;</span><span class="n">alloc_size</span><span class="p">,</span>
			       <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">complete</span><span class="p">)</span>
			<span class="n">qs</span><span class="o">-&gt;</span><span class="n">nomem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rx_frag</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">;</span>
	<span class="n">nr_frags</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr_frags</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpl_rx_pkt</span><span class="p">);</span>
		<span class="n">cpl</span> <span class="o">=</span> <span class="n">qs</span><span class="o">-&gt;</span><span class="n">lro_va</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">va</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXCSUM</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="n">cpl</span><span class="o">-&gt;</span><span class="n">csum_valid</span> <span class="o">&amp;&amp;</span> <span class="n">cpl</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="mh">0xffff</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_UNNECESSARY</span><span class="p">;</span>
			<span class="n">qs</span><span class="o">-&gt;</span><span class="n">port_stats</span><span class="p">[</span><span class="n">SGE_PSTAT_RX_CSUM_GOOD</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_NONE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">cpl</span> <span class="o">=</span> <span class="n">qs</span><span class="o">-&gt;</span><span class="n">lro_va</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">-=</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">rx_frag</span> <span class="o">+=</span> <span class="n">nr_frags</span><span class="p">;</span>
	<span class="n">__skb_frag_set_page</span><span class="p">(</span><span class="n">rx_frag</span><span class="p">,</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">page</span><span class="p">);</span>
	<span class="n">rx_frag</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">skb_frag_size_set</span><span class="p">(</span><span class="n">rx_frag</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">complete</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">skb_record_rx_queue</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">qs</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">qs</span><span class="p">[</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">first_qset</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpl</span><span class="o">-&gt;</span><span class="n">vlan_valid</span><span class="p">)</span>
		<span class="n">__vlan_hwaccel_put_tag</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">cpl</span><span class="o">-&gt;</span><span class="n">vlan</span><span class="p">));</span>
	<span class="n">napi_gro_frags</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	handle_rsp_cntrl_info - handles control information in a response</span>
<span class="cm"> *	@qs: the queue set corresponding to the response</span>
<span class="cm"> *	@flags: the response control flags</span>
<span class="cm"> *</span>
<span class="cm"> *	Handles the control information of an SGE response, such as GTS</span>
<span class="cm"> *	indications and completion credits for the queue set&#39;s Tx queues.</span>
<span class="cm"> *	HW coalesces credits, we don&#39;t do any extra SW coalescing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">handle_rsp_cntrl_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">qs</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">credits</span><span class="p">;</span>

<span class="cp">#if USE_GTS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">F_RSPD_TXQ0_GTS</span><span class="p">)</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">TXQ_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_ETH</span><span class="p">].</span><span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">credits</span> <span class="o">=</span> <span class="n">G_RSPD_TXQ0_CR</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">credits</span><span class="p">)</span>
		<span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_ETH</span><span class="p">].</span><span class="n">processed</span> <span class="o">+=</span> <span class="n">credits</span><span class="p">;</span>

	<span class="n">credits</span> <span class="o">=</span> <span class="n">G_RSPD_TXQ2_CR</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">credits</span><span class="p">)</span>
		<span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_CTRL</span><span class="p">].</span><span class="n">processed</span> <span class="o">+=</span> <span class="n">credits</span><span class="p">;</span>

<span class="cp"># if USE_GTS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">F_RSPD_TXQ1_GTS</span><span class="p">)</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">TXQ_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_OFLD</span><span class="p">].</span><span class="n">flags</span><span class="p">);</span>
<span class="cp"># endif</span>
	<span class="n">credits</span> <span class="o">=</span> <span class="n">G_RSPD_TXQ1_CR</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">credits</span><span class="p">)</span>
		<span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_OFLD</span><span class="p">].</span><span class="n">processed</span> <span class="o">+=</span> <span class="n">credits</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	check_ring_db - check if we need to ring any doorbells</span>
<span class="cm"> *	@adapter: the adapter</span>
<span class="cm"> *	@qs: the queue set whose Tx queues are to be examined</span>
<span class="cm"> *	@sleeping: indicates which Tx queue sent GTS</span>
<span class="cm"> *</span>
<span class="cm"> *	Checks if some of a queue set&#39;s Tx queues need to ring their doorbells</span>
<span class="cm"> *	to resume transmission after idling while they still have unprocessed</span>
<span class="cm"> *	descriptors.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_ring_db</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">qs</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sleeping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sleeping</span> <span class="o">&amp;</span> <span class="n">F_RSPD_TXQ0_GTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sge_txq</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_ETH</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">cleaned</span> <span class="o">+</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">!=</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">processed</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">TXQ_LAST_PKT_DB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">TXQ_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_KDOORBELL</span><span class="p">,</span> <span class="n">F_SELEGRCNTX</span> <span class="o">|</span>
				     <span class="n">V_EGRCNTX</span><span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">cntxt_id</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sleeping</span> <span class="o">&amp;</span> <span class="n">F_RSPD_TXQ1_GTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sge_txq</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_OFLD</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">cleaned</span> <span class="o">+</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">!=</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">processed</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">TXQ_LAST_PKT_DB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">TXQ_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_KDOORBELL</span><span class="p">,</span> <span class="n">F_SELEGRCNTX</span> <span class="o">|</span>
				     <span class="n">V_EGRCNTX</span><span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">cntxt_id</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	is_new_response - check if a response is newly written</span>
<span class="cm"> *	@r: the response descriptor</span>
<span class="cm"> *	@q: the response queue</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns true if a response descriptor contains a yet unprocessed</span>
<span class="cm"> *	response.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_new_response</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">rsp_desc</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">intr_gen</span> <span class="o">&amp;</span> <span class="n">F_RSPD_GEN2</span><span class="p">)</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">gen</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_rspq_bufstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span> <span class="k">const</span> <span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">pg_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">rx_recycle_buf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define RSPD_GTS_MASK  (F_RSPD_TXQ0_GTS | F_RSPD_TXQ1_GTS)</span>
<span class="cp">#define RSPD_CTRL_MASK (RSPD_GTS_MASK | \</span>
<span class="cp">			V_RSPD_TXQ0_CR(M_RSPD_TXQ0_CR) | \</span>
<span class="cp">			V_RSPD_TXQ1_CR(M_RSPD_TXQ1_CR) | \</span>
<span class="cp">			V_RSPD_TXQ2_CR(M_RSPD_TXQ2_CR))</span>

<span class="cm">/* How long to delay the next interrupt in case of memory shortage, in 0.1us. */</span>
<span class="cp">#define NOMEM_INTR_DELAY 2500</span>

<span class="cm">/**</span>
<span class="cm"> *	process_responses - process responses from an SGE response queue</span>
<span class="cm"> *	@adap: the adapter</span>
<span class="cm"> *	@qs: the queue set to which the response queue belongs</span>
<span class="cm"> *	@budget: how many responses can be processed in this round</span>
<span class="cm"> *</span>
<span class="cm"> *	Process responses from an SGE response queue up to the supplied budget.</span>
<span class="cm"> *	Responses include received packets as well as credits and other events</span>
<span class="cm"> *	for the queues that belong to the response queue&#39;s queue set.</span>
<span class="cm"> *	A negative budget is effectively unlimited.</span>
<span class="cm"> *</span>
<span class="cm"> *	Additionally choose the interrupt holdoff time for the next interrupt</span>
<span class="cm"> *	on this queue.  If the system is under memory shortage use a fairly</span>
<span class="cm"> *	long delay to help recovery.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_responses</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">qs</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rsp_desc</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">budget_left</span> <span class="o">=</span> <span class="n">budget</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sleeping</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">offload_skbs</span><span class="p">[</span><span class="n">RX_BUNDLE_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ngathered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">next_holdoff</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">holdoff_tmr</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">budget_left</span> <span class="o">&amp;&amp;</span> <span class="n">is_new_response</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">q</span><span class="p">)))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">packet_complete</span><span class="p">,</span> <span class="n">eth</span><span class="p">,</span> <span class="n">ethpad</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">lro</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_GRO</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>
		<span class="n">__be32</span> <span class="n">rss_hi</span><span class="p">,</span> <span class="n">rss_lo</span><span class="p">;</span>

		<span class="n">rmb</span><span class="p">();</span>
		<span class="n">eth</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">rss_hdr</span><span class="p">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">CPL_RX_PKT</span><span class="p">;</span>
		<span class="n">rss_hi</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">r</span><span class="p">;</span>
		<span class="n">rss_lo</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">rss_hdr</span><span class="p">.</span><span class="n">rss_hash_val</span><span class="p">;</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">F_RSPD_ASYNC_NOTIF</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">AN_PKT_SIZE</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">no_mem</span><span class="p">;</span>

			<span class="n">memcpy</span><span class="p">(</span><span class="n">__skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">AN_PKT_SIZE</span><span class="p">),</span> <span class="n">r</span><span class="p">,</span> <span class="n">AN_PKT_SIZE</span><span class="p">);</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">CPL_ASYNC_NOTIF</span><span class="p">;</span>
			<span class="n">rss_hi</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">CPL_ASYNC_NOTIF</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">async_notif</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">F_RSPD_IMM_DATA_VALID</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">get_imm_packet</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
<span class="nl">no_mem:</span>
				<span class="n">q</span><span class="o">-&gt;</span><span class="n">next_holdoff</span> <span class="o">=</span> <span class="n">NOMEM_INTR_DELAY</span><span class="p">;</span>
				<span class="n">q</span><span class="o">-&gt;</span><span class="n">nomem</span><span class="o">++</span><span class="p">;</span>
				<span class="cm">/* consume one credit since we tried */</span>
				<span class="n">budget_left</span><span class="o">--</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">imm_data</span><span class="o">++</span><span class="p">;</span>
			<span class="n">ethpad</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">len_cq</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sge_fl</span> <span class="o">*</span><span class="n">fl</span><span class="p">;</span>

			<span class="n">lro</span> <span class="o">&amp;=</span> <span class="n">eth</span> <span class="o">&amp;&amp;</span> <span class="n">is_eth_tcp</span><span class="p">(</span><span class="n">rss_hi</span><span class="p">);</span>

			<span class="n">fl</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">&amp;</span> <span class="n">F_RSPD_FLQ</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">use_pages</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">sdesc</span><span class="p">[</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">].</span><span class="n">pg_chunk</span><span class="p">.</span><span class="n">va</span><span class="p">;</span>

				<span class="n">prefetch</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="cp">#if L1_CACHE_BYTES &lt; 128</span>
				<span class="n">prefetch</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">L1_CACHE_BYTES</span><span class="p">);</span>
<span class="cp">#endif</span>
				<span class="n">__refill_fl</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">fl</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">lro</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">lro_add_page</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">qs</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span>
						     <span class="n">G_RSPD_LEN</span><span class="p">(</span><span class="n">len</span><span class="p">),</span>
						     <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">F_RSPD_EOP</span><span class="p">);</span>
					 <span class="k">goto</span> <span class="n">next_fl</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">skb</span> <span class="o">=</span> <span class="n">get_packet_pg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span>
						    <span class="n">G_RSPD_LEN</span><span class="p">(</span><span class="n">len</span><span class="p">),</span>
						    <span class="n">eth</span> <span class="o">?</span>
						    <span class="n">SGE_RX_DROP_THRES</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">q</span><span class="o">-&gt;</span><span class="n">pg_skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">skb</span> <span class="o">=</span> <span class="n">get_packet</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="n">G_RSPD_LEN</span><span class="p">(</span><span class="n">len</span><span class="p">),</span>
						 <span class="n">eth</span> <span class="o">?</span> <span class="n">SGE_RX_DROP_THRES</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eth</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">no_mem</span><span class="p">;</span>
				<span class="n">q</span><span class="o">-&gt;</span><span class="n">rx_drops</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">rss_hdr</span><span class="p">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">CPL_TRACE_PKT</span><span class="p">))</span>
				<span class="n">__skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="nl">next_fl:</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">cidx</span> <span class="o">==</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
				<span class="n">fl</span><span class="o">-&gt;</span><span class="n">cidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">pure_rsps</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RSPD_CTRL_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sleeping</span> <span class="o">|=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RSPD_GTS_MASK</span><span class="p">;</span>
			<span class="n">handle_rsp_cntrl_info</span><span class="p">(</span><span class="n">qs</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">r</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">++</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cidx</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">cidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">prefetch</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">credits</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">/</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">refill_rspq</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">credits</span><span class="p">);</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">credits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">packet_complete</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span>
				  <span class="p">(</span><span class="n">F_RSPD_EOP</span> <span class="o">|</span> <span class="n">F_RSPD_IMM_DATA_VALID</span> <span class="o">|</span>
				   <span class="n">F_RSPD_ASYNC_NOTIF</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">packet_complete</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">eth</span><span class="p">)</span>
				<span class="n">rx_eth</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">ethpad</span><span class="p">,</span> <span class="n">lro</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">q</span><span class="o">-&gt;</span><span class="n">offload_pkts</span><span class="o">++</span><span class="p">;</span>
				<span class="cm">/* Preserve the RSS info in csum &amp; priority */</span>
				<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">=</span> <span class="n">rss_hi</span><span class="p">;</span>
				<span class="n">skb</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">rss_lo</span><span class="p">;</span>
				<span class="n">ngathered</span> <span class="o">=</span> <span class="n">rx_offload</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">tdev</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span>
						       <span class="n">offload_skbs</span><span class="p">,</span>
						       <span class="n">ngathered</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">F_RSPD_EOP</span><span class="p">)</span>
				<span class="n">clear_rspq_bufstate</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="o">--</span><span class="n">budget_left</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">deliver_partial_bundle</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">tdev</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">offload_skbs</span><span class="p">,</span> <span class="n">ngathered</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sleeping</span><span class="p">)</span>
		<span class="n">check_ring_db</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">qs</span><span class="p">,</span> <span class="n">sleeping</span><span class="p">);</span>

	<span class="n">smp_mb</span><span class="p">();</span>		<span class="cm">/* commit Tx queue .processed updates */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq_stopped</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">restart_tx</span><span class="p">(</span><span class="n">qs</span><span class="p">);</span>

	<span class="n">budget</span> <span class="o">-=</span> <span class="n">budget_left</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">budget</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_pure_response</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">rsp_desc</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="n">n</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">htonl</span><span class="p">(</span><span class="n">F_RSPD_ASYNC_NOTIF</span> <span class="o">|</span> <span class="n">F_RSPD_IMM_DATA_VALID</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">|</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">len_cq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	napi_rx_handler - the NAPI handler for Rx processing</span>
<span class="cm"> *	@napi: the napi instance</span>
<span class="cm"> *	@budget: how many packets we can process in this round</span>
<span class="cm"> *</span>
<span class="cm"> *	Handler for new data events when using NAPI.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">napi_rx_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">qs</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_qset</span><span class="p">,</span> <span class="n">napi</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span> <span class="o">=</span> <span class="n">qs</span><span class="o">-&gt;</span><span class="n">adap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">work_done</span> <span class="o">=</span> <span class="n">process_responses</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">qs</span><span class="p">,</span> <span class="n">budget</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">work_done</span> <span class="o">&lt;</span> <span class="n">budget</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Because we don&#39;t atomically flush the following</span>
<span class="cm">		 * write it is possible that in very rare cases it can</span>
<span class="cm">		 * reach the device in a way that races with a new</span>
<span class="cm">		 * response being written plus an error interrupt</span>
<span class="cm">		 * causing the NAPI interrupt handler below to return</span>
<span class="cm">		 * unhandled status to the OS.  To protect against</span>
<span class="cm">		 * this would require flushing the write and doing</span>
<span class="cm">		 * both the write and the flush with interrupts off.</span>
<span class="cm">		 * Way too expensive and unjustifiable given the</span>
<span class="cm">		 * rarity of the race.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The race cannot happen at all with MSI-X.</span>
<span class="cm">		 */</span>
		<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_GTS</span><span class="p">,</span> <span class="n">V_RSPQ</span><span class="p">(</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">cntxt_id</span><span class="p">)</span> <span class="o">|</span>
			     <span class="n">V_NEWTIMER</span><span class="p">(</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">next_holdoff</span><span class="p">)</span> <span class="o">|</span>
			     <span class="n">V_NEWINDEX</span><span class="p">(</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">cidx</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">work_done</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns true if the device is already scheduled for polling.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">napi_is_scheduled</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">NAPI_STATE_SCHED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">napi</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	process_pure_responses - process pure responses from a response queue</span>
<span class="cm"> *	@adap: the adapter</span>
<span class="cm"> *	@qs: the queue set owning the response queue</span>
<span class="cm"> *	@r: the first pure response to process</span>
<span class="cm"> *</span>
<span class="cm"> *	A simpler version of process_responses() that handles only pure (i.e.,</span>
<span class="cm"> *	non data-carrying) responses.  Such respones are too light-weight to</span>
<span class="cm"> *	justify calling a softirq under NAPI, so we handle them specially in</span>
<span class="cm"> *	the interrupt handler.  The function is called with a pointer to a</span>
<span class="cm"> *	response, which the caller must ensure is a valid pure response.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 1 if it encounters a valid data-carrying response, 0 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_pure_responses</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">qs</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">rsp_desc</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sleeping</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

		<span class="n">r</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">++</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cidx</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">cidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">prefetch</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RSPD_CTRL_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sleeping</span> <span class="o">|=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RSPD_GTS_MASK</span><span class="p">;</span>
			<span class="n">handle_rsp_cntrl_info</span><span class="p">(</span><span class="n">qs</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">q</span><span class="o">-&gt;</span><span class="n">pure_rsps</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">credits</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">/</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">refill_rspq</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">credits</span><span class="p">);</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">credits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_new_response</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">rmb</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">is_pure_response</span><span class="p">(</span><span class="n">r</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sleeping</span><span class="p">)</span>
		<span class="n">check_ring_db</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">qs</span><span class="p">,</span> <span class="n">sleeping</span><span class="p">);</span>

	<span class="n">smp_mb</span><span class="p">();</span>		<span class="cm">/* commit Tx queue .processed updates */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq_stopped</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">restart_tx</span><span class="p">(</span><span class="n">qs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">is_new_response</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	handle_responses - decide what to do with new responses in NAPI mode</span>
<span class="cm"> *	@adap: the adapter</span>
<span class="cm"> *	@q: the response queue</span>
<span class="cm"> *</span>
<span class="cm"> *	This is used by the NAPI interrupt handlers to decide what to do with</span>
<span class="cm"> *	new SGE responses.  If there are no new responses it returns -1.  If</span>
<span class="cm"> *	there are new responses and they are pure (i.e., non-data carrying)</span>
<span class="cm"> *	it handles them straight in hard interrupt context as they are very</span>
<span class="cm"> *	cheap and don&#39;t deliver any packets.  Finally, if there are any data</span>
<span class="cm"> *	signaling responses it schedules the NAPI handler.  Returns 1 if it</span>
<span class="cm"> *	schedules NAPI, 0 if all new responses were pure.</span>
<span class="cm"> *</span>
<span class="cm"> *	The caller must ascertain NAPI is not already running.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">handle_responses</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">qs</span> <span class="o">=</span> <span class="n">rspq_to_qset</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rsp_desc</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_new_response</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">rmb</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_pure_response</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">process_pure_responses</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">qs</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_GTS</span><span class="p">,</span> <span class="n">V_RSPQ</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cntxt_id</span><span class="p">)</span> <span class="o">|</span>
			     <span class="n">V_NEWTIMER</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">holdoff_tmr</span><span class="p">)</span> <span class="o">|</span> <span class="n">V_NEWINDEX</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The MSI-X interrupt handler for an SGE response queue for the non-NAPI case</span>
<span class="cm"> * (i.e., response queue serviced in hard interrupt).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">t3_sge_intr_msix</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">qs</span> <span class="o">=</span> <span class="n">cookie</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span> <span class="o">=</span> <span class="n">qs</span><span class="o">-&gt;</span><span class="n">adap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">process_responses</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">qs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">unhandled_irqs</span><span class="o">++</span><span class="p">;</span>
	<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_GTS</span><span class="p">,</span> <span class="n">V_RSPQ</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cntxt_id</span><span class="p">)</span> <span class="o">|</span>
		     <span class="n">V_NEWTIMER</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">next_holdoff</span><span class="p">)</span> <span class="o">|</span> <span class="n">V_NEWINDEX</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">));</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The MSI-X interrupt handler for an SGE response queue for the NAPI case</span>
<span class="cm"> * (i.e., response queue serviced by NAPI polling).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">t3_sge_intr_msix_napi</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">qs</span> <span class="o">=</span> <span class="n">cookie</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">handle_responses</span><span class="p">(</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">adap</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">unhandled_irqs</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The non-NAPI MSI interrupt handler.  This needs to handle data events from</span>
<span class="cm"> * SGE response queues as well as error and other async events as they all use</span>
<span class="cm"> * the same MSI vector.  We use one SGE response queue per port in this mode</span>
<span class="cm"> * and protect all response queues with queue 0&#39;s lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">t3_intr_msi</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">new_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span> <span class="o">=</span> <span class="n">cookie</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rspq</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">process_responses</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_GTS</span><span class="p">,</span> <span class="n">V_RSPQ</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cntxt_id</span><span class="p">)</span> <span class="o">|</span>
			     <span class="n">V_NEWTIMER</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">next_holdoff</span><span class="p">)</span> <span class="o">|</span> <span class="n">V_NEWINDEX</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">));</span>
		<span class="n">new_packets</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">nports</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span>
	    <span class="n">process_responses</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">q1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">rspq</span><span class="p">;</span>

		<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_GTS</span><span class="p">,</span> <span class="n">V_RSPQ</span><span class="p">(</span><span class="n">q1</span><span class="o">-&gt;</span><span class="n">cntxt_id</span><span class="p">)</span> <span class="o">|</span>
			     <span class="n">V_NEWTIMER</span><span class="p">(</span><span class="n">q1</span><span class="o">-&gt;</span><span class="n">next_holdoff</span><span class="p">)</span> <span class="o">|</span>
			     <span class="n">V_NEWINDEX</span><span class="p">(</span><span class="n">q1</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">));</span>
		<span class="n">new_packets</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_packets</span> <span class="o">&amp;&amp;</span> <span class="n">t3_slow_intr_handler</span><span class="p">(</span><span class="n">adap</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">unhandled_irqs</span><span class="o">++</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rspq_check_napi</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">qs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">napi_is_scheduled</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">is_new_response</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">],</span> <span class="n">q</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The MSI interrupt handler for the NAPI case (i.e., response queues serviced</span>
<span class="cm"> * by NAPI polling).  Handles data events from SGE response queues as well as</span>
<span class="cm"> * error and other async events as they all use the same MSI vector.  We use</span>
<span class="cm"> * one SGE response queue per port in this mode and protect all response</span>
<span class="cm"> * queues with queue 0&#39;s lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">t3_intr_msi_napi</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">new_packets</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span> <span class="o">=</span> <span class="n">cookie</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rspq</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">new_packets</span> <span class="o">=</span> <span class="n">rspq_check_napi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">nports</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">new_packets</span> <span class="o">+=</span> <span class="n">rspq_check_napi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_packets</span> <span class="o">&amp;&amp;</span> <span class="n">t3_slow_intr_handler</span><span class="p">(</span><span class="n">adap</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">unhandled_irqs</span><span class="o">++</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A helper function that processes responses and issues GTS.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">process_responses_gts</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">work</span><span class="p">;</span>

	<span class="n">work</span> <span class="o">=</span> <span class="n">process_responses</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">rspq_to_qset</span><span class="p">(</span><span class="n">rq</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_GTS</span><span class="p">,</span> <span class="n">V_RSPQ</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cntxt_id</span><span class="p">)</span> <span class="o">|</span>
		     <span class="n">V_NEWTIMER</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">next_holdoff</span><span class="p">)</span> <span class="o">|</span> <span class="n">V_NEWINDEX</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">work</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The legacy INTx interrupt handler.  This needs to handle data events from</span>
<span class="cm"> * SGE response queues as well as error and other async events as they all use</span>
<span class="cm"> * the same interrupt pin.  We use one SGE response queue per port in this mode</span>
<span class="cm"> * and protect all response queues with queue 0&#39;s lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">t3_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">work_done</span><span class="p">,</span> <span class="n">w0</span><span class="p">,</span> <span class="n">w1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span> <span class="o">=</span> <span class="n">cookie</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">q0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rspq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">q1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">rspq</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q0</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">w0</span> <span class="o">=</span> <span class="n">is_new_response</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q0</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">[</span><span class="n">q0</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">],</span> <span class="n">q0</span><span class="p">);</span>
	<span class="n">w1</span> <span class="o">=</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">nports</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span>
	    <span class="n">is_new_response</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q1</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">[</span><span class="n">q1</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">],</span> <span class="n">q1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">w0</span> <span class="o">|</span> <span class="n">w1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_PL_CLI</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">t3_read_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_PL_CLI</span><span class="p">);</span>	<span class="cm">/* flush */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">w0</span><span class="p">))</span>
			<span class="n">process_responses_gts</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">q0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">w1</span><span class="p">)</span>
			<span class="n">process_responses_gts</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">q1</span><span class="p">);</span>

		<span class="n">work_done</span> <span class="o">=</span> <span class="n">w0</span> <span class="o">|</span> <span class="n">w1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">work_done</span> <span class="o">=</span> <span class="n">t3_slow_intr_handler</span><span class="p">(</span><span class="n">adap</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q0</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_RETVAL</span><span class="p">(</span><span class="n">work_done</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Interrupt handler for legacy INTx interrupts for T3B-based cards.</span>
<span class="cm"> * Handles data events from SGE response queues as well as error and other</span>
<span class="cm"> * async events as they all use the same interrupt pin.  We use one SGE</span>
<span class="cm"> * response queue per port in this mode and protect all response queues with</span>
<span class="cm"> * queue 0&#39;s lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">t3b_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span> <span class="o">=</span> <span class="n">cookie</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">q0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rspq</span><span class="p">;</span>

	<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_PL_CLI</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">map</span> <span class="o">=</span> <span class="n">t3_read_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_DATA_INTR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">map</span><span class="p">))</span>	<span class="cm">/* shared interrupt, most likely */</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q0</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">map</span> <span class="o">&amp;</span> <span class="n">F_ERRINTR</span><span class="p">))</span>
		<span class="n">t3_slow_intr_handler</span><span class="p">(</span><span class="n">adap</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">map</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">process_responses_gts</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">q0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">map</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">process_responses_gts</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">rspq</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q0</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NAPI interrupt handler for legacy INTx interrupts for T3B-based cards.</span>
<span class="cm"> * Handles data events from SGE response queues as well as error and other</span>
<span class="cm"> * async events as they all use the same interrupt pin.  We use one SGE</span>
<span class="cm"> * response queue per port in this mode and protect all response queues with</span>
<span class="cm"> * queue 0&#39;s lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">t3b_intr_napi</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span> <span class="o">=</span> <span class="n">cookie</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">qs0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sge_rspq</span> <span class="o">*</span><span class="n">q0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qs0</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">;</span>

	<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_PL_CLI</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">map</span> <span class="o">=</span> <span class="n">t3_read_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_DATA_INTR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">map</span><span class="p">))</span>	<span class="cm">/* shared interrupt, most likely */</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q0</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">map</span> <span class="o">&amp;</span> <span class="n">F_ERRINTR</span><span class="p">))</span>
		<span class="n">t3_slow_intr_handler</span><span class="p">(</span><span class="n">adap</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">map</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qs0</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">map</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">napi</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q0</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	t3_intr_handler - select the top-level interrupt handler</span>
<span class="cm"> *	@adap: the adapter</span>
<span class="cm"> *	@polling: whether using NAPI to service response queues</span>
<span class="cm"> *</span>
<span class="cm"> *	Selects the top-level interrupt handler based on the type of interrupts</span>
<span class="cm"> *	(MSI-X, MSI, or legacy) and whether NAPI will be used to service the</span>
<span class="cm"> *	response queues.</span>
<span class="cm"> */</span>
<span class="n">irq_handler_t</span> <span class="nf">t3_intr_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">polling</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">USING_MSIX</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">polling</span> <span class="o">?</span> <span class="n">t3_sge_intr_msix_napi</span> <span class="o">:</span> <span class="n">t3_sge_intr_msix</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">USING_MSI</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">polling</span> <span class="o">?</span> <span class="n">t3_intr_msi_napi</span> <span class="o">:</span> <span class="n">t3_intr_msi</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">rev</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">polling</span> <span class="o">?</span> <span class="n">t3b_intr_napi</span> <span class="o">:</span> <span class="n">t3b_intr</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">t3_intr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define SGE_PARERR (F_CPPARITYERROR | F_OCPARITYERROR | F_RCPARITYERROR | \</span>
<span class="cp">		    F_IRPARITYERROR | V_ITPARITYERROR(M_ITPARITYERROR) | \</span>
<span class="cp">		    V_FLPARITYERROR(M_FLPARITYERROR) | F_LODRBPARITYERROR | \</span>
<span class="cp">		    F_HIDRBPARITYERROR | F_LORCQPARITYERROR | \</span>
<span class="cp">		    F_HIRCQPARITYERROR)</span>
<span class="cp">#define SGE_FRAMINGERR (F_UC_REQ_FRAMINGERROR | F_R_REQ_FRAMINGERROR)</span>
<span class="cp">#define SGE_FATALERR (SGE_PARERR | SGE_FRAMINGERR | F_RSPQCREDITOVERFOW | \</span>
<span class="cp">		      F_RSPQDISABLED)</span>

<span class="cm">/**</span>
<span class="cm"> *	t3_sge_err_intr_handler - SGE async event interrupt handler</span>
<span class="cm"> *	@adapter: the adapter</span>
<span class="cm"> *</span>
<span class="cm"> *	Interrupt handler for SGE asynchronous (non-data) events.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">t3_sge_err_intr_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="n">t3_read_reg</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">A_SG_INT_CAUSE</span><span class="p">)</span> <span class="o">&amp;</span>
				 <span class="o">~</span><span class="n">F_FLEMPTY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">SGE_PARERR</span><span class="p">)</span>
		<span class="n">CH_ALERT</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="s">&quot;SGE parity error (0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">status</span> <span class="o">&amp;</span> <span class="n">SGE_PARERR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">SGE_FRAMINGERR</span><span class="p">)</span>
		<span class="n">CH_ALERT</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="s">&quot;SGE framing error (0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">status</span> <span class="o">&amp;</span> <span class="n">SGE_FRAMINGERR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">F_RSPQCREDITOVERFOW</span><span class="p">)</span>
		<span class="n">CH_ALERT</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="s">&quot;SGE response queue credit overflow</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">F_RSPQDISABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">t3_read_reg</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">A_SG_RSPQ_FL_STATUS</span><span class="p">);</span>

		<span class="n">CH_ALERT</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
			 <span class="s">&quot;packet delivered to disabled response queue &quot;</span>
			 <span class="s">&quot;(0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="n">S_RSPQ0DISABLED</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">F_HIPIODRBDROPERR</span> <span class="o">|</span> <span class="n">F_LOPIODRBDROPERR</span><span class="p">))</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">cxgb3_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">db_drop_task</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">F_HIPRIORITYDBFULL</span> <span class="o">|</span> <span class="n">F_LOPRIORITYDBFULL</span><span class="p">))</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">cxgb3_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">db_full_task</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">F_HIPRIORITYDBEMPTY</span> <span class="o">|</span> <span class="n">F_LOPRIORITYDBEMPTY</span><span class="p">))</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">cxgb3_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">db_empty_task</span><span class="p">);</span>

	<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">A_SG_INT_CAUSE</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span>  <span class="n">SGE_FATALERR</span><span class="p">)</span>
		<span class="n">t3_fatal_err</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sge_timer_tx - perform periodic maintenance of an SGE qset</span>
<span class="cm"> *	@data: the SGE queue set to maintain</span>
<span class="cm"> *</span>
<span class="cm"> *	Runs periodically from a timer to perform maintenance of an SGE queue</span>
<span class="cm"> *	set.  It performs two tasks:</span>
<span class="cm"> *</span>
<span class="cm"> *	Cleans up any completed Tx descriptors that may still be pending.</span>
<span class="cm"> *	Normal descriptor cleanup happens when new packets are added to a Tx</span>
<span class="cm"> *	queue so this timer is relatively infrequent and does any cleanup only</span>
<span class="cm"> *	if the Tx queue has not seen any new packets in a while.  We make a</span>
<span class="cm"> *	best effort attempt to reclaim descriptors, in that we don&#39;t wait</span>
<span class="cm"> *	around if we cannot get a queue&#39;s lock (which most likely is because</span>
<span class="cm"> *	someone else is queueing new packets and so will also handle the clean</span>
<span class="cm"> *	up).  Since control queues use immediate data exclusively we don&#39;t</span>
<span class="cm"> *	bother cleaning them up here.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sge_timer_tx</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">qs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tbd</span><span class="p">[</span><span class="n">SGE_TXQ_PER_SET</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next_period</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__netif_tx_trylock</span><span class="p">(</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">tx_q</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">tbd</span><span class="p">[</span><span class="n">TXQ_ETH</span><span class="p">]</span> <span class="o">=</span> <span class="n">reclaim_completed_tx</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_ETH</span><span class="p">],</span>
                                                     <span class="n">TX_RECLAIM_TIMER_CHUNK</span><span class="p">);</span>
		<span class="n">__netif_tx_unlock</span><span class="p">(</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">tx_q</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_OFLD</span><span class="p">].</span><span class="n">lock</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tbd</span><span class="p">[</span><span class="n">TXQ_OFLD</span><span class="p">]</span> <span class="o">=</span> <span class="n">reclaim_completed_tx</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_OFLD</span><span class="p">],</span>
						     <span class="n">TX_RECLAIM_TIMER_CHUNK</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_OFLD</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">next_period</span> <span class="o">=</span> <span class="n">TX_RECLAIM_PERIOD</span> <span class="o">&gt;&gt;</span>
                      <span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">tbd</span><span class="p">[</span><span class="n">TXQ_ETH</span><span class="p">],</span> <span class="n">tbd</span><span class="p">[</span><span class="n">TXQ_OFLD</span><span class="p">])</span> <span class="o">/</span>
                      <span class="n">TX_RECLAIM_TIMER_CHUNK</span><span class="p">);</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">tx_reclaim_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">next_period</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	sge_timer_rx - perform periodic maintenance of an SGE qset</span>
<span class="cm"> *	@data: the SGE queue set to maintain</span>
<span class="cm"> *</span>
<span class="cm"> *	a) Replenishes Rx queues that have run out due to memory shortage.</span>
<span class="cm"> *	Normally new Rx buffers are added when existing ones are consumed but</span>
<span class="cm"> *	when out of memory a queue can become empty.  We try to add only a few</span>
<span class="cm"> *	buffers here, the queue will be replenished fully as these new buffers</span>
<span class="cm"> *	are used up if memory shortage has subsided.</span>
<span class="cm"> *</span>
<span class="cm"> *	b) Return coalesced response queue credits in case a response queue is</span>
<span class="cm"> *	starved.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sge_timer_rx</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">qs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">port_info</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">lock</span> <span class="o">=</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">rev</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span>
	       <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">lock</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rspq</span><span class="p">.</span><span class="n">lock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spin_trylock_irq</span><span class="p">(</span><span class="n">lock</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">napi_is_scheduled</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">rev</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">t3_read_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_RSPQ_FL_STATUS</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">qs</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">cntxt_id</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">qs</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">starved</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">credits</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">qs</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">credits</span><span class="o">--</span><span class="p">;</span>
				<span class="n">refill_rspq</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">qs</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">restarted</span><span class="o">++</span><span class="p">;</span>
				<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_RSPQ_FL_STATUS</span><span class="p">,</span>
					     <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">qs</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">cntxt_id</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">credits</span> <span class="o">&lt;</span> <span class="n">qs</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">)</span>
		<span class="n">__refill_fl</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">credits</span> <span class="o">&lt;</span> <span class="n">qs</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">)</span>
		<span class="n">__refill_fl</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

<span class="nl">unlock:</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">rx_reclaim_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">RX_RECLAIM_PERIOD</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	t3_update_qset_coalesce - update coalescing settings for a queue set</span>
<span class="cm"> *	@qs: the SGE queue set</span>
<span class="cm"> *	@p: new queue set parameters</span>
<span class="cm"> *</span>
<span class="cm"> *	Update the coalescing settings for an SGE queue set.  Nothing is done</span>
<span class="cm"> *	if the queue set is not initialized yet.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">t3_update_qset_coalesce</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">qs</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">qset_params</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">qs</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">holdoff_tmr</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">coalesce_usecs</span> <span class="o">*</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1U</span><span class="p">);</span><span class="cm">/* can&#39;t be 0 */</span>
	<span class="n">qs</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">polling</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">polling</span><span class="p">;</span>
	<span class="n">qs</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">.</span><span class="n">poll</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">polling</span> <span class="o">?</span> <span class="n">napi_rx_handler</span> <span class="o">:</span> <span class="n">ofld_poll</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	t3_sge_alloc_qset - initialize an SGE queue set</span>
<span class="cm"> *	@adapter: the adapter</span>
<span class="cm"> *	@id: the queue set id</span>
<span class="cm"> *	@nports: how many Ethernet ports will be using this queue set</span>
<span class="cm"> *	@irq_vec_idx: the IRQ vector index for response queue interrupts</span>
<span class="cm"> *	@p: configuration parameters for this queue set</span>
<span class="cm"> *	@ntxq: number of Tx queues for the queue set</span>
<span class="cm"> *	@netdev: net device associated with this queue set</span>
<span class="cm"> *	@netdevq: net device TX queue associated with this queue set</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocate resources and initialize an SGE queue set.  A queue set</span>
<span class="cm"> *	comprises a response queue, two Rx free-buffer queues, and up to 3</span>
<span class="cm"> *	Tx queues.  The Tx queues are assigned roles in the order Ethernet</span>
<span class="cm"> *	queue, offload queue, and control queue.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">t3_sge_alloc_qset</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nports</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">irq_vec_idx</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">qset_params</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">ntxq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">netdevq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">avail</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">qs</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>

	<span class="n">init_qset_cntxt</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">tx_reclaim_timer</span><span class="p">,</span> <span class="n">sge_timer_tx</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">q</span><span class="p">);</span>
	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rx_reclaim_timer</span><span class="p">,</span> <span class="n">sge_timer_rx</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">q</span><span class="p">);</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">desc</span> <span class="o">=</span> <span class="n">alloc_ring</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">fl_size</span><span class="p">,</span>
				   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rx_desc</span><span class="p">),</span>
				   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rx_sw_desc</span><span class="p">),</span>
				   <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sdesc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">desc</span> <span class="o">=</span> <span class="n">alloc_ring</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">jumbo_size</span><span class="p">,</span>
				   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rx_desc</span><span class="p">),</span>
				   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rx_sw_desc</span><span class="p">),</span>
				   <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">sdesc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">desc</span> <span class="o">=</span> <span class="n">alloc_ring</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rspq_size</span><span class="p">,</span>
				  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rsp_desc</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">phys_addr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ntxq</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The control queue always uses immediate data so does not</span>
<span class="cm">		 * need to keep track of any sk_buffs.</span>
<span class="cm">		 */</span>
		<span class="kt">size_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">i</span> <span class="o">==</span> <span class="n">TXQ_CTRL</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tx_sw_desc</span><span class="p">);</span>

		<span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span> <span class="o">=</span> <span class="n">alloc_ring</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">txq_size</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tx_desc</span><span class="p">),</span> <span class="n">sz</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sdesc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">gen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">txq_size</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sendq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_OFLD</span><span class="p">].</span><span class="n">qresume_tsk</span><span class="p">,</span> <span class="n">restart_offloadq</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">q</span><span class="p">);</span>
	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_CTRL</span><span class="p">].</span><span class="n">qresume_tsk</span><span class="p">,</span> <span class="n">restart_ctrlq</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">q</span><span class="p">);</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">gen</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">gen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">fl_size</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">jumbo_size</span><span class="p">;</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">gen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rspq_size</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">rx_queue</span><span class="p">);</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_ETH</span><span class="p">].</span><span class="n">stop_thres</span> <span class="o">=</span> <span class="n">nports</span> <span class="o">*</span>
	    <span class="n">flits_to_desc</span><span class="p">(</span><span class="n">sgl_len</span><span class="p">(</span><span class="n">MAX_SKB_FRAGS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span>

<span class="cp">#if FL0_PG_CHUNK_SIZE &gt; 0</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">buf_size</span> <span class="o">=</span> <span class="n">FL0_PG_CHUNK_SIZE</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">buf_size</span> <span class="o">=</span> <span class="n">SGE_RX_SM_BUF_SIZE</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpl_rx_data</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#if FL1_PG_CHUNK_SIZE &gt; 0</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">buf_size</span> <span class="o">=</span> <span class="n">FL1_PG_CHUNK_SIZE</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">buf_size</span> <span class="o">=</span> <span class="n">is_offload</span><span class="p">(</span><span class="n">adapter</span><span class="p">)</span> <span class="o">?</span>
		<span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="o">-</span> <span class="n">SKB_DATA_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">skb_shared_info</span><span class="p">))</span> <span class="o">:</span>
		<span class="n">MAX_FRAME_SIZE</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpl_rx_pkt</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">use_pages</span> <span class="o">=</span> <span class="n">FL0_PG_CHUNK_SIZE</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">use_pages</span> <span class="o">=</span> <span class="n">FL1_PG_CHUNK_SIZE</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">order</span> <span class="o">=</span> <span class="n">FL0_PG_ORDER</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">order</span> <span class="o">=</span> <span class="n">FL1_PG_ORDER</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">alloc_size</span> <span class="o">=</span> <span class="n">FL0_PG_ALLOC_SIZE</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">alloc_size</span> <span class="o">=</span> <span class="n">FL1_PG_ALLOC_SIZE</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">reg_lock</span><span class="p">);</span>

	<span class="cm">/* FL threshold comparison uses &lt; */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">t3_sge_init_rspcntxt</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">cntxt_id</span><span class="p">,</span> <span class="n">irq_vec_idx</span><span class="p">,</span>
				   <span class="n">q</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">phys_addr</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">size</span><span class="p">,</span>
				   <span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">buf_size</span> <span class="o">-</span> <span class="n">SGE_PG_RSVD</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_unlock</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SGE_RXQ_PER_SET</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">t3_sge_init_flcntxt</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cntxt_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					  <span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">,</span>
					  <span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buf_size</span> <span class="o">-</span> <span class="n">SGE_PG_RSVD</span><span class="p">,</span>
					  <span class="n">p</span><span class="o">-&gt;</span><span class="n">cong_thres</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">t3_sge_init_ecntxt</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_ETH</span><span class="p">].</span><span class="n">cntxt_id</span><span class="p">,</span> <span class="n">USE_GTS</span><span class="p">,</span>
				 <span class="n">SGE_CNTXT_ETH</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_ETH</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">,</span>
				 <span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_ETH</span><span class="p">].</span><span class="n">size</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_ETH</span><span class="p">].</span><span class="n">token</span><span class="p">,</span>
				 <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ntxq</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">t3_sge_init_ecntxt</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_OFLD</span><span class="p">].</span><span class="n">cntxt_id</span><span class="p">,</span>
					 <span class="n">USE_GTS</span><span class="p">,</span> <span class="n">SGE_CNTXT_OFLD</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span>
					 <span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_OFLD</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">,</span>
					 <span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_OFLD</span><span class="p">].</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ntxq</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">t3_sge_init_ecntxt</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_CTRL</span><span class="p">].</span><span class="n">cntxt_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					 <span class="n">SGE_CNTXT_CTRL</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span>
					 <span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_CTRL</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">,</span>
					 <span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_CTRL</span><span class="p">].</span><span class="n">size</span><span class="p">,</span>
					 <span class="n">q</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_CTRL</span><span class="p">].</span><span class="n">token</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">reg_lock</span><span class="p">);</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">adap</span> <span class="o">=</span> <span class="n">adapter</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">tx_q</span> <span class="o">=</span> <span class="n">netdevq</span><span class="p">;</span>
	<span class="n">t3_update_qset_coalesce</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

	<span class="n">avail</span> <span class="o">=</span> <span class="n">refill_fl</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">,</span>
			  <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_COMP</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">avail</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">CH_ALERT</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="s">&quot;free list queue 0 initialization failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">avail</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">)</span>
		<span class="n">CH_WARN</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="s">&quot;free list queue 0 enabled with %d credits</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">avail</span><span class="p">);</span>

	<span class="n">avail</span> <span class="o">=</span> <span class="n">refill_fl</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">,</span>
			  <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_COMP</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">avail</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">)</span>
		<span class="n">CH_WARN</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="s">&quot;free list queue 1 enabled with %d credits</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">avail</span><span class="p">);</span>
	<span class="n">refill_rspq</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">A_SG_GTS</span><span class="p">,</span> <span class="n">V_RSPQ</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">cntxt_id</span><span class="p">)</span> <span class="o">|</span>
		     <span class="n">V_NEWTIMER</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rspq</span><span class="p">.</span><span class="n">holdoff_tmr</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_unlock:</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">reg_lock</span><span class="p">);</span>
<span class="nl">err:</span>
	<span class="n">t3_free_qset</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *      t3_start_sge_timers - start SGE timer call backs</span>
<span class="cm"> *      @adap: the adapter</span>
<span class="cm"> *</span>
<span class="cm"> *      Starts each SGE queue set&#39;s timer call back</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">t3_start_sge_timers</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SGE_QSETS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">qs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">tx_reclaim_timer</span><span class="p">.</span><span class="n">function</span><span class="p">)</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">tx_reclaim_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">TX_RECLAIM_PERIOD</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rx_reclaim_timer</span><span class="p">.</span><span class="n">function</span><span class="p">)</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rx_reclaim_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">RX_RECLAIM_PERIOD</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	t3_stop_sge_timers - stop SGE timer call backs</span>
<span class="cm"> *	@adap: the adapter</span>
<span class="cm"> *</span>
<span class="cm"> *	Stops each SGE queue set&#39;s timer call back</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">t3_stop_sge_timers</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SGE_QSETS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">qs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">tx_reclaim_timer</span><span class="p">.</span><span class="n">function</span><span class="p">)</span>
			<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">tx_reclaim_timer</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rx_reclaim_timer</span><span class="p">.</span><span class="n">function</span><span class="p">)</span>
			<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rx_reclaim_timer</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	t3_free_sge_resources - free SGE resources</span>
<span class="cm"> *	@adap: the adapter</span>
<span class="cm"> *</span>
<span class="cm"> *	Frees resources used by the SGE queue sets.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">t3_free_sge_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SGE_QSETS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">t3_free_qset</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">qs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	t3_sge_start - enable SGE</span>
<span class="cm"> *	@adap: the adapter</span>
<span class="cm"> *</span>
<span class="cm"> *	Enables the SGE for DMAs.  This is the last step in starting packet</span>
<span class="cm"> *	transfers.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">t3_sge_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">t3_set_reg_field</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_CONTROL</span><span class="p">,</span> <span class="n">F_GLOBALENABLE</span><span class="p">,</span> <span class="n">F_GLOBALENABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	t3_sge_stop - disable SGE operation</span>
<span class="cm"> *	@adap: the adapter</span>
<span class="cm"> *</span>
<span class="cm"> *	Disables the DMA engine.  This can be called in emeregencies (e.g.,</span>
<span class="cm"> *	from error interrupts) or from normal process context.  In the latter</span>
<span class="cm"> *	case it also disables any pending queue restart tasklets.  Note that</span>
<span class="cm"> *	if it is called in interrupt context it cannot disable the restart</span>
<span class="cm"> *	tasklets as it cannot wait, however the tasklets will have no effect</span>
<span class="cm"> *	since the doorbells are disabled and the driver will call this again</span>
<span class="cm"> *	later from process context, at which time the tasklets will be stopped</span>
<span class="cm"> *	if they are still running.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">t3_sge_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">t3_set_reg_field</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_CONTROL</span><span class="p">,</span> <span class="n">F_GLOBALENABLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_interrupt</span><span class="p">())</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SGE_QSETS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sge_qset</span> <span class="o">*</span><span class="n">qs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">qs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="n">tasklet_kill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_OFLD</span><span class="p">].</span><span class="n">qresume_tsk</span><span class="p">);</span>
			<span class="n">tasklet_kill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">TXQ_CTRL</span><span class="p">].</span><span class="n">qresume_tsk</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	t3_sge_init - initialize SGE</span>
<span class="cm"> *	@adap: the adapter</span>
<span class="cm"> *	@p: the SGE parameters</span>
<span class="cm"> *</span>
<span class="cm"> *	Performs SGE initialization needed every time after a chip reset.</span>
<span class="cm"> *	We do not initialize any of the queue sets here, instead the driver</span>
<span class="cm"> *	top-level must request those individually.  We also do not enable DMA</span>
<span class="cm"> *	here, that should be done after the queues have been set up.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">t3_sge_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_params</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ctrl</span><span class="p">,</span> <span class="n">ups</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">(</span><span class="n">pci_resource_len</span><span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">);</span>

	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">F_DROPPKT</span> <span class="o">|</span> <span class="n">V_PKTSHIFT</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="n">F_FLMODE</span> <span class="o">|</span> <span class="n">F_AVOIDCQOVFL</span> <span class="o">|</span>
	    <span class="n">F_CQCRDTCTRL</span> <span class="o">|</span> <span class="n">F_CONGMODE</span> <span class="o">|</span> <span class="n">F_TNLFLMODE</span> <span class="o">|</span> <span class="n">F_FATLPERREN</span> <span class="o">|</span>
	    <span class="n">V_HOSTPAGESIZE</span><span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mi">11</span><span class="p">)</span> <span class="o">|</span> <span class="n">F_BIGENDIANINGRESS</span> <span class="o">|</span>
	    <span class="n">V_USERSPACESIZE</span><span class="p">(</span><span class="n">ups</span> <span class="o">?</span> <span class="n">ups</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">F_ISCSICOALESCING</span><span class="p">;</span>
<span class="cp">#if SGE_NUM_GENBITS == 1</span>
	<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">F_EGRGENCTRL</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">rev</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">USING_MSIX</span> <span class="o">|</span> <span class="n">USING_MSI</span><span class="p">)))</span>
			<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">F_ONEINTMULTQ</span> <span class="o">|</span> <span class="n">F_OPTONEINTMULTQ</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_CONTROL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
	<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_EGR_RCQ_DRB_THRSH</span><span class="p">,</span> <span class="n">V_HIRCQDRBTHRSH</span><span class="p">(</span><span class="mi">512</span><span class="p">)</span> <span class="o">|</span>
		     <span class="n">V_LORCQDRBTHRSH</span><span class="p">(</span><span class="mi">512</span><span class="p">));</span>
	<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_TIMER_TICK</span><span class="p">,</span> <span class="n">core_ticks_per_usec</span><span class="p">(</span><span class="n">adap</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span><span class="p">);</span>
	<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_CMDQ_CREDIT_TH</span><span class="p">,</span> <span class="n">V_THRESHOLD</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="o">|</span>
		     <span class="n">V_TIMEOUT</span><span class="p">(</span><span class="mi">200</span> <span class="o">*</span> <span class="n">core_ticks_per_usec</span><span class="p">(</span><span class="n">adap</span><span class="p">)));</span>
	<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_HI_DRB_HI_THRSH</span><span class="p">,</span>
		     <span class="n">adap</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">rev</span> <span class="o">&lt;</span> <span class="n">T3_REV_C</span> <span class="o">?</span> <span class="mi">1000</span> <span class="o">:</span> <span class="mi">500</span><span class="p">);</span>
	<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_HI_DRB_LO_THRSH</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>
	<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_LO_DRB_HI_THRSH</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_LO_DRB_LO_THRSH</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>
	<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_OCO_BASE</span><span class="p">,</span> <span class="n">V_BASE1</span><span class="p">(</span><span class="mh">0xfff</span><span class="p">));</span>
	<span class="n">t3_write_reg</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">A_SG_DRB_PRI_THRESH</span><span class="p">,</span> <span class="mi">63</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	t3_sge_prep - one-time SGE initialization</span>
<span class="cm"> *	@adap: the associated adapter</span>
<span class="cm"> *	@p: SGE parameters</span>
<span class="cm"> *</span>
<span class="cm"> *	Performs one-time initialization of SGE SW state.  Includes determining</span>
<span class="cm"> *	defaults for the assorted SGE parameters, which admins can change until</span>
<span class="cm"> *	they are used to initialize the SGE.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">t3_sge_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_params</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">max_pkt_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpl_rx_data</span><span class="p">)</span> <span class="o">-</span>
	    <span class="n">SKB_DATA_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">skb_shared_info</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SGE_QSETS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">qset_params</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">qset</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">q</span><span class="o">-&gt;</span><span class="n">polling</span> <span class="o">=</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">rev</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">coalesce_usecs</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">rspq_size</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">fl_size</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
 		<span class="n">q</span><span class="o">-&gt;</span><span class="n">jumbo_size</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">txq_size</span><span class="p">[</span><span class="n">TXQ_ETH</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">txq_size</span><span class="p">[</span><span class="n">TXQ_OFLD</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">txq_size</span><span class="p">[</span><span class="n">TXQ_CTRL</span><span class="p">]</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">cong_thres</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">.</span><span class="n">reg_lock</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
