<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › broadcom › bnx2x › bnx2x.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>bnx2x.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* bnx2x.h: Broadcom Everest network driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2007-2012 Broadcom Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * Maintained by: Eilon Greenstein &lt;eilong@broadcom.com&gt;</span>
<span class="cm"> * Written by: Eliezer Tamir</span>
<span class="cm"> * Based on code from Michael Chan&#39;s bnx2 driver</span>
<span class="cm"> */</span>

<span class="cp">#ifndef BNX2X_H</span>
<span class="cp">#define BNX2X_H</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cm">/* compilation time flags */</span>

<span class="cm">/* define this to make the driver freeze on error to allow getting debug info</span>
<span class="cm"> * (you will need to reboot afterwards) */</span>
<span class="cm">/* #define BNX2X_STOP_ON_ERROR */</span>

<span class="cp">#define DRV_MODULE_VERSION      &quot;1.72.50-0&quot;</span>
<span class="cp">#define DRV_MODULE_RELDATE      &quot;2012/04/23&quot;</span>
<span class="cp">#define BNX2X_BC_VER            0x040200</span>

<span class="cp">#if defined(CONFIG_DCB)</span>
<span class="cp">#define BCM_DCBNL</span>
<span class="cp">#endif</span>


<span class="cp">#include &quot;bnx2x_hsi.h&quot;</span>

<span class="cp">#if defined(CONFIG_CNIC) || defined(CONFIG_CNIC_MODULE)</span>
<span class="cp">#define BCM_CNIC 1</span>
<span class="cp">#include &quot;../cnic_if.h&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef BCM_CNIC</span>
<span class="cp">#define BNX2X_MIN_MSIX_VEC_CNT 3</span>
<span class="cp">#define BNX2X_MSIX_VEC_FP_START 2</span>
<span class="cp">#else</span>
<span class="cp">#define BNX2X_MIN_MSIX_VEC_CNT 2</span>
<span class="cp">#define BNX2X_MSIX_VEC_FP_START 1</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;linux/mdio.h&gt;</span>

<span class="cp">#include &quot;bnx2x_reg.h&quot;</span>
<span class="cp">#include &quot;bnx2x_fw_defs.h&quot;</span>
<span class="cp">#include &quot;bnx2x_hsi.h&quot;</span>
<span class="cp">#include &quot;bnx2x_link.h&quot;</span>
<span class="cp">#include &quot;bnx2x_sp.h&quot;</span>
<span class="cp">#include &quot;bnx2x_dcb.h&quot;</span>
<span class="cp">#include &quot;bnx2x_stats.h&quot;</span>

<span class="cm">/* error/debug prints */</span>

<span class="cp">#define DRV_MODULE_NAME		&quot;bnx2x&quot;</span>

<span class="cm">/* for messages that are currently off */</span>
<span class="cp">#define BNX2X_MSG_OFF			0x0</span>
<span class="cp">#define BNX2X_MSG_MCP			0x0010000 </span><span class="cm">/* was: NETIF_MSG_HW */</span><span class="cp"></span>
<span class="cp">#define BNX2X_MSG_STATS			0x0020000 </span><span class="cm">/* was: NETIF_MSG_TIMER */</span><span class="cp"></span>
<span class="cp">#define BNX2X_MSG_NVM			0x0040000 </span><span class="cm">/* was: NETIF_MSG_HW */</span><span class="cp"></span>
<span class="cp">#define BNX2X_MSG_DMAE			0x0080000 </span><span class="cm">/* was: NETIF_MSG_HW */</span><span class="cp"></span>
<span class="cp">#define BNX2X_MSG_SP			0x0100000 </span><span class="cm">/* was: NETIF_MSG_INTR */</span><span class="cp"></span>
<span class="cp">#define BNX2X_MSG_FP			0x0200000 </span><span class="cm">/* was: NETIF_MSG_INTR */</span><span class="cp"></span>
<span class="cp">#define BNX2X_MSG_IOV			0x0800000</span>
<span class="cp">#define BNX2X_MSG_IDLE			0x2000000 </span><span class="cm">/* used for idle check*/</span><span class="cp"></span>
<span class="cp">#define BNX2X_MSG_ETHTOOL		0x4000000</span>
<span class="cp">#define BNX2X_MSG_DCB			0x8000000</span>

<span class="cm">/* regular debug print */</span>
<span class="cp">#define DP(__mask, fmt, ...)					\</span>
<span class="cp">do {								\</span>
<span class="cp">	if (unlikely(bp-&gt;msg_enable &amp; (__mask)))		\</span>
<span class="cp">		pr_notice(&quot;[%s:%d(%s)]&quot; fmt,			\</span>
<span class="cp">			  __func__, __LINE__,			\</span>
<span class="cp">			  bp-&gt;dev ? (bp-&gt;dev-&gt;name) : &quot;?&quot;,	\</span>
<span class="cp">			  ##__VA_ARGS__);			\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define DP_CONT(__mask, fmt, ...)				\</span>
<span class="cp">do {								\</span>
<span class="cp">	if (unlikely(bp-&gt;msg_enable &amp; (__mask)))		\</span>
<span class="cp">		pr_cont(fmt, ##__VA_ARGS__);			\</span>
<span class="cp">} while (0)</span>

<span class="cm">/* errors debug print */</span>
<span class="cp">#define BNX2X_DBG_ERR(fmt, ...)					\</span>
<span class="cp">do {								\</span>
<span class="cp">	if (unlikely(netif_msg_probe(bp)))			\</span>
<span class="cp">		pr_err(&quot;[%s:%d(%s)]&quot; fmt,			\</span>
<span class="cp">		       __func__, __LINE__,			\</span>
<span class="cp">		       bp-&gt;dev ? (bp-&gt;dev-&gt;name) : &quot;?&quot;,		\</span>
<span class="cp">		       ##__VA_ARGS__);				\</span>
<span class="cp">} while (0)</span>

<span class="cm">/* for errors (never masked) */</span>
<span class="cp">#define BNX2X_ERR(fmt, ...)					\</span>
<span class="cp">do {								\</span>
<span class="cp">	pr_err(&quot;[%s:%d(%s)]&quot; fmt,				\</span>
<span class="cp">	       __func__, __LINE__,				\</span>
<span class="cp">	       bp-&gt;dev ? (bp-&gt;dev-&gt;name) : &quot;?&quot;,			\</span>
<span class="cp">	       ##__VA_ARGS__);					\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define BNX2X_ERROR(fmt, ...)					\</span>
<span class="cp">	pr_err(&quot;[%s:%d]&quot; fmt, __func__, __LINE__, ##__VA_ARGS__)</span>


<span class="cm">/* before we have a dev-&gt;name use dev_info() */</span>
<span class="cp">#define BNX2X_DEV_INFO(fmt, ...)				 \</span>
<span class="cp">do {								 \</span>
<span class="cp">	if (unlikely(netif_msg_probe(bp)))			 \</span>
<span class="cp">		dev_info(&amp;bp-&gt;pdev-&gt;dev, fmt, ##__VA_ARGS__);	 \</span>
<span class="cp">} while (0)</span>

<span class="cp">#ifdef BNX2X_STOP_ON_ERROR</span>
<span class="kt">void</span> <span class="n">bnx2x_int_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">);</span>
<span class="cp">#define bnx2x_panic()				\</span>
<span class="cp">do {						\</span>
<span class="cp">	bp-&gt;panic = 1;				\</span>
<span class="cp">	BNX2X_ERR(&quot;driver assert\n&quot;);		\</span>
<span class="cp">	bnx2x_int_disable(bp);			\</span>
<span class="cp">	bnx2x_panic_dump(bp);			\</span>
<span class="cp">} while (0)</span>
<span class="cp">#else</span>
<span class="cp">#define bnx2x_panic()				\</span>
<span class="cp">do {						\</span>
<span class="cp">	bp-&gt;panic = 1;				\</span>
<span class="cp">	BNX2X_ERR(&quot;driver assert\n&quot;);		\</span>
<span class="cp">	bnx2x_panic_dump(bp);			\</span>
<span class="cp">} while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#define bnx2x_mc_addr(ha)      ((ha)-&gt;addr)</span>
<span class="cp">#define bnx2x_uc_addr(ha)      ((ha)-&gt;addr)</span>

<span class="cp">#define U64_LO(x)			(u32)(((u64)(x)) &amp; 0xffffffff)</span>
<span class="cp">#define U64_HI(x)			(u32)(((u64)(x)) &gt;&gt; 32)</span>
<span class="cp">#define HILO_U64(hi, lo)		((((u64)(hi)) &lt;&lt; 32) + (lo))</span>


<span class="cp">#define REG_ADDR(bp, offset)		((bp-&gt;regview) + (offset))</span>

<span class="cp">#define REG_RD(bp, offset)		readl(REG_ADDR(bp, offset))</span>
<span class="cp">#define REG_RD8(bp, offset)		readb(REG_ADDR(bp, offset))</span>
<span class="cp">#define REG_RD16(bp, offset)		readw(REG_ADDR(bp, offset))</span>

<span class="cp">#define REG_WR(bp, offset, val)		writel((u32)val, REG_ADDR(bp, offset))</span>
<span class="cp">#define REG_WR8(bp, offset, val)	writeb((u8)val, REG_ADDR(bp, offset))</span>
<span class="cp">#define REG_WR16(bp, offset, val)	writew((u16)val, REG_ADDR(bp, offset))</span>

<span class="cp">#define REG_RD_IND(bp, offset)		bnx2x_reg_rd_ind(bp, offset)</span>
<span class="cp">#define REG_WR_IND(bp, offset, val)	bnx2x_reg_wr_ind(bp, offset, val)</span>

<span class="cp">#define REG_RD_DMAE(bp, offset, valp, len32) \</span>
<span class="cp">	do { \</span>
<span class="cp">		bnx2x_read_dmae(bp, offset, len32);\</span>
<span class="cp">		memcpy(valp, bnx2x_sp(bp, wb_data[0]), (len32) * 4); \</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define REG_WR_DMAE(bp, offset, valp, len32) \</span>
<span class="cp">	do { \</span>
<span class="cp">		memcpy(bnx2x_sp(bp, wb_data[0]), valp, (len32) * 4); \</span>
<span class="cp">		bnx2x_write_dmae(bp, bnx2x_sp_mapping(bp, wb_data), \</span>
<span class="cp">				 offset, len32); \</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define REG_WR_DMAE_LEN(bp, offset, valp, len32) \</span>
<span class="cp">	REG_WR_DMAE(bp, offset, valp, len32)</span>

<span class="cp">#define VIRT_WR_DMAE_LEN(bp, data, addr, len32, le32_swap) \</span>
<span class="cp">	do { \</span>
<span class="cp">		memcpy(GUNZIP_BUF(bp), data, (len32) * 4); \</span>
<span class="cp">		bnx2x_write_big_buf_wb(bp, addr, len32); \</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define SHMEM_ADDR(bp, field)		(bp-&gt;common.shmem_base + \</span>
<span class="cp">					 offsetof(struct shmem_region, field))</span>
<span class="cp">#define SHMEM_RD(bp, field)		REG_RD(bp, SHMEM_ADDR(bp, field))</span>
<span class="cp">#define SHMEM_WR(bp, field, val)	REG_WR(bp, SHMEM_ADDR(bp, field), val)</span>

<span class="cp">#define SHMEM2_ADDR(bp, field)		(bp-&gt;common.shmem2_base + \</span>
<span class="cp">					 offsetof(struct shmem2_region, field))</span>
<span class="cp">#define SHMEM2_RD(bp, field)		REG_RD(bp, SHMEM2_ADDR(bp, field))</span>
<span class="cp">#define SHMEM2_WR(bp, field, val)	REG_WR(bp, SHMEM2_ADDR(bp, field), val)</span>
<span class="cp">#define MF_CFG_ADDR(bp, field)		(bp-&gt;common.mf_cfg_base + \</span>
<span class="cp">					 offsetof(struct mf_cfg, field))</span>
<span class="cp">#define MF2_CFG_ADDR(bp, field)		(bp-&gt;common.mf2_cfg_base + \</span>
<span class="cp">					 offsetof(struct mf2_cfg, field))</span>

<span class="cp">#define MF_CFG_RD(bp, field)		REG_RD(bp, MF_CFG_ADDR(bp, field))</span>
<span class="cp">#define MF_CFG_WR(bp, field, val)	REG_WR(bp,\</span>
<span class="cp">					       MF_CFG_ADDR(bp, field), (val))</span>
<span class="cp">#define MF2_CFG_RD(bp, field)		REG_RD(bp, MF2_CFG_ADDR(bp, field))</span>

<span class="cp">#define SHMEM2_HAS(bp, field)		((bp)-&gt;common.shmem2_base &amp;&amp;	\</span>
<span class="cp">					 (SHMEM2_RD((bp), size) &gt;	\</span>
<span class="cp">					 offsetof(struct shmem2_region, field)))</span>

<span class="cp">#define EMAC_RD(bp, reg)		REG_RD(bp, emac_base + reg)</span>
<span class="cp">#define EMAC_WR(bp, reg, val)		REG_WR(bp, emac_base + reg, val)</span>

<span class="cm">/* SP SB indices */</span>

<span class="cm">/* General SP events - stats query, cfc delete, etc  */</span>
<span class="cp">#define HC_SP_INDEX_ETH_DEF_CONS		3</span>

<span class="cm">/* EQ completions */</span>
<span class="cp">#define HC_SP_INDEX_EQ_CONS			7</span>

<span class="cm">/* FCoE L2 connection completions */</span>
<span class="cp">#define HC_SP_INDEX_ETH_FCOE_TX_CQ_CONS		6</span>
<span class="cp">#define HC_SP_INDEX_ETH_FCOE_RX_CQ_CONS		4</span>
<span class="cm">/* iSCSI L2 */</span>
<span class="cp">#define HC_SP_INDEX_ETH_ISCSI_CQ_CONS		5</span>
<span class="cp">#define HC_SP_INDEX_ETH_ISCSI_RX_CQ_CONS	1</span>

<span class="cm">/* Special clients parameters */</span>

<span class="cm">/* SB indices */</span>
<span class="cm">/* FCoE L2 */</span>
<span class="cp">#define BNX2X_FCOE_L2_RX_INDEX \</span>
<span class="cp">	(&amp;bp-&gt;def_status_blk-&gt;sp_sb.\</span>
<span class="cp">	index_values[HC_SP_INDEX_ETH_FCOE_RX_CQ_CONS])</span>

<span class="cp">#define BNX2X_FCOE_L2_TX_INDEX \</span>
<span class="cp">	(&amp;bp-&gt;def_status_blk-&gt;sp_sb.\</span>
<span class="cp">	index_values[HC_SP_INDEX_ETH_FCOE_TX_CQ_CONS])</span>

<span class="cm">/**</span>
<span class="cm"> *  CIDs and CLIDs:</span>
<span class="cm"> *  CLIDs below is a CLID for func 0, then the CLID for other</span>
<span class="cm"> *  functions will be calculated by the formula:</span>
<span class="cm"> *</span>
<span class="cm"> *  FUNC_N_CLID_X = N * NUM_SPECIAL_CLIENTS + FUNC_0_CLID_X</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">BNX2X_ISCSI_ETH_CL_ID_IDX</span><span class="p">,</span>
	<span class="n">BNX2X_FCOE_ETH_CL_ID_IDX</span><span class="p">,</span>
	<span class="n">BNX2X_MAX_CNIC_ETH_CL_ID_IDX</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define BNX2X_CNIC_START_ETH_CID	48</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* iSCSI L2 */</span>
	<span class="n">BNX2X_ISCSI_ETH_CID</span> <span class="o">=</span> <span class="n">BNX2X_CNIC_START_ETH_CID</span><span class="p">,</span>
	<span class="cm">/* FCoE L2 */</span>
	<span class="n">BNX2X_FCOE_ETH_CID</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/** Additional rings budgeting */</span>
<span class="cp">#ifdef BCM_CNIC</span>
<span class="cp">#define CNIC_PRESENT			1</span>
<span class="cp">#define FCOE_PRESENT			1</span>
<span class="cp">#else</span>
<span class="cp">#define CNIC_PRESENT			0</span>
<span class="cp">#define FCOE_PRESENT			0</span>
<span class="cp">#endif </span><span class="cm">/* BCM_CNIC */</span><span class="cp"></span>
<span class="cp">#define NON_ETH_CONTEXT_USE	(FCOE_PRESENT)</span>

<span class="cp">#define AEU_IN_ATTN_BITS_PXPPCICLOCKCLIENT_PARITY_ERROR \</span>
<span class="cp">	AEU_INPUTS_ATTN_BITS_PXPPCICLOCKCLIENT_PARITY_ERROR</span>

<span class="cp">#define SM_RX_ID			0</span>
<span class="cp">#define SM_TX_ID			1</span>

<span class="cm">/* defines for multiple tx priority indices */</span>
<span class="cp">#define FIRST_TX_ONLY_COS_INDEX		1</span>
<span class="cp">#define FIRST_TX_COS_INDEX		0</span>

<span class="cm">/* defines for decodeing the fastpath index and the cos index out of the</span>
<span class="cm"> * transmission queue index</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_TXQS_PER_COS	FP_SB_MAX_E1x</span>

<span class="cp">#define TXQ_TO_FP(txq_index)	((txq_index) % MAX_TXQS_PER_COS)</span>
<span class="cp">#define TXQ_TO_COS(txq_index)	((txq_index) / MAX_TXQS_PER_COS)</span>

<span class="cm">/* rules for calculating the cids of tx-only connections */</span>
<span class="cp">#define CID_TO_FP(cid)		((cid) % MAX_TXQS_PER_COS)</span>
<span class="cp">#define CID_COS_TO_TX_ONLY_CID(cid, cos)	(cid + cos * MAX_TXQS_PER_COS)</span>

<span class="cm">/* fp index inside class of service range */</span>
<span class="cp">#define FP_COS_TO_TXQ(fp, cos)    ((fp)-&gt;index + cos * MAX_TXQS_PER_COS)</span>

<span class="cm">/*</span>
<span class="cm"> * 0..15 eth cos0</span>
<span class="cm"> * 16..31 eth cos1 if applicable</span>
<span class="cm"> * 32..47 eth cos2 If applicable</span>
<span class="cm"> * fcoe queue follows eth queues (16, 32, 48 depending on cos)</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_ETH_TXQ_IDX(bp)	(MAX_TXQS_PER_COS * (bp)-&gt;max_cos)</span>
<span class="cp">#define FCOE_TXQ_IDX(bp)	(MAX_ETH_TXQ_IDX(bp))</span>

<span class="cm">/* fast path */</span>
<span class="cm">/*</span>
<span class="cm"> * This driver uses new build_skb() API :</span>
<span class="cm"> * RX ring buffer contains pointer to kmalloc() data only,</span>
<span class="cm"> * skb are built only after Hardware filled the frame.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sw_rx_bd</span> <span class="p">{</span>
	<span class="n">u8</span>		<span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="n">DEFINE_DMA_UNMAP_ADDR</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sw_tx_bd</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>	<span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">u16</span>		<span class="n">first_bd</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">flags</span><span class="p">;</span>
<span class="cm">/* Set on the first BD descriptor when there is a split BD */</span>
<span class="cp">#define BNX2X_TSO_SPLIT_BD		(1&lt;&lt;0)</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sw_rx_page</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span>	<span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">DEFINE_DMA_UNMAP_ADDR</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">union</span> <span class="n">db_prod</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">doorbell_set_prod</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">raw</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* dropless fc FW/HW related params */</span>
<span class="cp">#define BRB_SIZE(bp)		(CHIP_IS_E3(bp) ? 1024 : 512)</span>
<span class="cp">#define MAX_AGG_QS(bp)		(CHIP_IS_E1(bp) ? \</span>
<span class="cp">					ETH_MAX_AGGREGATION_QUEUES_E1 :\</span>
<span class="cp">					ETH_MAX_AGGREGATION_QUEUES_E1H_E2)</span>
<span class="cp">#define FW_DROP_LEVEL(bp)	(3 + MAX_SPQ_PENDING + MAX_AGG_QS(bp))</span>
<span class="cp">#define FW_PREFETCH_CNT		16</span>
<span class="cp">#define DROPLESS_FC_HEADROOM	100</span>

<span class="cm">/* MC hsi */</span>
<span class="cp">#define BCM_PAGE_SHIFT		12</span>
<span class="cp">#define BCM_PAGE_SIZE		(1 &lt;&lt; BCM_PAGE_SHIFT)</span>
<span class="cp">#define BCM_PAGE_MASK		(~(BCM_PAGE_SIZE - 1))</span>
<span class="cp">#define BCM_PAGE_ALIGN(addr)	(((addr) + BCM_PAGE_SIZE - 1) &amp; BCM_PAGE_MASK)</span>

<span class="cp">#define PAGES_PER_SGE_SHIFT	0</span>
<span class="cp">#define PAGES_PER_SGE		(1 &lt;&lt; PAGES_PER_SGE_SHIFT)</span>
<span class="cp">#define SGE_PAGE_SIZE		PAGE_SIZE</span>
<span class="cp">#define SGE_PAGE_SHIFT		PAGE_SHIFT</span>
<span class="cp">#define SGE_PAGE_ALIGN(addr)	PAGE_ALIGN((typeof(PAGE_SIZE))(addr))</span>

<span class="cm">/* SGE ring related macros */</span>
<span class="cp">#define NUM_RX_SGE_PAGES	2</span>
<span class="cp">#define RX_SGE_CNT		(BCM_PAGE_SIZE / sizeof(struct eth_rx_sge))</span>
<span class="cp">#define NEXT_PAGE_SGE_DESC_CNT	2</span>
<span class="cp">#define MAX_RX_SGE_CNT		(RX_SGE_CNT - NEXT_PAGE_SGE_DESC_CNT)</span>
<span class="cm">/* RX_SGE_CNT is promised to be a power of 2 */</span>
<span class="cp">#define RX_SGE_MASK		(RX_SGE_CNT - 1)</span>
<span class="cp">#define NUM_RX_SGE		(RX_SGE_CNT * NUM_RX_SGE_PAGES)</span>
<span class="cp">#define MAX_RX_SGE		(NUM_RX_SGE - 1)</span>
<span class="cp">#define NEXT_SGE_IDX(x)		((((x) &amp; RX_SGE_MASK) == \</span>
<span class="cp">				  (MAX_RX_SGE_CNT - 1)) ? \</span>
<span class="cp">					(x) + 1 + NEXT_PAGE_SGE_DESC_CNT : \</span>
<span class="cp">					(x) + 1)</span>
<span class="cp">#define RX_SGE(x)		((x) &amp; MAX_RX_SGE)</span>

<span class="cm">/*</span>
<span class="cm"> * Number of required  SGEs is the sum of two:</span>
<span class="cm"> * 1. Number of possible opened aggregations (next packet for</span>
<span class="cm"> *    these aggregations will probably consume SGE immidiatelly)</span>
<span class="cm"> * 2. Rest of BRB blocks divided by 2 (block will consume new SGE only</span>
<span class="cm"> *    after placement on BD for new TPA aggregation)</span>
<span class="cm"> *</span>
<span class="cm"> * Takes into account NEXT_PAGE_SGE_DESC_CNT &quot;next&quot; elements on each page</span>
<span class="cm"> */</span>
<span class="cp">#define NUM_SGE_REQ		(MAX_AGG_QS(bp) + \</span>
<span class="cp">					(BRB_SIZE(bp) - MAX_AGG_QS(bp)) / 2)</span>
<span class="cp">#define NUM_SGE_PG_REQ		((NUM_SGE_REQ + MAX_RX_SGE_CNT - 1) / \</span>
<span class="cp">						MAX_RX_SGE_CNT)</span>
<span class="cp">#define SGE_TH_LO(bp)		(NUM_SGE_REQ + \</span>
<span class="cp">				 NUM_SGE_PG_REQ * NEXT_PAGE_SGE_DESC_CNT)</span>
<span class="cp">#define SGE_TH_HI(bp)		(SGE_TH_LO(bp) + DROPLESS_FC_HEADROOM)</span>

<span class="cm">/* Manipulate a bit vector defined as an array of u64 */</span>

<span class="cm">/* Number of bits in one sge_mask array element */</span>
<span class="cp">#define BIT_VEC64_ELEM_SZ		64</span>
<span class="cp">#define BIT_VEC64_ELEM_SHIFT		6</span>
<span class="cp">#define BIT_VEC64_ELEM_MASK		((u64)BIT_VEC64_ELEM_SZ - 1)</span>


<span class="cp">#define __BIT_VEC64_SET_BIT(el, bit) \</span>
<span class="cp">	do { \</span>
<span class="cp">		el = ((el) | ((u64)0x1 &lt;&lt; (bit))); \</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define __BIT_VEC64_CLEAR_BIT(el, bit) \</span>
<span class="cp">	do { \</span>
<span class="cp">		el = ((el) &amp; (~((u64)0x1 &lt;&lt; (bit)))); \</span>
<span class="cp">	} while (0)</span>


<span class="cp">#define BIT_VEC64_SET_BIT(vec64, idx) \</span>
<span class="cp">	__BIT_VEC64_SET_BIT((vec64)[(idx) &gt;&gt; BIT_VEC64_ELEM_SHIFT], \</span>
<span class="cp">			   (idx) &amp; BIT_VEC64_ELEM_MASK)</span>

<span class="cp">#define BIT_VEC64_CLEAR_BIT(vec64, idx) \</span>
<span class="cp">	__BIT_VEC64_CLEAR_BIT((vec64)[(idx) &gt;&gt; BIT_VEC64_ELEM_SHIFT], \</span>
<span class="cp">			     (idx) &amp; BIT_VEC64_ELEM_MASK)</span>

<span class="cp">#define BIT_VEC64_TEST_BIT(vec64, idx) \</span>
<span class="cp">	(((vec64)[(idx) &gt;&gt; BIT_VEC64_ELEM_SHIFT] &gt;&gt; \</span>
<span class="cp">	((idx) &amp; BIT_VEC64_ELEM_MASK)) &amp; 0x1)</span>

<span class="cm">/* Creates a bitmask of all ones in less significant bits.</span>
<span class="cm">   idx - index of the most significant bit in the created mask */</span>
<span class="cp">#define BIT_VEC64_ONES_MASK(idx) \</span>
<span class="cp">		(((u64)0x1 &lt;&lt; (((idx) &amp; BIT_VEC64_ELEM_MASK) + 1)) - 1)</span>
<span class="cp">#define BIT_VEC64_ELEM_ONE_MASK	((u64)(~0))</span>

<span class="cm">/*******************************************************/</span>



<span class="cm">/* Number of u64 elements in SGE mask array */</span>
<span class="cp">#define RX_SGE_MASK_LEN			(NUM_RX_SGE / BIT_VEC64_ELEM_SZ)</span>
<span class="cp">#define RX_SGE_MASK_LEN_MASK		(RX_SGE_MASK_LEN - 1)</span>
<span class="cp">#define NEXT_SGE_MASK_ELEM(el)		(((el) + 1) &amp; RX_SGE_MASK_LEN_MASK)</span>

<span class="k">union</span> <span class="n">host_hc_status_block</span> <span class="p">{</span>
	<span class="cm">/* pointer to fp status block e1x */</span>
	<span class="k">struct</span> <span class="n">host_hc_status_block_e1x</span> <span class="o">*</span><span class="n">e1x_sb</span><span class="p">;</span>
	<span class="cm">/* pointer to fp status block e2 */</span>
	<span class="k">struct</span> <span class="n">host_hc_status_block_e2</span>  <span class="o">*</span><span class="n">e2_sb</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">bnx2x_agg_info</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * First aggregation buffer is a data buffer, the following - are pages.</span>
<span class="cm">	 * We will preallocate the data buffer for each aggregation when</span>
<span class="cm">	 * we open the interface and will replace the BD at the consumer</span>
<span class="cm">	 * with this one when we receive the TPA_START CQE in order to</span>
<span class="cm">	 * keep the Rx BD ring consistent.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">sw_rx_bd</span>		<span class="n">first_buf</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">tpa_state</span><span class="p">;</span>
<span class="cp">#define BNX2X_TPA_START			1</span>
<span class="cp">#define BNX2X_TPA_STOP			2</span>
<span class="cp">#define BNX2X_TPA_ERROR			3</span>
	<span class="n">u8</span>			<span class="n">placement_offset</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">parsing_flags</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">vlan_tag</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">len_on_bd</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">rxhash</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">gro_size</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">full_page</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define Q_STATS_OFFSET32(stat_name) \</span>
<span class="cp">			(offsetof(struct bnx2x_eth_q_stats, stat_name) / 4)</span>

<span class="k">struct</span> <span class="n">bnx2x_fp_txdata</span> <span class="p">{</span>

	<span class="k">struct</span> <span class="n">sw_tx_bd</span>		<span class="o">*</span><span class="n">tx_buf_ring</span><span class="p">;</span>

	<span class="k">union</span> <span class="n">eth_tx_bd_types</span>	<span class="o">*</span><span class="n">tx_desc_ring</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">tx_desc_mapping</span><span class="p">;</span>

	<span class="n">u32</span>			<span class="n">cid</span><span class="p">;</span>

	<span class="k">union</span> <span class="n">db_prod</span>		<span class="n">tx_db</span><span class="p">;</span>

	<span class="n">u16</span>			<span class="n">tx_pkt_prod</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">tx_pkt_cons</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">tx_bd_prod</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">tx_bd_cons</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">tx_pkt</span><span class="p">;</span>

	<span class="n">__le16</span>			<span class="o">*</span><span class="n">tx_cons_sb</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">txq_index</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">bnx2x_tpa_mode_t</span> <span class="p">{</span>
	<span class="n">TPA_MODE_LRO</span><span class="p">,</span>
	<span class="n">TPA_MODE_GRO</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2x</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span> <span class="cm">/* parent */</span>

<span class="cp">#define BNX2X_NAPI_WEIGHT       128</span>
	<span class="k">struct</span> <span class="n">napi_struct</span>	<span class="n">napi</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">host_hc_status_block</span>	<span class="n">status_blk</span><span class="p">;</span>
	<span class="cm">/* chip independed shortcuts into sb structure */</span>
	<span class="n">__le16</span>			<span class="o">*</span><span class="n">sb_index_values</span><span class="p">;</span>
	<span class="n">__le16</span>			<span class="o">*</span><span class="n">sb_running_index</span><span class="p">;</span>
	<span class="cm">/* chip independed shortcut into rx_prods_offset memory */</span>
	<span class="n">u32</span>			<span class="n">ustorm_rx_prods_offset</span><span class="p">;</span>

	<span class="n">u32</span>			<span class="n">rx_buf_size</span><span class="p">;</span>

	<span class="n">dma_addr_t</span>		<span class="n">status_blk_mapping</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">bnx2x_tpa_mode_t</span>	<span class="n">mode</span><span class="p">;</span>

	<span class="n">u8</span>			<span class="n">max_cos</span><span class="p">;</span> <span class="cm">/* actual number of active tx coses */</span>
	<span class="k">struct</span> <span class="n">bnx2x_fp_txdata</span>	<span class="n">txdata</span><span class="p">[</span><span class="n">BNX2X_MULTI_TX_COS</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">sw_rx_bd</span>		<span class="o">*</span><span class="n">rx_buf_ring</span><span class="p">;</span>	<span class="cm">/* BDs mappings ring */</span>
	<span class="k">struct</span> <span class="n">sw_rx_page</span>	<span class="o">*</span><span class="n">rx_page_ring</span><span class="p">;</span>	<span class="cm">/* SGE pages mappings ring */</span>

	<span class="k">struct</span> <span class="n">eth_rx_bd</span>	<span class="o">*</span><span class="n">rx_desc_ring</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">rx_desc_mapping</span><span class="p">;</span>

	<span class="k">union</span> <span class="n">eth_rx_cqe</span>	<span class="o">*</span><span class="n">rx_comp_ring</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">rx_comp_mapping</span><span class="p">;</span>

	<span class="cm">/* SGE ring */</span>
	<span class="k">struct</span> <span class="n">eth_rx_sge</span>	<span class="o">*</span><span class="n">rx_sge_ring</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">rx_sge_mapping</span><span class="p">;</span>

	<span class="n">u64</span>			<span class="n">sge_mask</span><span class="p">[</span><span class="n">RX_SGE_MASK_LEN</span><span class="p">];</span>

	<span class="n">u32</span>			<span class="n">cid</span><span class="p">;</span>

	<span class="n">__le16</span>			<span class="n">fp_hc_idx</span><span class="p">;</span>

	<span class="n">u8</span>			<span class="n">index</span><span class="p">;</span>		<span class="cm">/* number in fp array */</span>
	<span class="n">u8</span>			<span class="n">rx_queue</span><span class="p">;</span>	<span class="cm">/* index for skb_record */</span>
	<span class="n">u8</span>			<span class="n">cl_id</span><span class="p">;</span>		<span class="cm">/* eth client id */</span>
	<span class="n">u8</span>			<span class="n">cl_qzone_id</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">fw_sb_id</span><span class="p">;</span>	<span class="cm">/* status block number in FW */</span>
	<span class="n">u8</span>			<span class="n">igu_sb_id</span><span class="p">;</span>	<span class="cm">/* status block number in HW */</span>

	<span class="n">u16</span>			<span class="n">rx_bd_prod</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">rx_bd_cons</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">rx_comp_prod</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">rx_comp_cons</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">rx_sge_prod</span><span class="p">;</span>
	<span class="cm">/* The last maximal completed SGE */</span>
	<span class="n">u16</span>			<span class="n">last_max_sge</span><span class="p">;</span>
	<span class="n">__le16</span>			<span class="o">*</span><span class="n">rx_cons_sb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">rx_pkt</span><span class="p">,</span>
				<span class="n">rx_calls</span><span class="p">;</span>

	<span class="cm">/* TPA related */</span>
	<span class="k">struct</span> <span class="n">bnx2x_agg_info</span>	<span class="n">tpa_info</span><span class="p">[</span><span class="n">ETH_MAX_AGGREGATION_QUEUES_E1H_E2</span><span class="p">];</span>
	<span class="n">u8</span>			<span class="n">disable_tpa</span><span class="p">;</span>
<span class="cp">#ifdef BNX2X_STOP_ON_ERROR</span>
	<span class="n">u64</span>			<span class="n">tpa_queue_used</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">struct</span> <span class="n">tstorm_per_queue_stats</span> <span class="n">old_tclient</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ustorm_per_queue_stats</span> <span class="n">old_uclient</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xstorm_per_queue_stats</span> <span class="n">old_xclient</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bnx2x_eth_q_stats</span> <span class="n">eth_q_stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bnx2x_eth_q_stats_old</span> <span class="n">eth_q_stats_old</span><span class="p">;</span>

	<span class="cm">/* The size is calculated using the following:</span>
<span class="cm">	     sizeof name field from netdev structure +</span>
<span class="cm">	     4 (&#39;-Xx-&#39; string) +</span>
<span class="cm">	     4 (for the digits and to make it DWORD aligned) */</span>
<span class="cp">#define FP_NAME_SIZE		(sizeof(((struct net_device *)0)-&gt;name) + 8)</span>
	<span class="kt">char</span>			<span class="n">name</span><span class="p">[</span><span class="n">FP_NAME_SIZE</span><span class="p">];</span>

	<span class="cm">/* MACs object */</span>
	<span class="k">struct</span> <span class="n">bnx2x_vlan_mac_obj</span> <span class="n">mac_obj</span><span class="p">;</span>

	<span class="cm">/* Queue State object */</span>
	<span class="k">struct</span> <span class="n">bnx2x_queue_sp_obj</span> <span class="n">q_obj</span><span class="p">;</span>

<span class="p">};</span>

<span class="cp">#define bnx2x_fp(bp, nr, var)		(bp-&gt;fp[nr].var)</span>

<span class="cm">/* Use 2500 as a mini-jumbo MTU for FCoE */</span>
<span class="cp">#define BNX2X_FCOE_MINI_JUMBO_MTU	2500</span>

<span class="cm">/* FCoE L2 `fastpath&#39; entry is right after the eth entries */</span>
<span class="cp">#define FCOE_IDX			BNX2X_NUM_ETH_QUEUES(bp)</span>
<span class="cp">#define bnx2x_fcoe_fp(bp)		(&amp;bp-&gt;fp[FCOE_IDX])</span>
<span class="cp">#define bnx2x_fcoe(bp, var)		(bnx2x_fcoe_fp(bp)-&gt;var)</span>
<span class="cp">#define bnx2x_fcoe_tx(bp, var)		(bnx2x_fcoe_fp(bp)-&gt; \</span>
<span class="cp">						txdata[FIRST_TX_COS_INDEX].var)</span>


<span class="cp">#define IS_ETH_FP(fp)			(fp-&gt;index &lt; \</span>
<span class="cp">					 BNX2X_NUM_ETH_QUEUES(fp-&gt;bp))</span>
<span class="cp">#ifdef BCM_CNIC</span>
<span class="cp">#define IS_FCOE_FP(fp)			(fp-&gt;index == FCOE_IDX)</span>
<span class="cp">#define IS_FCOE_IDX(idx)		((idx) == FCOE_IDX)</span>
<span class="cp">#else</span>
<span class="cp">#define IS_FCOE_FP(fp)		false</span>
<span class="cp">#define IS_FCOE_IDX(idx)	false</span>
<span class="cp">#endif</span>


<span class="cm">/* MC hsi */</span>
<span class="cp">#define MAX_FETCH_BD		13	</span><span class="cm">/* HW max BDs per packet */</span><span class="cp"></span>
<span class="cp">#define RX_COPY_THRESH		92</span>

<span class="cp">#define NUM_TX_RINGS		16</span>
<span class="cp">#define TX_DESC_CNT		(BCM_PAGE_SIZE / sizeof(union eth_tx_bd_types))</span>
<span class="cp">#define NEXT_PAGE_TX_DESC_CNT	1</span>
<span class="cp">#define MAX_TX_DESC_CNT		(TX_DESC_CNT - NEXT_PAGE_TX_DESC_CNT)</span>
<span class="cp">#define NUM_TX_BD		(TX_DESC_CNT * NUM_TX_RINGS)</span>
<span class="cp">#define MAX_TX_BD		(NUM_TX_BD - 1)</span>
<span class="cp">#define MAX_TX_AVAIL		(MAX_TX_DESC_CNT * NUM_TX_RINGS - 2)</span>
<span class="cp">#define NEXT_TX_IDX(x)		((((x) &amp; MAX_TX_DESC_CNT) == \</span>
<span class="cp">				  (MAX_TX_DESC_CNT - 1)) ? \</span>
<span class="cp">					(x) + 1 + NEXT_PAGE_TX_DESC_CNT : \</span>
<span class="cp">					(x) + 1)</span>
<span class="cp">#define TX_BD(x)		((x) &amp; MAX_TX_BD)</span>
<span class="cp">#define TX_BD_POFF(x)		((x) &amp; MAX_TX_DESC_CNT)</span>

<span class="cm">/* The RX BD ring is special, each bd is 8 bytes but the last one is 16 */</span>
<span class="cp">#define NUM_RX_RINGS		8</span>
<span class="cp">#define RX_DESC_CNT		(BCM_PAGE_SIZE / sizeof(struct eth_rx_bd))</span>
<span class="cp">#define NEXT_PAGE_RX_DESC_CNT	2</span>
<span class="cp">#define MAX_RX_DESC_CNT		(RX_DESC_CNT - NEXT_PAGE_RX_DESC_CNT)</span>
<span class="cp">#define RX_DESC_MASK		(RX_DESC_CNT - 1)</span>
<span class="cp">#define NUM_RX_BD		(RX_DESC_CNT * NUM_RX_RINGS)</span>
<span class="cp">#define MAX_RX_BD		(NUM_RX_BD - 1)</span>
<span class="cp">#define MAX_RX_AVAIL		(MAX_RX_DESC_CNT * NUM_RX_RINGS - 2)</span>

<span class="cm">/* dropless fc calculations for BDs</span>
<span class="cm"> *</span>
<span class="cm"> * Number of BDs should as number of buffers in BRB:</span>
<span class="cm"> * Low threshold takes into account NEXT_PAGE_RX_DESC_CNT</span>
<span class="cm"> * &quot;next&quot; elements on each page</span>
<span class="cm"> */</span>
<span class="cp">#define NUM_BD_REQ		BRB_SIZE(bp)</span>
<span class="cp">#define NUM_BD_PG_REQ		((NUM_BD_REQ + MAX_RX_DESC_CNT - 1) / \</span>
<span class="cp">					      MAX_RX_DESC_CNT)</span>
<span class="cp">#define BD_TH_LO(bp)		(NUM_BD_REQ + \</span>
<span class="cp">				 NUM_BD_PG_REQ * NEXT_PAGE_RX_DESC_CNT + \</span>
<span class="cp">				 FW_DROP_LEVEL(bp))</span>
<span class="cp">#define BD_TH_HI(bp)		(BD_TH_LO(bp) + DROPLESS_FC_HEADROOM)</span>

<span class="cp">#define MIN_RX_AVAIL		((bp)-&gt;dropless_fc ? BD_TH_HI(bp) + 128 : 128)</span>

<span class="cp">#define MIN_RX_SIZE_TPA_HW	(CHIP_IS_E1(bp) ? \</span>
<span class="cp">					ETH_MIN_RX_CQES_WITH_TPA_E1 : \</span>
<span class="cp">					ETH_MIN_RX_CQES_WITH_TPA_E1H_E2)</span>
<span class="cp">#define MIN_RX_SIZE_NONTPA_HW   ETH_MIN_RX_CQES_WITHOUT_TPA</span>
<span class="cp">#define MIN_RX_SIZE_TPA		(max_t(u32, MIN_RX_SIZE_TPA_HW, MIN_RX_AVAIL))</span>
<span class="cp">#define MIN_RX_SIZE_NONTPA	(max_t(u32, MIN_RX_SIZE_NONTPA_HW,\</span>
<span class="cp">								MIN_RX_AVAIL))</span>

<span class="cp">#define NEXT_RX_IDX(x)		((((x) &amp; RX_DESC_MASK) == \</span>
<span class="cp">				  (MAX_RX_DESC_CNT - 1)) ? \</span>
<span class="cp">					(x) + 1 + NEXT_PAGE_RX_DESC_CNT : \</span>
<span class="cp">					(x) + 1)</span>
<span class="cp">#define RX_BD(x)		((x) &amp; MAX_RX_BD)</span>

<span class="cm">/*</span>
<span class="cm"> * As long as CQE is X times bigger than BD entry we have to allocate X times</span>
<span class="cm"> * more pages for CQ ring in order to keep it balanced with BD ring</span>
<span class="cm"> */</span>
<span class="cp">#define CQE_BD_REL	(sizeof(union eth_rx_cqe) / sizeof(struct eth_rx_bd))</span>
<span class="cp">#define NUM_RCQ_RINGS		(NUM_RX_RINGS * CQE_BD_REL)</span>
<span class="cp">#define RCQ_DESC_CNT		(BCM_PAGE_SIZE / sizeof(union eth_rx_cqe))</span>
<span class="cp">#define NEXT_PAGE_RCQ_DESC_CNT	1</span>
<span class="cp">#define MAX_RCQ_DESC_CNT	(RCQ_DESC_CNT - NEXT_PAGE_RCQ_DESC_CNT)</span>
<span class="cp">#define NUM_RCQ_BD		(RCQ_DESC_CNT * NUM_RCQ_RINGS)</span>
<span class="cp">#define MAX_RCQ_BD		(NUM_RCQ_BD - 1)</span>
<span class="cp">#define MAX_RCQ_AVAIL		(MAX_RCQ_DESC_CNT * NUM_RCQ_RINGS - 2)</span>
<span class="cp">#define NEXT_RCQ_IDX(x)		((((x) &amp; MAX_RCQ_DESC_CNT) == \</span>
<span class="cp">				  (MAX_RCQ_DESC_CNT - 1)) ? \</span>
<span class="cp">					(x) + 1 + NEXT_PAGE_RCQ_DESC_CNT : \</span>
<span class="cp">					(x) + 1)</span>
<span class="cp">#define RCQ_BD(x)		((x) &amp; MAX_RCQ_BD)</span>

<span class="cm">/* dropless fc calculations for RCQs</span>
<span class="cm"> *</span>
<span class="cm"> * Number of RCQs should be as number of buffers in BRB:</span>
<span class="cm"> * Low threshold takes into account NEXT_PAGE_RCQ_DESC_CNT</span>
<span class="cm"> * &quot;next&quot; elements on each page</span>
<span class="cm"> */</span>
<span class="cp">#define NUM_RCQ_REQ		BRB_SIZE(bp)</span>
<span class="cp">#define NUM_RCQ_PG_REQ		((NUM_BD_REQ + MAX_RCQ_DESC_CNT - 1) / \</span>
<span class="cp">					      MAX_RCQ_DESC_CNT)</span>
<span class="cp">#define RCQ_TH_LO(bp)		(NUM_RCQ_REQ + \</span>
<span class="cp">				 NUM_RCQ_PG_REQ * NEXT_PAGE_RCQ_DESC_CNT + \</span>
<span class="cp">				 FW_DROP_LEVEL(bp))</span>
<span class="cp">#define RCQ_TH_HI(bp)		(RCQ_TH_LO(bp) + DROPLESS_FC_HEADROOM)</span>


<span class="cm">/* This is needed for determining of last_max */</span>
<span class="cp">#define SUB_S16(a, b)		(s16)((s16)(a) - (s16)(b))</span>
<span class="cp">#define SUB_S32(a, b)		(s32)((s32)(a) - (s32)(b))</span>


<span class="cp">#define BNX2X_SWCID_SHIFT	17</span>
<span class="cp">#define BNX2X_SWCID_MASK	((0x1 &lt;&lt; BNX2X_SWCID_SHIFT) - 1)</span>

<span class="cm">/* used on a CID received from the HW */</span>
<span class="cp">#define SW_CID(x)			(le32_to_cpu(x) &amp; BNX2X_SWCID_MASK)</span>
<span class="cp">#define CQE_CMD(x)			(le32_to_cpu(x) &gt;&gt; \</span>
<span class="cp">					COMMON_RAMROD_ETH_RX_CQE_CMD_ID_SHIFT)</span>

<span class="cp">#define BD_UNMAP_ADDR(bd)		HILO_U64(le32_to_cpu((bd)-&gt;addr_hi), \</span>
<span class="cp">						 le32_to_cpu((bd)-&gt;addr_lo))</span>
<span class="cp">#define BD_UNMAP_LEN(bd)		(le16_to_cpu((bd)-&gt;nbytes))</span>

<span class="cp">#define BNX2X_DB_MIN_SHIFT		3	</span><span class="cm">/* 8 bytes */</span><span class="cp"></span>
<span class="cp">#define BNX2X_DB_SHIFT			7	</span><span class="cm">/* 128 bytes*/</span><span class="cp"></span>
<span class="cp">#if (BNX2X_DB_SHIFT &lt; BNX2X_DB_MIN_SHIFT)</span>
<span class="cp">#error &quot;Min DB doorbell stride is 8&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#define DPM_TRIGER_TYPE			0x40</span>
<span class="cp">#define DOORBELL(bp, cid, val) \</span>
<span class="cp">	do { \</span>
<span class="cp">		writel((u32)(val), bp-&gt;doorbells + (bp-&gt;db_size * (cid)) + \</span>
<span class="cp">		       DPM_TRIGER_TYPE); \</span>
<span class="cp">	} while (0)</span>


<span class="cm">/* TX CSUM helpers */</span>
<span class="cp">#define SKB_CS_OFF(skb)		(offsetof(struct tcphdr, check) - \</span>
<span class="cp">				 skb-&gt;csum_offset)</span>
<span class="cp">#define SKB_CS(skb)		(*(u16 *)(skb_transport_header(skb) + \</span>
<span class="cp">					  skb-&gt;csum_offset))</span>

<span class="cp">#define pbd_tcp_flags(skb)	(ntohl(tcp_flag_word(tcp_hdr(skb)))&gt;&gt;16 &amp; 0xff)</span>

<span class="cp">#define XMIT_PLAIN			0</span>
<span class="cp">#define XMIT_CSUM_V4			0x1</span>
<span class="cp">#define XMIT_CSUM_V6			0x2</span>
<span class="cp">#define XMIT_CSUM_TCP			0x4</span>
<span class="cp">#define XMIT_GSO_V4			0x8</span>
<span class="cp">#define XMIT_GSO_V6			0x10</span>

<span class="cp">#define XMIT_CSUM			(XMIT_CSUM_V4 | XMIT_CSUM_V6)</span>
<span class="cp">#define XMIT_GSO			(XMIT_GSO_V4 | XMIT_GSO_V6)</span>


<span class="cm">/* stuff added to make the code fit 80Col */</span>
<span class="cp">#define CQE_TYPE(cqe_fp_flags)	 ((cqe_fp_flags) &amp; ETH_FAST_PATH_RX_CQE_TYPE)</span>
<span class="cp">#define CQE_TYPE_START(cqe_type) ((cqe_type) == RX_ETH_CQE_TYPE_ETH_START_AGG)</span>
<span class="cp">#define CQE_TYPE_STOP(cqe_type)  ((cqe_type) == RX_ETH_CQE_TYPE_ETH_STOP_AGG)</span>
<span class="cp">#define CQE_TYPE_SLOW(cqe_type)  ((cqe_type) == RX_ETH_CQE_TYPE_ETH_RAMROD)</span>
<span class="cp">#define CQE_TYPE_FAST(cqe_type)  ((cqe_type) == RX_ETH_CQE_TYPE_ETH_FASTPATH)</span>

<span class="cp">#define ETH_RX_ERROR_FALGS		ETH_FAST_PATH_RX_CQE_PHY_DECODE_ERR_FLG</span>

<span class="cp">#define BNX2X_PRS_FLAG_OVERETH_IPV4(flags) \</span>
<span class="cp">				(((le16_to_cpu(flags) &amp; \</span>
<span class="cp">				   PARSING_FLAGS_OVER_ETHERNET_PROTOCOL) &gt;&gt; \</span>
<span class="cp">				  PARSING_FLAGS_OVER_ETHERNET_PROTOCOL_SHIFT) \</span>
<span class="cp">				 == PRS_FLAG_OVERETH_IPV4)</span>
<span class="cp">#define BNX2X_RX_SUM_FIX(cqe) \</span>
<span class="cp">	BNX2X_PRS_FLAG_OVERETH_IPV4(cqe-&gt;fast_path_cqe.pars_flags.flags)</span>


<span class="cp">#define FP_USB_FUNC_OFF	\</span>
<span class="cp">			offsetof(struct cstorm_status_block_u, func)</span>
<span class="cp">#define FP_CSB_FUNC_OFF	\</span>
<span class="cp">			offsetof(struct cstorm_status_block_c, func)</span>

<span class="cp">#define HC_INDEX_ETH_RX_CQ_CONS		1</span>

<span class="cp">#define HC_INDEX_OOO_TX_CQ_CONS		4</span>

<span class="cp">#define HC_INDEX_ETH_TX_CQ_CONS_COS0	5</span>

<span class="cp">#define HC_INDEX_ETH_TX_CQ_CONS_COS1	6</span>

<span class="cp">#define HC_INDEX_ETH_TX_CQ_CONS_COS2	7</span>

<span class="cp">#define HC_INDEX_ETH_FIRST_TX_CQ_CONS	HC_INDEX_ETH_TX_CQ_CONS_COS0</span>

<span class="cp">#define BNX2X_RX_SB_INDEX \</span>
<span class="cp">	(&amp;fp-&gt;sb_index_values[HC_INDEX_ETH_RX_CQ_CONS])</span>

<span class="cp">#define BNX2X_TX_SB_INDEX_BASE BNX2X_TX_SB_INDEX_COS0</span>

<span class="cp">#define BNX2X_TX_SB_INDEX_COS0 \</span>
<span class="cp">	(&amp;fp-&gt;sb_index_values[HC_INDEX_ETH_TX_CQ_CONS_COS0])</span>

<span class="cm">/* end of fast path */</span>

<span class="cm">/* common */</span>

<span class="k">struct</span> <span class="n">bnx2x_common</span> <span class="p">{</span>

	<span class="n">u32</span>			<span class="n">chip_id</span><span class="p">;</span>
<span class="cm">/* chip num:16-31, rev:12-15, metal:4-11, bond_id:0-3 */</span>
<span class="cp">#define CHIP_ID(bp)			(bp-&gt;common.chip_id &amp; 0xfffffff0)</span>

<span class="cp">#define CHIP_NUM(bp)			(bp-&gt;common.chip_id &gt;&gt; 16)</span>
<span class="cp">#define CHIP_NUM_57710			0x164e</span>
<span class="cp">#define CHIP_NUM_57711			0x164f</span>
<span class="cp">#define CHIP_NUM_57711E			0x1650</span>
<span class="cp">#define CHIP_NUM_57712			0x1662</span>
<span class="cp">#define CHIP_NUM_57712_MF		0x1663</span>
<span class="cp">#define CHIP_NUM_57713			0x1651</span>
<span class="cp">#define CHIP_NUM_57713E			0x1652</span>
<span class="cp">#define CHIP_NUM_57800			0x168a</span>
<span class="cp">#define CHIP_NUM_57800_MF		0x16a5</span>
<span class="cp">#define CHIP_NUM_57810			0x168e</span>
<span class="cp">#define CHIP_NUM_57810_MF		0x16ae</span>
<span class="cp">#define CHIP_NUM_57811			0x163d</span>
<span class="cp">#define CHIP_NUM_57811_MF		0x163e</span>
<span class="cp">#define CHIP_NUM_57840			0x168d</span>
<span class="cp">#define CHIP_NUM_57840_MF		0x16ab</span>
<span class="cp">#define CHIP_IS_E1(bp)			(CHIP_NUM(bp) == CHIP_NUM_57710)</span>
<span class="cp">#define CHIP_IS_57711(bp)		(CHIP_NUM(bp) == CHIP_NUM_57711)</span>
<span class="cp">#define CHIP_IS_57711E(bp)		(CHIP_NUM(bp) == CHIP_NUM_57711E)</span>
<span class="cp">#define CHIP_IS_57712(bp)		(CHIP_NUM(bp) == CHIP_NUM_57712)</span>
<span class="cp">#define CHIP_IS_57712_MF(bp)		(CHIP_NUM(bp) == CHIP_NUM_57712_MF)</span>
<span class="cp">#define CHIP_IS_57800(bp)		(CHIP_NUM(bp) == CHIP_NUM_57800)</span>
<span class="cp">#define CHIP_IS_57800_MF(bp)		(CHIP_NUM(bp) == CHIP_NUM_57800_MF)</span>
<span class="cp">#define CHIP_IS_57810(bp)		(CHIP_NUM(bp) == CHIP_NUM_57810)</span>
<span class="cp">#define CHIP_IS_57810_MF(bp)		(CHIP_NUM(bp) == CHIP_NUM_57810_MF)</span>
<span class="cp">#define CHIP_IS_57811(bp)		(CHIP_NUM(bp) == CHIP_NUM_57811)</span>
<span class="cp">#define CHIP_IS_57811_MF(bp)		(CHIP_NUM(bp) == CHIP_NUM_57811_MF)</span>
<span class="cp">#define CHIP_IS_57840(bp)		(CHIP_NUM(bp) == CHIP_NUM_57840)</span>
<span class="cp">#define CHIP_IS_57840_MF(bp)		(CHIP_NUM(bp) == CHIP_NUM_57840_MF)</span>
<span class="cp">#define CHIP_IS_E1H(bp)			(CHIP_IS_57711(bp) || \</span>
<span class="cp">					 CHIP_IS_57711E(bp))</span>
<span class="cp">#define CHIP_IS_E2(bp)			(CHIP_IS_57712(bp) || \</span>
<span class="cp">					 CHIP_IS_57712_MF(bp))</span>
<span class="cp">#define CHIP_IS_E3(bp)			(CHIP_IS_57800(bp) || \</span>
<span class="cp">					 CHIP_IS_57800_MF(bp) || \</span>
<span class="cp">					 CHIP_IS_57810(bp) || \</span>
<span class="cp">					 CHIP_IS_57810_MF(bp) || \</span>
<span class="cp">					 CHIP_IS_57811(bp) || \</span>
<span class="cp">					 CHIP_IS_57811_MF(bp) || \</span>
<span class="cp">					 CHIP_IS_57840(bp) || \</span>
<span class="cp">					 CHIP_IS_57840_MF(bp))</span>
<span class="cp">#define CHIP_IS_E1x(bp)			(CHIP_IS_E1((bp)) || CHIP_IS_E1H((bp)))</span>
<span class="cp">#define USES_WARPCORE(bp)		(CHIP_IS_E3(bp))</span>
<span class="cp">#define IS_E1H_OFFSET			(!CHIP_IS_E1(bp))</span>

<span class="cp">#define CHIP_REV_SHIFT			12</span>
<span class="cp">#define CHIP_REV_MASK			(0xF &lt;&lt; CHIP_REV_SHIFT)</span>
<span class="cp">#define CHIP_REV_VAL(bp)		(bp-&gt;common.chip_id &amp; CHIP_REV_MASK)</span>
<span class="cp">#define CHIP_REV_Ax			(0x0 &lt;&lt; CHIP_REV_SHIFT)</span>
<span class="cp">#define CHIP_REV_Bx			(0x1 &lt;&lt; CHIP_REV_SHIFT)</span>
<span class="cm">/* assume maximum 5 revisions */</span>
<span class="cp">#define CHIP_REV_IS_SLOW(bp)		(CHIP_REV_VAL(bp) &gt; 0x00005000)</span>
<span class="cm">/* Emul versions are A=&gt;0xe, B=&gt;0xc, C=&gt;0xa, D=&gt;8, E=&gt;6 */</span>
<span class="cp">#define CHIP_REV_IS_EMUL(bp)		((CHIP_REV_IS_SLOW(bp)) &amp;&amp; \</span>
<span class="cp">					 !(CHIP_REV_VAL(bp) &amp; 0x00001000))</span>
<span class="cm">/* FPGA versions are A=&gt;0xf, B=&gt;0xd, C=&gt;0xb, D=&gt;9, E=&gt;7 */</span>
<span class="cp">#define CHIP_REV_IS_FPGA(bp)		((CHIP_REV_IS_SLOW(bp)) &amp;&amp; \</span>
<span class="cp">					 (CHIP_REV_VAL(bp) &amp; 0x00001000))</span>

<span class="cp">#define CHIP_TIME(bp)			((CHIP_REV_IS_EMUL(bp)) ? 2000 : \</span>
<span class="cp">					((CHIP_REV_IS_FPGA(bp)) ? 200 : 1))</span>

<span class="cp">#define CHIP_METAL(bp)			(bp-&gt;common.chip_id &amp; 0x00000ff0)</span>
<span class="cp">#define CHIP_BOND_ID(bp)		(bp-&gt;common.chip_id &amp; 0x0000000f)</span>
<span class="cp">#define CHIP_REV_SIM(bp)		(((CHIP_REV_MASK - CHIP_REV_VAL(bp)) &gt;&gt;\</span>
<span class="cp">					   (CHIP_REV_SHIFT + 1)) \</span>
<span class="cp">						&lt;&lt; CHIP_REV_SHIFT)</span>
<span class="cp">#define CHIP_REV(bp)			(CHIP_REV_IS_SLOW(bp) ? \</span>
<span class="cp">						CHIP_REV_SIM(bp) :\</span>
<span class="cp">						CHIP_REV_VAL(bp))</span>
<span class="cp">#define CHIP_IS_E3B0(bp)		(CHIP_IS_E3(bp) &amp;&amp; \</span>
<span class="cp">					 (CHIP_REV(bp) == CHIP_REV_Bx))</span>
<span class="cp">#define CHIP_IS_E3A0(bp)		(CHIP_IS_E3(bp) &amp;&amp; \</span>
<span class="cp">					 (CHIP_REV(bp) == CHIP_REV_Ax))</span>

	<span class="kt">int</span>			<span class="n">flash_size</span><span class="p">;</span>
<span class="cp">#define BNX2X_NVRAM_1MB_SIZE			0x20000	</span><span class="cm">/* 1M bit in bytes */</span><span class="cp"></span>
<span class="cp">#define BNX2X_NVRAM_TIMEOUT_COUNT		30000</span>
<span class="cp">#define BNX2X_NVRAM_PAGE_SIZE			256</span>

	<span class="n">u32</span>			<span class="n">shmem_base</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">shmem2_base</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">mf_cfg_base</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">mf2_cfg_base</span><span class="p">;</span>

	<span class="n">u32</span>			<span class="n">hw_config</span><span class="p">;</span>

	<span class="n">u32</span>			<span class="n">bc_ver</span><span class="p">;</span>

	<span class="n">u8</span>			<span class="n">int_block</span><span class="p">;</span>
<span class="cp">#define INT_BLOCK_HC			0</span>
<span class="cp">#define INT_BLOCK_IGU			1</span>
<span class="cp">#define INT_BLOCK_MODE_NORMAL		0</span>
<span class="cp">#define INT_BLOCK_MODE_BW_COMP		2</span>
<span class="cp">#define CHIP_INT_MODE_IS_NBC(bp)		\</span>
<span class="cp">			(!CHIP_IS_E1x(bp) &amp;&amp;	\</span>
<span class="cp">			!((bp)-&gt;common.int_block &amp; INT_BLOCK_MODE_BW_COMP))</span>
<span class="cp">#define CHIP_INT_MODE_IS_BC(bp) (!CHIP_INT_MODE_IS_NBC(bp))</span>

	<span class="n">u8</span>			<span class="n">chip_port_mode</span><span class="p">;</span>
<span class="cp">#define CHIP_4_PORT_MODE			0x0</span>
<span class="cp">#define CHIP_2_PORT_MODE			0x1</span>
<span class="cp">#define CHIP_PORT_MODE_NONE			0x2</span>
<span class="cp">#define CHIP_MODE(bp)			(bp-&gt;common.chip_port_mode)</span>
<span class="cp">#define CHIP_MODE_IS_4_PORT(bp) (CHIP_MODE(bp) == CHIP_4_PORT_MODE)</span>

	<span class="n">u32</span>			<span class="n">boot_mode</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* IGU MSIX STATISTICS on 57712: 64 for VFs; 4 for PFs; 4 for Attentions */</span>
<span class="cp">#define BNX2X_IGU_STAS_MSG_VF_CNT 64</span>
<span class="cp">#define BNX2X_IGU_STAS_MSG_PF_CNT 4</span>

<span class="cm">/* end of common */</span>

<span class="cm">/* port */</span>

<span class="k">struct</span> <span class="n">bnx2x_port</span> <span class="p">{</span>
	<span class="n">u32</span>			<span class="n">pmf</span><span class="p">;</span>

	<span class="n">u32</span>			<span class="n">link_config</span><span class="p">[</span><span class="n">LINK_CONFIG_SIZE</span><span class="p">];</span>

	<span class="n">u32</span>			<span class="n">supported</span><span class="p">[</span><span class="n">LINK_CONFIG_SIZE</span><span class="p">];</span>
<span class="cm">/* link settings - missing defines */</span>
<span class="cp">#define SUPPORTED_2500baseX_Full	(1 &lt;&lt; 15)</span>

	<span class="n">u32</span>			<span class="n">advertising</span><span class="p">[</span><span class="n">LINK_CONFIG_SIZE</span><span class="p">];</span>
<span class="cm">/* link settings - missing defines */</span>
<span class="cp">#define ADVERTISED_2500baseX_Full	(1 &lt;&lt; 15)</span>

	<span class="n">u32</span>			<span class="n">phy_addr</span><span class="p">;</span>

	<span class="cm">/* used to synchronize phy accesses */</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">phy_mutex</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">need_hw_lock</span><span class="p">;</span>

	<span class="n">u32</span>			<span class="n">port_stx</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">nig_stats</span>	<span class="n">old_nig_stats</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* end of port */</span>

<span class="cp">#define STATS_OFFSET32(stat_name) \</span>
<span class="cp">			(offsetof(struct bnx2x_eth_stats, stat_name) / 4)</span>

<span class="cm">/* slow path */</span>

<span class="cm">/* slow path work-queue */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">bnx2x_wq</span><span class="p">;</span>

<span class="cp">#define BNX2X_MAX_NUM_OF_VFS	64</span>
<span class="cp">#define BNX2X_VF_ID_INVALID	0xFF</span>

<span class="cm">/*</span>
<span class="cm"> * The total number of L2 queues, MSIX vectors and HW contexts (CIDs) is</span>
<span class="cm"> * control by the number of fast-path status blocks supported by the</span>
<span class="cm"> * device (HW/FW). Each fast-path status block (FP-SB) aka non-default</span>
<span class="cm"> * status block represents an independent interrupts context that can</span>
<span class="cm"> * serve a regular L2 networking queue. However special L2 queues such</span>
<span class="cm"> * as the FCoE queue do not require a FP-SB and other components like</span>
<span class="cm"> * the CNIC may consume FP-SB reducing the number of possible L2 queues</span>
<span class="cm"> *</span>
<span class="cm"> * If the maximum number of FP-SB available is X then:</span>
<span class="cm"> * a. If CNIC is supported it consumes 1 FP-SB thus the max number of</span>
<span class="cm"> *    regular L2 queues is Y=X-1</span>
<span class="cm"> * b. in MF mode the actual number of L2 queues is Y= (X-1/MF_factor)</span>
<span class="cm"> * c. If the FCoE L2 queue is supported the actual number of L2 queues</span>
<span class="cm"> *    is Y+1</span>
<span class="cm"> * d. The number of irqs (MSIX vectors) is either Y+1 (one extra for</span>
<span class="cm"> *    slow-path interrupts) or Y+2 if CNIC is supported (one additional</span>
<span class="cm"> *    FP interrupt context for the CNIC).</span>
<span class="cm"> * e. The number of HW context (CID count) is always X or X+1 if FCoE</span>
<span class="cm"> *    L2 queue is supported. the cid for the FCoE L2 queue is always X.</span>
<span class="cm"> */</span>

<span class="cm">/* fast-path interrupt contexts E1x */</span>
<span class="cp">#define FP_SB_MAX_E1x		16</span>
<span class="cm">/* fast-path interrupt contexts E2 */</span>
<span class="cp">#define FP_SB_MAX_E2		HC_SB_MAX_SB_E2</span>

<span class="k">union</span> <span class="n">cdu_context</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">eth_context</span> <span class="n">eth</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">pad</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* CDU host DB constants */</span>
<span class="cp">#define CDU_ILT_PAGE_SZ_HW	3</span>
<span class="cp">#define CDU_ILT_PAGE_SZ		(8192 &lt;&lt; CDU_ILT_PAGE_SZ_HW) </span><span class="cm">/* 64K */</span><span class="cp"></span>
<span class="cp">#define ILT_PAGE_CIDS		(CDU_ILT_PAGE_SZ / sizeof(union cdu_context))</span>

<span class="cp">#ifdef BCM_CNIC</span>
<span class="cp">#define CNIC_ISCSI_CID_MAX	256</span>
<span class="cp">#define CNIC_FCOE_CID_MAX	2048</span>
<span class="cp">#define CNIC_CID_MAX		(CNIC_ISCSI_CID_MAX + CNIC_FCOE_CID_MAX)</span>
<span class="cp">#define CNIC_ILT_LINES		DIV_ROUND_UP(CNIC_CID_MAX, ILT_PAGE_CIDS)</span>
<span class="cp">#endif</span>

<span class="cp">#define QM_ILT_PAGE_SZ_HW	0</span>
<span class="cp">#define QM_ILT_PAGE_SZ		(4096 &lt;&lt; QM_ILT_PAGE_SZ_HW) </span><span class="cm">/* 4K */</span><span class="cp"></span>
<span class="cp">#define QM_CID_ROUND		1024</span>

<span class="cp">#ifdef BCM_CNIC</span>
<span class="cm">/* TM (timers) host DB constants */</span>
<span class="cp">#define TM_ILT_PAGE_SZ_HW	0</span>
<span class="cp">#define TM_ILT_PAGE_SZ		(4096 &lt;&lt; TM_ILT_PAGE_SZ_HW) </span><span class="cm">/* 4K */</span><span class="cp"></span>
<span class="cm">/* #define TM_CONN_NUM		(CNIC_STARTING_CID+CNIC_ISCSI_CXT_MAX) */</span>
<span class="cp">#define TM_CONN_NUM		1024</span>
<span class="cp">#define TM_ILT_SZ		(8 * TM_CONN_NUM)</span>
<span class="cp">#define TM_ILT_LINES		DIV_ROUND_UP(TM_ILT_SZ, TM_ILT_PAGE_SZ)</span>

<span class="cm">/* SRC (Searcher) host DB constants */</span>
<span class="cp">#define SRC_ILT_PAGE_SZ_HW	0</span>
<span class="cp">#define SRC_ILT_PAGE_SZ		(4096 &lt;&lt; SRC_ILT_PAGE_SZ_HW) </span><span class="cm">/* 4K */</span><span class="cp"></span>
<span class="cp">#define SRC_HASH_BITS		10</span>
<span class="cp">#define SRC_CONN_NUM		(1 &lt;&lt; SRC_HASH_BITS) </span><span class="cm">/* 1024 */</span><span class="cp"></span>
<span class="cp">#define SRC_ILT_SZ		(sizeof(struct src_ent) * SRC_CONN_NUM)</span>
<span class="cp">#define SRC_T2_SZ		SRC_ILT_SZ</span>
<span class="cp">#define SRC_ILT_LINES		DIV_ROUND_UP(SRC_ILT_SZ, SRC_ILT_PAGE_SZ)</span>

<span class="cp">#endif</span>

<span class="cp">#define MAX_DMAE_C		8</span>

<span class="cm">/* DMA memory not used in fastpath */</span>
<span class="k">struct</span> <span class="n">bnx2x_slowpath</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mac_configuration_cmd</span>		<span class="n">e1x</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">eth_classify_rules_ramrod_data</span>	<span class="n">e2</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">mac_rdata</span><span class="p">;</span>


	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tstorm_eth_mac_filter_config</span>	<span class="n">e1x</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">eth_filter_rules_ramrod_data</span>	<span class="n">e2</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">rx_mode_rdata</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mac_configuration_cmd</span>		<span class="n">e1</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">eth_multicast_rules_ramrod_data</span>  <span class="n">e2</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">mcast_rdata</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">eth_rss_update_ramrod_data</span>	<span class="n">rss_rdata</span><span class="p">;</span>

	<span class="cm">/* Queue State related ramrods are always sent under rtnl_lock */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">client_init_ramrod_data</span>  <span class="n">init_data</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">client_update_ramrod_data</span> <span class="n">update_data</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">q_rdata</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">function_start_data</span>	<span class="n">func_start</span><span class="p">;</span>
		<span class="cm">/* pfc configuration for DCBX ramrod */</span>
		<span class="k">struct</span> <span class="n">flow_control_configuration</span> <span class="n">pfc_config</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">func_rdata</span><span class="p">;</span>

	<span class="cm">/* afex ramrod can not be a part of func_rdata union because these</span>
<span class="cm">	 * events might arrive in parallel to other events from func_rdata.</span>
<span class="cm">	 * Therefore, if they would have been defined in the same union,</span>
<span class="cm">	 * data can get corrupted.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">afex_vif_list_ramrod_data</span> <span class="n">func_afex_rdata</span><span class="p">;</span>

	<span class="cm">/* used by dmae command executer */</span>
	<span class="k">struct</span> <span class="n">dmae_command</span>		<span class="n">dmae</span><span class="p">[</span><span class="n">MAX_DMAE_C</span><span class="p">];</span>

	<span class="n">u32</span>				<span class="n">stats_comp</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">mac_stats</span>			<span class="n">mac_stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nig_stats</span>		<span class="n">nig_stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">host_port_stats</span>		<span class="n">port_stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">host_func_stats</span>		<span class="n">func_stats</span><span class="p">;</span>

	<span class="n">u32</span>				<span class="n">wb_comp</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">wb_data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="k">union</span> <span class="n">drv_info_to_mcp</span>		<span class="n">drv_info_to_mcp</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define bnx2x_sp(bp, var)		(&amp;bp-&gt;slowpath-&gt;var)</span>
<span class="cp">#define bnx2x_sp_mapping(bp, var) \</span>
<span class="cp">		(bp-&gt;slowpath_mapping + offsetof(struct bnx2x_slowpath, var))</span>


<span class="cm">/* attn group wiring */</span>
<span class="cp">#define MAX_DYNAMIC_ATTN_GRPS		8</span>

<span class="k">struct</span> <span class="n">attn_route</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">sig</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">iro</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">base</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">m1</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">m2</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">m3</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hw_context</span> <span class="p">{</span>
	<span class="k">union</span> <span class="n">cdu_context</span> <span class="o">*</span><span class="n">vcxt</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">cxt_mapping</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* forward */</span>
<span class="k">struct</span> <span class="n">bnx2x_ilt</span><span class="p">;</span>


<span class="k">enum</span> <span class="n">bnx2x_recovery_state</span> <span class="p">{</span>
	<span class="n">BNX2X_RECOVERY_DONE</span><span class="p">,</span>
	<span class="n">BNX2X_RECOVERY_INIT</span><span class="p">,</span>
	<span class="n">BNX2X_RECOVERY_WAIT</span><span class="p">,</span>
	<span class="n">BNX2X_RECOVERY_FAILED</span><span class="p">,</span>
	<span class="n">BNX2X_RECOVERY_NIC_LOADING</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Event queue (EQ or event ring) MC hsi</span>
<span class="cm"> * NUM_EQ_PAGES and EQ_DESC_CNT_PAGE must be power of 2</span>
<span class="cm"> */</span>
<span class="cp">#define NUM_EQ_PAGES		1</span>
<span class="cp">#define EQ_DESC_CNT_PAGE	(BCM_PAGE_SIZE / sizeof(union event_ring_elem))</span>
<span class="cp">#define EQ_DESC_MAX_PAGE	(EQ_DESC_CNT_PAGE - 1)</span>
<span class="cp">#define NUM_EQ_DESC		(EQ_DESC_CNT_PAGE * NUM_EQ_PAGES)</span>
<span class="cp">#define EQ_DESC_MASK		(NUM_EQ_DESC - 1)</span>
<span class="cp">#define MAX_EQ_AVAIL		(EQ_DESC_MAX_PAGE * NUM_EQ_PAGES - 2)</span>

<span class="cm">/* depends on EQ_DESC_CNT_PAGE being a power of 2 */</span>
<span class="cp">#define NEXT_EQ_IDX(x)		((((x) &amp; EQ_DESC_MAX_PAGE) == \</span>
<span class="cp">				  (EQ_DESC_MAX_PAGE - 1)) ? (x) + 2 : (x) + 1)</span>

<span class="cm">/* depends on the above and on NUM_EQ_PAGES being a power of 2 */</span>
<span class="cp">#define EQ_DESC(x)		((x) &amp; EQ_DESC_MASK)</span>

<span class="cp">#define BNX2X_EQ_INDEX \</span>
<span class="cp">	(&amp;bp-&gt;def_status_blk-&gt;sp_sb.\</span>
<span class="cp">	index_values[HC_SP_INDEX_EQ_CONS])</span>

<span class="cm">/* This is a data that will be used to create a link report message.</span>
<span class="cm"> * We will keep the data used for the last link report in order</span>
<span class="cm"> * to prevent reporting the same link parameters twice.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bnx2x_link_report_data</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">line_speed</span><span class="p">;</span>			<span class="cm">/* Effective line speed */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">link_report_flags</span><span class="p">;</span><span class="cm">/* BNX2X_LINK_REPORT_XXX flags */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">BNX2X_LINK_REPORT_FD</span><span class="p">,</span>		<span class="cm">/* Full DUPLEX */</span>
	<span class="n">BNX2X_LINK_REPORT_LINK_DOWN</span><span class="p">,</span>
	<span class="n">BNX2X_LINK_REPORT_RX_FC_ON</span><span class="p">,</span>
	<span class="n">BNX2X_LINK_REPORT_TX_FC_ON</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">BNX2X_PORT_QUERY_IDX</span><span class="p">,</span>
	<span class="n">BNX2X_PF_QUERY_IDX</span><span class="p">,</span>
	<span class="n">BNX2X_FCOE_QUERY_IDX</span><span class="p">,</span>
	<span class="n">BNX2X_FIRST_QUEUE_QUERY_IDX</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">bnx2x_fw_stats_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">stats_query_header</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">stats_query_entry</span> <span class="n">query</span><span class="p">[</span><span class="n">FP_SB_MAX_E1x</span><span class="o">+</span>
		<span class="n">BNX2X_FIRST_QUEUE_QUERY_IDX</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">bnx2x_fw_stats_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">stats_counter</span>	<span class="n">storm_counters</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">per_port_stats</span>	<span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">per_pf_stats</span>	<span class="n">pf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_statistics_params</span>	<span class="n">fcoe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">per_queue_stats</span>  <span class="n">queue_stats</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* Public slow path states */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">BNX2X_SP_RTNL_SETUP_TC</span><span class="p">,</span>
	<span class="n">BNX2X_SP_RTNL_TX_TIMEOUT</span><span class="p">,</span>
	<span class="n">BNX2X_SP_RTNL_AFEX_F_UPDATE</span><span class="p">,</span>
	<span class="n">BNX2X_SP_RTNL_FAN_FAILURE</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">bnx2x_prev_path_list</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">bus</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">slot</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">bnx2x</span> <span class="p">{</span>
	<span class="cm">/* Fields used in the tx and intr/napi performance paths</span>
<span class="cm">	 * are grouped together in the beginning of the structure</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">bnx2x_fastpath</span>	<span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">regview</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">doorbells</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">db_size</span><span class="p">;</span>

	<span class="n">u8</span>			<span class="n">pf_num</span><span class="p">;</span>	<span class="cm">/* absolute PF number */</span>
	<span class="n">u8</span>			<span class="n">pfid</span><span class="p">;</span>	<span class="cm">/* per-path PF number */</span>
	<span class="kt">int</span>			<span class="n">base_fw_ndsb</span><span class="p">;</span> <span class="cm">/**/</span>
<span class="cp">#define BP_PATH(bp)			(CHIP_IS_E1x(bp) ? 0 : (bp-&gt;pf_num &amp; 1))</span>
<span class="cp">#define BP_PORT(bp)			(bp-&gt;pfid &amp; 1)</span>
<span class="cp">#define BP_FUNC(bp)			(bp-&gt;pfid)</span>
<span class="cp">#define BP_ABS_FUNC(bp)			(bp-&gt;pf_num)</span>
<span class="cp">#define BP_VN(bp)			((bp)-&gt;pfid &gt;&gt; 1)</span>
<span class="cp">#define BP_MAX_VN_NUM(bp)		(CHIP_MODE_IS_4_PORT(bp) ? 2 : 4)</span>
<span class="cp">#define BP_L_ID(bp)			(BP_VN(bp) &lt;&lt; 2)</span>
<span class="cp">#define BP_FW_MB_IDX_VN(bp, vn)		(BP_PORT(bp) +\</span>
<span class="cp">	  (vn) * ((CHIP_IS_E1x(bp) || (CHIP_MODE_IS_4_PORT(bp))) ? 2  : 1))</span>
<span class="cp">#define BP_FW_MB_IDX(bp)		BP_FW_MB_IDX_VN(bp, BP_VN(bp))</span>

	<span class="k">struct</span> <span class="n">net_device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span>		<span class="o">*</span><span class="n">pdev</span><span class="p">;</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">iro</span>	<span class="o">*</span><span class="n">iro_arr</span><span class="p">;</span>
<span class="cp">#define IRO (bp-&gt;iro_arr)</span>

	<span class="k">enum</span> <span class="n">bnx2x_recovery_state</span> <span class="n">recovery_state</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">is_leader</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msix_entry</span>	<span class="o">*</span><span class="n">msix_table</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">tx_ring_size</span><span class="p">;</span>

<span class="cm">/* L2 header size + 2*VLANs (8 bytes) + LLC SNAP (8 bytes) */</span>
<span class="cp">#define ETH_OVREHEAD		(ETH_HLEN + 8 + 8)</span>
<span class="cp">#define ETH_MIN_PACKET_SIZE		60</span>
<span class="cp">#define ETH_MAX_PACKET_SIZE		1500</span>
<span class="cp">#define ETH_MAX_JUMBO_PACKET_SIZE	9600</span>
<span class="cm">/* TCP with Timestamp Option (32) + IPv6 (40) */</span>
<span class="cp">#define ETH_MAX_TPA_HEADER_SIZE		72</span>

	<span class="cm">/* Max supported alignment is 256 (8 shift) */</span>
<span class="cp">#define BNX2X_RX_ALIGN_SHIFT		min(8, L1_CACHE_SHIFT)</span>

	<span class="cm">/* FW uses 2 Cache lines Alignment for start packet and size</span>
<span class="cm">	 *</span>
<span class="cm">	 * We assume skb_build() uses sizeof(struct skb_shared_info) bytes</span>
<span class="cm">	 * at the end of skb-&gt;data, to avoid wasting a full cache line.</span>
<span class="cm">	 * This reduces memory use (skb-&gt;truesize).</span>
<span class="cm">	 */</span>
<span class="cp">#define BNX2X_FW_RX_ALIGN_START	(1UL &lt;&lt; BNX2X_RX_ALIGN_SHIFT)</span>

<span class="cp">#define BNX2X_FW_RX_ALIGN_END					\</span>
<span class="cp">	max(1UL &lt;&lt; BNX2X_RX_ALIGN_SHIFT, 			\</span>
<span class="cp">	    SKB_DATA_ALIGN(sizeof(struct skb_shared_info)))</span>

<span class="cp">#define BNX2X_PXP_DRAM_ALIGN		(BNX2X_RX_ALIGN_SHIFT - 5)</span>

	<span class="k">struct</span> <span class="n">host_sp_status_block</span> <span class="o">*</span><span class="n">def_status_blk</span><span class="p">;</span>
<span class="cp">#define DEF_SB_IGU_ID			16</span>
<span class="cp">#define DEF_SB_ID			HC_SP_SB_ID</span>
	<span class="n">__le16</span>			<span class="n">def_idx</span><span class="p">;</span>
	<span class="n">__le16</span>			<span class="n">def_att_idx</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">attn_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">attn_route</span>	<span class="n">attn_group</span><span class="p">[</span><span class="n">MAX_DYNAMIC_ATTN_GRPS</span><span class="p">];</span>

	<span class="cm">/* slow path ring */</span>
	<span class="k">struct</span> <span class="n">eth_spe</span>		<span class="o">*</span><span class="n">spq</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">spq_mapping</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">spq_prod_idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eth_spe</span>		<span class="o">*</span><span class="n">spq_prod_bd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eth_spe</span>		<span class="o">*</span><span class="n">spq_last_bd</span><span class="p">;</span>
	<span class="n">__le16</span>			<span class="o">*</span><span class="n">dsb_sp_prod</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">cq_spq_left</span><span class="p">;</span> <span class="cm">/* ETH_XXX ramrods credit */</span>
	<span class="cm">/* used to synchronize spq accesses */</span>
	<span class="n">spinlock_t</span>		<span class="n">spq_lock</span><span class="p">;</span>

	<span class="cm">/* event queue */</span>
	<span class="k">union</span> <span class="n">event_ring_elem</span>	<span class="o">*</span><span class="n">eq_ring</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">eq_mapping</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">eq_prod</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">eq_cons</span><span class="p">;</span>
	<span class="n">__le16</span>			<span class="o">*</span><span class="n">eq_cons_sb</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">eq_spq_left</span><span class="p">;</span> <span class="cm">/* COMMON_XXX ramrods credit */</span>



	<span class="cm">/* Counter for marking that there is a STAT_QUERY ramrod pending */</span>
	<span class="n">u16</span>			<span class="n">stats_pending</span><span class="p">;</span>
	<span class="cm">/*  Counter for completed statistics ramrods */</span>
	<span class="n">u16</span>			<span class="n">stats_comp</span><span class="p">;</span>

	<span class="cm">/* End of fields used in the performance code paths */</span>

	<span class="kt">int</span>			<span class="n">panic</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">msg_enable</span><span class="p">;</span>

	<span class="n">u32</span>			<span class="n">flags</span><span class="p">;</span>
<span class="cp">#define PCIX_FLAG			(1 &lt;&lt; 0)</span>
<span class="cp">#define PCI_32BIT_FLAG			(1 &lt;&lt; 1)</span>
<span class="cp">#define ONE_PORT_FLAG			(1 &lt;&lt; 2)</span>
<span class="cp">#define NO_WOL_FLAG			(1 &lt;&lt; 3)</span>
<span class="cp">#define USING_DAC_FLAG			(1 &lt;&lt; 4)</span>
<span class="cp">#define USING_MSIX_FLAG			(1 &lt;&lt; 5)</span>
<span class="cp">#define USING_MSI_FLAG			(1 &lt;&lt; 6)</span>
<span class="cp">#define DISABLE_MSI_FLAG		(1 &lt;&lt; 7)</span>
<span class="cp">#define TPA_ENABLE_FLAG			(1 &lt;&lt; 8)</span>
<span class="cp">#define NO_MCP_FLAG			(1 &lt;&lt; 9)</span>

<span class="cp">#define BP_NOMCP(bp)			(bp-&gt;flags &amp; NO_MCP_FLAG)</span>
<span class="cp">#define GRO_ENABLE_FLAG			(1 &lt;&lt; 10)</span>
<span class="cp">#define MF_FUNC_DIS			(1 &lt;&lt; 11)</span>
<span class="cp">#define OWN_CNIC_IRQ			(1 &lt;&lt; 12)</span>
<span class="cp">#define NO_ISCSI_OOO_FLAG		(1 &lt;&lt; 13)</span>
<span class="cp">#define NO_ISCSI_FLAG			(1 &lt;&lt; 14)</span>
<span class="cp">#define NO_FCOE_FLAG			(1 &lt;&lt; 15)</span>
<span class="cp">#define BC_SUPPORTS_PFC_STATS		(1 &lt;&lt; 17)</span>
<span class="cp">#define USING_SINGLE_MSIX_FLAG		(1 &lt;&lt; 20)</span>

<span class="cp">#define NO_ISCSI(bp)		((bp)-&gt;flags &amp; NO_ISCSI_FLAG)</span>
<span class="cp">#define NO_ISCSI_OOO(bp)	((bp)-&gt;flags &amp; NO_ISCSI_OOO_FLAG)</span>
<span class="cp">#define NO_FCOE(bp)		((bp)-&gt;flags &amp; NO_FCOE_FLAG)</span>

	<span class="kt">int</span>			<span class="n">pm_cap</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">mrrs</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">delayed_work</span>	<span class="n">sp_task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">delayed_work</span>	<span class="n">sp_rtnl_task</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">delayed_work</span>	<span class="n">period_task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">timer</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">current_interval</span><span class="p">;</span>

	<span class="n">u16</span>			<span class="n">fw_seq</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">fw_drv_pulse_wr_seq</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">func_stx</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">link_params</span>	<span class="n">link_params</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">link_vars</span>	<span class="n">link_vars</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">link_cnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bnx2x_link_report_data</span> <span class="n">last_reported_link</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mdio_if_info</span>	<span class="n">mdio</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">bnx2x_common</span>	<span class="n">common</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bnx2x_port</span>	<span class="n">port</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">cmng_init</span>	<span class="n">cmng</span><span class="p">;</span>

	<span class="n">u32</span>			<span class="n">mf_config</span><span class="p">[</span><span class="n">E1HVN_MAX</span><span class="p">];</span>
	<span class="n">u32</span>			<span class="n">mf_ext_config</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">path_has_ovlan</span><span class="p">;</span> <span class="cm">/* E3 */</span>
	<span class="n">u16</span>			<span class="n">mf_ov</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">mf_mode</span><span class="p">;</span>
<span class="cp">#define IS_MF(bp)		(bp-&gt;mf_mode != 0)</span>
<span class="cp">#define IS_MF_SI(bp)		(bp-&gt;mf_mode == MULTI_FUNCTION_SI)</span>
<span class="cp">#define IS_MF_SD(bp)		(bp-&gt;mf_mode == MULTI_FUNCTION_SD)</span>
<span class="cp">#define IS_MF_AFEX(bp)		(bp-&gt;mf_mode == MULTI_FUNCTION_AFEX)</span>

	<span class="n">u8</span>			<span class="n">wol</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">rx_ring_size</span><span class="p">;</span>

	<span class="n">u16</span>			<span class="n">tx_quick_cons_trip_int</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">tx_quick_cons_trip</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">tx_ticks_int</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">tx_ticks</span><span class="p">;</span>

	<span class="n">u16</span>			<span class="n">rx_quick_cons_trip_int</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">rx_quick_cons_trip</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">rx_ticks_int</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">rx_ticks</span><span class="p">;</span>
<span class="cm">/* Maximal coalescing timeout in us */</span>
<span class="cp">#define BNX2X_MAX_COALESCE_TOUT		(0xf0*12)</span>

	<span class="n">u32</span>			<span class="n">lin_cnt</span><span class="p">;</span>

	<span class="n">u16</span>			<span class="n">state</span><span class="p">;</span>
<span class="cp">#define BNX2X_STATE_CLOSED		0</span>
<span class="cp">#define BNX2X_STATE_OPENING_WAIT4_LOAD	0x1000</span>
<span class="cp">#define BNX2X_STATE_OPENING_WAIT4_PORT	0x2000</span>
<span class="cp">#define BNX2X_STATE_OPEN		0x3000</span>
<span class="cp">#define BNX2X_STATE_CLOSING_WAIT4_HALT	0x4000</span>
<span class="cp">#define BNX2X_STATE_CLOSING_WAIT4_DELETE 0x5000</span>

<span class="cp">#define BNX2X_STATE_DIAG		0xe000</span>
<span class="cp">#define BNX2X_STATE_ERROR		0xf000</span>

<span class="cp">#define BNX2X_MAX_PRIORITY		8</span>
<span class="cp">#define BNX2X_MAX_ENTRIES_PER_PRI	16</span>
<span class="cp">#define BNX2X_MAX_COS			3</span>
<span class="cp">#define BNX2X_MAX_TX_COS		2</span>
	<span class="kt">int</span>			<span class="n">num_queues</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">disable_tpa</span><span class="p">;</span>

	<span class="n">u32</span>			<span class="n">rx_mode</span><span class="p">;</span>
<span class="cp">#define BNX2X_RX_MODE_NONE		0</span>
<span class="cp">#define BNX2X_RX_MODE_NORMAL		1</span>
<span class="cp">#define BNX2X_RX_MODE_ALLMULTI		2</span>
<span class="cp">#define BNX2X_RX_MODE_PROMISC		3</span>
<span class="cp">#define BNX2X_MAX_MULTICAST		64</span>

	<span class="n">u8</span>			<span class="n">igu_dsb_id</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">igu_base_sb</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">igu_sb_cnt</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">def_status_blk_mapping</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">bnx2x_slowpath</span>	<span class="o">*</span><span class="n">slowpath</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">slowpath_mapping</span><span class="p">;</span>

	<span class="cm">/* Total number of FW statistics requests */</span>
	<span class="n">u8</span>			<span class="n">fw_stats_num</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is a memory buffer that will contain both statistics</span>
<span class="cm">	 * ramrod request and data.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">fw_stats</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">fw_stats_mapping</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * FW statistics request shortcut (points at the</span>
<span class="cm">	 * beginning of fw_stats buffer).</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">bnx2x_fw_stats_req</span>	<span class="o">*</span><span class="n">fw_stats_req</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>			<span class="n">fw_stats_req_mapping</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">fw_stats_req_sz</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * FW statistics data shortcut (points at the begining of</span>
<span class="cm">	 * fw_stats buffer + fw_stats_req_sz).</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">bnx2x_fw_stats_data</span>	<span class="o">*</span><span class="n">fw_stats_data</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>			<span class="n">fw_stats_data_mapping</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">fw_stats_data_sz</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">hw_context</span>	<span class="n">context</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">bnx2x_ilt</span>	<span class="o">*</span><span class="n">ilt</span><span class="p">;</span>
<span class="cp">#define BP_ILT(bp)		((bp)-&gt;ilt)</span>
<span class="cp">#define ILT_MAX_LINES		256</span>
<span class="cm">/*</span>
<span class="cm"> * Maximum supported number of RSS queues: number of IGU SBs minus one that goes</span>
<span class="cm"> * to CNIC.</span>
<span class="cm"> */</span>
<span class="cp">#define BNX2X_MAX_RSS_COUNT(bp)	((bp)-&gt;igu_sb_cnt - CNIC_PRESENT)</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum CID count that might be required by the bnx2x:</span>
<span class="cm"> * Max Tss * Max_Tx_Multi_Cos + CNIC L2 Clients (FCoE and iSCSI related)</span>
<span class="cm"> */</span>
<span class="cp">#define BNX2X_L2_CID_COUNT(bp)	(MAX_TXQS_PER_COS * BNX2X_MULTI_TX_COS +\</span>
<span class="cp">					NON_ETH_CONTEXT_USE + CNIC_PRESENT)</span>
<span class="cp">#define L2_ILT_LINES(bp)	(DIV_ROUND_UP(BNX2X_L2_CID_COUNT(bp),\</span>
<span class="cp">					ILT_PAGE_CIDS))</span>
<span class="cp">#define BNX2X_DB_SIZE(bp)	(BNX2X_L2_CID_COUNT(bp) * (1 &lt;&lt; BNX2X_DB_SHIFT))</span>

	<span class="kt">int</span>			<span class="n">qm_cid_count</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">dropless_fc</span><span class="p">;</span>

<span class="cp">#ifdef BCM_CNIC</span>
	<span class="n">u32</span>			<span class="n">cnic_flags</span><span class="p">;</span>
<span class="cp">#define BNX2X_CNIC_FLAG_MAC_SET		1</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">t2</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">t2_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cnic_ops</span>	<span class="n">__rcu</span>	<span class="o">*</span><span class="n">cnic_ops</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">cnic_data</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">cnic_tag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cnic_eth_dev</span>	<span class="n">cnic_eth_dev</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">host_hc_status_block</span> <span class="n">cnic_sb</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">cnic_sb_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eth_spe</span>		<span class="o">*</span><span class="n">cnic_kwq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eth_spe</span>		<span class="o">*</span><span class="n">cnic_kwq_prod</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eth_spe</span>		<span class="o">*</span><span class="n">cnic_kwq_cons</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eth_spe</span>		<span class="o">*</span><span class="n">cnic_kwq_last</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">cnic_kwq_pending</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">cnic_spq_pending</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">fip_mac</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">cnic_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bnx2x_vlan_mac_obj</span> <span class="n">iscsi_l2_mac_obj</span><span class="p">;</span>

	<span class="cm">/* Start index of the &quot;special&quot; (CNIC related) L2 cleints */</span>
	<span class="n">u8</span>				<span class="n">cnic_base_cl_id</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="kt">int</span>			<span class="n">dmae_ready</span><span class="p">;</span>
	<span class="cm">/* used to synchronize dmae accesses */</span>
	<span class="n">spinlock_t</span>		<span class="n">dmae_lock</span><span class="p">;</span>

	<span class="cm">/* used to protect the FW mail box */</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">fw_mb_mutex</span><span class="p">;</span>

	<span class="cm">/* used to synchronize stats collecting */</span>
	<span class="kt">int</span>			<span class="n">stats_state</span><span class="p">;</span>

	<span class="cm">/* used for synchronization of concurrent threads statistics handling */</span>
	<span class="n">spinlock_t</span>		<span class="n">stats_lock</span><span class="p">;</span>

	<span class="cm">/* used by dmae command loader */</span>
	<span class="k">struct</span> <span class="n">dmae_command</span>	<span class="n">stats_dmae</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">executer_idx</span><span class="p">;</span>

	<span class="n">u16</span>			<span class="n">stats_counter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bnx2x_eth_stats</span>	<span class="n">eth_stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">host_func_stats</span>		<span class="n">func_stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bnx2x_eth_stats_old</span>	<span class="n">eth_stats_old</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bnx2x_net_stats_old</span>	<span class="n">net_stats_old</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bnx2x_fw_port_stats_old</span>	<span class="n">fw_stats_old</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">stats_init</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">z_stream_s</span>	<span class="o">*</span><span class="n">strm</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">gunzip_buf</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">gunzip_mapping</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">gunzip_outlen</span><span class="p">;</span>
<span class="cp">#define FW_BUF_SIZE			0x8000</span>
<span class="cp">#define GUNZIP_BUF(bp)			(bp-&gt;gunzip_buf)</span>
<span class="cp">#define GUNZIP_PHYS(bp)			(bp-&gt;gunzip_mapping)</span>
<span class="cp">#define GUNZIP_OUTLEN(bp)		(bp-&gt;gunzip_outlen)</span>

	<span class="k">struct</span> <span class="n">raw_op</span>		<span class="o">*</span><span class="n">init_ops</span><span class="p">;</span>
	<span class="cm">/* Init blocks offsets inside init_ops */</span>
	<span class="n">u16</span>			<span class="o">*</span><span class="n">init_ops_offsets</span><span class="p">;</span>
	<span class="cm">/* Data blob - has 32 bit granularity */</span>
	<span class="n">u32</span>			<span class="o">*</span><span class="n">init_data</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">init_mode_flags</span><span class="p">;</span>
<span class="cp">#define INIT_MODE_FLAGS(bp)	(bp-&gt;init_mode_flags)</span>
	<span class="cm">/* Zipped PRAM blobs - raw data */</span>
	<span class="k">const</span> <span class="n">u8</span>		<span class="o">*</span><span class="n">tsem_int_table_data</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span>		<span class="o">*</span><span class="n">tsem_pram_data</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span>		<span class="o">*</span><span class="n">usem_int_table_data</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span>		<span class="o">*</span><span class="n">usem_pram_data</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span>		<span class="o">*</span><span class="n">xsem_int_table_data</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span>		<span class="o">*</span><span class="n">xsem_pram_data</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span>		<span class="o">*</span><span class="n">csem_int_table_data</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span>		<span class="o">*</span><span class="n">csem_pram_data</span><span class="p">;</span>
<span class="cp">#define INIT_OPS(bp)			(bp-&gt;init_ops)</span>
<span class="cp">#define INIT_OPS_OFFSETS(bp)		(bp-&gt;init_ops_offsets)</span>
<span class="cp">#define INIT_DATA(bp)			(bp-&gt;init_data)</span>
<span class="cp">#define INIT_TSEM_INT_TABLE_DATA(bp)	(bp-&gt;tsem_int_table_data)</span>
<span class="cp">#define INIT_TSEM_PRAM_DATA(bp)		(bp-&gt;tsem_pram_data)</span>
<span class="cp">#define INIT_USEM_INT_TABLE_DATA(bp)	(bp-&gt;usem_int_table_data)</span>
<span class="cp">#define INIT_USEM_PRAM_DATA(bp)		(bp-&gt;usem_pram_data)</span>
<span class="cp">#define INIT_XSEM_INT_TABLE_DATA(bp)	(bp-&gt;xsem_int_table_data)</span>
<span class="cp">#define INIT_XSEM_PRAM_DATA(bp)		(bp-&gt;xsem_pram_data)</span>
<span class="cp">#define INIT_CSEM_INT_TABLE_DATA(bp)	(bp-&gt;csem_int_table_data)</span>
<span class="cp">#define INIT_CSEM_PRAM_DATA(bp)		(bp-&gt;csem_pram_data)</span>

<span class="cp">#define PHY_FW_VER_LEN			20</span>
	<span class="kt">char</span>			<span class="n">fw_ver</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span>	<span class="o">*</span><span class="n">firmware</span><span class="p">;</span>

	<span class="cm">/* DCB support on/off */</span>
	<span class="n">u16</span> <span class="n">dcb_state</span><span class="p">;</span>
<span class="cp">#define BNX2X_DCB_STATE_OFF			0</span>
<span class="cp">#define BNX2X_DCB_STATE_ON			1</span>

	<span class="cm">/* DCBX engine mode */</span>
	<span class="kt">int</span> <span class="n">dcbx_enabled</span><span class="p">;</span>
<span class="cp">#define BNX2X_DCBX_ENABLED_OFF			0</span>
<span class="cp">#define BNX2X_DCBX_ENABLED_ON_NEG_OFF		1</span>
<span class="cp">#define BNX2X_DCBX_ENABLED_ON_NEG_ON		2</span>
<span class="cp">#define BNX2X_DCBX_ENABLED_INVALID		(-1)</span>

	<span class="n">bool</span> <span class="n">dcbx_mode_uset</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">bnx2x_config_dcbx_params</span>		<span class="n">dcbx_config_params</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bnx2x_dcbx_port_params</span>		<span class="n">dcbx_port_params</span><span class="p">;</span>
	<span class="kt">int</span>					<span class="n">dcb_version</span><span class="p">;</span>

	<span class="cm">/* CAM credit pools */</span>
	<span class="k">struct</span> <span class="n">bnx2x_credit_pool_obj</span>		<span class="n">macs_pool</span><span class="p">;</span>

	<span class="cm">/* RX_MODE object */</span>
	<span class="k">struct</span> <span class="n">bnx2x_rx_mode_obj</span>		<span class="n">rx_mode_obj</span><span class="p">;</span>

	<span class="cm">/* MCAST object */</span>
	<span class="k">struct</span> <span class="n">bnx2x_mcast_obj</span>			<span class="n">mcast_obj</span><span class="p">;</span>

	<span class="cm">/* RSS configuration object */</span>
	<span class="k">struct</span> <span class="n">bnx2x_rss_config_obj</span>		<span class="n">rss_conf_obj</span><span class="p">;</span>

	<span class="cm">/* Function State controlling object */</span>
	<span class="k">struct</span> <span class="n">bnx2x_func_sp_obj</span>		<span class="n">func_obj</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>				<span class="n">sp_state</span><span class="p">;</span>

	<span class="cm">/* operation indication for the sp_rtnl task */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>				<span class="n">sp_rtnl_state</span><span class="p">;</span>

	<span class="cm">/* DCBX Negotation results */</span>
	<span class="k">struct</span> <span class="n">dcbx_features</span>			<span class="n">dcbx_local_feat</span><span class="p">;</span>
	<span class="n">u32</span>					<span class="n">dcbx_error</span><span class="p">;</span>

<span class="cp">#ifdef BCM_DCBNL</span>
	<span class="k">struct</span> <span class="n">dcbx_features</span>			<span class="n">dcbx_remote_feat</span><span class="p">;</span>
	<span class="n">u32</span>					<span class="n">dcbx_remote_flags</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/* AFEX: store default vlan used */</span>
	<span class="kt">int</span>					<span class="n">afex_def_vlan_tag</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">mf_cfg_afex_vlan_mode</span>		<span class="n">afex_vlan_mode</span><span class="p">;</span>
	<span class="n">u32</span>					<span class="n">pending_max</span><span class="p">;</span>

	<span class="cm">/* multiple tx classes of service */</span>
	<span class="n">u8</span>					<span class="n">max_cos</span><span class="p">;</span>

	<span class="cm">/* priority to cos mapping */</span>
	<span class="n">u8</span>					<span class="n">prio_to_cos</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* Tx queues may be less or equal to Rx queues */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">num_queues</span><span class="p">;</span>
<span class="cp">#define BNX2X_NUM_QUEUES(bp)	(bp-&gt;num_queues)</span>
<span class="cp">#define BNX2X_NUM_ETH_QUEUES(bp) (BNX2X_NUM_QUEUES(bp) - NON_ETH_CONTEXT_USE)</span>
<span class="cp">#define BNX2X_NUM_RX_QUEUES(bp)	BNX2X_NUM_QUEUES(bp)</span>

<span class="cp">#define is_multi(bp)		(BNX2X_NUM_QUEUES(bp) &gt; 1)</span>

<span class="cp">#define BNX2X_MAX_QUEUES(bp)	BNX2X_MAX_RSS_COUNT(bp)</span>
<span class="cm">/* #define is_eth_multi(bp)	(BNX2X_NUM_ETH_QUEUES(bp) &gt; 1) */</span>

<span class="cp">#define RSS_IPV4_CAP_MASK						\</span>
<span class="cp">	TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV4_CAPABILITY</span>

<span class="cp">#define RSS_IPV4_TCP_CAP_MASK						\</span>
<span class="cp">	TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV4_TCP_CAPABILITY</span>

<span class="cp">#define RSS_IPV6_CAP_MASK						\</span>
<span class="cp">	TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV6_CAPABILITY</span>

<span class="cp">#define RSS_IPV6_TCP_CAP_MASK						\</span>
<span class="cp">	TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV6_TCP_CAPABILITY</span>

<span class="cm">/* func init flags */</span>
<span class="cp">#define FUNC_FLG_RSS		0x0001</span>
<span class="cp">#define FUNC_FLG_STATS		0x0002</span>
<span class="cm">/* removed  FUNC_FLG_UNMATCHED	0x0004 */</span>
<span class="cp">#define FUNC_FLG_TPA		0x0008</span>
<span class="cp">#define FUNC_FLG_SPQ		0x0010</span>
<span class="cp">#define FUNC_FLG_LEADING	0x0020	</span><span class="cm">/* PF only */</span><span class="cp"></span>


<span class="k">struct</span> <span class="n">bnx2x_func_init_params</span> <span class="p">{</span>
	<span class="cm">/* dma */</span>
	<span class="n">dma_addr_t</span>	<span class="n">fw_stat_map</span><span class="p">;</span>	<span class="cm">/* valid iff FUNC_FLG_STATS */</span>
	<span class="n">dma_addr_t</span>	<span class="n">spq_map</span><span class="p">;</span>	<span class="cm">/* valid iff FUNC_FLG_SPQ */</span>

	<span class="n">u16</span>		<span class="n">func_flgs</span><span class="p">;</span>
	<span class="n">u16</span>		<span class="n">func_id</span><span class="p">;</span>	<span class="cm">/* abs fid */</span>
	<span class="n">u16</span>		<span class="n">pf_id</span><span class="p">;</span>
	<span class="n">u16</span>		<span class="n">spq_prod</span><span class="p">;</span>	<span class="cm">/* valid iff FUNC_FLG_SPQ */</span>
<span class="p">};</span>

<span class="cp">#define for_each_eth_queue(bp, var) \</span>
<span class="cp">	for ((var) = 0; (var) &lt; BNX2X_NUM_ETH_QUEUES(bp); (var)++)</span>

<span class="cp">#define for_each_nondefault_eth_queue(bp, var) \</span>
<span class="cp">	for ((var) = 1; (var) &lt; BNX2X_NUM_ETH_QUEUES(bp); (var)++)</span>

<span class="cp">#define for_each_queue(bp, var) \</span>
<span class="cp">	for ((var) = 0; (var) &lt; BNX2X_NUM_QUEUES(bp); (var)++) \</span>
<span class="cp">		if (skip_queue(bp, var))	\</span>
<span class="cp">			continue;		\</span>
<span class="cp">		else</span>

<span class="cm">/* Skip forwarding FP */</span>
<span class="cp">#define for_each_rx_queue(bp, var) \</span>
<span class="cp">	for ((var) = 0; (var) &lt; BNX2X_NUM_QUEUES(bp); (var)++) \</span>
<span class="cp">		if (skip_rx_queue(bp, var))	\</span>
<span class="cp">			continue;		\</span>
<span class="cp">		else</span>

<span class="cm">/* Skip OOO FP */</span>
<span class="cp">#define for_each_tx_queue(bp, var) \</span>
<span class="cp">	for ((var) = 0; (var) &lt; BNX2X_NUM_QUEUES(bp); (var)++) \</span>
<span class="cp">		if (skip_tx_queue(bp, var))	\</span>
<span class="cp">			continue;		\</span>
<span class="cp">		else</span>

<span class="cp">#define for_each_nondefault_queue(bp, var) \</span>
<span class="cp">	for ((var) = 1; (var) &lt; BNX2X_NUM_QUEUES(bp); (var)++) \</span>
<span class="cp">		if (skip_queue(bp, var))	\</span>
<span class="cp">			continue;		\</span>
<span class="cp">		else</span>

<span class="cp">#define for_each_cos_in_tx_queue(fp, var) \</span>
<span class="cp">	for ((var) = 0; (var) &lt; (fp)-&gt;max_cos; (var)++)</span>

<span class="cm">/* skip rx queue</span>
<span class="cm"> * if FCOE l2 support is disabled and this is the fcoe L2 queue</span>
<span class="cm"> */</span>
<span class="cp">#define skip_rx_queue(bp, idx)	(NO_FCOE(bp) &amp;&amp; IS_FCOE_IDX(idx))</span>

<span class="cm">/* skip tx queue</span>
<span class="cm"> * if FCOE l2 support is disabled and this is the fcoe L2 queue</span>
<span class="cm"> */</span>
<span class="cp">#define skip_tx_queue(bp, idx)	(NO_FCOE(bp) &amp;&amp; IS_FCOE_IDX(idx))</span>

<span class="cp">#define skip_queue(bp, idx)	(NO_FCOE(bp) &amp;&amp; IS_FCOE_IDX(idx))</span>




<span class="cm">/**</span>
<span class="cm"> * bnx2x_set_mac_one - configure a single MAC address</span>
<span class="cm"> *</span>
<span class="cm"> * @bp:			driver handle</span>
<span class="cm"> * @mac:		MAC to configure</span>
<span class="cm"> * @obj:		MAC object handle</span>
<span class="cm"> * @set:		if &#39;true&#39; add a new MAC, otherwise - delete</span>
<span class="cm"> * @mac_type:		the type of the MAC to configure (e.g. ETH, UC list)</span>
<span class="cm"> * @ramrod_flags:	RAMROD_XXX flags (e.g. RAMROD_CONT, RAMROD_COMP_WAIT)</span>
<span class="cm"> *</span>
<span class="cm"> * Configures one MAC according to provided parameters or continues the</span>
<span class="cm"> * execution of previously scheduled commands if RAMROD_CONT is set in</span>
<span class="cm"> * ramrod_flags.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero if operation has successfully completed, a positive value if the</span>
<span class="cm"> * operation has been successfully scheduled and a negative - if a requested</span>
<span class="cm"> * operations has failed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">bnx2x_set_mac_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">bnx2x_vlan_mac_obj</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">bool</span> <span class="n">set</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">mac_type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ramrod_flags</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * Deletes all MACs configured for the specific MAC object.</span>
<span class="cm"> *</span>
<span class="cm"> * @param bp Function driver instance</span>
<span class="cm"> * @param mac_obj MAC object to cleanup</span>
<span class="cm"> *</span>
<span class="cm"> * @return zero if all MACs were cleaned</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * bnx2x_del_all_macs - delete all MACs configured for the specific MAC object</span>
<span class="cm"> *</span>
<span class="cm"> * @bp:			driver handle</span>
<span class="cm"> * @mac_obj:		MAC object handle</span>
<span class="cm"> * @mac_type:		type of the MACs to clear (BNX2X_XXX_MAC)</span>
<span class="cm"> * @wait_for_comp:	if &#39;true&#39; block until completion</span>
<span class="cm"> *</span>
<span class="cm"> * Deletes all MACs of the specific type (e.g. ETH, UC list).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero if operation has successfully completed, a positive value if the</span>
<span class="cm"> * operation has been successfully scheduled and a negative - if a requested</span>
<span class="cm"> * operations has failed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">bnx2x_del_all_macs</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">bnx2x_vlan_mac_obj</span> <span class="o">*</span><span class="n">mac_obj</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">mac_type</span><span class="p">,</span> <span class="n">bool</span> <span class="n">wait_for_comp</span><span class="p">);</span>

<span class="cm">/* Init Function API  */</span>
<span class="kt">void</span> <span class="n">bnx2x_func_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bnx2x_func_init_params</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">bnx2x_get_gpio</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gpio_num</span><span class="p">,</span> <span class="n">u8</span> <span class="n">port</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">bnx2x_set_gpio</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gpio_num</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mode</span><span class="p">,</span> <span class="n">u8</span> <span class="n">port</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">bnx2x_set_mult_gpio</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">u8</span> <span class="n">pins</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">bnx2x_set_gpio_int</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gpio_num</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mode</span><span class="p">,</span> <span class="n">u8</span> <span class="n">port</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bnx2x_read_mf_cfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">);</span>


<span class="cm">/* dmae */</span>
<span class="kt">void</span> <span class="n">bnx2x_read_dmae</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">u32</span> <span class="n">src_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len32</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bnx2x_write_dmae</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dst_addr</span><span class="p">,</span>
		      <span class="n">u32</span> <span class="n">len32</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bnx2x_post_dmae</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dmae_command</span> <span class="o">*</span><span class="n">dmae</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">bnx2x_dmae_opcode_add_comp</span><span class="p">(</span><span class="n">u32</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">u8</span> <span class="n">comp_type</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">bnx2x_dmae_opcode_clr_src_reset</span><span class="p">(</span><span class="n">u32</span> <span class="n">opcode</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">bnx2x_dmae_opcode</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">u8</span> <span class="n">src_type</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dst_type</span><span class="p">,</span>
		      <span class="n">bool</span> <span class="n">with_comp</span><span class="p">,</span> <span class="n">u8</span> <span class="n">comp_type</span><span class="p">);</span>


<span class="kt">void</span> <span class="n">bnx2x_calc_fc_adv</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">bnx2x_sp_post</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">command</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cid</span><span class="p">,</span>
		  <span class="n">u32</span> <span class="n">data_hi</span><span class="p">,</span> <span class="n">u32</span> <span class="n">data_lo</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd_type</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bnx2x_update_coalesce</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">bnx2x_get_cur_phy_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">reg_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">expected</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ms</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">REG_RD</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">expected</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ms</span> <span class="o">-=</span> <span class="n">wait</span><span class="p">;</span>
		<span class="n">msleep</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ms</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define BNX2X_ILT_ZALLOC(x, y, size) \</span>
<span class="cp">	do { \</span>
<span class="cp">		x = dma_alloc_coherent(&amp;bp-&gt;pdev-&gt;dev, size, y, GFP_KERNEL); \</span>
<span class="cp">		if (x) \</span>
<span class="cp">			memset(x, 0, size); \</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define BNX2X_ILT_FREE(x, y, size) \</span>
<span class="cp">	do { \</span>
<span class="cp">		if (x) { \</span>
<span class="cp">			dma_free_coherent(&amp;bp-&gt;pdev-&gt;dev, size, x, y); \</span>
<span class="cp">			x = NULL; \</span>
<span class="cp">			y = 0; \</span>
<span class="cp">		} \</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define ILOG2(x)	(ilog2((x)))</span>

<span class="cp">#define ILT_NUM_PAGE_ENTRIES	(3072)</span>
<span class="cm">/* In 57710/11 we use whole table since we have 8 func</span>
<span class="cm"> * In 57712 we have only 4 func, but use same size per func, then only half of</span>
<span class="cm"> * the table in use</span>
<span class="cm"> */</span>
<span class="cp">#define ILT_PER_FUNC		(ILT_NUM_PAGE_ENTRIES/8)</span>

<span class="cp">#define FUNC_ILT_BASE(func)	(func * ILT_PER_FUNC)</span>
<span class="cm">/*</span>
<span class="cm"> * the phys address is shifted right 12 bits and has an added</span>
<span class="cm"> * 1=valid bit added to the 53rd bit</span>
<span class="cm"> * then since this is a wide register(TM)</span>
<span class="cm"> * we split it into two 32 bit writes</span>
<span class="cm"> */</span>
<span class="cp">#define ONCHIP_ADDR1(x)		((u32)(((u64)x &gt;&gt; 12) &amp; 0xFFFFFFFF))</span>
<span class="cp">#define ONCHIP_ADDR2(x)		((u32)((1 &lt;&lt; 20) | ((u64)x &gt;&gt; 44)))</span>

<span class="cm">/* load/unload mode */</span>
<span class="cp">#define LOAD_NORMAL			0</span>
<span class="cp">#define LOAD_OPEN			1</span>
<span class="cp">#define LOAD_DIAG			2</span>
<span class="cp">#define UNLOAD_NORMAL			0</span>
<span class="cp">#define UNLOAD_CLOSE			1</span>
<span class="cp">#define UNLOAD_RECOVERY			2</span>


<span class="cm">/* DMAE command defines */</span>
<span class="cp">#define DMAE_TIMEOUT			-1</span>
<span class="cp">#define DMAE_PCI_ERROR			-2	</span><span class="cm">/* E2 and onward */</span><span class="cp"></span>
<span class="cp">#define DMAE_NOT_RDY			-3</span>
<span class="cp">#define DMAE_PCI_ERR_FLAG		0x80000000</span>

<span class="cp">#define DMAE_SRC_PCI			0</span>
<span class="cp">#define DMAE_SRC_GRC			1</span>

<span class="cp">#define DMAE_DST_NONE			0</span>
<span class="cp">#define DMAE_DST_PCI			1</span>
<span class="cp">#define DMAE_DST_GRC			2</span>

<span class="cp">#define DMAE_COMP_PCI			0</span>
<span class="cp">#define DMAE_COMP_GRC			1</span>

<span class="cm">/* E2 and onward - PCI error handling in the completion */</span>

<span class="cp">#define DMAE_COMP_REGULAR		0</span>
<span class="cp">#define DMAE_COM_SET_ERR		1</span>

<span class="cp">#define DMAE_CMD_SRC_PCI		(DMAE_SRC_PCI &lt;&lt; \</span>
<span class="cp">						DMAE_COMMAND_SRC_SHIFT)</span>
<span class="cp">#define DMAE_CMD_SRC_GRC		(DMAE_SRC_GRC &lt;&lt; \</span>
<span class="cp">						DMAE_COMMAND_SRC_SHIFT)</span>

<span class="cp">#define DMAE_CMD_DST_PCI		(DMAE_DST_PCI &lt;&lt; \</span>
<span class="cp">						DMAE_COMMAND_DST_SHIFT)</span>
<span class="cp">#define DMAE_CMD_DST_GRC		(DMAE_DST_GRC &lt;&lt; \</span>
<span class="cp">						DMAE_COMMAND_DST_SHIFT)</span>

<span class="cp">#define DMAE_CMD_C_DST_PCI		(DMAE_COMP_PCI &lt;&lt; \</span>
<span class="cp">						DMAE_COMMAND_C_DST_SHIFT)</span>
<span class="cp">#define DMAE_CMD_C_DST_GRC		(DMAE_COMP_GRC &lt;&lt; \</span>
<span class="cp">						DMAE_COMMAND_C_DST_SHIFT)</span>

<span class="cp">#define DMAE_CMD_C_ENABLE		DMAE_COMMAND_C_TYPE_ENABLE</span>

<span class="cp">#define DMAE_CMD_ENDIANITY_NO_SWAP	(0 &lt;&lt; DMAE_COMMAND_ENDIANITY_SHIFT)</span>
<span class="cp">#define DMAE_CMD_ENDIANITY_B_SWAP	(1 &lt;&lt; DMAE_COMMAND_ENDIANITY_SHIFT)</span>
<span class="cp">#define DMAE_CMD_ENDIANITY_DW_SWAP	(2 &lt;&lt; DMAE_COMMAND_ENDIANITY_SHIFT)</span>
<span class="cp">#define DMAE_CMD_ENDIANITY_B_DW_SWAP	(3 &lt;&lt; DMAE_COMMAND_ENDIANITY_SHIFT)</span>

<span class="cp">#define DMAE_CMD_PORT_0			0</span>
<span class="cp">#define DMAE_CMD_PORT_1			DMAE_COMMAND_PORT</span>

<span class="cp">#define DMAE_CMD_SRC_RESET		DMAE_COMMAND_SRC_RESET</span>
<span class="cp">#define DMAE_CMD_DST_RESET		DMAE_COMMAND_DST_RESET</span>
<span class="cp">#define DMAE_CMD_E1HVN_SHIFT		DMAE_COMMAND_E1HVN_SHIFT</span>

<span class="cp">#define DMAE_SRC_PF			0</span>
<span class="cp">#define DMAE_SRC_VF			1</span>

<span class="cp">#define DMAE_DST_PF			0</span>
<span class="cp">#define DMAE_DST_VF			1</span>

<span class="cp">#define DMAE_C_SRC			0</span>
<span class="cp">#define DMAE_C_DST			1</span>

<span class="cp">#define DMAE_LEN32_RD_MAX		0x80</span>
<span class="cp">#define DMAE_LEN32_WR_MAX(bp)		(CHIP_IS_E1(bp) ? 0x400 : 0x2000)</span>

<span class="cp">#define DMAE_COMP_VAL			0x60d0d0ae </span><span class="cm">/* E2 and on - upper bit</span>
<span class="cm">							indicates eror */</span><span class="cp"></span>

<span class="cp">#define MAX_DMAE_C_PER_PORT		8</span>
<span class="cp">#define INIT_DMAE_C(bp)			(BP_PORT(bp) * MAX_DMAE_C_PER_PORT + \</span>
<span class="cp">					 BP_VN(bp))</span>
<span class="cp">#define PMF_DMAE_C(bp)			(BP_PORT(bp) * MAX_DMAE_C_PER_PORT + \</span>
<span class="cp">					 E1HVN_MAX)</span>

<span class="cm">/* PCIE link and speed */</span>
<span class="cp">#define PCICFG_LINK_WIDTH		0x1f00000</span>
<span class="cp">#define PCICFG_LINK_WIDTH_SHIFT		20</span>
<span class="cp">#define PCICFG_LINK_SPEED		0xf0000</span>
<span class="cp">#define PCICFG_LINK_SPEED_SHIFT		16</span>


<span class="cp">#define BNX2X_NUM_TESTS			7</span>

<span class="cp">#define BNX2X_PHY_LOOPBACK		0</span>
<span class="cp">#define BNX2X_MAC_LOOPBACK		1</span>
<span class="cp">#define BNX2X_PHY_LOOPBACK_FAILED	1</span>
<span class="cp">#define BNX2X_MAC_LOOPBACK_FAILED	2</span>
<span class="cp">#define BNX2X_LOOPBACK_FAILED		(BNX2X_MAC_LOOPBACK_FAILED | \</span>
<span class="cp">					 BNX2X_PHY_LOOPBACK_FAILED)</span>


<span class="cp">#define STROM_ASSERT_ARRAY_SIZE		50</span>


<span class="cm">/* must be used on a CID before placing it on a HW ring */</span>
<span class="cp">#define HW_CID(bp, x)			((BP_PORT(bp) &lt;&lt; 23) | \</span>
<span class="cp">					 (BP_VN(bp) &lt;&lt; BNX2X_SWCID_SHIFT) | \</span>
<span class="cp">					 (x))</span>

<span class="cp">#define SP_DESC_CNT		(BCM_PAGE_SIZE / sizeof(struct eth_spe))</span>
<span class="cp">#define MAX_SP_DESC_CNT			(SP_DESC_CNT - 1)</span>


<span class="cp">#define BNX2X_BTR			4</span>
<span class="cp">#define MAX_SPQ_PENDING			8</span>

<span class="cm">/* CMNG constants, as derived from system spec calculations */</span>
<span class="cm">/* default MIN rate in case VNIC min rate is configured to zero - 100Mbps */</span>
<span class="cp">#define DEF_MIN_RATE					100</span>
<span class="cm">/* resolution of the rate shaping timer - 400 usec */</span>
<span class="cp">#define RS_PERIODIC_TIMEOUT_USEC			400</span>
<span class="cm">/* number of bytes in single QM arbitration cycle -</span>
<span class="cm"> * coefficient for calculating the fairness timer */</span>
<span class="cp">#define QM_ARB_BYTES					160000</span>
<span class="cm">/* resolution of Min algorithm 1:100 */</span>
<span class="cp">#define MIN_RES						100</span>
<span class="cm">/* how many bytes above threshold for the minimal credit of Min algorithm*/</span>
<span class="cp">#define MIN_ABOVE_THRESH				32768</span>
<span class="cm">/* Fairness algorithm integration time coefficient -</span>
<span class="cm"> * for calculating the actual Tfair */</span>
<span class="cp">#define T_FAIR_COEF	((MIN_ABOVE_THRESH +  QM_ARB_BYTES) * 8 * MIN_RES)</span>
<span class="cm">/* Memory of fairness algorithm . 2 cycles */</span>
<span class="cp">#define FAIR_MEM					2</span>


<span class="cp">#define ATTN_NIG_FOR_FUNC		(1L &lt;&lt; 8)</span>
<span class="cp">#define ATTN_SW_TIMER_4_FUNC		(1L &lt;&lt; 9)</span>
<span class="cp">#define GPIO_2_FUNC			(1L &lt;&lt; 10)</span>
<span class="cp">#define GPIO_3_FUNC			(1L &lt;&lt; 11)</span>
<span class="cp">#define GPIO_4_FUNC			(1L &lt;&lt; 12)</span>
<span class="cp">#define ATTN_GENERAL_ATTN_1		(1L &lt;&lt; 13)</span>
<span class="cp">#define ATTN_GENERAL_ATTN_2		(1L &lt;&lt; 14)</span>
<span class="cp">#define ATTN_GENERAL_ATTN_3		(1L &lt;&lt; 15)</span>
<span class="cp">#define ATTN_GENERAL_ATTN_4		(1L &lt;&lt; 13)</span>
<span class="cp">#define ATTN_GENERAL_ATTN_5		(1L &lt;&lt; 14)</span>
<span class="cp">#define ATTN_GENERAL_ATTN_6		(1L &lt;&lt; 15)</span>

<span class="cp">#define ATTN_HARD_WIRED_MASK		0xff00</span>
<span class="cp">#define ATTENTION_ID			4</span>


<span class="cm">/* stuff added to make the code fit 80Col */</span>

<span class="cp">#define BNX2X_PMF_LINK_ASSERT \</span>
<span class="cp">	GENERAL_ATTEN_OFFSET(LINK_SYNC_ATTENTION_BIT_FUNC_0 + BP_FUNC(bp))</span>

<span class="cp">#define BNX2X_MC_ASSERT_BITS \</span>
<span class="cp">	(GENERAL_ATTEN_OFFSET(TSTORM_FATAL_ASSERT_ATTENTION_BIT) | \</span>
<span class="cp">	 GENERAL_ATTEN_OFFSET(USTORM_FATAL_ASSERT_ATTENTION_BIT) | \</span>
<span class="cp">	 GENERAL_ATTEN_OFFSET(CSTORM_FATAL_ASSERT_ATTENTION_BIT) | \</span>
<span class="cp">	 GENERAL_ATTEN_OFFSET(XSTORM_FATAL_ASSERT_ATTENTION_BIT))</span>

<span class="cp">#define BNX2X_MCP_ASSERT \</span>
<span class="cp">	GENERAL_ATTEN_OFFSET(MCP_FATAL_ASSERT_ATTENTION_BIT)</span>

<span class="cp">#define BNX2X_GRC_TIMEOUT	GENERAL_ATTEN_OFFSET(LATCHED_ATTN_TIMEOUT_GRC)</span>
<span class="cp">#define BNX2X_GRC_RSV		(GENERAL_ATTEN_OFFSET(LATCHED_ATTN_RBCR) | \</span>
<span class="cp">				 GENERAL_ATTEN_OFFSET(LATCHED_ATTN_RBCT) | \</span>
<span class="cp">				 GENERAL_ATTEN_OFFSET(LATCHED_ATTN_RBCN) | \</span>
<span class="cp">				 GENERAL_ATTEN_OFFSET(LATCHED_ATTN_RBCU) | \</span>
<span class="cp">				 GENERAL_ATTEN_OFFSET(LATCHED_ATTN_RBCP) | \</span>
<span class="cp">				 GENERAL_ATTEN_OFFSET(LATCHED_ATTN_RSVD_GRC))</span>

<span class="cp">#define HW_INTERRUT_ASSERT_SET_0 \</span>
<span class="cp">				(AEU_INPUTS_ATTN_BITS_TSDM_HW_INTERRUPT | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_TCM_HW_INTERRUPT | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_TSEMI_HW_INTERRUPT | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_PBCLIENT_HW_INTERRUPT)</span>
<span class="cp">#define HW_PRTY_ASSERT_SET_0	(AEU_INPUTS_ATTN_BITS_BRB_PARITY_ERROR | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_PARSER_PARITY_ERROR | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_TSDM_PARITY_ERROR | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_SEARCHER_PARITY_ERROR |\</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_TSEMI_PARITY_ERROR |\</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_TCM_PARITY_ERROR |\</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_PBCLIENT_PARITY_ERROR)</span>
<span class="cp">#define HW_INTERRUT_ASSERT_SET_1 \</span>
<span class="cp">				(AEU_INPUTS_ATTN_BITS_QM_HW_INTERRUPT | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_TIMERS_HW_INTERRUPT | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_XSDM_HW_INTERRUPT | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_XCM_HW_INTERRUPT | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_XSEMI_HW_INTERRUPT | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_USDM_HW_INTERRUPT | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_UCM_HW_INTERRUPT | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_USEMI_HW_INTERRUPT | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_UPB_HW_INTERRUPT | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_CSDM_HW_INTERRUPT | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_CCM_HW_INTERRUPT)</span>
<span class="cp">#define HW_PRTY_ASSERT_SET_1	(AEU_INPUTS_ATTN_BITS_PBF_PARITY_ERROR |\</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_QM_PARITY_ERROR | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_TIMERS_PARITY_ERROR |\</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_XSDM_PARITY_ERROR | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_XCM_PARITY_ERROR |\</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_XSEMI_PARITY_ERROR | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_DOORBELLQ_PARITY_ERROR |\</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_NIG_PARITY_ERROR |\</span>
<span class="cp">			     AEU_INPUTS_ATTN_BITS_VAUX_PCI_CORE_PARITY_ERROR |\</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_DEBUG_PARITY_ERROR | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_USDM_PARITY_ERROR | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_UCM_PARITY_ERROR |\</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_USEMI_PARITY_ERROR | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_UPB_PARITY_ERROR | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_CSDM_PARITY_ERROR |\</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_CCM_PARITY_ERROR)</span>
<span class="cp">#define HW_INTERRUT_ASSERT_SET_2 \</span>
<span class="cp">				(AEU_INPUTS_ATTN_BITS_CSEMI_HW_INTERRUPT | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_CDU_HW_INTERRUPT | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_DMAE_HW_INTERRUPT | \</span>
<span class="cp">			AEU_INPUTS_ATTN_BITS_PXPPCICLOCKCLIENT_HW_INTERRUPT |\</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_MISC_HW_INTERRUPT)</span>
<span class="cp">#define HW_PRTY_ASSERT_SET_2	(AEU_INPUTS_ATTN_BITS_CSEMI_PARITY_ERROR | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_PXP_PARITY_ERROR | \</span>
<span class="cp">			AEU_INPUTS_ATTN_BITS_PXPPCICLOCKCLIENT_PARITY_ERROR |\</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_CFC_PARITY_ERROR | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_CDU_PARITY_ERROR | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_DMAE_PARITY_ERROR |\</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_IGU_PARITY_ERROR | \</span>
<span class="cp">				 AEU_INPUTS_ATTN_BITS_MISC_PARITY_ERROR)</span>

<span class="cp">#define HW_PRTY_ASSERT_SET_3 (AEU_INPUTS_ATTN_BITS_MCP_LATCHED_ROM_PARITY | \</span>
<span class="cp">		AEU_INPUTS_ATTN_BITS_MCP_LATCHED_UMP_RX_PARITY | \</span>
<span class="cp">		AEU_INPUTS_ATTN_BITS_MCP_LATCHED_UMP_TX_PARITY | \</span>
<span class="cp">		AEU_INPUTS_ATTN_BITS_MCP_LATCHED_SCPAD_PARITY)</span>

<span class="cp">#define HW_PRTY_ASSERT_SET_4 (AEU_INPUTS_ATTN_BITS_PGLUE_PARITY_ERROR | \</span>
<span class="cp">			      AEU_INPUTS_ATTN_BITS_ATC_PARITY_ERROR)</span>

<span class="cp">#define MULTI_MASK			0x7f</span>


<span class="cp">#define DEF_USB_FUNC_OFF	offsetof(struct cstorm_def_status_block_u, func)</span>
<span class="cp">#define DEF_CSB_FUNC_OFF	offsetof(struct cstorm_def_status_block_c, func)</span>
<span class="cp">#define DEF_XSB_FUNC_OFF	offsetof(struct xstorm_def_status_block, func)</span>
<span class="cp">#define DEF_TSB_FUNC_OFF	offsetof(struct tstorm_def_status_block, func)</span>

<span class="cp">#define DEF_USB_IGU_INDEX_OFF \</span>
<span class="cp">			offsetof(struct cstorm_def_status_block_u, igu_index)</span>
<span class="cp">#define DEF_CSB_IGU_INDEX_OFF \</span>
<span class="cp">			offsetof(struct cstorm_def_status_block_c, igu_index)</span>
<span class="cp">#define DEF_XSB_IGU_INDEX_OFF \</span>
<span class="cp">			offsetof(struct xstorm_def_status_block, igu_index)</span>
<span class="cp">#define DEF_TSB_IGU_INDEX_OFF \</span>
<span class="cp">			offsetof(struct tstorm_def_status_block, igu_index)</span>

<span class="cp">#define DEF_USB_SEGMENT_OFF \</span>
<span class="cp">			offsetof(struct cstorm_def_status_block_u, segment)</span>
<span class="cp">#define DEF_CSB_SEGMENT_OFF \</span>
<span class="cp">			offsetof(struct cstorm_def_status_block_c, segment)</span>
<span class="cp">#define DEF_XSB_SEGMENT_OFF \</span>
<span class="cp">			offsetof(struct xstorm_def_status_block, segment)</span>
<span class="cp">#define DEF_TSB_SEGMENT_OFF \</span>
<span class="cp">			offsetof(struct tstorm_def_status_block, segment)</span>

<span class="cp">#define BNX2X_SP_DSB_INDEX \</span>
<span class="cp">		(&amp;bp-&gt;def_status_blk-&gt;sp_sb.\</span>
<span class="cp">					index_values[HC_SP_INDEX_ETH_DEF_CONS])</span>

<span class="cp">#define SET_FLAG(value, mask, flag) \</span>
<span class="cp">	do {\</span>
<span class="cp">		(value) &amp;= ~(mask);\</span>
<span class="cp">		(value) |= ((flag) &lt;&lt; (mask##_SHIFT));\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define GET_FLAG(value, mask) \</span>
<span class="cp">	(((value) &amp; (mask)) &gt;&gt; (mask##_SHIFT))</span>

<span class="cp">#define GET_FIELD(value, fname) \</span>
<span class="cp">	(((value) &amp; (fname##_MASK)) &gt;&gt; (fname##_SHIFT))</span>

<span class="cp">#define CAM_IS_INVALID(x) \</span>
<span class="cp">	(GET_FLAG(x.flags, \</span>
<span class="cp">	MAC_CONFIGURATION_ENTRY_ACTION_TYPE) == \</span>
<span class="cp">	(T_ETH_MAC_COMMAND_INVALIDATE))</span>

<span class="cm">/* Number of u32 elements in MC hash array */</span>
<span class="cp">#define MC_HASH_SIZE			8</span>
<span class="cp">#define MC_HASH_OFFSET(bp, i)		(BAR_TSTRORM_INTMEM + \</span>
<span class="cp">	TSTORM_APPROXIMATE_MATCH_MULTICAST_FILTERING_OFFSET(BP_FUNC(bp)) + i*4)</span>


<span class="cp">#ifndef PXP2_REG_PXP2_INT_STS</span>
<span class="cp">#define PXP2_REG_PXP2_INT_STS		PXP2_REG_PXP2_INT_STS_0</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef ETH_MAX_RX_CLIENTS_E2</span>
<span class="cp">#define ETH_MAX_RX_CLIENTS_E2		ETH_MAX_RX_CLIENTS_E1H</span>
<span class="cp">#endif</span>

<span class="cp">#define BNX2X_VPD_LEN			128</span>
<span class="cp">#define VENDOR_ID_LEN			4</span>

<span class="cm">/* Congestion management fairness mode */</span>
<span class="cp">#define CMNG_FNS_NONE		0</span>
<span class="cp">#define CMNG_FNS_MINMAX		1</span>

<span class="cp">#define HC_SEG_ACCESS_DEF		0   </span><span class="cm">/*Driver decision 0-3*/</span><span class="cp"></span>
<span class="cp">#define HC_SEG_ACCESS_ATTN		4</span>
<span class="cp">#define HC_SEG_ACCESS_NORM		0   </span><span class="cm">/*Driver decision 0-1*/</span><span class="cp"></span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">dmae_reg_go_c</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">DMAE_REG_GO_C0</span><span class="p">,</span> <span class="n">DMAE_REG_GO_C1</span><span class="p">,</span> <span class="n">DMAE_REG_GO_C2</span><span class="p">,</span> <span class="n">DMAE_REG_GO_C3</span><span class="p">,</span>
	<span class="n">DMAE_REG_GO_C4</span><span class="p">,</span> <span class="n">DMAE_REG_GO_C5</span><span class="p">,</span> <span class="n">DMAE_REG_GO_C6</span><span class="p">,</span> <span class="n">DMAE_REG_GO_C7</span><span class="p">,</span>
	<span class="n">DMAE_REG_GO_C8</span><span class="p">,</span> <span class="n">DMAE_REG_GO_C9</span><span class="p">,</span> <span class="n">DMAE_REG_GO_C10</span><span class="p">,</span> <span class="n">DMAE_REG_GO_C11</span><span class="p">,</span>
	<span class="n">DMAE_REG_GO_C12</span><span class="p">,</span> <span class="n">DMAE_REG_GO_C13</span><span class="p">,</span> <span class="n">DMAE_REG_GO_C14</span><span class="p">,</span> <span class="n">DMAE_REG_GO_C15</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">bnx2x_set_ethtool_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bnx2x_notify_link_changed</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">);</span>


<span class="cp">#define BNX2X_MF_SD_PROTOCOL(bp) \</span>
<span class="cp">	((bp)-&gt;mf_config[BP_VN(bp)] &amp; FUNC_MF_CFG_PROTOCOL_MASK)</span>

<span class="cp">#ifdef BCM_CNIC</span>
<span class="cp">#define BNX2X_IS_MF_SD_PROTOCOL_ISCSI(bp) \</span>
<span class="cp">	(BNX2X_MF_SD_PROTOCOL(bp) == FUNC_MF_CFG_PROTOCOL_ISCSI)</span>

<span class="cp">#define BNX2X_IS_MF_SD_PROTOCOL_FCOE(bp) \</span>
<span class="cp">	(BNX2X_MF_SD_PROTOCOL(bp) == FUNC_MF_CFG_PROTOCOL_FCOE)</span>

<span class="cp">#define IS_MF_ISCSI_SD(bp) (IS_MF_SD(bp) &amp;&amp; BNX2X_IS_MF_SD_PROTOCOL_ISCSI(bp))</span>
<span class="cp">#define IS_MF_FCOE_SD(bp) (IS_MF_SD(bp) &amp;&amp; BNX2X_IS_MF_SD_PROTOCOL_FCOE(bp))</span>

<span class="cp">#define BNX2X_MF_EXT_PROTOCOL_FCOE(bp)  ((bp)-&gt;mf_ext_config &amp; \</span>
<span class="cp">					 MACP_FUNC_CFG_FLAGS_FCOE_OFFLOAD)</span>

<span class="cp">#define IS_MF_FCOE_AFEX(bp) (IS_MF_AFEX(bp) &amp;&amp; BNX2X_MF_EXT_PROTOCOL_FCOE(bp))</span>
<span class="cp">#define IS_MF_STORAGE_SD(bp) (IS_MF_SD(bp) &amp;&amp; \</span>
<span class="cp">				(BNX2X_IS_MF_SD_PROTOCOL_ISCSI(bp) || \</span>
<span class="cp">				 BNX2X_IS_MF_SD_PROTOCOL_FCOE(bp)))</span>
<span class="cp">#else</span>
<span class="cp">#define IS_MF_FCOE_AFEX(bp)	false</span>
<span class="cp">#endif</span>


<span class="cp">#endif </span><span class="cm">/* bnx2x.h */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
