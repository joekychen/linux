<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › broadcom › bnx2x › bnx2x_init.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>bnx2x_init.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* bnx2x_init.h: Broadcom Everest network driver.</span>
<span class="cm"> *               Structures and macroes needed during the initialization.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2007-2012 Broadcom Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * Maintained by: Eilon Greenstein &lt;eilong@broadcom.com&gt;</span>
<span class="cm"> * Written by: Eliezer Tamir</span>
<span class="cm"> * Modified by: Vladislav Zolotarov &lt;vladz@broadcom.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#ifndef BNX2X_INIT_H</span>
<span class="cp">#define BNX2X_INIT_H</span>

<span class="cm">/* Init operation types and structures */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">OP_RD</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>	<span class="cm">/* read a single register */</span>
	<span class="n">OP_WR</span><span class="p">,</span>		<span class="cm">/* write a single register */</span>
	<span class="n">OP_SW</span><span class="p">,</span>		<span class="cm">/* copy a string to the device */</span>
	<span class="n">OP_ZR</span><span class="p">,</span>		<span class="cm">/* clear memory */</span>
	<span class="n">OP_ZP</span><span class="p">,</span>		<span class="cm">/* unzip then copy with DMAE */</span>
	<span class="n">OP_WR_64</span><span class="p">,</span>	<span class="cm">/* write 64 bit pattern */</span>
	<span class="n">OP_WB</span><span class="p">,</span>		<span class="cm">/* copy a string using DMAE */</span>
	<span class="n">OP_WB_ZR</span><span class="p">,</span>	<span class="cm">/* Clear a string using DMAE or indirect-wr */</span>
	<span class="cm">/* Skip the following ops if all of the init modes don&#39;t match */</span>
	<span class="n">OP_IF_MODE_OR</span><span class="p">,</span>
	<span class="cm">/* Skip the following ops if any of the init modes don&#39;t match */</span>
	<span class="n">OP_IF_MODE_AND</span><span class="p">,</span>
	<span class="n">OP_MAX</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">STAGE_START</span><span class="p">,</span>
	<span class="n">STAGE_END</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Returns the index of start or end of a specific block stage in ops array*/</span>
<span class="cp">#define BLOCK_OPS_IDX(block, stage, end) \</span>
<span class="cp">	(2*(((block)*NUM_OF_INIT_PHASES) + (stage)) + (end))</span>


<span class="cm">/* structs for the various opcodes */</span>
<span class="k">struct</span> <span class="n">raw_op</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">op</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">offset</span><span class="o">:</span><span class="mi">24</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">raw_data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">op_read</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">op</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">offset</span><span class="o">:</span><span class="mi">24</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">op_write</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">op</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">offset</span><span class="o">:</span><span class="mi">24</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">op_arr_write</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">op</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">offset</span><span class="o">:</span><span class="mi">24</span><span class="p">;</span>
<span class="cp">#ifdef __BIG_ENDIAN</span>
	<span class="n">u16</span> <span class="n">data_len</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data_off</span><span class="p">;</span>
<span class="cp">#else </span><span class="cm">/* __LITTLE_ENDIAN */</span><span class="cp"></span>
	<span class="n">u16</span> <span class="n">data_off</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data_len</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">op_zero</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">op</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">offset</span><span class="o">:</span><span class="mi">24</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">op_if_mode</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">op</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cmd_offset</span><span class="o">:</span><span class="mi">24</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mode_bit_map</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">union</span> <span class="n">init_op</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">op_read</span>		<span class="n">read</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">op_write</span>		<span class="n">write</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">op_arr_write</span>	<span class="n">arr_wr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">op_zero</span>		<span class="n">zero</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">raw_op</span>		<span class="n">raw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">op_if_mode</span>	<span class="n">if_mode</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/* Init Phases */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">PHASE_COMMON</span><span class="p">,</span>
	<span class="n">PHASE_PORT0</span><span class="p">,</span>
	<span class="n">PHASE_PORT1</span><span class="p">,</span>
	<span class="n">PHASE_PF0</span><span class="p">,</span>
	<span class="n">PHASE_PF1</span><span class="p">,</span>
	<span class="n">PHASE_PF2</span><span class="p">,</span>
	<span class="n">PHASE_PF3</span><span class="p">,</span>
	<span class="n">PHASE_PF4</span><span class="p">,</span>
	<span class="n">PHASE_PF5</span><span class="p">,</span>
	<span class="n">PHASE_PF6</span><span class="p">,</span>
	<span class="n">PHASE_PF7</span><span class="p">,</span>
	<span class="n">NUM_OF_INIT_PHASES</span>
<span class="p">};</span>

<span class="cm">/* Init Modes */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">MODE_ASIC</span>                      <span class="o">=</span> <span class="mh">0x00000001</span><span class="p">,</span>
	<span class="n">MODE_FPGA</span>                      <span class="o">=</span> <span class="mh">0x00000002</span><span class="p">,</span>
	<span class="n">MODE_EMUL</span>                      <span class="o">=</span> <span class="mh">0x00000004</span><span class="p">,</span>
	<span class="n">MODE_E2</span>                        <span class="o">=</span> <span class="mh">0x00000008</span><span class="p">,</span>
	<span class="n">MODE_E3</span>                        <span class="o">=</span> <span class="mh">0x00000010</span><span class="p">,</span>
	<span class="n">MODE_PORT2</span>                     <span class="o">=</span> <span class="mh">0x00000020</span><span class="p">,</span>
	<span class="n">MODE_PORT4</span>                     <span class="o">=</span> <span class="mh">0x00000040</span><span class="p">,</span>
	<span class="n">MODE_SF</span>                        <span class="o">=</span> <span class="mh">0x00000080</span><span class="p">,</span>
	<span class="n">MODE_MF</span>                        <span class="o">=</span> <span class="mh">0x00000100</span><span class="p">,</span>
	<span class="n">MODE_MF_SD</span>                     <span class="o">=</span> <span class="mh">0x00000200</span><span class="p">,</span>
	<span class="n">MODE_MF_SI</span>                     <span class="o">=</span> <span class="mh">0x00000400</span><span class="p">,</span>
	<span class="n">MODE_MF_AFEX</span>                   <span class="o">=</span> <span class="mh">0x00000800</span><span class="p">,</span>
	<span class="n">MODE_E3_A0</span>                     <span class="o">=</span> <span class="mh">0x00001000</span><span class="p">,</span>
	<span class="n">MODE_E3_B0</span>                     <span class="o">=</span> <span class="mh">0x00002000</span><span class="p">,</span>
	<span class="n">MODE_COS3</span>                      <span class="o">=</span> <span class="mh">0x00004000</span><span class="p">,</span>
	<span class="n">MODE_COS6</span>                      <span class="o">=</span> <span class="mh">0x00008000</span><span class="p">,</span>
	<span class="n">MODE_LITTLE_ENDIAN</span>             <span class="o">=</span> <span class="mh">0x00010000</span><span class="p">,</span>
	<span class="n">MODE_BIG_ENDIAN</span>                <span class="o">=</span> <span class="mh">0x00020000</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Init Blocks */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">BLOCK_ATC</span><span class="p">,</span>
	<span class="n">BLOCK_BRB1</span><span class="p">,</span>
	<span class="n">BLOCK_CCM</span><span class="p">,</span>
	<span class="n">BLOCK_CDU</span><span class="p">,</span>
	<span class="n">BLOCK_CFC</span><span class="p">,</span>
	<span class="n">BLOCK_CSDM</span><span class="p">,</span>
	<span class="n">BLOCK_CSEM</span><span class="p">,</span>
	<span class="n">BLOCK_DBG</span><span class="p">,</span>
	<span class="n">BLOCK_DMAE</span><span class="p">,</span>
	<span class="n">BLOCK_DORQ</span><span class="p">,</span>
	<span class="n">BLOCK_HC</span><span class="p">,</span>
	<span class="n">BLOCK_IGU</span><span class="p">,</span>
	<span class="n">BLOCK_MISC</span><span class="p">,</span>
	<span class="n">BLOCK_NIG</span><span class="p">,</span>
	<span class="n">BLOCK_PBF</span><span class="p">,</span>
	<span class="n">BLOCK_PGLUE_B</span><span class="p">,</span>
	<span class="n">BLOCK_PRS</span><span class="p">,</span>
	<span class="n">BLOCK_PXP2</span><span class="p">,</span>
	<span class="n">BLOCK_PXP</span><span class="p">,</span>
	<span class="n">BLOCK_QM</span><span class="p">,</span>
	<span class="n">BLOCK_SRC</span><span class="p">,</span>
	<span class="n">BLOCK_TCM</span><span class="p">,</span>
	<span class="n">BLOCK_TM</span><span class="p">,</span>
	<span class="n">BLOCK_TSDM</span><span class="p">,</span>
	<span class="n">BLOCK_TSEM</span><span class="p">,</span>
	<span class="n">BLOCK_UCM</span><span class="p">,</span>
	<span class="n">BLOCK_UPB</span><span class="p">,</span>
	<span class="n">BLOCK_USDM</span><span class="p">,</span>
	<span class="n">BLOCK_USEM</span><span class="p">,</span>
	<span class="n">BLOCK_XCM</span><span class="p">,</span>
	<span class="n">BLOCK_XPB</span><span class="p">,</span>
	<span class="n">BLOCK_XSDM</span><span class="p">,</span>
	<span class="n">BLOCK_XSEM</span><span class="p">,</span>
	<span class="n">BLOCK_MISC_AEU</span><span class="p">,</span>
	<span class="n">NUM_OF_INIT_BLOCKS</span>
<span class="p">};</span>

<span class="cm">/* QM queue numbers */</span>
<span class="cp">#define BNX2X_ETH_Q		0</span>
<span class="cp">#define BNX2X_TOE_Q		3</span>
<span class="cp">#define BNX2X_TOE_ACK_Q		6</span>
<span class="cp">#define BNX2X_ISCSI_Q		9</span>
<span class="cp">#define BNX2X_ISCSI_ACK_Q	11</span>
<span class="cp">#define BNX2X_FCOE_Q		10</span>

<span class="cm">/* Vnics per mode */</span>
<span class="cp">#define BNX2X_PORT2_MODE_NUM_VNICS 4</span>
<span class="cp">#define BNX2X_PORT4_MODE_NUM_VNICS 2</span>

<span class="cm">/* COS offset for port1 in E3 B0 4port mode */</span>
<span class="cp">#define BNX2X_E3B0_PORT1_COS_OFFSET 3</span>

<span class="cm">/* QM Register addresses */</span>
<span class="cp">#define BNX2X_Q_VOQ_REG_ADDR(pf_q_num)\</span>
<span class="cp">	(QM_REG_QVOQIDX_0 + 4 * (pf_q_num))</span>
<span class="cp">#define BNX2X_VOQ_Q_REG_ADDR(cos, pf_q_num)\</span>
<span class="cp">	(QM_REG_VOQQMASK_0_LSB + 4 * ((cos) * 2 + ((pf_q_num) &gt;&gt; 5)))</span>
<span class="cp">#define BNX2X_Q_CMDQ_REG_ADDR(pf_q_num)\</span>
<span class="cp">	(QM_REG_BYTECRDCMDQ_0 + 4 * ((pf_q_num) &gt;&gt; 4))</span>

<span class="cm">/* extracts the QM queue number for the specified port and vnic */</span>
<span class="cp">#define BNX2X_PF_Q_NUM(q_num, port, vnic)\</span>
<span class="cp">	((((port) &lt;&lt; 1) | (vnic)) * 16 + (q_num))</span>


<span class="cm">/* Maps the specified queue to the specified COS */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bnx2x_map_q_cos</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">u32</span> <span class="n">q_num</span><span class="p">,</span> <span class="n">u32</span> <span class="n">new_cos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* find current COS mapping */</span>
	<span class="n">u32</span> <span class="n">curr_cos</span> <span class="o">=</span> <span class="n">REG_RD</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">QM_REG_QVOQIDX_0</span> <span class="o">+</span> <span class="n">q_num</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>

	<span class="cm">/* check if queue-&gt;COS mapping has changed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curr_cos</span> <span class="o">!=</span> <span class="n">new_cos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">num_vnics</span> <span class="o">=</span> <span class="n">BNX2X_PORT2_MODE_NUM_VNICS</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">reg_addr</span><span class="p">,</span> <span class="n">reg_bit_map</span><span class="p">,</span> <span class="n">vnic</span><span class="p">;</span>

		<span class="cm">/* update parameters for 4port mode */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">INIT_MODE_FLAGS</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MODE_PORT4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">num_vnics</span> <span class="o">=</span> <span class="n">BNX2X_PORT4_MODE_NUM_VNICS</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">BP_PORT</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">curr_cos</span> <span class="o">+=</span> <span class="n">BNX2X_E3B0_PORT1_COS_OFFSET</span><span class="p">;</span>
				<span class="n">new_cos</span> <span class="o">+=</span> <span class="n">BNX2X_E3B0_PORT1_COS_OFFSET</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* change queue mapping for each VNIC */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">vnic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">vnic</span> <span class="o">&lt;</span> <span class="n">num_vnics</span><span class="p">;</span> <span class="n">vnic</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">pf_q_num</span> <span class="o">=</span>
				<span class="n">BNX2X_PF_Q_NUM</span><span class="p">(</span><span class="n">q_num</span><span class="p">,</span> <span class="n">BP_PORT</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">vnic</span><span class="p">);</span>
			<span class="n">u32</span> <span class="n">q_bit_map</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">pf_q_num</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">);</span>

			<span class="cm">/* overwrite queue-&gt;VOQ mapping */</span>
			<span class="n">REG_WR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">BNX2X_Q_VOQ_REG_ADDR</span><span class="p">(</span><span class="n">pf_q_num</span><span class="p">),</span> <span class="n">new_cos</span><span class="p">);</span>

			<span class="cm">/* clear queue bit from current COS bit map */</span>
			<span class="n">reg_addr</span> <span class="o">=</span> <span class="n">BNX2X_VOQ_Q_REG_ADDR</span><span class="p">(</span><span class="n">curr_cos</span><span class="p">,</span> <span class="n">pf_q_num</span><span class="p">);</span>
			<span class="n">reg_bit_map</span> <span class="o">=</span> <span class="n">REG_RD</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">reg_addr</span><span class="p">);</span>
			<span class="n">REG_WR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">reg_addr</span><span class="p">,</span> <span class="n">reg_bit_map</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">q_bit_map</span><span class="p">));</span>

			<span class="cm">/* set queue bit in new COS bit map */</span>
			<span class="n">reg_addr</span> <span class="o">=</span> <span class="n">BNX2X_VOQ_Q_REG_ADDR</span><span class="p">(</span><span class="n">new_cos</span><span class="p">,</span> <span class="n">pf_q_num</span><span class="p">);</span>
			<span class="n">reg_bit_map</span> <span class="o">=</span> <span class="n">REG_RD</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">reg_addr</span><span class="p">);</span>
			<span class="n">REG_WR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">reg_addr</span><span class="p">,</span> <span class="n">reg_bit_map</span> <span class="o">|</span> <span class="n">q_bit_map</span><span class="p">);</span>

			<span class="cm">/* set/clear queue bit in command-queue bit map</span>
<span class="cm">			 * (E2/E3A0 only, valid COS values are 0/1)</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">INIT_MODE_FLAGS</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MODE_E3_B0</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">reg_addr</span> <span class="o">=</span> <span class="n">BNX2X_Q_CMDQ_REG_ADDR</span><span class="p">(</span><span class="n">pf_q_num</span><span class="p">);</span>
				<span class="n">reg_bit_map</span> <span class="o">=</span> <span class="n">REG_RD</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">reg_addr</span><span class="p">);</span>
				<span class="n">q_bit_map</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">pf_q_num</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">));</span>
				<span class="n">reg_bit_map</span> <span class="o">=</span> <span class="n">new_cos</span> <span class="o">?</span>
					      <span class="p">(</span><span class="n">reg_bit_map</span> <span class="o">|</span> <span class="n">q_bit_map</span><span class="p">)</span> <span class="o">:</span>
					      <span class="p">(</span><span class="n">reg_bit_map</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">q_bit_map</span><span class="p">));</span>
				<span class="n">REG_WR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">reg_addr</span><span class="p">,</span> <span class="n">reg_bit_map</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Configures the QM according to the specified per-traffic-type COSes */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bnx2x_dcb_config_qm</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="k">enum</span> <span class="n">cos_mode</span> <span class="n">mode</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">priority_cos</span> <span class="o">*</span><span class="n">traffic_cos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bnx2x_map_q_cos</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">BNX2X_FCOE_Q</span><span class="p">,</span>
			<span class="n">traffic_cos</span><span class="p">[</span><span class="n">LLFC_TRAFFIC_TYPE_FCOE</span><span class="p">].</span><span class="n">cos</span><span class="p">);</span>
	<span class="n">bnx2x_map_q_cos</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">BNX2X_ISCSI_Q</span><span class="p">,</span>
			<span class="n">traffic_cos</span><span class="p">[</span><span class="n">LLFC_TRAFFIC_TYPE_ISCSI</span><span class="p">].</span><span class="n">cos</span><span class="p">);</span>
	<span class="n">bnx2x_map_q_cos</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">BNX2X_ISCSI_ACK_Q</span><span class="p">,</span>
		<span class="n">traffic_cos</span><span class="p">[</span><span class="n">LLFC_TRAFFIC_TYPE_ISCSI</span><span class="p">].</span><span class="n">cos</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">STATIC_COS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* required only in backward compatible COS mode */</span>
		<span class="n">bnx2x_map_q_cos</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">BNX2X_ETH_Q</span><span class="p">,</span>
				<span class="n">traffic_cos</span><span class="p">[</span><span class="n">LLFC_TRAFFIC_TYPE_NW</span><span class="p">].</span><span class="n">cos</span><span class="p">);</span>
		<span class="n">bnx2x_map_q_cos</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">BNX2X_TOE_Q</span><span class="p">,</span>
				<span class="n">traffic_cos</span><span class="p">[</span><span class="n">LLFC_TRAFFIC_TYPE_NW</span><span class="p">].</span><span class="n">cos</span><span class="p">);</span>
		<span class="n">bnx2x_map_q_cos</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">BNX2X_TOE_ACK_Q</span><span class="p">,</span>
				<span class="n">traffic_cos</span><span class="p">[</span><span class="n">LLFC_TRAFFIC_TYPE_NW</span><span class="p">].</span><span class="n">cos</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/* congestion managment port init api description</span>
<span class="cm"> * the api works as follows:</span>
<span class="cm"> * the driver should pass the cmng_init_input struct, the port_init function</span>
<span class="cm"> * will prepare the required internal ram structure which will be passed back</span>
<span class="cm"> * to the driver (cmng_init) that will write it into the internal ram.</span>
<span class="cm"> *</span>
<span class="cm"> * IMPORTANT REMARKS:</span>
<span class="cm"> * 1. the cmng_init struct does not represent the contiguous internal ram</span>
<span class="cm"> *    structure. the driver should use the XSTORM_CMNG_PERPORT_VARS_OFFSET</span>
<span class="cm"> *    offset in order to write the port sub struct and the</span>
<span class="cm"> *    PFID_FROM_PORT_AND_VNIC offset for writing the vnic sub struct (in other</span>
<span class="cm"> *    words - don&#39;t use memcpy!).</span>
<span class="cm"> * 2. although the cmng_init struct is filled for the maximal vnic number</span>
<span class="cm"> *    possible, the driver should only write the valid vnics into the internal</span>
<span class="cm"> *    ram according to the appropriate port mode.</span>
<span class="cm"> */</span>
<span class="cp">#define BITS_TO_BYTES(x) ((x)/8)</span>

<span class="cm">/* CMNG constants, as derived from system spec calculations */</span>

<span class="cm">/* default MIN rate in case VNIC min rate is configured to zero- 100Mbps */</span>
<span class="cp">#define DEF_MIN_RATE 100</span>

<span class="cm">/* resolution of the rate shaping timer - 400 usec */</span>
<span class="cp">#define RS_PERIODIC_TIMEOUT_USEC 400</span>

<span class="cm">/* number of bytes in single QM arbitration cycle -</span>
<span class="cm"> * coefficient for calculating the fairness timer</span>
<span class="cm"> */</span>
<span class="cp">#define QM_ARB_BYTES 160000</span>

<span class="cm">/* resolution of Min algorithm 1:100 */</span>
<span class="cp">#define MIN_RES 100</span>

<span class="cm">/* how many bytes above threshold for</span>
<span class="cm"> * the minimal credit of Min algorithm</span>
<span class="cm"> */</span>
<span class="cp">#define MIN_ABOVE_THRESH 32768</span>

<span class="cm">/* Fairness algorithm integration time coefficient -</span>
<span class="cm"> * for calculating the actual Tfair</span>
<span class="cm"> */</span>
<span class="cp">#define T_FAIR_COEF ((MIN_ABOVE_THRESH + QM_ARB_BYTES) * 8 * MIN_RES)</span>

<span class="cm">/* Memory of fairness algorithm - 2 cycles */</span>
<span class="cp">#define FAIR_MEM 2</span>
<span class="cp">#define SAFC_TIMEOUT_USEC 52</span>

<span class="cp">#define SDM_TICKS 4</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bnx2x_init_max</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cmng_init_input</span> <span class="o">*</span><span class="n">input_data</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">r_param</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cmng_init</span> <span class="o">*</span><span class="n">ram_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">vnic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cmng_vnic</span> <span class="o">*</span><span class="n">vdata</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ram_data</span><span class="o">-&gt;</span><span class="n">vnic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cmng_struct_per_port</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ram_data</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="cm">/* rate shaping per-port variables</span>
<span class="cm">	 * 100 micro seconds in SDM ticks = 25</span>
<span class="cm">	 * since each tick is 4 microSeconds</span>
<span class="cm">	 */</span>

	<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rs_vars</span><span class="p">.</span><span class="n">rs_periodic_timeout</span> <span class="o">=</span>
	<span class="n">RS_PERIODIC_TIMEOUT_USEC</span> <span class="o">/</span> <span class="n">SDM_TICKS</span><span class="p">;</span>

	<span class="cm">/* this is the threshold below which no timer arming will occur.</span>
<span class="cm">	 * 1.25 coefficient is for the threshold to be a little bigger</span>
<span class="cm">	 * then the real time to compensate for timer in-accuracy</span>
<span class="cm">	 */</span>
	<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rs_vars</span><span class="p">.</span><span class="n">rs_threshold</span> <span class="o">=</span>
	<span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="n">RS_PERIODIC_TIMEOUT_USEC</span> <span class="o">*</span> <span class="n">r_param</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>

	<span class="cm">/* rate shaping per-vnic variables */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">vnic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">vnic</span> <span class="o">&lt;</span> <span class="n">BNX2X_PORT2_MODE_NUM_VNICS</span><span class="p">;</span> <span class="n">vnic</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* global vnic counter */</span>
		<span class="n">vdata</span><span class="o">-&gt;</span><span class="n">vnic_max_rate</span><span class="p">[</span><span class="n">vnic</span><span class="p">].</span><span class="n">vn_counter</span><span class="p">.</span><span class="n">rate</span> <span class="o">=</span>
		<span class="n">input_data</span><span class="o">-&gt;</span><span class="n">vnic_max_rate</span><span class="p">[</span><span class="n">vnic</span><span class="p">];</span>
		<span class="cm">/* maximal Mbps for this vnic</span>
<span class="cm">		 * the quota in each timer period - number of bytes</span>
<span class="cm">		 * transmitted in this period</span>
<span class="cm">		 */</span>
		<span class="n">vdata</span><span class="o">-&gt;</span><span class="n">vnic_max_rate</span><span class="p">[</span><span class="n">vnic</span><span class="p">].</span><span class="n">vn_counter</span><span class="p">.</span><span class="n">quota</span> <span class="o">=</span>
			<span class="n">RS_PERIODIC_TIMEOUT_USEC</span> <span class="o">*</span>
			<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">vdata</span><span class="o">-&gt;</span><span class="n">vnic_max_rate</span><span class="p">[</span><span class="n">vnic</span><span class="p">].</span><span class="n">vn_counter</span><span class="p">.</span><span class="n">rate</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bnx2x_init_min</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cmng_init_input</span> <span class="o">*</span><span class="n">input_data</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">r_param</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cmng_init</span> <span class="o">*</span><span class="n">ram_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">vnic</span><span class="p">,</span> <span class="n">fair_periodic_timeout_usec</span><span class="p">,</span> <span class="n">vnicWeightSum</span><span class="p">,</span> <span class="n">tFair</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cmng_vnic</span> <span class="o">*</span><span class="n">vdata</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ram_data</span><span class="o">-&gt;</span><span class="n">vnic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cmng_struct_per_port</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ram_data</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>

	<span class="cm">/* this is the resolution of the fairness timer */</span>
	<span class="n">fair_periodic_timeout_usec</span> <span class="o">=</span> <span class="n">QM_ARB_BYTES</span> <span class="o">/</span> <span class="n">r_param</span><span class="p">;</span>

	<span class="cm">/* fairness per-port variables</span>
<span class="cm">	 * for 10G it is 1000usec. for 1G it is 10000usec.</span>
<span class="cm">	 */</span>
	<span class="n">tFair</span> <span class="o">=</span> <span class="n">T_FAIR_COEF</span> <span class="o">/</span> <span class="n">input_data</span><span class="o">-&gt;</span><span class="n">port_rate</span><span class="p">;</span>

	<span class="cm">/* this is the threshold below which we won&#39;t arm the timer anymore */</span>
	<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">fair_vars</span><span class="p">.</span><span class="n">fair_threshold</span> <span class="o">=</span> <span class="n">QM_ARB_BYTES</span><span class="p">;</span>

	<span class="cm">/* we multiply by 1e3/8 to get bytes/msec. We don&#39;t want the credits</span>
<span class="cm">	 * to pass a credit of the T_FAIR*FAIR_MEM (algorithm resolution)</span>
<span class="cm">	 */</span>
	<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">fair_vars</span><span class="p">.</span><span class="n">upper_bound</span> <span class="o">=</span> <span class="n">r_param</span> <span class="o">*</span> <span class="n">tFair</span> <span class="o">*</span> <span class="n">FAIR_MEM</span><span class="p">;</span>

	<span class="cm">/* since each tick is 4 microSeconds */</span>
	<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">fair_vars</span><span class="p">.</span><span class="n">fairness_timeout</span> <span class="o">=</span>
				<span class="n">fair_periodic_timeout_usec</span> <span class="o">/</span> <span class="n">SDM_TICKS</span><span class="p">;</span>

	<span class="cm">/* calculate sum of weights */</span>
	<span class="n">vnicWeightSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">vnic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">vnic</span> <span class="o">&lt;</span> <span class="n">BNX2X_PORT2_MODE_NUM_VNICS</span><span class="p">;</span> <span class="n">vnic</span><span class="o">++</span><span class="p">)</span>
		<span class="n">vnicWeightSum</span> <span class="o">+=</span> <span class="n">input_data</span><span class="o">-&gt;</span><span class="n">vnic_min_rate</span><span class="p">[</span><span class="n">vnic</span><span class="p">];</span>

	<span class="cm">/* global vnic counter */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vnicWeightSum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* fairness per-vnic variables */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">vnic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">vnic</span> <span class="o">&lt;</span> <span class="n">BNX2X_PORT2_MODE_NUM_VNICS</span><span class="p">;</span> <span class="n">vnic</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* this is the credit for each period of the fairness</span>
<span class="cm">			 * algorithm - number of bytes in T_FAIR (this vnic</span>
<span class="cm">			 * share of the port rate)</span>
<span class="cm">			 */</span>
			<span class="n">vdata</span><span class="o">-&gt;</span><span class="n">vnic_min_rate</span><span class="p">[</span><span class="n">vnic</span><span class="p">].</span><span class="n">vn_credit_delta</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">input_data</span><span class="o">-&gt;</span><span class="n">vnic_min_rate</span><span class="p">[</span><span class="n">vnic</span><span class="p">]</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">*</span>
				<span class="p">(</span><span class="n">T_FAIR_COEF</span> <span class="o">/</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">vnicWeightSum</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vdata</span><span class="o">-&gt;</span><span class="n">vnic_min_rate</span><span class="p">[</span><span class="n">vnic</span><span class="p">].</span><span class="n">vn_credit_delta</span> <span class="o">&lt;</span>
			    <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">fair_vars</span><span class="p">.</span><span class="n">fair_threshold</span> <span class="o">+</span>
			    <span class="n">MIN_ABOVE_THRESH</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">vdata</span><span class="o">-&gt;</span><span class="n">vnic_min_rate</span><span class="p">[</span><span class="n">vnic</span><span class="p">].</span><span class="n">vn_credit_delta</span> <span class="o">=</span>
					<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">fair_vars</span><span class="p">.</span><span class="n">fair_threshold</span> <span class="o">+</span>
					<span class="n">MIN_ABOVE_THRESH</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bnx2x_init_fw_wrr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cmng_init_input</span> <span class="o">*</span><span class="n">input_data</span><span class="p">,</span>
				     <span class="n">u32</span> <span class="n">r_param</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cmng_init</span> <span class="o">*</span><span class="n">ram_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">vnic</span><span class="p">,</span> <span class="n">cos</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cosWeightSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cmng_vnic</span> <span class="o">*</span><span class="n">vdata</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ram_data</span><span class="o">-&gt;</span><span class="n">vnic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cmng_struct_per_port</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ram_data</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cos</span> <span class="o">&lt;</span> <span class="n">MAX_COS_NUMBER</span><span class="p">;</span> <span class="n">cos</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cosWeightSum</span> <span class="o">+=</span> <span class="n">input_data</span><span class="o">-&gt;</span><span class="n">cos_min_rate</span><span class="p">[</span><span class="n">cos</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cosWeightSum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">vnic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">vnic</span> <span class="o">&lt;</span> <span class="n">BNX2X_PORT2_MODE_NUM_VNICS</span><span class="p">;</span> <span class="n">vnic</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Since cos and vnic shouldn&#39;t work together the rate</span>
<span class="cm">			 * to divide between the coses is the port rate.</span>
<span class="cm">			 */</span>
			<span class="n">u32</span> <span class="o">*</span><span class="n">ccd</span> <span class="o">=</span> <span class="n">vdata</span><span class="o">-&gt;</span><span class="n">vnic_min_rate</span><span class="p">[</span><span class="n">vnic</span><span class="p">].</span><span class="n">cos_credit_delta</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">cos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cos</span> <span class="o">&lt;</span> <span class="n">MAX_COS_NUMBER</span><span class="p">;</span> <span class="n">cos</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* this is the credit for each period of</span>
<span class="cm">				 * the fairness algorithm - number of bytes</span>
<span class="cm">				 * in T_FAIR (this cos share of the vnic rate)</span>
<span class="cm">				 */</span>
				<span class="n">ccd</span><span class="p">[</span><span class="n">cos</span><span class="p">]</span> <span class="o">=</span>
				    <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">input_data</span><span class="o">-&gt;</span><span class="n">cos_min_rate</span><span class="p">[</span><span class="n">cos</span><span class="p">]</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">*</span>
				    <span class="p">(</span><span class="n">T_FAIR_COEF</span> <span class="o">/</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">cosWeightSum</span><span class="p">));</span>
				 <span class="k">if</span> <span class="p">(</span><span class="n">ccd</span><span class="p">[</span><span class="n">cos</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">fair_vars</span><span class="p">.</span><span class="n">fair_threshold</span>
						<span class="o">+</span> <span class="n">MIN_ABOVE_THRESH</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ccd</span><span class="p">[</span><span class="n">cos</span><span class="p">]</span> <span class="o">=</span>
					    <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">fair_vars</span><span class="p">.</span><span class="n">fair_threshold</span> <span class="o">+</span>
					    <span class="n">MIN_ABOVE_THRESH</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bnx2x_init_safc</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cmng_init_input</span> <span class="o">*</span><span class="n">input_data</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">cmng_init</span> <span class="o">*</span><span class="n">ram_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* in microSeconds */</span>
	<span class="n">ram_data</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">safc_vars</span><span class="p">.</span><span class="n">safc_timeout_usec</span> <span class="o">=</span> <span class="n">SAFC_TIMEOUT_USEC</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Congestion management port init */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bnx2x_init_cmng</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cmng_init_input</span> <span class="o">*</span><span class="n">input_data</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">cmng_init</span> <span class="o">*</span><span class="n">ram_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">r_param</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ram_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmng_init</span><span class="p">));</span>

	<span class="n">ram_data</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">input_data</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* number of bytes transmitted in a rate of 10Gbps</span>
<span class="cm">	 * in one usec = 1.25KB.</span>
<span class="cm">	 */</span>
	<span class="n">r_param</span> <span class="o">=</span> <span class="n">BITS_TO_BYTES</span><span class="p">(</span><span class="n">input_data</span><span class="o">-&gt;</span><span class="n">port_rate</span><span class="p">);</span>
	<span class="n">bnx2x_init_max</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="n">r_param</span><span class="p">,</span> <span class="n">ram_data</span><span class="p">);</span>
	<span class="n">bnx2x_init_min</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="n">r_param</span><span class="p">,</span> <span class="n">ram_data</span><span class="p">);</span>
	<span class="n">bnx2x_init_fw_wrr</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="n">r_param</span><span class="p">,</span> <span class="n">ram_data</span><span class="p">);</span>
	<span class="n">bnx2x_init_safc</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="n">ram_data</span><span class="p">);</span>
<span class="p">}</span>



<span class="cm">/* Returns the index of start or end of a specific block stage in ops array */</span>
<span class="cp">#define BLOCK_OPS_IDX(block, stage, end) \</span>
<span class="cp">			(2*(((block)*NUM_OF_INIT_PHASES) + (stage)) + (end))</span>


<span class="cp">#define INITOP_SET		0	</span><span class="cm">/* set the HW directly */</span><span class="cp"></span>
<span class="cp">#define INITOP_CLEAR		1	</span><span class="cm">/* clear the HW directly */</span><span class="cp"></span>
<span class="cp">#define INITOP_INIT		2	</span><span class="cm">/* set the init-value array */</span><span class="cp"></span>

<span class="cm">/****************************************************************************</span>
<span class="cm">* ILT management</span>
<span class="cm">****************************************************************************/</span>
<span class="k">struct</span> <span class="n">ilt_line</span> <span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">page_mapping</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ilt_client_info</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">page_size</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">end</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">client_num</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">flags</span><span class="p">;</span>
<span class="cp">#define ILT_CLIENT_SKIP_INIT	0x1</span>
<span class="cp">#define ILT_CLIENT_SKIP_MEM	0x2</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">bnx2x_ilt</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">start_line</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ilt_line</span>		<span class="o">*</span><span class="n">lines</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ilt_client_info</span>	<span class="n">clients</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="cp">#define ILT_CLIENT_CDU	0</span>
<span class="cp">#define ILT_CLIENT_QM	1</span>
<span class="cp">#define ILT_CLIENT_SRC	2</span>
<span class="cp">#define ILT_CLIENT_TM	3</span>
<span class="p">};</span>

<span class="cm">/****************************************************************************</span>
<span class="cm">* SRC configuration</span>
<span class="cm">****************************************************************************/</span>
<span class="k">struct</span> <span class="n">src_ent</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">opaque</span><span class="p">[</span><span class="mi">56</span><span class="p">];</span>
	<span class="n">u64</span> <span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/****************************************************************************</span>
<span class="cm">* Parity configuration</span>
<span class="cm">****************************************************************************/</span>
<span class="cp">#define BLOCK_PRTY_INFO(block, en_mask, m1, m1h, m2, m3) \</span>
<span class="cp">{ \</span>
<span class="cp">	block##_REG_##block##_PRTY_MASK, \</span>
<span class="cp">	block##_REG_##block##_PRTY_STS_CLR, \</span>
<span class="cp">	en_mask, {m1, m1h, m2, m3}, #block \</span>
<span class="cp">}</span>

<span class="cp">#define BLOCK_PRTY_INFO_0(block, en_mask, m1, m1h, m2, m3) \</span>
<span class="cp">{ \</span>
<span class="cp">	block##_REG_##block##_PRTY_MASK_0, \</span>
<span class="cp">	block##_REG_##block##_PRTY_STS_CLR_0, \</span>
<span class="cp">	en_mask, {m1, m1h, m2, m3}, #block&quot;_0&quot; \</span>
<span class="cp">}</span>

<span class="cp">#define BLOCK_PRTY_INFO_1(block, en_mask, m1, m1h, m2, m3) \</span>
<span class="cp">{ \</span>
<span class="cp">	block##_REG_##block##_PRTY_MASK_1, \</span>
<span class="cp">	block##_REG_##block##_PRTY_STS_CLR_1, \</span>
<span class="cp">	en_mask, {m1, m1h, m2, m3}, #block&quot;_1&quot; \</span>
<span class="cp">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">mask_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sts_clr_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">en_mask</span><span class="p">;</span>		<span class="cm">/* Mask to enable parity attentions */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">e1</span><span class="p">;</span>		<span class="cm">/* 57710 */</span>
		<span class="n">u32</span> <span class="n">e1h</span><span class="p">;</span>	<span class="cm">/* 57711 */</span>
		<span class="n">u32</span> <span class="n">e2</span><span class="p">;</span>		<span class="cm">/* 57712 */</span>
		<span class="n">u32</span> <span class="n">e3</span><span class="p">;</span>		<span class="cm">/* 578xx */</span>
	<span class="p">}</span> <span class="n">reg_mask</span><span class="p">;</span>		<span class="cm">/* Register mask (all valid bits) */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>		<span class="cm">/* Block&#39;s longest name is 6 characters long</span>
<span class="cm">				 * (name + suffix)</span>
<span class="cm">				 */</span>
<span class="p">}</span> <span class="n">bnx2x_blocks_parity_data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* bit 19 masked */</span>
	<span class="cm">/* REG_WR(bp, PXP_REG_PXP_PRTY_MASK, 0x80000); */</span>
	<span class="cm">/* bit 5,18,20-31 */</span>
	<span class="cm">/* REG_WR(bp, PXP2_REG_PXP2_PRTY_MASK_0, 0xfff40020); */</span>
	<span class="cm">/* bit 5 */</span>
	<span class="cm">/* REG_WR(bp, PXP2_REG_PXP2_PRTY_MASK_1, 0x20);	*/</span>
	<span class="cm">/* REG_WR(bp, HC_REG_HC_PRTY_MASK, 0x0); */</span>
	<span class="cm">/* REG_WR(bp, MISC_REG_MISC_PRTY_MASK, 0x0); */</span>

	<span class="cm">/* Block IGU, MISC, PXP and PXP2 parity errors as long as we don&#39;t</span>
<span class="cm">	 * want to handle &quot;system kill&quot; flow at the moment.</span>
<span class="cm">	 */</span>
	<span class="n">BLOCK_PRTY_INFO</span><span class="p">(</span><span class="n">PXP</span><span class="p">,</span> <span class="mh">0x7ffffff</span><span class="p">,</span> <span class="mh">0x3ffffff</span><span class="p">,</span> <span class="mh">0x3ffffff</span><span class="p">,</span> <span class="mh">0x7ffffff</span><span class="p">,</span>
			<span class="mh">0x7ffffff</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO_0</span><span class="p">(</span><span class="n">PXP2</span><span class="p">,</span>	<span class="mh">0xffffffff</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">,</span>
			  <span class="mh">0xffffffff</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO_1</span><span class="p">(</span><span class="n">PXP2</span><span class="p">,</span>	<span class="mh">0x1ffffff</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">,</span> <span class="mh">0x7ff</span><span class="p">,</span> <span class="mh">0x1ffffff</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO</span><span class="p">(</span><span class="n">HC</span><span class="p">,</span> <span class="mh">0x7</span><span class="p">,</span> <span class="mh">0x7</span><span class="p">,</span> <span class="mh">0x7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO</span><span class="p">(</span><span class="n">NIG</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="mh">0x3fffffff</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO_0</span><span class="p">(</span><span class="n">NIG</span><span class="p">,</span>	<span class="mh">0xffffffff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO_1</span><span class="p">(</span><span class="n">NIG</span><span class="p">,</span>	<span class="mh">0xffff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO</span><span class="p">(</span><span class="n">IGU</span><span class="p">,</span> <span class="mh">0x7ff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x7ff</span><span class="p">,</span> <span class="mh">0x7ff</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO</span><span class="p">(</span><span class="n">MISC</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO</span><span class="p">(</span><span class="n">QM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x1ff</span><span class="p">,</span> <span class="mh">0xfff</span><span class="p">,</span> <span class="mh">0xfff</span><span class="p">,</span> <span class="mh">0xfff</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO</span><span class="p">(</span><span class="n">ATC</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO</span><span class="p">(</span><span class="n">PGLUE_B</span><span class="p">,</span> <span class="mh">0x3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x3</span><span class="p">,</span> <span class="mh">0x3</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO</span><span class="p">(</span><span class="n">DORQ</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x3</span><span class="p">,</span> <span class="mh">0x3</span><span class="p">,</span> <span class="mh">0x3</span><span class="p">,</span> <span class="mh">0x3</span><span class="p">),</span>
	<span class="p">{</span><span class="n">GRCBASE_UPB</span> <span class="o">+</span> <span class="n">PB_REG_PB_PRTY_MASK</span><span class="p">,</span>
		<span class="n">GRCBASE_UPB</span> <span class="o">+</span> <span class="n">PB_REG_PB_PRTY_STS_CLR</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">,</span>
		<span class="p">{</span><span class="mh">0xf</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">},</span> <span class="s">&quot;UPB&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">GRCBASE_XPB</span> <span class="o">+</span> <span class="n">PB_REG_PB_PRTY_MASK</span><span class="p">,</span>
		<span class="n">GRCBASE_XPB</span> <span class="o">+</span> <span class="n">PB_REG_PB_PRTY_STS_CLR</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">{</span><span class="mh">0xf</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">},</span> <span class="s">&quot;XPB&quot;</span><span class="p">},</span>
	<span class="n">BLOCK_PRTY_INFO</span><span class="p">(</span><span class="n">SRC</span><span class="p">,</span> <span class="mh">0x4</span><span class="p">,</span> <span class="mh">0x7</span><span class="p">,</span> <span class="mh">0x7</span><span class="p">,</span> <span class="mh">0x7</span><span class="p">,</span> <span class="mh">0x7</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO</span><span class="p">(</span><span class="n">CDU</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO</span><span class="p">(</span><span class="n">CFC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">,</span> <span class="mh">0x3f</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO</span><span class="p">(</span><span class="n">DBG</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO</span><span class="p">(</span><span class="n">DMAE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO</span><span class="p">(</span><span class="n">BRB1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO</span><span class="p">(</span><span class="n">PRS</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">),</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO</span><span class="p">(</span><span class="n">PBF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x3ffff</span><span class="p">,</span> <span class="mh">0xfffff</span><span class="p">,</span> <span class="mh">0xfffffff</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO</span><span class="p">(</span><span class="n">TM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO</span><span class="p">(</span><span class="n">TSDM</span><span class="p">,</span> <span class="mh">0x18</span><span class="p">,</span> <span class="mh">0x7ff</span><span class="p">,</span> <span class="mh">0x7ff</span><span class="p">,</span> <span class="mh">0x7ff</span><span class="p">,</span> <span class="mh">0x7ff</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO</span><span class="p">(</span><span class="n">CSDM</span><span class="p">,</span> <span class="mh">0x8</span><span class="p">,</span> <span class="mh">0x7ff</span><span class="p">,</span> <span class="mh">0x7ff</span><span class="p">,</span> <span class="mh">0x7ff</span><span class="p">,</span> <span class="mh">0x7ff</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO</span><span class="p">(</span><span class="n">USDM</span><span class="p">,</span> <span class="mh">0x38</span><span class="p">,</span> <span class="mh">0x7ff</span><span class="p">,</span> <span class="mh">0x7ff</span><span class="p">,</span> <span class="mh">0x7ff</span><span class="p">,</span> <span class="mh">0x7ff</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO</span><span class="p">(</span><span class="n">XSDM</span><span class="p">,</span> <span class="mh">0x8</span><span class="p">,</span> <span class="mh">0x7ff</span><span class="p">,</span> <span class="mh">0x7ff</span><span class="p">,</span> <span class="mh">0x7ff</span><span class="p">,</span> <span class="mh">0x7ff</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO</span><span class="p">(</span><span class="n">TCM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x7ffffff</span><span class="p">,</span> <span class="mh">0x7ffffff</span><span class="p">,</span> <span class="mh">0x7ffffff</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO</span><span class="p">(</span><span class="n">CCM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x7ffffff</span><span class="p">,</span> <span class="mh">0x7ffffff</span><span class="p">,</span> <span class="mh">0x7ffffff</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO</span><span class="p">(</span><span class="n">UCM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x7ffffff</span><span class="p">,</span> <span class="mh">0x7ffffff</span><span class="p">,</span> <span class="mh">0x7ffffff</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO</span><span class="p">(</span><span class="n">XCM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x3fffffff</span><span class="p">,</span> <span class="mh">0x3fffffff</span><span class="p">,</span> <span class="mh">0x3fffffff</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO_0</span><span class="p">(</span><span class="n">TSEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">,</span>
			  <span class="mh">0xffffffff</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO_1</span><span class="p">(</span><span class="n">TSEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x3</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="mh">0x3f</span><span class="p">,</span> <span class="mh">0x3f</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO_0</span><span class="p">(</span><span class="n">USEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">,</span>
			  <span class="mh">0xffffffff</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO_1</span><span class="p">(</span><span class="n">USEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x3</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO_0</span><span class="p">(</span><span class="n">CSEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">,</span>
			  <span class="mh">0xffffffff</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO_1</span><span class="p">(</span><span class="n">CSEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x3</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO_0</span><span class="p">(</span><span class="n">XSEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">,</span>
			  <span class="mh">0xffffffff</span><span class="p">),</span>
	<span class="n">BLOCK_PRTY_INFO_1</span><span class="p">(</span><span class="n">XSEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x3</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="mh">0x3f</span><span class="p">,</span> <span class="mh">0x3f</span><span class="p">),</span>
<span class="p">};</span>


<span class="cm">/* [28] MCP Latched rom_parity</span>
<span class="cm"> * [29] MCP Latched ump_rx_parity</span>
<span class="cm"> * [30] MCP Latched ump_tx_parity</span>
<span class="cm"> * [31] MCP Latched scpad_parity</span>
<span class="cm"> */</span>
<span class="cp">#define MISC_AEU_ENABLE_MCP_PRTY_BITS	\</span>
<span class="cp">	(AEU_INPUTS_ATTN_BITS_MCP_LATCHED_ROM_PARITY | \</span>
<span class="cp">	 AEU_INPUTS_ATTN_BITS_MCP_LATCHED_UMP_RX_PARITY | \</span>
<span class="cp">	 AEU_INPUTS_ATTN_BITS_MCP_LATCHED_UMP_TX_PARITY | \</span>
<span class="cp">	 AEU_INPUTS_ATTN_BITS_MCP_LATCHED_SCPAD_PARITY)</span>

<span class="cm">/* Below registers control the MCP parity attention output. When</span>
<span class="cm"> * MISC_AEU_ENABLE_MCP_PRTY_BITS are set - attentions are</span>
<span class="cm"> * enabled, when cleared - disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">mcp_attn_ctl_regs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">MISC_REG_AEU_ENABLE4_FUNC_0_OUT_0</span><span class="p">,</span>
	<span class="n">MISC_REG_AEU_ENABLE4_NIG_0</span><span class="p">,</span>
	<span class="n">MISC_REG_AEU_ENABLE4_PXP_0</span><span class="p">,</span>
	<span class="n">MISC_REG_AEU_ENABLE4_FUNC_1_OUT_0</span><span class="p">,</span>
	<span class="n">MISC_REG_AEU_ENABLE4_NIG_1</span><span class="p">,</span>
	<span class="n">MISC_REG_AEU_ENABLE4_PXP_1</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bnx2x_set_mcp_parity</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">u8</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_val</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">mcp_attn_ctl_regs</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg_val</span> <span class="o">=</span> <span class="n">REG_RD</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">mcp_attn_ctl_regs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span>
			<span class="n">reg_val</span> <span class="o">|=</span> <span class="n">MISC_AEU_ENABLE_MCP_PRTY_BITS</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">reg_val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MISC_AEU_ENABLE_MCP_PRTY_BITS</span><span class="p">;</span>

		<span class="n">REG_WR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">mcp_attn_ctl_regs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">reg_val</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">bnx2x_parity_reg_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CHIP_IS_E1</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">bnx2x_blocks_parity_data</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">reg_mask</span><span class="p">.</span><span class="n">e1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">CHIP_IS_E1H</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">bnx2x_blocks_parity_data</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">reg_mask</span><span class="p">.</span><span class="n">e1h</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">CHIP_IS_E2</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">bnx2x_blocks_parity_data</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">reg_mask</span><span class="p">.</span><span class="n">e2</span><span class="p">;</span>
	<span class="k">else</span> <span class="cm">/* CHIP_IS_E3 */</span>
		<span class="k">return</span> <span class="n">bnx2x_blocks_parity_data</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">reg_mask</span><span class="p">.</span><span class="n">e3</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bnx2x_disable_blocks_parity</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">bnx2x_blocks_parity_data</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">dis_mask</span> <span class="o">=</span> <span class="n">bnx2x_parity_reg_mask</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dis_mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">REG_WR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">bnx2x_blocks_parity_data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask_addr</span><span class="p">,</span>
			       <span class="n">dis_mask</span><span class="p">);</span>
			<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_HW</span><span class="p">,</span> <span class="s">&quot;Setting parity mask &quot;</span>
						 <span class="s">&quot;for %s to</span><span class="se">\t\t</span><span class="s">0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">bnx2x_blocks_parity_data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">dis_mask</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Disable MCP parity attentions */</span>
	<span class="n">bnx2x_set_mcp_parity</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Clear the parity error status registers. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bnx2x_clear_blocks_parity</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_val</span><span class="p">,</span> <span class="n">mcp_aeu_bits</span> <span class="o">=</span>
		<span class="n">AEU_INPUTS_ATTN_BITS_MCP_LATCHED_ROM_PARITY</span> <span class="o">|</span>
		<span class="n">AEU_INPUTS_ATTN_BITS_MCP_LATCHED_SCPAD_PARITY</span> <span class="o">|</span>
		<span class="n">AEU_INPUTS_ATTN_BITS_MCP_LATCHED_UMP_RX_PARITY</span> <span class="o">|</span>
		<span class="n">AEU_INPUTS_ATTN_BITS_MCP_LATCHED_UMP_TX_PARITY</span><span class="p">;</span>

	<span class="cm">/* Clear SEM_FAST parities */</span>
	<span class="n">REG_WR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">XSEM_REG_FAST_MEMORY</span> <span class="o">+</span> <span class="n">SEM_FAST_REG_PARITY_RST</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">);</span>
	<span class="n">REG_WR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">TSEM_REG_FAST_MEMORY</span> <span class="o">+</span> <span class="n">SEM_FAST_REG_PARITY_RST</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">);</span>
	<span class="n">REG_WR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">USEM_REG_FAST_MEMORY</span> <span class="o">+</span> <span class="n">SEM_FAST_REG_PARITY_RST</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">);</span>
	<span class="n">REG_WR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">CSEM_REG_FAST_MEMORY</span> <span class="o">+</span> <span class="n">SEM_FAST_REG_PARITY_RST</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">bnx2x_blocks_parity_data</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">reg_mask</span> <span class="o">=</span> <span class="n">bnx2x_parity_reg_mask</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">reg_mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reg_val</span> <span class="o">=</span> <span class="n">REG_RD</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">bnx2x_blocks_parity_data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span>
					 <span class="n">sts_clr_addr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">reg_val</span> <span class="o">&amp;</span> <span class="n">reg_mask</span><span class="p">)</span>
				<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_HW</span><span class="p">,</span>
					    <span class="s">&quot;Parity errors in %s: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					    <span class="n">bnx2x_blocks_parity_data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span>
					    <span class="n">reg_val</span> <span class="o">&amp;</span> <span class="n">reg_mask</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Check if there were parity attentions in MCP */</span>
	<span class="n">reg_val</span> <span class="o">=</span> <span class="n">REG_RD</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">MISC_REG_AEU_AFTER_INVERT_4_MCP</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg_val</span> <span class="o">&amp;</span> <span class="n">mcp_aeu_bits</span><span class="p">)</span>
		<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_HW</span><span class="p">,</span> <span class="s">&quot;Parity error in MCP: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">reg_val</span> <span class="o">&amp;</span> <span class="n">mcp_aeu_bits</span><span class="p">);</span>

	<span class="cm">/* Clear parity attentions in MCP:</span>
<span class="cm">	 * [7]  clears Latched rom_parity</span>
<span class="cm">	 * [8]  clears Latched ump_rx_parity</span>
<span class="cm">	 * [9]  clears Latched ump_tx_parity</span>
<span class="cm">	 * [10] clears Latched scpad_parity (both ports)</span>
<span class="cm">	 */</span>
	<span class="n">REG_WR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">MISC_REG_AEU_CLR_LATCH_SIGNAL</span><span class="p">,</span> <span class="mh">0x780</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bnx2x_enable_blocks_parity</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">bnx2x_blocks_parity_data</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">reg_mask</span> <span class="o">=</span> <span class="n">bnx2x_parity_reg_mask</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">reg_mask</span><span class="p">)</span>
			<span class="n">REG_WR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">bnx2x_blocks_parity_data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask_addr</span><span class="p">,</span>
				<span class="n">bnx2x_blocks_parity_data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">en_mask</span> <span class="o">&amp;</span> <span class="n">reg_mask</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Enable MCP parity attentions */</span>
	<span class="n">bnx2x_set_mcp_parity</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>


<span class="cp">#endif </span><span class="cm">/* BNX2X_INIT_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
