<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › broadcom › bnx2x › bnx2x_cmn.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>bnx2x_cmn.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* bnx2x_cmn.c: Broadcom Everest network driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2007-2012 Broadcom Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * Maintained by: Eilon Greenstein &lt;eilong@broadcom.com&gt;</span>
<span class="cm"> * Written by: Eliezer Tamir</span>
<span class="cm"> * Based on code from Michael Chan&#39;s bnx2 driver</span>
<span class="cm"> * UDP CSUM errata workaround by Arik Gendelman</span>
<span class="cm"> * Slowpath and fastpath rework by Vladislav Zolotarov</span>
<span class="cm"> * Statistics and Link management by Yitchak Gertner</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/if_vlan.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;net/ipv6.h&gt;</span>
<span class="cp">#include &lt;net/ip6_checksum.h&gt;</span>
<span class="cp">#include &lt;linux/prefetch.h&gt;</span>
<span class="cp">#include &quot;bnx2x_cmn.h&quot;</span>
<span class="cp">#include &quot;bnx2x_init.h&quot;</span>
<span class="cp">#include &quot;bnx2x_sp.h&quot;</span>



<span class="cm">/**</span>
<span class="cm"> * bnx2x_move_fp - move content of the fastpath structure.</span>
<span class="cm"> *</span>
<span class="cm"> * @bp:		driver handle</span>
<span class="cm"> * @from:	source FP index</span>
<span class="cm"> * @to:		destination FP index</span>
<span class="cm"> *</span>
<span class="cm"> * Makes sure the contents of the bp-&gt;fp[to].napi is kept</span>
<span class="cm"> * intact. This is done by first copying the napi struct from</span>
<span class="cm"> * the target to the source, and then mem copying the entire</span>
<span class="cm"> * source onto the target</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bnx2x_move_fp</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">from_fp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">[</span><span class="n">from</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">to_fp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">[</span><span class="n">to</span><span class="p">];</span>

	<span class="cm">/* Copy the NAPI object as it has been already initialized */</span>
	<span class="n">from_fp</span><span class="o">-&gt;</span><span class="n">napi</span> <span class="o">=</span> <span class="n">to_fp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">;</span>

	<span class="cm">/* Move bnx2x_fastpath contents */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">to_fp</span><span class="p">,</span> <span class="n">from_fp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">to_fp</span><span class="p">));</span>
	<span class="n">to_fp</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">to</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">load_count</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mi">0</span><span class="p">}</span> <span class="p">};</span> <span class="cm">/* per-path: 0-common, 1-port0, 2-port1 */</span>

<span class="cm">/* free skb in the packet ring at pos idx</span>
<span class="cm"> * return idx of last bd freed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">bnx2x_free_tx_pkt</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bnx2x_fp_txdata</span> <span class="o">*</span><span class="n">txdata</span><span class="p">,</span>
			     <span class="n">u16</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pkts_compl</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">bytes_compl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sw_tx_bd</span> <span class="o">*</span><span class="n">tx_buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_buf_ring</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">eth_tx_start_bd</span> <span class="o">*</span><span class="n">tx_start_bd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eth_tx_bd</span> <span class="o">*</span><span class="n">tx_data_bd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">tx_buf</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">bd_idx</span> <span class="o">=</span> <span class="n">TX_BD</span><span class="p">(</span><span class="n">tx_buf</span><span class="o">-&gt;</span><span class="n">first_bd</span><span class="p">),</span> <span class="n">new_cons</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nbd</span><span class="p">;</span>

	<span class="cm">/* prefetch skb end pointer to speedup dev_kfree_skb() */</span>
	<span class="n">prefetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">);</span>

	<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_TX_DONE</span><span class="p">,</span> <span class="s">&quot;fp[%d]: pkt_idx %d  buff @(%p)-&gt;skb %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	   <span class="n">txdata</span><span class="o">-&gt;</span><span class="n">txq_index</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">tx_buf</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* unmap first bd */</span>
	<span class="n">tx_start_bd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_desc_ring</span><span class="p">[</span><span class="n">bd_idx</span><span class="p">].</span><span class="n">start_bd</span><span class="p">;</span>
	<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">BD_UNMAP_ADDR</span><span class="p">(</span><span class="n">tx_start_bd</span><span class="p">),</span>
			 <span class="n">BD_UNMAP_LEN</span><span class="p">(</span><span class="n">tx_start_bd</span><span class="p">),</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>


	<span class="n">nbd</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">tx_start_bd</span><span class="o">-&gt;</span><span class="n">nbd</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#ifdef BNX2X_STOP_ON_ERROR</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">nbd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">MAX_SKB_FRAGS</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;BAD nbd!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">bnx2x_panic</span><span class="p">();</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">new_cons</span> <span class="o">=</span> <span class="n">nbd</span> <span class="o">+</span> <span class="n">tx_buf</span><span class="o">-&gt;</span><span class="n">first_bd</span><span class="p">;</span>

	<span class="cm">/* Get the next bd */</span>
	<span class="n">bd_idx</span> <span class="o">=</span> <span class="n">TX_BD</span><span class="p">(</span><span class="n">NEXT_TX_IDX</span><span class="p">(</span><span class="n">bd_idx</span><span class="p">));</span>

	<span class="cm">/* Skip a parse bd... */</span>
	<span class="o">--</span><span class="n">nbd</span><span class="p">;</span>
	<span class="n">bd_idx</span> <span class="o">=</span> <span class="n">TX_BD</span><span class="p">(</span><span class="n">NEXT_TX_IDX</span><span class="p">(</span><span class="n">bd_idx</span><span class="p">));</span>

	<span class="cm">/* ...and the TSO split header bd since they have no mapping */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tx_buf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BNX2X_TSO_SPLIT_BD</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">--</span><span class="n">nbd</span><span class="p">;</span>
		<span class="n">bd_idx</span> <span class="o">=</span> <span class="n">TX_BD</span><span class="p">(</span><span class="n">NEXT_TX_IDX</span><span class="p">(</span><span class="n">bd_idx</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* now free frags */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nbd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">tx_data_bd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_desc_ring</span><span class="p">[</span><span class="n">bd_idx</span><span class="p">].</span><span class="n">reg_bd</span><span class="p">;</span>
		<span class="n">dma_unmap_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">BD_UNMAP_ADDR</span><span class="p">(</span><span class="n">tx_data_bd</span><span class="p">),</span>
			       <span class="n">BD_UNMAP_LEN</span><span class="p">(</span><span class="n">tx_data_bd</span><span class="p">),</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">nbd</span><span class="p">)</span>
			<span class="n">bd_idx</span> <span class="o">=</span> <span class="n">TX_BD</span><span class="p">(</span><span class="n">NEXT_TX_IDX</span><span class="p">(</span><span class="n">bd_idx</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* release skb */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="p">(</span><span class="o">*</span><span class="n">pkts_compl</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">bytes_compl</span><span class="p">)</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">tx_buf</span><span class="o">-&gt;</span><span class="n">first_bd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tx_buf</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">new_cons</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bnx2x_tx_int</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bnx2x_fp_txdata</span> <span class="o">*</span><span class="n">txdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">hw_cons</span><span class="p">,</span> <span class="n">sw_cons</span><span class="p">,</span> <span class="n">bd_cons</span> <span class="o">=</span> <span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_bd_cons</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pkts_compl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bytes_compl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef BNX2X_STOP_ON_ERROR</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">panic</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">txq</span> <span class="o">=</span> <span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">txdata</span><span class="o">-&gt;</span><span class="n">txq_index</span><span class="p">);</span>
	<span class="n">hw_cons</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_cons_sb</span><span class="p">);</span>
	<span class="n">sw_cons</span> <span class="o">=</span> <span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_pkt_cons</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">sw_cons</span> <span class="o">!=</span> <span class="n">hw_cons</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">pkt_cons</span><span class="p">;</span>

		<span class="n">pkt_cons</span> <span class="o">=</span> <span class="n">TX_BD</span><span class="p">(</span><span class="n">sw_cons</span><span class="p">);</span>

		<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_TX_DONE</span><span class="p">,</span>
		   <span class="s">&quot;queue[%d]: hw_cons %u  sw_cons %u  pkt_cons %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">txdata</span><span class="o">-&gt;</span><span class="n">txq_index</span><span class="p">,</span> <span class="n">hw_cons</span><span class="p">,</span> <span class="n">sw_cons</span><span class="p">,</span> <span class="n">pkt_cons</span><span class="p">);</span>

		<span class="n">bd_cons</span> <span class="o">=</span> <span class="n">bnx2x_free_tx_pkt</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">txdata</span><span class="p">,</span> <span class="n">pkt_cons</span><span class="p">,</span>
		    <span class="o">&amp;</span><span class="n">pkts_compl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bytes_compl</span><span class="p">);</span>

		<span class="n">sw_cons</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">netdev_tx_completed_queue</span><span class="p">(</span><span class="n">txq</span><span class="p">,</span> <span class="n">pkts_compl</span><span class="p">,</span> <span class="n">bytes_compl</span><span class="p">);</span>

	<span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_pkt_cons</span> <span class="o">=</span> <span class="n">sw_cons</span><span class="p">;</span>
	<span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_bd_cons</span> <span class="o">=</span> <span class="n">bd_cons</span><span class="p">;</span>

	<span class="cm">/* Need to make the tx_bd_cons update visible to start_xmit()</span>
<span class="cm">	 * before checking for netif_tx_queue_stopped().  Without the</span>
<span class="cm">	 * memory barrier, there is a small possibility that</span>
<span class="cm">	 * start_xmit() will miss it and cause the queue to be stopped</span>
<span class="cm">	 * forever.</span>
<span class="cm">	 * On the other hand we need an rmb() here to ensure the proper</span>
<span class="cm">	 * ordering of bit testing in the following</span>
<span class="cm">	 * netif_tx_queue_stopped(txq) call.</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">netif_tx_queue_stopped</span><span class="p">(</span><span class="n">txq</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* Taking tx_lock() is needed to prevent reenabling the queue</span>
<span class="cm">		 * while it&#39;s empty. This could have happen if rx_action() gets</span>
<span class="cm">		 * suspended in bnx2x_tx_int() after the condition before</span>
<span class="cm">		 * netif_tx_wake_queue(), while tx_action (bnx2x_start_xmit()):</span>
<span class="cm">		 *</span>
<span class="cm">		 * stops the queue-&gt;sees fresh tx_bd_cons-&gt;releases the queue-&gt;</span>
<span class="cm">		 * sends some packets consuming the whole queue again-&gt;</span>
<span class="cm">		 * stops the queue</span>
<span class="cm">		 */</span>

		<span class="n">__netif_tx_lock</span><span class="p">(</span><span class="n">txq</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">netif_tx_queue_stopped</span><span class="p">(</span><span class="n">txq</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">BNX2X_STATE_OPEN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">bnx2x_tx_avail</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">txdata</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">MAX_SKB_FRAGS</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span>
			<span class="n">netif_tx_wake_queue</span><span class="p">(</span><span class="n">txq</span><span class="p">);</span>

		<span class="n">__netif_tx_unlock</span><span class="p">(</span><span class="n">txq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bnx2x_update_last_max_sge</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span>
					     <span class="n">u16</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">last_max</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">last_max_sge</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">SUB_S16</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">last_max</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">fp</span><span class="o">-&gt;</span><span class="n">last_max_sge</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bnx2x_update_sge_prod</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span>
					 <span class="n">u16</span> <span class="n">sge_len</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">eth_end_agg_rx_cqe</span> <span class="o">*</span><span class="n">cqe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">last_max</span><span class="p">,</span> <span class="n">last_elem</span><span class="p">,</span> <span class="n">first_elem</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sge_len</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* First mark all used pages */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sge_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">BIT_VEC64_CLEAR_BIT</span><span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">sge_mask</span><span class="p">,</span>
			<span class="n">RX_SGE</span><span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">cqe</span><span class="o">-&gt;</span><span class="n">sgl_or_raw_data</span><span class="p">.</span><span class="n">sgl</span><span class="p">[</span><span class="n">i</span><span class="p">])));</span>

	<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_RX_STATUS</span><span class="p">,</span> <span class="s">&quot;fp_cqe-&gt;sgl[%d] = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	   <span class="n">sge_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">cqe</span><span class="o">-&gt;</span><span class="n">sgl_or_raw_data</span><span class="p">.</span><span class="n">sgl</span><span class="p">[</span><span class="n">sge_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]));</span>

	<span class="cm">/* Here we assume that the last SGE index is the biggest */</span>
	<span class="n">prefetch</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">sge_mask</span><span class="p">));</span>
	<span class="n">bnx2x_update_last_max_sge</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span>
		<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">cqe</span><span class="o">-&gt;</span><span class="n">sgl_or_raw_data</span><span class="p">.</span><span class="n">sgl</span><span class="p">[</span><span class="n">sge_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]));</span>

	<span class="n">last_max</span> <span class="o">=</span> <span class="n">RX_SGE</span><span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">last_max_sge</span><span class="p">);</span>
	<span class="n">last_elem</span> <span class="o">=</span> <span class="n">last_max</span> <span class="o">&gt;&gt;</span> <span class="n">BIT_VEC64_ELEM_SHIFT</span><span class="p">;</span>
	<span class="n">first_elem</span> <span class="o">=</span> <span class="n">RX_SGE</span><span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_sge_prod</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">BIT_VEC64_ELEM_SHIFT</span><span class="p">;</span>

	<span class="cm">/* If ring is not full */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_elem</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">first_elem</span><span class="p">)</span>
		<span class="n">last_elem</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Now update the prod */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">first_elem</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">last_elem</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">NEXT_SGE_MASK_ELEM</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">sge_mask</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">fp</span><span class="o">-&gt;</span><span class="n">sge_mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">BIT_VEC64_ELEM_ONE_MASK</span><span class="p">;</span>
		<span class="n">delta</span> <span class="o">+=</span> <span class="n">BIT_VEC64_ELEM_SZ</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_sge_prod</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="cm">/* clear page-end entries */</span>
		<span class="n">bnx2x_clear_sge_mask_next_elems</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_RX_STATUS</span><span class="p">,</span>
	   <span class="s">&quot;fp-&gt;last_max_sge = %d  fp-&gt;rx_sge_prod = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	   <span class="n">fp</span><span class="o">-&gt;</span><span class="n">last_max_sge</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_sge_prod</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Set Toeplitz hash value in the skb using the value from the</span>
<span class="cm"> * CQE (calculated by HW).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">bnx2x_get_rxhash</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">struct</span> <span class="n">eth_fast_path_rx_cqe</span> <span class="o">*</span><span class="n">cqe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Set Toeplitz hash from CQE */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXHASH</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">cqe</span><span class="o">-&gt;</span><span class="n">status_flags</span> <span class="o">&amp;</span> <span class="n">ETH_FAST_PATH_RX_CQE_RSS_HASH_FLG</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cqe</span><span class="o">-&gt;</span><span class="n">rss_hash_result</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bnx2x_tpa_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="n">u16</span> <span class="n">queue</span><span class="p">,</span>
			    <span class="n">u16</span> <span class="n">cons</span><span class="p">,</span> <span class="n">u16</span> <span class="n">prod</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">eth_fast_path_rx_cqe</span> <span class="o">*</span><span class="n">cqe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sw_rx_bd</span> <span class="o">*</span><span class="n">cons_rx_buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_buf_ring</span><span class="p">[</span><span class="n">cons</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sw_rx_bd</span> <span class="o">*</span><span class="n">prod_rx_buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_buf_ring</span><span class="p">[</span><span class="n">prod</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">eth_rx_bd</span> <span class="o">*</span><span class="n">prod_bd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_desc_ring</span><span class="p">[</span><span class="n">prod</span><span class="p">];</span>
	<span class="n">dma_addr_t</span> <span class="n">mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bnx2x_agg_info</span> <span class="o">*</span><span class="n">tpa_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">tpa_info</span><span class="p">[</span><span class="n">queue</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sw_rx_bd</span> <span class="o">*</span><span class="n">first_buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">first_buf</span><span class="p">;</span>

	<span class="cm">/* print error if current state != stop */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">tpa_state</span> <span class="o">!=</span> <span class="n">BNX2X_TPA_STOP</span><span class="p">)</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;start of bin not in stop [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>

	<span class="cm">/* Try to map an empty data buffer from the aggregation info  */</span>
	<span class="n">mapping</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="n">first_buf</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">NET_SKB_PAD</span><span class="p">,</span>
				 <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_buf_size</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 *  ...if it fails - move the skb from the consumer to the producer</span>
<span class="cm">	 *  and set the current aggregation state as ERROR to drop it</span>
<span class="cm">	 *  when TPA_STOP arrives.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">mapping</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* Move the BD from the consumer to the producer */</span>
		<span class="n">bnx2x_reuse_rx_data</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">cons</span><span class="p">,</span> <span class="n">prod</span><span class="p">);</span>
		<span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">tpa_state</span> <span class="o">=</span> <span class="n">BNX2X_TPA_ERROR</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* move empty data from pool to prod */</span>
	<span class="n">prod_rx_buf</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">first_buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">dma_unmap_addr_set</span><span class="p">(</span><span class="n">prod_rx_buf</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">mapping</span><span class="p">);</span>
	<span class="cm">/* point prod_bd to new data */</span>
	<span class="n">prod_bd</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">U64_HI</span><span class="p">(</span><span class="n">mapping</span><span class="p">));</span>
	<span class="n">prod_bd</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">U64_LO</span><span class="p">(</span><span class="n">mapping</span><span class="p">));</span>

	<span class="cm">/* move partial skb from cons to pool (don&#39;t unmap yet) */</span>
	<span class="o">*</span><span class="n">first_buf</span> <span class="o">=</span> <span class="o">*</span><span class="n">cons_rx_buf</span><span class="p">;</span>

	<span class="cm">/* mark bin state as START */</span>
	<span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">parsing_flags</span> <span class="o">=</span>
		<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">cqe</span><span class="o">-&gt;</span><span class="n">pars_flags</span><span class="p">.</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">vlan_tag</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">cqe</span><span class="o">-&gt;</span><span class="n">vlan_tag</span><span class="p">);</span>
	<span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">tpa_state</span> <span class="o">=</span> <span class="n">BNX2X_TPA_START</span><span class="p">;</span>
	<span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">len_on_bd</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">cqe</span><span class="o">-&gt;</span><span class="n">len_on_bd</span><span class="p">);</span>
	<span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">placement_offset</span> <span class="o">=</span> <span class="n">cqe</span><span class="o">-&gt;</span><span class="n">placement_offset</span><span class="p">;</span>
	<span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">rxhash</span> <span class="o">=</span> <span class="n">bnx2x_get_rxhash</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">cqe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">TPA_MODE_GRO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">gro_size</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">cqe</span><span class="o">-&gt;</span><span class="n">pkt_len_or_gro_seg_len</span><span class="p">);</span>
		<span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">full_page</span> <span class="o">=</span>
			<span class="n">SGE_PAGE_SIZE</span> <span class="o">*</span> <span class="n">PAGES_PER_SGE</span> <span class="o">/</span> <span class="n">gro_size</span> <span class="o">*</span> <span class="n">gro_size</span><span class="p">;</span>
		<span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">gro_size</span> <span class="o">=</span> <span class="n">gro_size</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef BNX2X_STOP_ON_ERROR</span>
	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">tpa_queue_used</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">queue</span><span class="p">);</span>
<span class="cp">#ifdef _ASM_GENERIC_INT_L64_H</span>
	<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_RX_STATUS</span><span class="p">,</span> <span class="s">&quot;fp-&gt;tpa_queue_used = 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="cp">#else</span>
	<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_RX_STATUS</span><span class="p">,</span> <span class="s">&quot;fp-&gt;tpa_queue_used = 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="cp">#endif</span>
	   <span class="n">fp</span><span class="o">-&gt;</span><span class="n">tpa_queue_used</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* Timestamp option length allowed for TPA aggregation:</span>
<span class="cm"> *</span>
<span class="cm"> *		nop nop kind length echo val</span>
<span class="cm"> */</span>
<span class="cp">#define TPA_TSTAMP_OPT_LEN	12</span>
<span class="cm">/**</span>
<span class="cm"> * bnx2x_set_lro_mss - calculate the approximate value of the MSS</span>
<span class="cm"> *</span>
<span class="cm"> * @bp:			driver handle</span>
<span class="cm"> * @parsing_flags:	parsing flags from the START CQE</span>
<span class="cm"> * @len_on_bd:		total length of the first packet for the</span>
<span class="cm"> *			aggregation.</span>
<span class="cm"> *</span>
<span class="cm"> * Approximate value of the MSS for this aggregation calculated using</span>
<span class="cm"> * the first packet of it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">bnx2x_set_lro_mss</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">u16</span> <span class="n">parsing_flags</span><span class="p">,</span>
			     <span class="n">u16</span> <span class="n">len_on_bd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * TPA arrgregation won&#39;t have either IP options or TCP options</span>
<span class="cm">	 * other than timestamp or IPv6 extension headers.</span>
<span class="cm">	 */</span>
	<span class="n">u16</span> <span class="n">hdrs_len</span> <span class="o">=</span> <span class="n">ETH_HLEN</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">GET_FLAG</span><span class="p">(</span><span class="n">parsing_flags</span><span class="p">,</span> <span class="n">PARSING_FLAGS_OVER_ETHERNET_PROTOCOL</span><span class="p">)</span> <span class="o">==</span>
	    <span class="n">PRS_FLAG_OVERETH_IPV6</span><span class="p">)</span>
		<span class="n">hdrs_len</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipv6hdr</span><span class="p">);</span>
	<span class="k">else</span> <span class="cm">/* IPv4 */</span>
		<span class="n">hdrs_len</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span><span class="p">);</span>


	<span class="cm">/* Check if there was a TCP timestamp, if there is it&#39;s will</span>
<span class="cm">	 * always be 12 bytes length: nop nop kind length echo val.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Otherwise FW would close the aggregation.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parsing_flags</span> <span class="o">&amp;</span> <span class="n">PARSING_FLAGS_TIME_STAMP_EXIST_FLAG</span><span class="p">)</span>
		<span class="n">hdrs_len</span> <span class="o">+=</span> <span class="n">TPA_TSTAMP_OPT_LEN</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">len_on_bd</span> <span class="o">-</span> <span class="n">hdrs_len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bnx2x_alloc_rx_sge</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="n">u16</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="n">PAGES_PER_SGE_SHIFT</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sw_rx_page</span> <span class="o">*</span><span class="n">sw_buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_page_ring</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">eth_rx_sge</span> <span class="o">*</span><span class="n">sge</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_sge_ring</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
	<span class="n">dma_addr_t</span> <span class="n">mapping</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;Can&#39;t alloc sge</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mapping</span> <span class="o">=</span> <span class="n">dma_map_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			       <span class="n">SGE_PAGE_SIZE</span><span class="o">*</span><span class="n">PAGES_PER_SGE</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">mapping</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">__free_pages</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">PAGES_PER_SGE_SHIFT</span><span class="p">);</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;Can&#39;t map sge</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sw_buf</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="n">dma_unmap_addr_set</span><span class="p">(</span><span class="n">sw_buf</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">mapping</span><span class="p">);</span>

	<span class="n">sge</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">U64_HI</span><span class="p">(</span><span class="n">mapping</span><span class="p">));</span>
	<span class="n">sge</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">U64_LO</span><span class="p">(</span><span class="n">mapping</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bnx2x_fill_frag_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">bnx2x_agg_info</span> <span class="o">*</span><span class="n">tpa_info</span><span class="p">,</span>
			       <span class="n">u16</span> <span class="n">pages</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">eth_end_agg_rx_cqe</span> <span class="o">*</span><span class="n">cqe</span><span class="p">,</span>
			       <span class="n">u16</span> <span class="n">cqe_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sw_rx_page</span> <span class="o">*</span><span class="n">rx_pg</span><span class="p">,</span> <span class="n">old_rx_pg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">,</span> <span class="n">frag_len</span><span class="p">,</span> <span class="n">frag_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">frag_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">len_on_bd</span> <span class="o">=</span> <span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">len_on_bd</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">full_page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gro_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">frag_size</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">cqe</span><span class="o">-&gt;</span><span class="n">pkt_len</span><span class="p">)</span> <span class="o">-</span> <span class="n">len_on_bd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">TPA_MODE_GRO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gro_size</span> <span class="o">=</span> <span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">gro_size</span><span class="p">;</span>
		<span class="n">full_page</span> <span class="o">=</span> <span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">full_page</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* This is needed in order to enable forwarding support */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frag_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span> <span class="o">=</span> <span class="n">bnx2x_set_lro_mss</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span>
					<span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">parsing_flags</span><span class="p">,</span> <span class="n">len_on_bd</span><span class="p">);</span>

		<span class="cm">/* set for GRO */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">TPA_MODE_GRO</span><span class="p">)</span>
			<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">GET_FLAG</span><span class="p">(</span><span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">parsing_flags</span><span class="p">,</span>
				      <span class="n">PARSING_FLAGS_OVER_ETHERNET_PROTOCOL</span><span class="p">)</span> <span class="o">==</span>
						<span class="n">PRS_FLAG_OVERETH_IPV6</span><span class="p">)</span> <span class="o">?</span>
				<span class="n">SKB_GSO_TCPV6</span> <span class="o">:</span> <span class="n">SKB_GSO_TCPV4</span><span class="p">;</span>
	<span class="p">}</span>


<span class="cp">#ifdef BNX2X_STOP_ON_ERROR</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pages</span> <span class="o">&gt;</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">MAX_SKB_FRAGS</span><span class="p">)</span><span class="o">*</span><span class="n">SGE_PAGE_SIZE</span><span class="o">*</span><span class="n">PAGES_PER_SGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;SGL length is too long: %d. CQE index is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">pages</span><span class="p">,</span> <span class="n">cqe_idx</span><span class="p">);</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;cqe-&gt;pkt_len = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cqe</span><span class="o">-&gt;</span><span class="n">pkt_len</span><span class="p">);</span>
		<span class="n">bnx2x_panic</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* Run through the SGL and compose the fragmented skb */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pages</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">PAGES_PER_SGE</span><span class="p">,</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">sge_idx</span> <span class="o">=</span> <span class="n">RX_SGE</span><span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">cqe</span><span class="o">-&gt;</span><span class="n">sgl_or_raw_data</span><span class="p">.</span><span class="n">sgl</span><span class="p">[</span><span class="n">j</span><span class="p">]));</span>

		<span class="cm">/* FW gives the indices of the SGE as if the ring is an array</span>
<span class="cm">		   (meaning that &quot;next&quot; element will consume 2 indices) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">TPA_MODE_GRO</span><span class="p">)</span>
			<span class="n">frag_len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">frag_size</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">full_page</span><span class="p">);</span>
		<span class="k">else</span> <span class="cm">/* LRO */</span>
			<span class="n">frag_len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">frag_size</span><span class="p">,</span>
					 <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">SGE_PAGE_SIZE</span> <span class="o">*</span> <span class="n">PAGES_PER_SGE</span><span class="p">));</span>

		<span class="n">rx_pg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_page_ring</span><span class="p">[</span><span class="n">sge_idx</span><span class="p">];</span>
		<span class="n">old_rx_pg</span> <span class="o">=</span> <span class="o">*</span><span class="n">rx_pg</span><span class="p">;</span>

		<span class="cm">/* If we fail to allocate a substitute page, we simply stop</span>
<span class="cm">		   where we are and drop the whole packet */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">bnx2x_alloc_rx_sge</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">sge_idx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">fp</span><span class="o">-&gt;</span><span class="n">eth_q_stats</span><span class="p">.</span><span class="n">rx_skb_alloc_failed</span><span class="o">++</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Unmap the page as we r going to pass it to the stack */</span>
		<span class="n">dma_unmap_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			       <span class="n">dma_unmap_addr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_rx_pg</span><span class="p">,</span> <span class="n">mapping</span><span class="p">),</span>
			       <span class="n">SGE_PAGE_SIZE</span><span class="o">*</span><span class="n">PAGES_PER_SGE</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="cm">/* Add one frag and update the appropriate fields in the skb */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">TPA_MODE_LRO</span><span class="p">)</span>
			<span class="n">skb_fill_page_desc</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">old_rx_pg</span><span class="p">.</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">frag_len</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span> <span class="cm">/* GRO */</span>
			<span class="kt">int</span> <span class="n">rem</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">rem</span> <span class="o">=</span> <span class="n">frag_len</span><span class="p">;</span> <span class="n">rem</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rem</span> <span class="o">-=</span> <span class="n">gro_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">rem</span> <span class="o">&gt;</span> <span class="n">gro_size</span> <span class="o">?</span> <span class="n">gro_size</span> <span class="o">:</span> <span class="n">rem</span><span class="p">;</span>
				<span class="n">skb_fill_page_desc</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">frag_id</span><span class="o">++</span><span class="p">,</span>
						   <span class="n">old_rx_pg</span><span class="p">.</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">offset</span><span class="p">)</span>
					<span class="n">get_page</span><span class="p">(</span><span class="n">old_rx_pg</span><span class="p">.</span><span class="n">page</span><span class="p">);</span>
				<span class="n">offset</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+=</span> <span class="n">frag_len</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">SGE_PAGE_SIZE</span> <span class="o">*</span> <span class="n">PAGES_PER_SGE</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">frag_len</span><span class="p">;</span>

		<span class="n">frag_size</span> <span class="o">-=</span> <span class="n">frag_len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bnx2x_tpa_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">bnx2x_agg_info</span> <span class="o">*</span><span class="n">tpa_info</span><span class="p">,</span>
			   <span class="n">u16</span> <span class="n">pages</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">eth_end_agg_rx_cqe</span> <span class="o">*</span><span class="n">cqe</span><span class="p">,</span>
			   <span class="n">u16</span> <span class="n">cqe_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sw_rx_bd</span> <span class="o">*</span><span class="n">rx_buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">first_buf</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pad</span> <span class="o">=</span> <span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">placement_offset</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">len</span> <span class="o">=</span> <span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">len_on_bd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">new_data</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">rx_buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">old_tpa_state</span> <span class="o">=</span> <span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">tpa_state</span><span class="p">;</span>

	<span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">tpa_state</span> <span class="o">=</span> <span class="n">BNX2X_TPA_STOP</span><span class="p">;</span>

	<span class="cm">/* If we there was an error during the handling of the TPA_START -</span>
<span class="cm">	 * drop this aggregation.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_tpa_state</span> <span class="o">==</span> <span class="n">BNX2X_TPA_ERROR</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

	<span class="cm">/* Try to allocate the new data */</span>
	<span class="n">new_data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_buf_size</span> <span class="o">+</span> <span class="n">NET_SKB_PAD</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="cm">/* Unmap skb in the pool anyway, as we are going to change</span>
<span class="cm">	   pool entry status to BNX2X_TPA_STOP even if new skb allocation</span>
<span class="cm">	   fails. */</span>
	<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_unmap_addr</span><span class="p">(</span><span class="n">rx_buf</span><span class="p">,</span> <span class="n">mapping</span><span class="p">),</span>
			 <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_buf_size</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">new_data</span><span class="p">))</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">build_skb</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#ifdef BNX2X_STOP_ON_ERROR</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pad</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_buf_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;skb_put is about to fail...  pad %d  len %d  rx_buf_size %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">pad</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_buf_size</span><span class="p">);</span>
			<span class="n">bnx2x_panic</span><span class="p">();</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>

		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pad</span> <span class="o">+</span> <span class="n">NET_SKB_PAD</span><span class="p">);</span>
		<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">rxhash</span> <span class="o">=</span> <span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">rxhash</span><span class="p">;</span>

		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_UNNECESSARY</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bnx2x_fill_frag_skb</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">tpa_info</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span>
					 <span class="n">skb</span><span class="p">,</span> <span class="n">cqe</span><span class="p">,</span> <span class="n">cqe_idx</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">parsing_flags</span> <span class="o">&amp;</span> <span class="n">PARSING_FLAGS_VLAN</span><span class="p">)</span>
				<span class="n">__vlan_hwaccel_put_tag</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">vlan_tag</span><span class="p">);</span>
			<span class="n">napi_gro_receive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_RX_STATUS</span><span class="p">,</span>
			   <span class="s">&quot;Failed to allocate new pages - dropping packet!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>


		<span class="cm">/* put new data in bin */</span>
		<span class="n">rx_buf</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">new_data</span><span class="p">;</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">new_data</span><span class="p">);</span>
<span class="nl">drop:</span>
	<span class="cm">/* drop the packet and keep the buffer in the bin */</span>
	<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_RX_STATUS</span><span class="p">,</span>
	   <span class="s">&quot;Failed to allocate or map a new skb - dropping packet!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">eth_q_stats</span><span class="p">.</span><span class="n">rx_skb_alloc_failed</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bnx2x_alloc_rx_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="n">u16</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sw_rx_bd</span> <span class="o">*</span><span class="n">rx_buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_buf_ring</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">eth_rx_bd</span> <span class="o">*</span><span class="n">rx_bd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_desc_ring</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
	<span class="n">dma_addr_t</span> <span class="n">mapping</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_buf_size</span> <span class="o">+</span> <span class="n">NET_SKB_PAD</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">mapping</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span> <span class="o">+</span> <span class="n">NET_SKB_PAD</span><span class="p">,</span>
				 <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_buf_size</span><span class="p">,</span>
				 <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">mapping</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;Can&#39;t map rx data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rx_buf</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">dma_unmap_addr_set</span><span class="p">(</span><span class="n">rx_buf</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">mapping</span><span class="p">);</span>

	<span class="n">rx_bd</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">U64_HI</span><span class="p">(</span><span class="n">mapping</span><span class="p">));</span>
	<span class="n">rx_bd</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">U64_LO</span><span class="p">(</span><span class="n">mapping</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bnx2x_csum_validate</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">union</span> <span class="n">eth_rx_cqe</span> <span class="o">*</span><span class="n">cqe</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Do nothing if no IP/L4 csum validation was done */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cqe</span><span class="o">-&gt;</span><span class="n">fast_path_cqe</span><span class="p">.</span><span class="n">status_flags</span> <span class="o">&amp;</span>
	    <span class="p">(</span><span class="n">ETH_FAST_PATH_RX_CQE_IP_XSUM_NO_VALIDATION_FLG</span> <span class="o">|</span>
	     <span class="n">ETH_FAST_PATH_RX_CQE_L4_XSUM_NO_VALIDATION_FLG</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* If both IP/L4 validation were done, check if an error was found. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cqe</span><span class="o">-&gt;</span><span class="n">fast_path_cqe</span><span class="p">.</span><span class="n">type_error_flags</span> <span class="o">&amp;</span>
	    <span class="p">(</span><span class="n">ETH_FAST_PATH_RX_CQE_IP_BAD_XSUM_FLG</span> <span class="o">|</span>
	     <span class="n">ETH_FAST_PATH_RX_CQE_L4_BAD_XSUM_FLG</span><span class="p">))</span>
		<span class="n">fp</span><span class="o">-&gt;</span><span class="n">eth_q_stats</span><span class="p">.</span><span class="n">hw_csum_err</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_UNNECESSARY</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bnx2x_rx_int</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">bd_cons</span><span class="p">,</span> <span class="n">bd_prod</span><span class="p">,</span> <span class="n">bd_prod_fw</span><span class="p">,</span> <span class="n">comp_ring_cons</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">hw_comp_cons</span><span class="p">,</span> <span class="n">sw_comp_cons</span><span class="p">,</span> <span class="n">sw_comp_prod</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rx_pkt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef BNX2X_STOP_ON_ERROR</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">panic</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* CQ &quot;next element&quot; is of the size of the regular element,</span>
<span class="cm">	   that&#39;s why it&#39;s ok here */</span>
	<span class="n">hw_comp_cons</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_cons_sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hw_comp_cons</span> <span class="o">&amp;</span> <span class="n">MAX_RCQ_DESC_CNT</span><span class="p">)</span> <span class="o">==</span> <span class="n">MAX_RCQ_DESC_CNT</span><span class="p">)</span>
		<span class="n">hw_comp_cons</span><span class="o">++</span><span class="p">;</span>

	<span class="n">bd_cons</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_bd_cons</span><span class="p">;</span>
	<span class="n">bd_prod</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_bd_prod</span><span class="p">;</span>
	<span class="n">bd_prod_fw</span> <span class="o">=</span> <span class="n">bd_prod</span><span class="p">;</span>
	<span class="n">sw_comp_cons</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_comp_cons</span><span class="p">;</span>
	<span class="n">sw_comp_prod</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_comp_prod</span><span class="p">;</span>

	<span class="cm">/* Memory barrier necessary as speculative reads of the rx</span>
<span class="cm">	 * buffer can be ahead of the index in the status block</span>
<span class="cm">	 */</span>
	<span class="n">rmb</span><span class="p">();</span>

	<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_RX_STATUS</span><span class="p">,</span>
	   <span class="s">&quot;queue[%d]:  hw_comp_cons %u  sw_comp_cons %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	   <span class="n">fp</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">hw_comp_cons</span><span class="p">,</span> <span class="n">sw_comp_cons</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">sw_comp_cons</span> <span class="o">!=</span> <span class="n">hw_comp_cons</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sw_rx_bd</span> <span class="o">*</span><span class="n">rx_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
		<span class="k">union</span> <span class="n">eth_rx_cqe</span> <span class="o">*</span><span class="n">cqe</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">eth_fast_path_rx_cqe</span> <span class="o">*</span><span class="n">cqe_fp</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">cqe_fp_flags</span><span class="p">;</span>
		<span class="k">enum</span> <span class="n">eth_rx_cqe_type</span> <span class="n">cqe_fp_type</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">len</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">queue</span><span class="p">;</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

<span class="cp">#ifdef BNX2X_STOP_ON_ERROR</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">panic</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

		<span class="n">comp_ring_cons</span> <span class="o">=</span> <span class="n">RCQ_BD</span><span class="p">(</span><span class="n">sw_comp_cons</span><span class="p">);</span>
		<span class="n">bd_prod</span> <span class="o">=</span> <span class="n">RX_BD</span><span class="p">(</span><span class="n">bd_prod</span><span class="p">);</span>
		<span class="n">bd_cons</span> <span class="o">=</span> <span class="n">RX_BD</span><span class="p">(</span><span class="n">bd_cons</span><span class="p">);</span>

		<span class="n">cqe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_comp_ring</span><span class="p">[</span><span class="n">comp_ring_cons</span><span class="p">];</span>
		<span class="n">cqe_fp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cqe</span><span class="o">-&gt;</span><span class="n">fast_path_cqe</span><span class="p">;</span>
		<span class="n">cqe_fp_flags</span> <span class="o">=</span> <span class="n">cqe_fp</span><span class="o">-&gt;</span><span class="n">type_error_flags</span><span class="p">;</span>
		<span class="n">cqe_fp_type</span> <span class="o">=</span> <span class="n">cqe_fp_flags</span> <span class="o">&amp;</span> <span class="n">ETH_FAST_PATH_RX_CQE_TYPE</span><span class="p">;</span>

		<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_RX_STATUS</span><span class="p">,</span>
		   <span class="s">&quot;CQE type %x  err %x  status %x  queue %x  vlan %x  len %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">CQE_TYPE</span><span class="p">(</span><span class="n">cqe_fp_flags</span><span class="p">),</span>
		   <span class="n">cqe_fp_flags</span><span class="p">,</span> <span class="n">cqe_fp</span><span class="o">-&gt;</span><span class="n">status_flags</span><span class="p">,</span>
		   <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cqe_fp</span><span class="o">-&gt;</span><span class="n">rss_hash_result</span><span class="p">),</span>
		   <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">cqe_fp</span><span class="o">-&gt;</span><span class="n">vlan_tag</span><span class="p">),</span>
		   <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">cqe_fp</span><span class="o">-&gt;</span><span class="n">pkt_len_or_gro_seg_len</span><span class="p">));</span>

		<span class="cm">/* is this a slowpath msg? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">CQE_TYPE_SLOW</span><span class="p">(</span><span class="n">cqe_fp_type</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">bnx2x_sp_event</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">cqe</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">next_cqe</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rx_buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_buf_ring</span><span class="p">[</span><span class="n">bd_cons</span><span class="p">];</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">rx_buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CQE_TYPE_FAST</span><span class="p">(</span><span class="n">cqe_fp_type</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">bnx2x_agg_info</span> <span class="o">*</span><span class="n">tpa_info</span><span class="p">;</span>
			<span class="n">u16</span> <span class="n">frag_size</span><span class="p">,</span> <span class="n">pages</span><span class="p">;</span>
<span class="cp">#ifdef BNX2X_STOP_ON_ERROR</span>
			<span class="cm">/* sanity check */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">disable_tpa</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">CQE_TYPE_START</span><span class="p">(</span><span class="n">cqe_fp_type</span><span class="p">)</span> <span class="o">||</span>
			     <span class="n">CQE_TYPE_STOP</span><span class="p">(</span><span class="n">cqe_fp_type</span><span class="p">)))</span>
				<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;START/STOP packet while disable_tpa type %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">CQE_TYPE</span><span class="p">(</span><span class="n">cqe_fp_type</span><span class="p">));</span>
<span class="cp">#endif</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">CQE_TYPE_START</span><span class="p">(</span><span class="n">cqe_fp_type</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">u16</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">cqe_fp</span><span class="o">-&gt;</span><span class="n">queue_index</span><span class="p">;</span>
				<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_RX_STATUS</span><span class="p">,</span>
				   <span class="s">&quot;calling tpa_start on queue %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">queue</span><span class="p">);</span>

				<span class="n">bnx2x_tpa_start</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span>
						<span class="n">bd_cons</span><span class="p">,</span> <span class="n">bd_prod</span><span class="p">,</span>
						<span class="n">cqe_fp</span><span class="p">);</span>

				<span class="k">goto</span> <span class="n">next_rx</span><span class="p">;</span>

			<span class="p">}</span>
			<span class="n">queue</span> <span class="o">=</span> <span class="n">cqe</span><span class="o">-&gt;</span><span class="n">end_agg_cqe</span><span class="p">.</span><span class="n">queue_index</span><span class="p">;</span>
			<span class="n">tpa_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">tpa_info</span><span class="p">[</span><span class="n">queue</span><span class="p">];</span>
			<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_RX_STATUS</span><span class="p">,</span>
			   <span class="s">&quot;calling tpa_stop on queue %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">queue</span><span class="p">);</span>

			<span class="n">frag_size</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">cqe</span><span class="o">-&gt;</span><span class="n">end_agg_cqe</span><span class="p">.</span><span class="n">pkt_len</span><span class="p">)</span> <span class="o">-</span>
				    <span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">len_on_bd</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">TPA_MODE_GRO</span><span class="p">)</span>
				<span class="n">pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">frag_size</span> <span class="o">+</span> <span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">full_page</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span>
					 <span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">full_page</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">pages</span> <span class="o">=</span> <span class="n">SGE_PAGE_ALIGN</span><span class="p">(</span><span class="n">frag_size</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
					<span class="n">SGE_PAGE_SHIFT</span><span class="p">;</span>

			<span class="n">bnx2x_tpa_stop</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">tpa_info</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">cqe</span><span class="o">-&gt;</span><span class="n">end_agg_cqe</span><span class="p">,</span> <span class="n">comp_ring_cons</span><span class="p">);</span>
<span class="cp">#ifdef BNX2X_STOP_ON_ERROR</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">panic</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

			<span class="n">bnx2x_update_sge_prod</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqe</span><span class="o">-&gt;</span><span class="n">end_agg_cqe</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">next_cqe</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* non TPA */</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">cqe_fp</span><span class="o">-&gt;</span><span class="n">pkt_len_or_gro_seg_len</span><span class="p">);</span>
		<span class="n">pad</span> <span class="o">=</span> <span class="n">cqe_fp</span><span class="o">-&gt;</span><span class="n">placement_offset</span><span class="p">;</span>
		<span class="n">dma_sync_single_for_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="n">dma_unmap_addr</span><span class="p">(</span><span class="n">rx_buf</span><span class="p">,</span> <span class="n">mapping</span><span class="p">),</span>
					<span class="n">pad</span> <span class="o">+</span> <span class="n">RX_COPY_THRESH</span><span class="p">,</span>
					<span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="n">pad</span> <span class="o">+=</span> <span class="n">NET_SKB_PAD</span><span class="p">;</span>
		<span class="n">prefetch</span><span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="n">pad</span><span class="p">);</span> <span class="cm">/* speedup eth_type_trans() */</span>
		<span class="cm">/* is this an error packet? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cqe_fp_flags</span> <span class="o">&amp;</span> <span class="n">ETH_RX_ERROR_FALGS</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_RX_ERR</span> <span class="o">|</span> <span class="n">NETIF_MSG_RX_STATUS</span><span class="p">,</span>
			   <span class="s">&quot;ERROR  flags %x  rx packet %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">cqe_fp_flags</span><span class="p">,</span> <span class="n">sw_comp_cons</span><span class="p">);</span>
			<span class="n">fp</span><span class="o">-&gt;</span><span class="n">eth_q_stats</span><span class="p">.</span><span class="n">rx_err_discard_pkt</span><span class="o">++</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">reuse_rx</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Since we don&#39;t have a jumbo ring</span>
<span class="cm">		 * copy small packets if mtu &gt; 1500</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">&gt;</span> <span class="n">ETH_MAX_PACKET_SIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">RX_COPY_THRESH</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb_ip_align</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_RX_ERR</span> <span class="o">|</span> <span class="n">NETIF_MSG_RX_STATUS</span><span class="p">,</span>
				   <span class="s">&quot;ERROR  packet dropped because of alloc failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">fp</span><span class="o">-&gt;</span><span class="n">eth_q_stats</span><span class="p">.</span><span class="n">rx_skb_alloc_failed</span><span class="o">++</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">reuse_rx</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span> <span class="o">+</span> <span class="n">pad</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">bnx2x_reuse_rx_data</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">bd_cons</span><span class="p">,</span> <span class="n">bd_prod</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">bnx2x_alloc_rx_data</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">bd_prod</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						 <span class="n">dma_unmap_addr</span><span class="p">(</span><span class="n">rx_buf</span><span class="p">,</span> <span class="n">mapping</span><span class="p">),</span>
						 <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_buf_size</span><span class="p">,</span>
						 <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
				<span class="n">skb</span> <span class="o">=</span> <span class="n">build_skb</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
					<span class="n">fp</span><span class="o">-&gt;</span><span class="n">eth_q_stats</span><span class="p">.</span><span class="n">rx_skb_alloc_failed</span><span class="o">++</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">next_rx</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pad</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_RX_ERR</span> <span class="o">|</span> <span class="n">NETIF_MSG_RX_STATUS</span><span class="p">,</span>
				   <span class="s">&quot;ERROR  packet dropped because of alloc failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">fp</span><span class="o">-&gt;</span><span class="n">eth_q_stats</span><span class="p">.</span><span class="n">rx_skb_alloc_failed</span><span class="o">++</span><span class="p">;</span>
<span class="nl">reuse_rx:</span>
				<span class="n">bnx2x_reuse_rx_data</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">bd_cons</span><span class="p">,</span> <span class="n">bd_prod</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">next_rx</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

		<span class="cm">/* Set Toeplitz hash for a none-LRO skb */</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">rxhash</span> <span class="o">=</span> <span class="n">bnx2x_get_rxhash</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">cqe_fp</span><span class="p">);</span>

		<span class="n">skb_checksum_none_assert</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXCSUM</span><span class="p">)</span>
			<span class="n">bnx2x_csum_validate</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">cqe</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>


		<span class="n">skb_record_rx_queue</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">cqe_fp</span><span class="o">-&gt;</span><span class="n">pars_flags</span><span class="p">.</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;</span>
		    <span class="n">PARSING_FLAGS_VLAN</span><span class="p">)</span>
			<span class="n">__vlan_hwaccel_put_tag</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
					       <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">cqe_fp</span><span class="o">-&gt;</span><span class="n">vlan_tag</span><span class="p">));</span>
		<span class="n">napi_gro_receive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>


<span class="nl">next_rx:</span>
		<span class="n">rx_buf</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">bd_cons</span> <span class="o">=</span> <span class="n">NEXT_RX_IDX</span><span class="p">(</span><span class="n">bd_cons</span><span class="p">);</span>
		<span class="n">bd_prod</span> <span class="o">=</span> <span class="n">NEXT_RX_IDX</span><span class="p">(</span><span class="n">bd_prod</span><span class="p">);</span>
		<span class="n">bd_prod_fw</span> <span class="o">=</span> <span class="n">NEXT_RX_IDX</span><span class="p">(</span><span class="n">bd_prod_fw</span><span class="p">);</span>
		<span class="n">rx_pkt</span><span class="o">++</span><span class="p">;</span>
<span class="nl">next_cqe:</span>
		<span class="n">sw_comp_prod</span> <span class="o">=</span> <span class="n">NEXT_RCQ_IDX</span><span class="p">(</span><span class="n">sw_comp_prod</span><span class="p">);</span>
		<span class="n">sw_comp_cons</span> <span class="o">=</span> <span class="n">NEXT_RCQ_IDX</span><span class="p">(</span><span class="n">sw_comp_cons</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rx_pkt</span> <span class="o">==</span> <span class="n">budget</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span> <span class="cm">/* while */</span>

	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_bd_cons</span> <span class="o">=</span> <span class="n">bd_cons</span><span class="p">;</span>
	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_bd_prod</span> <span class="o">=</span> <span class="n">bd_prod_fw</span><span class="p">;</span>
	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_comp_cons</span> <span class="o">=</span> <span class="n">sw_comp_cons</span><span class="p">;</span>
	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_comp_prod</span> <span class="o">=</span> <span class="n">sw_comp_prod</span><span class="p">;</span>

	<span class="cm">/* Update producers */</span>
	<span class="n">bnx2x_update_rx_prod</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">bd_prod_fw</span><span class="p">,</span> <span class="n">sw_comp_prod</span><span class="p">,</span>
			     <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_sge_prod</span><span class="p">);</span>

	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_pkt</span> <span class="o">+=</span> <span class="n">rx_pkt</span><span class="p">;</span>
	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_calls</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rx_pkt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">bnx2x_msix_fp_int</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fp_cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fp_cookie</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cos</span><span class="p">;</span>

	<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_INTR</span><span class="p">,</span>
	   <span class="s">&quot;got an MSI-X interrupt on IDX:SB [fp %d fw_sd %d igusb %d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	   <span class="n">fp</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">fw_sb_id</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">igu_sb_id</span><span class="p">);</span>
	<span class="n">bnx2x_ack_sb</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">igu_sb_id</span><span class="p">,</span> <span class="n">USTORM_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">IGU_INT_DISABLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cp">#ifdef BNX2X_STOP_ON_ERROR</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">panic</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* Handle Rx and Tx according to MSI-X vector */</span>
	<span class="n">prefetch</span><span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_cons_sb</span><span class="p">);</span>

	<span class="n">for_each_cos_in_tx_queue</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">cos</span><span class="p">)</span>
		<span class="n">prefetch</span><span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">txdata</span><span class="p">[</span><span class="n">cos</span><span class="p">].</span><span class="n">tx_cons_sb</span><span class="p">);</span>

	<span class="n">prefetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">sb_running_index</span><span class="p">[</span><span class="n">SM_RX_ID</span><span class="p">]);</span>
	<span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">napi</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* HW Lock for shared dual port PHYs */</span>
<span class="kt">void</span> <span class="nf">bnx2x_acquire_phy_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">phy_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">need_hw_lock</span><span class="p">)</span>
		<span class="n">bnx2x_acquire_hw_lock</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">HW_LOCK_RESOURCE_MDIO</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bnx2x_release_phy_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">need_hw_lock</span><span class="p">)</span>
		<span class="n">bnx2x_release_hw_lock</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">HW_LOCK_RESOURCE_MDIO</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">phy_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* calculates MF speed according to current linespeed and MF configuration */</span>
<span class="n">u16</span> <span class="nf">bnx2x_get_mf_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">line_speed</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">link_vars</span><span class="p">.</span><span class="n">line_speed</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_MF</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">maxCfg</span> <span class="o">=</span> <span class="n">bnx2x_extract_max_cfg</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span>
						   <span class="n">bp</span><span class="o">-&gt;</span><span class="n">mf_config</span><span class="p">[</span><span class="n">BP_VN</span><span class="p">(</span><span class="n">bp</span><span class="p">)]);</span>

		<span class="cm">/* Calculate the current MAX line speed limit for the MF</span>
<span class="cm">		 * devices</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_MF_SI</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span>
			<span class="n">line_speed</span> <span class="o">=</span> <span class="p">(</span><span class="n">line_speed</span> <span class="o">*</span> <span class="n">maxCfg</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span> <span class="cm">/* SD mode */</span>
			<span class="n">u16</span> <span class="n">vn_max_rate</span> <span class="o">=</span> <span class="n">maxCfg</span> <span class="o">*</span> <span class="mi">100</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">vn_max_rate</span> <span class="o">&lt;</span> <span class="n">line_speed</span><span class="p">)</span>
				<span class="n">line_speed</span> <span class="o">=</span> <span class="n">vn_max_rate</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">line_speed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bnx2x_fill_report_data - fill link report data to report</span>
<span class="cm"> *</span>
<span class="cm"> * @bp:		driver handle</span>
<span class="cm"> * @data:	link state to update</span>
<span class="cm"> *</span>
<span class="cm"> * It uses a none-atomic bit operations because is called under the mutex.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bnx2x_fill_report_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">bnx2x_link_report_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">line_speed</span> <span class="o">=</span> <span class="n">bnx2x_get_mf_speed</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">));</span>

	<span class="cm">/* Fill the report data: efective line speed */</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">line_speed</span> <span class="o">=</span> <span class="n">line_speed</span><span class="p">;</span>

	<span class="cm">/* Link is down */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">link_vars</span><span class="p">.</span><span class="n">link_up</span> <span class="o">||</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MF_FUNC_DIS</span><span class="p">))</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">BNX2X_LINK_REPORT_LINK_DOWN</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">link_report_flags</span><span class="p">);</span>

	<span class="cm">/* Full DUPLEX */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">link_vars</span><span class="p">.</span><span class="n">duplex</span> <span class="o">==</span> <span class="n">DUPLEX_FULL</span><span class="p">)</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">BNX2X_LINK_REPORT_FD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">link_report_flags</span><span class="p">);</span>

	<span class="cm">/* Rx Flow Control is ON */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">link_vars</span><span class="p">.</span><span class="n">flow_ctrl</span> <span class="o">&amp;</span> <span class="n">BNX2X_FLOW_CTRL_RX</span><span class="p">)</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">BNX2X_LINK_REPORT_RX_FC_ON</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">link_report_flags</span><span class="p">);</span>

	<span class="cm">/* Tx Flow Control is ON */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">link_vars</span><span class="p">.</span><span class="n">flow_ctrl</span> <span class="o">&amp;</span> <span class="n">BNX2X_FLOW_CTRL_TX</span><span class="p">)</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">BNX2X_LINK_REPORT_TX_FC_ON</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">link_report_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bnx2x_link_report - report link status to OS.</span>
<span class="cm"> *</span>
<span class="cm"> * @bp:		driver handle</span>
<span class="cm"> *</span>
<span class="cm"> * Calls the __bnx2x_link_report() under the same locking scheme</span>
<span class="cm"> * as a link/PHY state managing code to ensure a consistent link</span>
<span class="cm"> * reporting.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">bnx2x_link_report</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bnx2x_acquire_phy_lock</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">__bnx2x_link_report</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">bnx2x_release_phy_lock</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __bnx2x_link_report - report link status to OS.</span>
<span class="cm"> *</span>
<span class="cm"> * @bp:		driver handle</span>
<span class="cm"> *</span>
<span class="cm"> * None atomic inmlementation.</span>
<span class="cm"> * Should be called under the phy_lock.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__bnx2x_link_report</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2x_link_report_data</span> <span class="n">cur_data</span><span class="p">;</span>

	<span class="cm">/* reread mf_cfg */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CHIP_IS_E1</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span>
		<span class="n">bnx2x_read_mf_cfg</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="cm">/* Read the current link report info */</span>
	<span class="n">bnx2x_fill_report_data</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur_data</span><span class="p">);</span>

	<span class="cm">/* Don&#39;t report link down or exactly the same link status twice */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cur_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">last_reported_link</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cur_data</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BNX2X_LINK_REPORT_LINK_DOWN</span><span class="p">,</span>
		      <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">last_reported_link</span><span class="p">.</span><span class="n">link_report_flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="n">test_bit</span><span class="p">(</span><span class="n">BNX2X_LINK_REPORT_LINK_DOWN</span><span class="p">,</span>
		      <span class="o">&amp;</span><span class="n">cur_data</span><span class="p">.</span><span class="n">link_report_flags</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">link_cnt</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* We are going to report a new link parameters now -</span>
<span class="cm">	 * remember the current data for the next time.</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">last_reported_link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur_data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cur_data</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BNX2X_LINK_REPORT_LINK_DOWN</span><span class="p">,</span>
		     <span class="o">&amp;</span><span class="n">cur_data</span><span class="p">.</span><span class="n">link_report_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;NIC Link is Down</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">duplex</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">flow</span><span class="p">;</span>

		<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">BNX2X_LINK_REPORT_FD</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">cur_data</span><span class="p">.</span><span class="n">link_report_flags</span><span class="p">))</span>
			<span class="n">duplex</span> <span class="o">=</span> <span class="s">&quot;full&quot;</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">duplex</span> <span class="o">=</span> <span class="s">&quot;half&quot;</span><span class="p">;</span>

		<span class="cm">/* Handle the FC at the end so that only these flags would be</span>
<span class="cm">		 * possibly set. This way we may easily check if there is no FC</span>
<span class="cm">		 * enabled.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur_data</span><span class="p">.</span><span class="n">link_report_flags</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BNX2X_LINK_REPORT_RX_FC_ON</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">cur_data</span><span class="p">.</span><span class="n">link_report_flags</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BNX2X_LINK_REPORT_TX_FC_ON</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">cur_data</span><span class="p">.</span><span class="n">link_report_flags</span><span class="p">))</span>
					<span class="n">flow</span> <span class="o">=</span> <span class="s">&quot;ON - receive &amp; transmit&quot;</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">flow</span> <span class="o">=</span> <span class="s">&quot;ON - receive&quot;</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">flow</span> <span class="o">=</span> <span class="s">&quot;ON - transmit&quot;</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">flow</span> <span class="o">=</span> <span class="s">&quot;none&quot;</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">netdev_info</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;NIC Link is Up, %d Mbps %s duplex, Flow control: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">cur_data</span><span class="p">.</span><span class="n">line_speed</span><span class="p">,</span> <span class="n">duplex</span><span class="p">,</span> <span class="n">flow</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bnx2x_set_next_page_sgl</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">NUM_RX_SGE_PAGES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">eth_rx_sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">;</span>

		<span class="n">sge</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_sge_ring</span><span class="p">[</span><span class="n">RX_SGE_CNT</span> <span class="o">*</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">];</span>
		<span class="n">sge</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span>
			<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">U64_HI</span><span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_sge_mapping</span> <span class="o">+</span>
			<span class="n">BCM_PAGE_SIZE</span><span class="o">*</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">NUM_RX_SGE_PAGES</span><span class="p">)));</span>

		<span class="n">sge</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span>
			<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">U64_LO</span><span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_sge_mapping</span> <span class="o">+</span>
			<span class="n">BCM_PAGE_SIZE</span><span class="o">*</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">NUM_RX_SGE_PAGES</span><span class="p">)));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bnx2x_free_tpa_pool</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">last</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">last</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">bnx2x_agg_info</span> <span class="o">*</span><span class="n">tpa_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">tpa_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">sw_rx_bd</span> <span class="o">*</span><span class="n">first_buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">first_buf</span><span class="p">;</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">first_buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_IFDOWN</span><span class="p">,</span> <span class="s">&quot;tpa bin %d empty on free</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">tpa_state</span> <span class="o">==</span> <span class="n">BNX2X_TPA_START</span><span class="p">)</span>
			<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					 <span class="n">dma_unmap_addr</span><span class="p">(</span><span class="n">first_buf</span><span class="p">,</span> <span class="n">mapping</span><span class="p">),</span>
					 <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_buf_size</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
		<span class="n">first_buf</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bnx2x_init_rx_rings</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">func</span> <span class="o">=</span> <span class="n">BP_FUNC</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">ring_prod</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="cm">/* Allocate TPA resources */</span>
	<span class="n">for_each_rx_queue</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

		<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_IFUP</span><span class="p">,</span>
		   <span class="s">&quot;mtu %d  rx_buf_size %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_buf_size</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">disable_tpa</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Fill the per-aggregtion pool */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_AGG_QS</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">bnx2x_agg_info</span> <span class="o">*</span><span class="n">tpa_info</span> <span class="o">=</span>
					<span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">tpa_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="k">struct</span> <span class="n">sw_rx_bd</span> <span class="o">*</span><span class="n">first_buf</span> <span class="o">=</span>
					<span class="o">&amp;</span><span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">first_buf</span><span class="p">;</span>

				<span class="n">first_buf</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_buf_size</span> <span class="o">+</span> <span class="n">NET_SKB_PAD</span><span class="p">,</span>
							  <span class="n">GFP_ATOMIC</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first_buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;Failed to allocate TPA skb pool for queue[%d] - disabling TPA on this queue!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						  <span class="n">j</span><span class="p">);</span>
					<span class="n">bnx2x_free_tpa_pool</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
					<span class="n">fp</span><span class="o">-&gt;</span><span class="n">disable_tpa</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">dma_unmap_addr_set</span><span class="p">(</span><span class="n">first_buf</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">tpa_info</span><span class="o">-&gt;</span><span class="n">tpa_state</span> <span class="o">=</span> <span class="n">BNX2X_TPA_STOP</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* &quot;next page&quot; elements initialization */</span>
			<span class="n">bnx2x_set_next_page_sgl</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

			<span class="cm">/* set SGEs bit mask */</span>
			<span class="n">bnx2x_init_sge_ring_bit_mask</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

			<span class="cm">/* Allocate SGEs and initialize the ring elements */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ring_prod</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			     <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_RX_SGE_CNT</span><span class="o">*</span><span class="n">NUM_RX_SGE_PAGES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">bnx2x_alloc_rx_sge</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">ring_prod</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;was only able to allocate %d rx sges</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						  <span class="n">i</span><span class="p">);</span>
					<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;disabling TPA for queue[%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						  <span class="n">j</span><span class="p">);</span>
					<span class="cm">/* Cleanup already allocated elements */</span>
					<span class="n">bnx2x_free_rx_sge_range</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span>
								<span class="n">ring_prod</span><span class="p">);</span>
					<span class="n">bnx2x_free_tpa_pool</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span>
							    <span class="n">MAX_AGG_QS</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
					<span class="n">fp</span><span class="o">-&gt;</span><span class="n">disable_tpa</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">ring_prod</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">ring_prod</span> <span class="o">=</span> <span class="n">NEXT_SGE_IDX</span><span class="p">(</span><span class="n">ring_prod</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_sge_prod</span> <span class="o">=</span> <span class="n">ring_prod</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">for_each_rx_queue</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

		<span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_bd_cons</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Activate BD ring */</span>
		<span class="cm">/* Warning!</span>
<span class="cm">		 * this will generate an interrupt (to the TSTORM)</span>
<span class="cm">		 * must only be done after chip is initialized</span>
<span class="cm">		 */</span>
		<span class="n">bnx2x_update_rx_prod</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_bd_prod</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_comp_prod</span><span class="p">,</span>
				     <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_sge_prod</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">CHIP_IS_E1</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">REG_WR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">BAR_USTRORM_INTMEM</span> <span class="o">+</span>
			       <span class="n">USTORM_MEM_WORKAROUND_ADDRESS_OFFSET</span><span class="p">(</span><span class="n">func</span><span class="p">),</span>
			       <span class="n">U64_LO</span><span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_comp_mapping</span><span class="p">));</span>
			<span class="n">REG_WR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">BAR_USTRORM_INTMEM</span> <span class="o">+</span>
			       <span class="n">USTORM_MEM_WORKAROUND_ADDRESS_OFFSET</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span>
			       <span class="n">U64_HI</span><span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_comp_mapping</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bnx2x_free_tx_skbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cos</span><span class="p">;</span>

	<span class="n">for_each_tx_queue</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">for_each_cos_in_tx_queue</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">cos</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">bnx2x_fp_txdata</span> <span class="o">*</span><span class="n">txdata</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">txdata</span><span class="p">[</span><span class="n">cos</span><span class="p">];</span>
			<span class="kt">unsigned</span> <span class="n">pkts_compl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bytes_compl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">u16</span> <span class="n">sw_prod</span> <span class="o">=</span> <span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_pkt_prod</span><span class="p">;</span>
			<span class="n">u16</span> <span class="n">sw_cons</span> <span class="o">=</span> <span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_pkt_cons</span><span class="p">;</span>

			<span class="k">while</span> <span class="p">(</span><span class="n">sw_cons</span> <span class="o">!=</span> <span class="n">sw_prod</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bnx2x_free_tx_pkt</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">txdata</span><span class="p">,</span> <span class="n">TX_BD</span><span class="p">(</span><span class="n">sw_cons</span><span class="p">),</span>
				    <span class="o">&amp;</span><span class="n">pkts_compl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bytes_compl</span><span class="p">);</span>
				<span class="n">sw_cons</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">netdev_tx_reset_queue</span><span class="p">(</span>
			    <span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">txdata</span><span class="o">-&gt;</span><span class="n">txq_index</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bnx2x_free_rx_bds</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* ring wasn&#39;t allocated */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_buf_ring</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_RX_BD</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sw_rx_bd</span> <span class="o">*</span><span class="n">rx_buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_buf_ring</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">rx_buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="n">dma_unmap_addr</span><span class="p">(</span><span class="n">rx_buf</span><span class="p">,</span> <span class="n">mapping</span><span class="p">),</span>
				 <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_buf_size</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>

		<span class="n">rx_buf</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bnx2x_free_rx_skbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">for_each_rx_queue</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

		<span class="n">bnx2x_free_rx_bds</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">disable_tpa</span><span class="p">)</span>
			<span class="n">bnx2x_free_tpa_pool</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">MAX_AGG_QS</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bnx2x_free_skbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bnx2x_free_tx_skbs</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">bnx2x_free_rx_skbs</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bnx2x_update_max_mf_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* load old values */</span>
	<span class="n">u32</span> <span class="n">mf_cfg</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">mf_config</span><span class="p">[</span><span class="n">BP_VN</span><span class="p">(</span><span class="n">bp</span><span class="p">)];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">!=</span> <span class="n">bnx2x_extract_max_cfg</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">mf_cfg</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* leave all but MAX value */</span>
		<span class="n">mf_cfg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FUNC_MF_CFG_MAX_BW_MASK</span><span class="p">;</span>

		<span class="cm">/* set new MAX value */</span>
		<span class="n">mf_cfg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">FUNC_MF_CFG_MAX_BW_SHIFT</span><span class="p">)</span>
				<span class="o">&amp;</span> <span class="n">FUNC_MF_CFG_MAX_BW_MASK</span><span class="p">;</span>

		<span class="n">bnx2x_fw_command</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">DRV_MSG_CODE_SET_MF_BW</span><span class="p">,</span> <span class="n">mf_cfg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bnx2x_free_msix_irqs - free previously requested MSI-X IRQ vectors</span>
<span class="cm"> *</span>
<span class="cm"> * @bp:		driver handle</span>
<span class="cm"> * @nvecs:	number of vectors to be released</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bnx2x_free_msix_irqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nvecs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nvecs</span> <span class="o">==</span> <span class="n">offset</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">msix_table</span><span class="p">[</span><span class="n">offset</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_IFDOWN</span><span class="p">,</span> <span class="s">&quot;released sp irq (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	   <span class="n">bp</span><span class="o">-&gt;</span><span class="n">msix_table</span><span class="p">[</span><span class="n">offset</span><span class="p">].</span><span class="n">vector</span><span class="p">);</span>
	<span class="n">offset</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#ifdef BCM_CNIC</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nvecs</span> <span class="o">==</span> <span class="n">offset</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">offset</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">for_each_eth_queue</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nvecs</span> <span class="o">==</span> <span class="n">offset</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_IFDOWN</span><span class="p">,</span> <span class="s">&quot;about to release fp #%d-&gt;%d irq</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">i</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">msix_table</span><span class="p">[</span><span class="n">offset</span><span class="p">].</span><span class="n">vector</span><span class="p">);</span>

		<span class="n">free_irq</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">msix_table</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bnx2x_free_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">USING_MSIX_FLAG</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">USING_SINGLE_MSIX_FLAG</span><span class="p">))</span>
		<span class="n">bnx2x_free_msix_irqs</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">BNX2X_NUM_ETH_QUEUES</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">+</span>
				     <span class="n">CNIC_PRESENT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">bnx2x_enable_msix</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">msix_vec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">req_cnt</span><span class="p">;</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">msix_table</span><span class="p">[</span><span class="n">msix_vec</span><span class="p">].</span><span class="n">entry</span> <span class="o">=</span> <span class="n">msix_vec</span><span class="p">;</span>
	<span class="n">BNX2X_DEV_INFO</span><span class="p">(</span><span class="s">&quot;msix_table[0].entry = %d (slowpath)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	   <span class="n">bp</span><span class="o">-&gt;</span><span class="n">msix_table</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">msix_vec</span><span class="o">++</span><span class="p">;</span>

<span class="cp">#ifdef BCM_CNIC</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">msix_table</span><span class="p">[</span><span class="n">msix_vec</span><span class="p">].</span><span class="n">entry</span> <span class="o">=</span> <span class="n">msix_vec</span><span class="p">;</span>
	<span class="n">BNX2X_DEV_INFO</span><span class="p">(</span><span class="s">&quot;msix_table[%d].entry = %d (CNIC)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	   <span class="n">bp</span><span class="o">-&gt;</span><span class="n">msix_table</span><span class="p">[</span><span class="n">msix_vec</span><span class="p">].</span><span class="n">entry</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">msix_table</span><span class="p">[</span><span class="n">msix_vec</span><span class="p">].</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">msix_vec</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/* We need separate vectors for ETH queues only (not FCoE) */</span>
	<span class="n">for_each_eth_queue</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">msix_table</span><span class="p">[</span><span class="n">msix_vec</span><span class="p">].</span><span class="n">entry</span> <span class="o">=</span> <span class="n">msix_vec</span><span class="p">;</span>
		<span class="n">BNX2X_DEV_INFO</span><span class="p">(</span><span class="s">&quot;msix_table[%d].entry = %d (fastpath #%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">msix_vec</span><span class="p">,</span> <span class="n">msix_vec</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">msix_vec</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">req_cnt</span> <span class="o">=</span> <span class="n">BNX2X_NUM_ETH_QUEUES</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">+</span> <span class="n">CNIC_PRESENT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_msix</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">msix_table</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">req_cnt</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * reconfigure number of tx/rx queues according to available</span>
<span class="cm">	 * MSI-X vectors</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&gt;=</span> <span class="n">BNX2X_MIN_MSIX_VEC_CNT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* how less vectors we will have? */</span>
		<span class="kt">int</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">req_cnt</span> <span class="o">-</span> <span class="n">rc</span><span class="p">;</span>

		<span class="n">BNX2X_DEV_INFO</span><span class="p">(</span><span class="s">&quot;Trying to use less MSI-X vectors: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_msix</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">msix_table</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rc</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BNX2X_DEV_INFO</span><span class="p">(</span><span class="s">&quot;MSI-X is not attainable rc %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">no_msix</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * decrease number of queues by number of unallocated entries</span>
<span class="cm">		 */</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">num_queues</span> <span class="o">-=</span> <span class="n">diff</span><span class="p">;</span>

		<span class="n">BNX2X_DEV_INFO</span><span class="p">(</span><span class="s">&quot;New queue configuration set: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">bp</span><span class="o">-&gt;</span><span class="n">num_queues</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get by with single vector */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_msix</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">msix_table</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BNX2X_DEV_INFO</span><span class="p">(</span><span class="s">&quot;Single MSI-X is not attainable rc %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">rc</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">no_msix</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">BNX2X_DEV_INFO</span><span class="p">(</span><span class="s">&quot;Using single MSI-X vector</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">USING_SINGLE_MSIX_FLAG</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BNX2X_DEV_INFO</span><span class="p">(</span><span class="s">&quot;MSI-X is not attainable  rc %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">no_msix</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">USING_MSIX_FLAG</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">no_msix:</span>
	<span class="cm">/* fall to INTx if not enough memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">DISABLE_MSI_FLAG</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bnx2x_req_msix_irqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">msix_table</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
			 <span class="n">bnx2x_msix_sp_int</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			 <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;request sp irq failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef BCM_CNIC</span>
	<span class="n">offset</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">for_each_eth_queue</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">),</span> <span class="s">&quot;%s-fp-%d&quot;</span><span class="p">,</span>
			 <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">msix_table</span><span class="p">[</span><span class="n">offset</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
				 <span class="n">bnx2x_msix_fp_int</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;request fp #%d irq (%d) failed  rc %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
			      <span class="n">bp</span><span class="o">-&gt;</span><span class="n">msix_table</span><span class="p">[</span><span class="n">offset</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="n">bnx2x_free_msix_irqs</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">offset</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">BNX2X_NUM_ETH_QUEUES</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">CNIC_PRESENT</span><span class="p">;</span>
	<span class="n">netdev_info</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;using MSI-X  IRQs: sp %d  fp[%d] %d ... fp[%d] %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">bp</span><span class="o">-&gt;</span><span class="n">msix_table</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
	       <span class="mi">0</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">msix_table</span><span class="p">[</span><span class="n">offset</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
	       <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">msix_table</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">vector</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bnx2x_enable_msi</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_msi</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BNX2X_DEV_INFO</span><span class="p">(</span><span class="s">&quot;MSI is not attainable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">USING_MSI_FLAG</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bnx2x_req_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">USING_MSI_FLAG</span> <span class="o">|</span> <span class="n">USING_MSIX_FLAG</span><span class="p">))</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">IRQF_SHARED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">USING_MSIX_FLAG</span><span class="p">)</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">msix_table</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">vector</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">bnx2x_interrupt</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bnx2x_setup_irqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">USING_MSIX_FLAG</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">USING_SINGLE_MSIX_FLAG</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">bnx2x_req_msix_irqs</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bnx2x_ack_int</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">bnx2x_req_irq</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;IRQ request failed  rc %d, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">USING_MSI_FLAG</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
			<span class="n">netdev_info</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;using MSI IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">USING_MSIX_FLAG</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">msix_table</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">vector</span><span class="p">;</span>
			<span class="n">netdev_info</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;using MSIX IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bnx2x_napi_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_rx_queue</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
		<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">napi</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bnx2x_napi_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_rx_queue</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
		<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">napi</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bnx2x_netif_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bnx2x_napi_enable</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">bnx2x_int_enable</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">BNX2X_STATE_OPEN</span><span class="p">)</span>
			<span class="n">netif_tx_wake_all_queues</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bnx2x_netif_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">disable_hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bnx2x_int_disable_sync</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">disable_hw</span><span class="p">);</span>
	<span class="n">bnx2x_napi_disable</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">u16</span> <span class="nf">bnx2x_select_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

<span class="cp">#ifdef BCM_CNIC</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NO_FCOE</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">ether_type</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">h_proto</span><span class="p">);</span>

		<span class="cm">/* Skip VLAN tag if present */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ether_type</span> <span class="o">==</span> <span class="n">ETH_P_8021Q</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">vlan_ethhdr</span> <span class="o">*</span><span class="n">vhdr</span> <span class="o">=</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">vlan_ethhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

			<span class="n">ether_type</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">vhdr</span><span class="o">-&gt;</span><span class="n">h_vlan_encapsulated_proto</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* If ethertype is FCoE or FIP - use FCoE ring */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ether_type</span> <span class="o">==</span> <span class="n">ETH_P_FCOE</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ether_type</span> <span class="o">==</span> <span class="n">ETH_P_FIP</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">bnx2x_fcoe_tx</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">txq_index</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="cm">/* select a non-FCoE queue */</span>
	<span class="k">return</span> <span class="n">__skb_tx_hash</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">BNX2X_NUM_ETH_QUEUES</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">bnx2x_set_num_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* RSS queues */</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">num_queues</span> <span class="o">=</span> <span class="n">bnx2x_calc_num_queues</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

<span class="cp">#ifdef BCM_CNIC</span>
	<span class="cm">/* override in STORAGE SD modes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_MF_STORAGE_SD</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">||</span> <span class="n">IS_MF_FCOE_AFEX</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">num_queues</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/* Add special queues */</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">num_queues</span> <span class="o">+=</span> <span class="n">NON_ETH_CONTEXT_USE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bnx2x_set_real_num_queues - configure netdev-&gt;real_num_[tx,rx]_queues</span>
<span class="cm"> *</span>
<span class="cm"> * @bp:		Driver handle</span>
<span class="cm"> *</span>
<span class="cm"> * We currently support for at most 16 Tx queues for each CoS thus we will</span>
<span class="cm"> * allocate a multiple of 16 for ETH L2 rings according to the value of the</span>
<span class="cm"> * bp-&gt;max_cos.</span>
<span class="cm"> *</span>
<span class="cm"> * If there is an FCoE L2 queue the appropriate Tx queue will have the next</span>
<span class="cm"> * index after all ETH L2 indices.</span>
<span class="cm"> *</span>
<span class="cm"> * If the actual number of Tx queues (for each CoS) is less than 16 then there</span>
<span class="cm"> * will be the holes at the end of each group of 16 ETh L2 indices (0..15,</span>
<span class="cm"> * 16..31,...) with indicies that are not coupled with any real Tx queue.</span>
<span class="cm"> *</span>
<span class="cm"> * The proper configuration of skb-&gt;queue_mapping is handled by</span>
<span class="cm"> * bnx2x_select_queue() and __skb_tx_hash().</span>
<span class="cm"> *</span>
<span class="cm"> * bnx2x_setup_tc() takes care of the proper TC mappings so that __skb_tx_hash()</span>
<span class="cm"> * will return a proper Tx index if TC is enabled (netdev-&gt;num_tc &gt; 0).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bnx2x_set_real_num_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">rx</span><span class="p">;</span>

	<span class="n">tx</span> <span class="o">=</span> <span class="n">MAX_TXQS_PER_COS</span> <span class="o">*</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">max_cos</span><span class="p">;</span>
	<span class="n">rx</span> <span class="o">=</span> <span class="n">BNX2X_NUM_ETH_QUEUES</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

<span class="cm">/* account for fcoe queue */</span>
<span class="cp">#ifdef BCM_CNIC</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NO_FCOE</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rx</span> <span class="o">+=</span> <span class="n">FCOE_PRESENT</span><span class="p">;</span>
		<span class="n">tx</span> <span class="o">+=</span> <span class="n">FCOE_PRESENT</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">netif_set_real_num_tx_queues</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">tx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;Failed to set real number of Tx queues: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">netif_set_real_num_rx_queues</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">rx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;Failed to set real number of Rx queues: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_IFUP</span><span class="p">,</span> <span class="s">&quot;Setting real num queues to (tx, rx) (%d, %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">tx</span><span class="p">,</span> <span class="n">rx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bnx2x_set_rx_buf_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_queue</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">u32</span> <span class="n">mtu</span><span class="p">;</span>

		<span class="cm">/* Always use a mini-jumbo MTU for the FCoE L2 ring */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_FCOE_IDX</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
			<span class="cm">/*</span>
<span class="cm">			 * Although there are no IP frames expected to arrive to</span>
<span class="cm">			 * this ring we still want to add an</span>
<span class="cm">			 * IP_HEADER_ALIGNMENT_PADDING to prevent a buffer</span>
<span class="cm">			 * overrun attack.</span>
<span class="cm">			 */</span>
			<span class="n">mtu</span> <span class="o">=</span> <span class="n">BNX2X_FCOE_MINI_JUMBO_MTU</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">mtu</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">;</span>
		<span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_buf_size</span> <span class="o">=</span> <span class="n">BNX2X_FW_RX_ALIGN_START</span> <span class="o">+</span>
				  <span class="n">IP_HEADER_ALIGNMENT_PADDING</span> <span class="o">+</span>
				  <span class="n">ETH_OVREHEAD</span> <span class="o">+</span>
				  <span class="n">mtu</span> <span class="o">+</span>
				  <span class="n">BNX2X_FW_RX_ALIGN_END</span><span class="p">;</span>
		<span class="cm">/* Note : rx_buf_size doesnt take into account NET_SKB_PAD */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bnx2x_init_rss_pf</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ind_table</span><span class="p">[</span><span class="n">T_ETH_INDIRECTION_TABLE_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	<span class="n">u8</span> <span class="n">num_eth_queues</span> <span class="o">=</span> <span class="n">BNX2X_NUM_ETH_QUEUES</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="cm">/* Prepare the initial contents fo the indirection table if RSS is</span>
<span class="cm">	 * enabled</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ind_table</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ind_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">cl_id</span> <span class="o">+</span>
			<span class="n">ethtool_rxfh_indir_default</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">num_eth_queues</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * For 57710 and 57711 SEARCHER configuration (rss_keys) is</span>
<span class="cm">	 * per-port, so if explicit configuration is needed , do it only</span>
<span class="cm">	 * for a PMF.</span>
<span class="cm">	 *</span>
<span class="cm">	 * For 57712 and newer on the other hand it&#39;s a per-function</span>
<span class="cm">	 * configuration.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">bnx2x_config_rss_eth</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">ind_table</span><span class="p">,</span>
				    <span class="n">bp</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">pmf</span> <span class="o">||</span> <span class="o">!</span><span class="n">CHIP_IS_E1x</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bnx2x_config_rss_pf</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bnx2x_rss_config_obj</span> <span class="o">*</span><span class="n">rss_obj</span><span class="p">,</span>
			<span class="n">u8</span> <span class="o">*</span><span class="n">ind_table</span><span class="p">,</span> <span class="n">bool</span> <span class="n">config_hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2x_config_rss_params</span> <span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="nb">NULL</span><span class="p">};</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Although RSS is meaningless when there is a single HW queue we</span>
<span class="cm">	 * still need it enabled in order to have HW Rx hash generated.</span>
<span class="cm">	 *</span>
<span class="cm">	 * if (!is_eth_multi(bp))</span>
<span class="cm">	 *      bp-&gt;multi_mode = ETH_RSS_MODE_DISABLED;</span>
<span class="cm">	 */</span>

	<span class="n">params</span><span class="p">.</span><span class="n">rss_obj</span> <span class="o">=</span> <span class="n">rss_obj</span><span class="p">;</span>

	<span class="n">__set_bit</span><span class="p">(</span><span class="n">RAMROD_COMP_WAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">.</span><span class="n">ramrod_flags</span><span class="p">);</span>

	<span class="n">__set_bit</span><span class="p">(</span><span class="n">BNX2X_RSS_MODE_REGULAR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">.</span><span class="n">rss_flags</span><span class="p">);</span>

	<span class="cm">/* RSS configuration */</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">BNX2X_RSS_IPV4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">.</span><span class="n">rss_flags</span><span class="p">);</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">BNX2X_RSS_IPV4_TCP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">.</span><span class="n">rss_flags</span><span class="p">);</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">BNX2X_RSS_IPV6</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">.</span><span class="n">rss_flags</span><span class="p">);</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">BNX2X_RSS_IPV6_TCP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">.</span><span class="n">rss_flags</span><span class="p">);</span>

	<span class="cm">/* Hash bits */</span>
	<span class="n">params</span><span class="p">.</span><span class="n">rss_result_mask</span> <span class="o">=</span> <span class="n">MULTI_MASK</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">ind_table</span><span class="p">,</span> <span class="n">ind_table</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">ind_table</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">config_hash</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* RSS keys */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">rss_key</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">params</span><span class="p">.</span><span class="n">rss_key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">random32</span><span class="p">();</span>

		<span class="n">__set_bit</span><span class="p">(</span><span class="n">BNX2X_RSS_SET_SRCH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">.</span><span class="n">rss_flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">bnx2x_config_rss</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bnx2x_init_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">u32</span> <span class="n">load_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2x_func_state_params</span> <span class="n">func_params</span> <span class="o">=</span> <span class="p">{</span><span class="nb">NULL</span><span class="p">};</span>

	<span class="cm">/* Prepare parameters for function state transitions */</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">RAMROD_COMP_WAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">func_params</span><span class="p">.</span><span class="n">ramrod_flags</span><span class="p">);</span>

	<span class="n">func_params</span><span class="p">.</span><span class="n">f_obj</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">func_obj</span><span class="p">;</span>
	<span class="n">func_params</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">BNX2X_F_CMD_HW_INIT</span><span class="p">;</span>

	<span class="n">func_params</span><span class="p">.</span><span class="n">params</span><span class="p">.</span><span class="n">hw_init</span><span class="p">.</span><span class="n">load_phase</span> <span class="o">=</span> <span class="n">load_code</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">bnx2x_func_state_change</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">func_params</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Cleans the object that have internal lists without sending</span>
<span class="cm"> * ramrods. Should be run when interrutps are disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bnx2x_squeeze_objects</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ramrod_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vlan_mac_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bnx2x_mcast_ramrod_params</span> <span class="n">rparam</span> <span class="o">=</span> <span class="p">{</span><span class="nb">NULL</span><span class="p">};</span>
	<span class="k">struct</span> <span class="n">bnx2x_vlan_mac_obj</span> <span class="o">*</span><span class="n">mac_obj</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">mac_obj</span><span class="p">;</span>

	<span class="cm">/***************** Cleanup MACs&#39; object first *************************/</span>

	<span class="cm">/* Wait for completion of requested */</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">RAMROD_COMP_WAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ramrod_flags</span><span class="p">);</span>
	<span class="cm">/* Perform a dry cleanup */</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">RAMROD_DRV_CLR_ONLY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ramrod_flags</span><span class="p">);</span>

	<span class="cm">/* Clean ETH primary MAC */</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">BNX2X_ETH_MAC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vlan_mac_flags</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">mac_obj</span><span class="o">-&gt;</span><span class="n">delete_all</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">mac_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vlan_mac_flags</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">ramrod_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;Failed to clean ETH MACs: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

	<span class="cm">/* Cleanup UC list */</span>
	<span class="n">vlan_mac_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">BNX2X_UC_LIST_MAC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vlan_mac_flags</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">mac_obj</span><span class="o">-&gt;</span><span class="n">delete_all</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">mac_obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vlan_mac_flags</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">ramrod_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;Failed to clean UC list MACs: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

	<span class="cm">/***************** Now clean mcast object *****************************/</span>
	<span class="n">rparam</span><span class="p">.</span><span class="n">mcast_obj</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">mcast_obj</span><span class="p">;</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">RAMROD_DRV_CLR_ONLY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rparam</span><span class="p">.</span><span class="n">ramrod_flags</span><span class="p">);</span>

	<span class="cm">/* Add a DEL command... */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">bnx2x_config_mcast</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rparam</span><span class="p">,</span> <span class="n">BNX2X_MCAST_CMD_DEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;Failed to add a new DEL command to a multi-cast object: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">rc</span><span class="p">);</span>

	<span class="cm">/* ...and wait until all pending commands are cleared */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">bnx2x_config_mcast</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rparam</span><span class="p">,</span> <span class="n">BNX2X_MCAST_CMD_CONT</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;Failed to clean multi-cast object: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">rc</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">bnx2x_config_mcast</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rparam</span><span class="p">,</span> <span class="n">BNX2X_MCAST_CMD_CONT</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifndef BNX2X_STOP_ON_ERROR</span>
<span class="cp">#define LOAD_ERROR_EXIT(bp, label) \</span>
<span class="cp">	do { \</span>
<span class="cp">		(bp)-&gt;state = BNX2X_STATE_ERROR; \</span>
<span class="cp">		goto label; \</span>
<span class="cp">	} while (0)</span>
<span class="cp">#else</span>
<span class="cp">#define LOAD_ERROR_EXIT(bp, label) \</span>
<span class="cp">	do { \</span>
<span class="cp">		(bp)-&gt;state = BNX2X_STATE_ERROR; \</span>
<span class="cp">		(bp)-&gt;panic = 1; \</span>
<span class="cp">		return -EBUSY; \</span>
<span class="cp">	} while (0)</span>
<span class="cp">#endif</span>

<span class="n">bool</span> <span class="nf">bnx2x_test_firmware_version</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">bool</span> <span class="n">is_err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* build FW version dword */</span>
	<span class="n">u32</span> <span class="n">my_fw</span> <span class="o">=</span> <span class="p">(</span><span class="n">BCM_5710_FW_MAJOR_VERSION</span><span class="p">)</span> <span class="o">+</span>
		    <span class="p">(</span><span class="n">BCM_5710_FW_MINOR_VERSION</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span>
		    <span class="p">(</span><span class="n">BCM_5710_FW_REVISION_VERSION</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span>
		    <span class="p">(</span><span class="n">BCM_5710_FW_ENGINEERING_VERSION</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>

	<span class="cm">/* read loaded FW from chip */</span>
	<span class="n">u32</span> <span class="n">loaded_fw</span> <span class="o">=</span> <span class="n">REG_RD</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">XSEM_REG_PRAM</span><span class="p">);</span>

	<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_IFUP</span><span class="p">,</span> <span class="s">&quot;loaded fw %x, my fw %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">loaded_fw</span><span class="p">,</span> <span class="n">my_fw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">loaded_fw</span> <span class="o">!=</span> <span class="n">my_fw</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_err</span><span class="p">)</span>
			<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;bnx2x with FW %x was already loaded, which mismatches my %x FW. aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">loaded_fw</span><span class="p">,</span> <span class="n">my_fw</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bnx2x_bz_fp - zero content of the fastpath structure.</span>
<span class="cm"> *</span>
<span class="cm"> * @bp:		driver handle</span>
<span class="cm"> * @index:	fastpath index to be zeroed</span>
<span class="cm"> *</span>
<span class="cm"> * Makes sure the contents of the bp-&gt;fp[index].napi is kept</span>
<span class="cm"> * intact.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bnx2x_bz_fp</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">napi_struct</span> <span class="n">orig_napi</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">;</span>
	<span class="cm">/* bzero bnx2x_fastpath contents */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats_init</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">));</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Keep Queue statistics */</span>
		<span class="k">struct</span> <span class="n">bnx2x_eth_q_stats</span> <span class="o">*</span><span class="n">tmp_eth_q_stats</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">bnx2x_eth_q_stats_old</span> <span class="o">*</span><span class="n">tmp_eth_q_stats_old</span><span class="p">;</span>

		<span class="n">tmp_eth_q_stats</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x_eth_q_stats</span><span class="p">),</span>
					  <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp_eth_q_stats</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">tmp_eth_q_stats</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">eth_q_stats</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x_eth_q_stats</span><span class="p">));</span>

		<span class="n">tmp_eth_q_stats_old</span> <span class="o">=</span>
			<span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x_eth_q_stats_old</span><span class="p">),</span>
				<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp_eth_q_stats_old</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">tmp_eth_q_stats_old</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">eth_q_stats_old</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x_eth_q_stats_old</span><span class="p">));</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tmp_eth_q_stats</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">eth_q_stats</span><span class="p">,</span> <span class="n">tmp_eth_q_stats</span><span class="p">,</span>
				   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x_eth_q_stats</span><span class="p">));</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">tmp_eth_q_stats</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tmp_eth_q_stats_old</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">eth_q_stats_old</span><span class="p">,</span> <span class="n">tmp_eth_q_stats_old</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x_eth_q_stats_old</span><span class="p">));</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">tmp_eth_q_stats_old</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span>

	<span class="cm">/* Restore the NAPI object as it has been already initialized */</span>
	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">napi</span> <span class="o">=</span> <span class="n">orig_napi</span><span class="p">;</span>

	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">bp</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ETH_FP</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span>
		<span class="n">fp</span><span class="o">-&gt;</span><span class="n">max_cos</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">max_cos</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="cm">/* Special queues support only one CoS */</span>
		<span class="n">fp</span><span class="o">-&gt;</span><span class="n">max_cos</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * set the tpa flag for each queue. The tpa flag determines the queue</span>
<span class="cm">	 * minimal size so it must be set prior to queue memory allocation</span>
<span class="cm">	 */</span>
	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">disable_tpa</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TPA_ENABLE_FLAG</span> <span class="o">||</span>
				  <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GRO_ENABLE_FLAG</span> <span class="o">&amp;&amp;</span>
				   <span class="n">bnx2x_mtu_allows_gro</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">)));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TPA_ENABLE_FLAG</span><span class="p">)</span>
		<span class="n">fp</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">TPA_MODE_LRO</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GRO_ENABLE_FLAG</span><span class="p">)</span>
		<span class="n">fp</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">TPA_MODE_GRO</span><span class="p">;</span>

<span class="cp">#ifdef BCM_CNIC</span>
	<span class="cm">/* We don&#39;t want TPA on an FCoE L2 ring */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_FCOE_FP</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span>
		<span class="n">fp</span><span class="o">-&gt;</span><span class="n">disable_tpa</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>


<span class="cm">/* must be called with rtnl_lock */</span>
<span class="kt">int</span> <span class="nf">bnx2x_nic_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">load_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="n">BP_PORT</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">load_code</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

<span class="cp">#ifdef BNX2X_STOP_ON_ERROR</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">panic</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;Can&#39;t load NIC when there is panic</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">BNX2X_STATE_OPENING_WAIT4_LOAD</span><span class="p">;</span>

	<span class="cm">/* Set the initial link reported state to link down */</span>
	<span class="n">bnx2x_acquire_phy_lock</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">last_reported_link</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">last_reported_link</span><span class="p">));</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">BNX2X_LINK_REPORT_LINK_DOWN</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">last_reported_link</span><span class="p">.</span><span class="n">link_report_flags</span><span class="p">);</span>
	<span class="n">bnx2x_release_phy_lock</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="cm">/* must be called before memory allocation and HW init */</span>
	<span class="n">bnx2x_ilt_set_info</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Zero fastpath structures preserving invariants like napi, which are</span>
<span class="cm">	 * allocated only once, fp index, max_cos, bp pointer.</span>
<span class="cm">	 * Also set fp-&gt;disable_tpa.</span>
<span class="cm">	 */</span>
	<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_IFUP</span><span class="p">,</span> <span class="s">&quot;num queues: %d&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">num_queues</span><span class="p">);</span>
	<span class="n">for_each_queue</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
		<span class="n">bnx2x_bz_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>


	<span class="cm">/* Set the receive queues buffer size */</span>
	<span class="n">bnx2x_set_rx_buf_size</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bnx2x_alloc_mem</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* As long as bnx2x_alloc_mem() may possibly update</span>
<span class="cm">	 * bp-&gt;num_queues, bnx2x_set_real_num_queues() should always</span>
<span class="cm">	 * come after it.</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">bnx2x_set_real_num_queues</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;Unable to set real_num_queues</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">LOAD_ERROR_EXIT</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">load_error0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* configure multi cos mappings in kernel.</span>
<span class="cm">	 * this configuration may be overriden by a multi class queue discipline</span>
<span class="cm">	 * or by a dcbx negotiation result.</span>
<span class="cm">	 */</span>
	<span class="n">bnx2x_setup_tc</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">max_cos</span><span class="p">);</span>

	<span class="n">bnx2x_napi_enable</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="cm">/* set pf load just before approaching the MCP */</span>
	<span class="n">bnx2x_set_pf_load</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="cm">/* Send LOAD_REQUEST command to MCP</span>
<span class="cm">	 * Returns the type of LOAD command:</span>
<span class="cm">	 * if it is the first port to be initialized</span>
<span class="cm">	 * common blocks should be initialized, otherwise - not</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">BP_NOMCP</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* init fw_seq */</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">fw_seq</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">SHMEM_RD</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">func_mb</span><span class="p">[</span><span class="n">BP_FW_MB_IDX</span><span class="p">(</span><span class="n">bp</span><span class="p">)].</span><span class="n">drv_mb_header</span><span class="p">)</span> <span class="o">&amp;</span>
			 <span class="n">DRV_MSG_SEQ_NUMBER_MASK</span><span class="p">);</span>
		<span class="n">BNX2X_DEV_INFO</span><span class="p">(</span><span class="s">&quot;fw_seq 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">fw_seq</span><span class="p">);</span>

		<span class="cm">/* Get current FW pulse sequence */</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">fw_drv_pulse_wr_seq</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">SHMEM_RD</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">func_mb</span><span class="p">[</span><span class="n">BP_FW_MB_IDX</span><span class="p">(</span><span class="n">bp</span><span class="p">)].</span><span class="n">drv_pulse_mb</span><span class="p">)</span> <span class="o">&amp;</span>
			 <span class="n">DRV_PULSE_SEQ_MASK</span><span class="p">);</span>
		<span class="n">BNX2X_DEV_INFO</span><span class="p">(</span><span class="s">&quot;drv_pulse 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">fw_drv_pulse_wr_seq</span><span class="p">);</span>

		<span class="n">load_code</span> <span class="o">=</span> <span class="n">bnx2x_fw_command</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">DRV_MSG_CODE_LOAD_REQ</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">load_code</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;MCP response failure, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="n">LOAD_ERROR_EXIT</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">load_error1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">load_code</span> <span class="o">==</span> <span class="n">FW_MSG_CODE_DRV_LOAD_REFUSED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;Driver load refused</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span> <span class="cm">/* other port in diagnostic mode */</span>
			<span class="n">LOAD_ERROR_EXIT</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">load_error1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">load_code</span> <span class="o">!=</span> <span class="n">FW_MSG_CODE_DRV_LOAD_COMMON_CHIP</span> <span class="o">&amp;&amp;</span>
		    <span class="n">load_code</span> <span class="o">!=</span> <span class="n">FW_MSG_CODE_DRV_LOAD_COMMON</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* abort nic load if version mismatch */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bnx2x_test_firmware_version</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">true</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
				<span class="n">LOAD_ERROR_EXIT</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">load_error2</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">path</span> <span class="o">=</span> <span class="n">BP_PATH</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

		<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_IFUP</span><span class="p">,</span> <span class="s">&quot;NO MCP - load counts[%d]      %d, %d, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">path</span><span class="p">,</span> <span class="n">load_count</span><span class="p">[</span><span class="n">path</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">load_count</span><span class="p">[</span><span class="n">path</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
		   <span class="n">load_count</span><span class="p">[</span><span class="n">path</span><span class="p">][</span><span class="mi">2</span><span class="p">]);</span>
		<span class="n">load_count</span><span class="p">[</span><span class="n">path</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="n">load_count</span><span class="p">[</span><span class="n">path</span><span class="p">][</span><span class="mi">1</span> <span class="o">+</span> <span class="n">port</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_IFUP</span><span class="p">,</span> <span class="s">&quot;NO MCP - new load counts[%d]  %d, %d, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">path</span><span class="p">,</span> <span class="n">load_count</span><span class="p">[</span><span class="n">path</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">load_count</span><span class="p">[</span><span class="n">path</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
		   <span class="n">load_count</span><span class="p">[</span><span class="n">path</span><span class="p">][</span><span class="mi">2</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">load_count</span><span class="p">[</span><span class="n">path</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">load_code</span> <span class="o">=</span> <span class="n">FW_MSG_CODE_DRV_LOAD_COMMON</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">load_count</span><span class="p">[</span><span class="n">path</span><span class="p">][</span><span class="mi">1</span> <span class="o">+</span> <span class="n">port</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">load_code</span> <span class="o">=</span> <span class="n">FW_MSG_CODE_DRV_LOAD_PORT</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">load_code</span> <span class="o">=</span> <span class="n">FW_MSG_CODE_DRV_LOAD_FUNCTION</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">load_code</span> <span class="o">==</span> <span class="n">FW_MSG_CODE_DRV_LOAD_COMMON</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">load_code</span> <span class="o">==</span> <span class="n">FW_MSG_CODE_DRV_LOAD_COMMON_CHIP</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">load_code</span> <span class="o">==</span> <span class="n">FW_MSG_CODE_DRV_LOAD_PORT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">pmf</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We need the barrier to ensure the ordering between the</span>
<span class="cm">		 * writing to bp-&gt;port.pmf here and reading it from the</span>
<span class="cm">		 * bnx2x_periodic_task().</span>
<span class="cm">		 */</span>
		<span class="n">smp_mb</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">pmf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_IFUP</span><span class="p">,</span> <span class="s">&quot;pmf %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">pmf</span><span class="p">);</span>

	<span class="cm">/* Init Function state controlling object */</span>
	<span class="n">bnx2x__init_func_obj</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="cm">/* Initialize HW */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">bnx2x_init_hw</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">load_code</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;HW init failed, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">bnx2x_fw_command</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">DRV_MSG_CODE_LOAD_DONE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">LOAD_ERROR_EXIT</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">load_error2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Connect to IRQs */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">bnx2x_setup_irqs</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;IRQs setup failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">bnx2x_fw_command</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">DRV_MSG_CODE_LOAD_DONE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">LOAD_ERROR_EXIT</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">load_error2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Setup NIC internals and enable interrupts */</span>
	<span class="n">bnx2x_nic_init</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">load_code</span><span class="p">);</span>

	<span class="cm">/* Init per-function objects */</span>
	<span class="n">bnx2x_init_bp_objs</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">load_code</span> <span class="o">==</span> <span class="n">FW_MSG_CODE_DRV_LOAD_COMMON</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">load_code</span> <span class="o">==</span> <span class="n">FW_MSG_CODE_DRV_LOAD_COMMON_CHIP</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">shmem2_base</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SHMEM2_HAS</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">dcc_support</span><span class="p">))</span>
			<span class="n">SHMEM2_WR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">dcc_support</span><span class="p">,</span>
				  <span class="p">(</span><span class="n">SHMEM_DCC_SUPPORT_DISABLE_ENABLE_PF_TLV</span> <span class="o">|</span>
				   <span class="n">SHMEM_DCC_SUPPORT_BANDWIDTH_ALLOCATION_TLV</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SHMEM2_HAS</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">afex_driver_support</span><span class="p">))</span>
			<span class="n">SHMEM2_WR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">afex_driver_support</span><span class="p">,</span>
				  <span class="n">SHMEM_AFEX_SUPPORTED_VERSION_ONE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Set AFEX default VLAN tag to an invalid value */</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">afex_def_vlan_tag</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">BNX2X_STATE_OPENING_WAIT4_PORT</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">bnx2x_func_start</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;Function start failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">bnx2x_fw_command</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">DRV_MSG_CODE_LOAD_DONE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">LOAD_ERROR_EXIT</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">load_error3</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Send LOAD_DONE command to MCP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">BP_NOMCP</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">load_code</span> <span class="o">=</span> <span class="n">bnx2x_fw_command</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">DRV_MSG_CODE_LOAD_DONE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">load_code</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;MCP response failure, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="n">LOAD_ERROR_EXIT</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">load_error3</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">bnx2x_setup_leading</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;Setup leading failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">LOAD_ERROR_EXIT</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">load_error3</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#ifdef BCM_CNIC</span>
	<span class="cm">/* Enable Timer scan */</span>
	<span class="n">REG_WR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">TM_REG_EN_LINEAR0_TIMER</span> <span class="o">+</span> <span class="n">port</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">for_each_nondefault_queue</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">bnx2x_setup_queue</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;Queue setup failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">LOAD_ERROR_EXIT</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">load_error4</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">bnx2x_init_rss_pf</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;PF RSS init failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">LOAD_ERROR_EXIT</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">load_error4</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Now when Clients are configured we are ready to work */</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">BNX2X_STATE_OPEN</span><span class="p">;</span>

	<span class="cm">/* Configure a ucast MAC */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">bnx2x_set_eth_mac</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;Setting Ethernet MAC failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">LOAD_ERROR_EXIT</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">load_error4</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pending_max</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bnx2x_update_max_mf_config</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">pending_max</span><span class="p">);</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">pending_max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">pmf</span><span class="p">)</span>
		<span class="n">bnx2x_initial_phy_init</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">load_mode</span><span class="p">);</span>

	<span class="cm">/* Start fast path */</span>

	<span class="cm">/* Initialize Rx filter. */</span>
	<span class="n">netif_addr_lock_bh</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">bnx2x_set_rx_mode</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">netif_addr_unlock_bh</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Start the Tx */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">load_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LOAD_NORMAL</span>:
		<span class="cm">/* Tx queue should be only reenabled */</span>
		<span class="n">netif_tx_wake_all_queues</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">LOAD_OPEN</span>:
		<span class="n">netif_tx_start_all_queues</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">LOAD_DIAG</span>:
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">BNX2X_STATE_DIAG</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">pmf</span><span class="p">)</span>
		<span class="n">bnx2x_update_drv_flags</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">DRV_FLAGS_DCB_CONFIGURED</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">bnx2x__link_status_update</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="cm">/* start the timer */</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">current_interval</span><span class="p">);</span>

<span class="cp">#ifdef BCM_CNIC</span>
	<span class="cm">/* re-read iscsi info */</span>
	<span class="n">bnx2x_get_iscsi_info</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">bnx2x_setup_cnic_irq_info</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">BNX2X_STATE_OPEN</span><span class="p">)</span>
		<span class="n">bnx2x_cnic_notify</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">CNIC_CTL_START_CMD</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* mark driver is loaded in shmem2 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">SHMEM2_HAS</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">drv_capabilities_flag</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">SHMEM2_RD</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">drv_capabilities_flag</span><span class="p">[</span><span class="n">BP_FW_MB_IDX</span><span class="p">(</span><span class="n">bp</span><span class="p">)]);</span>
		<span class="n">SHMEM2_WR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">drv_capabilities_flag</span><span class="p">[</span><span class="n">BP_FW_MB_IDX</span><span class="p">(</span><span class="n">bp</span><span class="p">)],</span>
			  <span class="n">val</span> <span class="o">|</span> <span class="n">DRV_FLAGS_CAPABILITIES_LOADED_SUPPORTED</span> <span class="o">|</span>
			  <span class="n">DRV_FLAGS_CAPABILITIES_LOADED_L2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Wait for all pending SP commands to complete */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bnx2x_wait_sp_comp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="o">~</span><span class="mh">0x0UL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;Timeout waiting for SP elements to complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">bnx2x_nic_unload</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">UNLOAD_CLOSE</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bnx2x_dcbx_init</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifndef BNX2X_STOP_ON_ERROR</span>
<span class="nl">load_error4:</span>
<span class="cp">#ifdef BCM_CNIC</span>
	<span class="cm">/* Disable Timer scan */</span>
	<span class="n">REG_WR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">TM_REG_EN_LINEAR0_TIMER</span> <span class="o">+</span> <span class="n">port</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="nl">load_error3:</span>
	<span class="n">bnx2x_int_disable_sync</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Clean queueable objects */</span>
	<span class="n">bnx2x_squeeze_objects</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="cm">/* Free SKBs, SGEs, TPA pool and driver internals */</span>
	<span class="n">bnx2x_free_skbs</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">for_each_rx_queue</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
		<span class="n">bnx2x_free_rx_sge_range</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">fp</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">NUM_RX_SGE</span><span class="p">);</span>

	<span class="cm">/* Release IRQs */</span>
	<span class="n">bnx2x_free_irq</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="nl">load_error2:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">BP_NOMCP</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bnx2x_fw_command</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">DRV_MSG_CODE_UNLOAD_REQ_WOL_MCP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bnx2x_fw_command</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">DRV_MSG_CODE_UNLOAD_DONE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">pmf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">load_error1:</span>
	<span class="n">bnx2x_napi_disable</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="cm">/* clear pf_load status, as it was already set */</span>
	<span class="n">bnx2x_clear_pf_load</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="nl">load_error0:</span>
	<span class="n">bnx2x_free_mem</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* ! BNX2X_STOP_ON_ERROR */</span><span class="cp"></span>
<span class="p">}</span>

<span class="cm">/* must be called with rtnl_lock */</span>
<span class="kt">int</span> <span class="nf">bnx2x_nic_unload</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unload_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">global</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* mark driver is unloaded in shmem2 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">SHMEM2_HAS</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">drv_capabilities_flag</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">SHMEM2_RD</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">drv_capabilities_flag</span><span class="p">[</span><span class="n">BP_FW_MB_IDX</span><span class="p">(</span><span class="n">bp</span><span class="p">)]);</span>
		<span class="n">SHMEM2_WR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">drv_capabilities_flag</span><span class="p">[</span><span class="n">BP_FW_MB_IDX</span><span class="p">(</span><span class="n">bp</span><span class="p">)],</span>
			  <span class="n">val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">DRV_FLAGS_CAPABILITIES_LOADED_L2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">BNX2X_STATE_CLOSED</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">BNX2X_STATE_ERROR</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* We can get here if the driver has been unloaded</span>
<span class="cm">		 * during parity error recovery and is either waiting for a</span>
<span class="cm">		 * leader to complete or for other functions to unload and</span>
<span class="cm">		 * then ifdown has been issued. In this case we want to</span>
<span class="cm">		 * unload and let other functions to complete a recovery</span>
<span class="cm">		 * process.</span>
<span class="cm">		 */</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">recovery_state</span> <span class="o">=</span> <span class="n">BNX2X_RECOVERY_DONE</span><span class="p">;</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">is_leader</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">bnx2x_release_leader_lock</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">smp_mb</span><span class="p">();</span>

		<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_IFDOWN</span><span class="p">,</span> <span class="s">&quot;Releasing a leadership...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;Can&#39;t unload in closed or error state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * It&#39;s important to set the bp-&gt;state to the value different from</span>
<span class="cm">	 * BNX2X_STATE_OPEN and only then stop the Tx. Otherwise bnx2x_tx_int()</span>
<span class="cm">	 * may restart the Tx from the NAPI context (see bnx2x_tx_int()).</span>
<span class="cm">	 */</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">BNX2X_STATE_CLOSING_WAIT4_HALT</span><span class="p">;</span>
	<span class="n">smp_mb</span><span class="p">();</span>

	<span class="cm">/* Stop Tx */</span>
	<span class="n">bnx2x_tx_disable</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

<span class="cp">#ifdef BCM_CNIC</span>
	<span class="n">bnx2x_cnic_notify</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">CNIC_CTL_STOP_CMD</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">rx_mode</span> <span class="o">=</span> <span class="n">BNX2X_RX_MODE_NONE</span><span class="p">;</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>

	<span class="cm">/* Set ALWAYS_ALIVE bit in shmem */</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">fw_drv_pulse_wr_seq</span> <span class="o">|=</span> <span class="n">DRV_PULSE_ALWAYS_ALIVE</span><span class="p">;</span>

	<span class="n">bnx2x_drv_pulse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="n">bnx2x_stats_handle</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">STATS_EVENT_STOP</span><span class="p">);</span>
	<span class="n">bnx2x_save_statistics</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="cm">/* Cleanup the chip if needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unload_mode</span> <span class="o">!=</span> <span class="n">UNLOAD_RECOVERY</span><span class="p">)</span>
		<span class="n">bnx2x_chip_cleanup</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">unload_mode</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Send the UNLOAD_REQUEST to the MCP */</span>
		<span class="n">bnx2x_send_unload_req</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">unload_mode</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Prevent transactions to host from the functions on the</span>
<span class="cm">		 * engine that doesn&#39;t reset global blocks in case of global</span>
<span class="cm">		 * attention once gloabl blocks are reset and gates are opened</span>
<span class="cm">		 * (the engine which leader will perform the recovery</span>
<span class="cm">		 * last).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CHIP_IS_E1x</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span>
			<span class="n">bnx2x_pf_disable</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

		<span class="cm">/* Disable HW interrupts, NAPI */</span>
		<span class="n">bnx2x_netif_stop</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* Release IRQs */</span>
		<span class="n">bnx2x_free_irq</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

		<span class="cm">/* Report UNLOAD_DONE to MCP */</span>
		<span class="n">bnx2x_send_unload_done</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * At this stage no more interrupts will arrive so we may safly clean</span>
<span class="cm">	 * the queueable objects here in case they failed to get cleaned so far.</span>
<span class="cm">	 */</span>
	<span class="n">bnx2x_squeeze_objects</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="cm">/* There should be no more pending SP commands at this stage */</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">sp_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">pmf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Free SKBs, SGEs, TPA pool and driver internals */</span>
	<span class="n">bnx2x_free_skbs</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">for_each_rx_queue</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
		<span class="n">bnx2x_free_rx_sge_range</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">fp</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">NUM_RX_SGE</span><span class="p">);</span>

	<span class="n">bnx2x_free_mem</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">BNX2X_STATE_CLOSED</span><span class="p">;</span>

	<span class="cm">/* Check if there are pending parity attentions. If there are - set</span>
<span class="cm">	 * RECOVERY_IN_PROGRESS.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bnx2x_chk_parity_attn</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">global</span><span class="p">,</span> <span class="nb">false</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bnx2x_set_reset_in_progress</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

		<span class="cm">/* Set RESET_IS_GLOBAL if needed */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">global</span><span class="p">)</span>
			<span class="n">bnx2x_set_reset_global</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="p">}</span>


	<span class="cm">/* The last driver must disable a &quot;close the gate&quot; if there is no</span>
<span class="cm">	 * parity attention or &quot;process kill&quot; pending.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bnx2x_clear_pf_load</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">bnx2x_reset_is_done</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">BP_PATH</span><span class="p">(</span><span class="n">bp</span><span class="p">)))</span>
		<span class="n">bnx2x_disable_close_the_gate</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bnx2x_set_power_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">pci_power_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">pmcsr</span><span class="p">;</span>

	<span class="cm">/* If there is no power capability, silently succeed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pm_cap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BNX2X_DEV_INFO</span><span class="p">(</span><span class="s">&quot;No power capability. Breaking.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">pm_cap</span> <span class="o">+</span> <span class="n">PCI_PM_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmcsr</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PCI_D0</span>:
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">pm_cap</span> <span class="o">+</span> <span class="n">PCI_PM_CTRL</span><span class="p">,</span>
				      <span class="p">((</span><span class="n">pmcsr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PCI_PM_CTRL_STATE_MASK</span><span class="p">)</span> <span class="o">|</span>
				       <span class="n">PCI_PM_CTRL_PME_STATUS</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pmcsr</span> <span class="o">&amp;</span> <span class="n">PCI_PM_CTRL_STATE_MASK</span><span class="p">)</span>
			<span class="cm">/* delay required during transition out of D3hot */</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PCI_D3hot</span>:
		<span class="cm">/* If there are other clients above don&#39;t</span>
<span class="cm">		   shut down the power */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">enable_cnt</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* Don&#39;t shut down the power for emulation and FPGA */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">CHIP_REV_IS_SLOW</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">pmcsr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_PM_CTRL_STATE_MASK</span><span class="p">;</span>
		<span class="n">pmcsr</span> <span class="o">|=</span> <span class="mi">3</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">wol</span><span class="p">)</span>
			<span class="n">pmcsr</span> <span class="o">|=</span> <span class="n">PCI_PM_CTRL_PME_ENABLE</span><span class="p">;</span>

		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">pm_cap</span> <span class="o">+</span> <span class="n">PCI_PM_CTRL</span><span class="p">,</span>
				      <span class="n">pmcsr</span><span class="p">);</span>

		<span class="cm">/* No more memory access after this point until</span>
<span class="cm">		* device is brought back to D0.</span>
<span class="cm">		*/</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t support state = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * net_device service functions</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bnx2x_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">work_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bnx2x_fastpath</span><span class="p">,</span>
						 <span class="n">napi</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef BNX2X_STOP_ON_ERROR</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">panic</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>

		<span class="n">for_each_cos_in_tx_queue</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">cos</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bnx2x_tx_queue_has_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">txdata</span><span class="p">[</span><span class="n">cos</span><span class="p">]))</span>
				<span class="n">bnx2x_tx_int</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">txdata</span><span class="p">[</span><span class="n">cos</span><span class="p">]);</span>


		<span class="k">if</span> <span class="p">(</span><span class="n">bnx2x_has_rx_work</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">work_done</span> <span class="o">+=</span> <span class="n">bnx2x_rx_int</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">budget</span> <span class="o">-</span> <span class="n">work_done</span><span class="p">);</span>

			<span class="cm">/* must not complete if we consumed full budget */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">work_done</span> <span class="o">&gt;=</span> <span class="n">budget</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Fall out from the NAPI loop if needed */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bnx2x_has_rx_work</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">||</span> <span class="n">bnx2x_has_tx_work</span><span class="p">(</span><span class="n">fp</span><span class="p">)))</span> <span class="p">{</span>
<span class="cp">#ifdef BCM_CNIC</span>
			<span class="cm">/* No need to update SB for FCoE L2 ring as long as</span>
<span class="cm">			 * it&#39;s connected to the default SB and the SB</span>
<span class="cm">			 * has been updated when NAPI was scheduled.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_FCOE_FP</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#endif</span>

			<span class="n">bnx2x_update_fpsb_idx</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
			<span class="cm">/* bnx2x_has_rx_work() reads the status block,</span>
<span class="cm">			 * thus we need to ensure that status block indices</span>
<span class="cm">			 * have been actually read (bnx2x_update_fpsb_idx)</span>
<span class="cm">			 * prior to this check (bnx2x_has_rx_work) so that</span>
<span class="cm">			 * we won&#39;t write the &quot;newer&quot; value of the status block</span>
<span class="cm">			 * to IGU (if there was a DMA right after</span>
<span class="cm">			 * bnx2x_has_rx_work and if there is no rmb, the memory</span>
<span class="cm">			 * reading (bnx2x_update_fpsb_idx) may be postponed</span>
<span class="cm">			 * to right before bnx2x_ack_sb). In this case there</span>
<span class="cm">			 * will never be another interrupt until there is</span>
<span class="cm">			 * another update of the status block, while there</span>
<span class="cm">			 * is still unhandled work.</span>
<span class="cm">			 */</span>
			<span class="n">rmb</span><span class="p">();</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bnx2x_has_rx_work</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">||</span> <span class="n">bnx2x_has_tx_work</span><span class="p">(</span><span class="n">fp</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>
				<span class="cm">/* Re-enable interrupts */</span>
				<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_RX_STATUS</span><span class="p">,</span>
				   <span class="s">&quot;Update index to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">fp_hc_idx</span><span class="p">);</span>
				<span class="n">bnx2x_ack_sb</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">igu_sb_id</span><span class="p">,</span> <span class="n">USTORM_ID</span><span class="p">,</span>
					     <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">fp_hc_idx</span><span class="p">),</span>
					     <span class="n">IGU_INT_ENABLE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">work_done</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* we split the first BD into headers and data BDs</span>
<span class="cm"> * to ease the pain of our fellow microcode engineers</span>
<span class="cm"> * we use one mapping for both BDs</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="n">u16</span> <span class="nf">bnx2x_tx_split</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">bnx2x_fp_txdata</span> <span class="o">*</span><span class="n">txdata</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sw_tx_bd</span> <span class="o">*</span><span class="n">tx_buf</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">eth_tx_start_bd</span> <span class="o">**</span><span class="n">tx_bd</span><span class="p">,</span> <span class="n">u16</span> <span class="n">hlen</span><span class="p">,</span>
				   <span class="n">u16</span> <span class="n">bd_prod</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">eth_tx_start_bd</span> <span class="o">*</span><span class="n">h_tx_bd</span> <span class="o">=</span> <span class="o">*</span><span class="n">tx_bd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eth_tx_bd</span> <span class="o">*</span><span class="n">d_tx_bd</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">mapping</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old_len</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">h_tx_bd</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">);</span>

	<span class="cm">/* first fix first BD */</span>
	<span class="n">h_tx_bd</span><span class="o">-&gt;</span><span class="n">nbd</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">nbd</span><span class="p">);</span>
	<span class="n">h_tx_bd</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">hlen</span><span class="p">);</span>

	<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_TX_QUEUED</span><span class="p">,</span>	<span class="s">&quot;TSO split header size is %d (%x:%x) nbd %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	   <span class="n">h_tx_bd</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">h_tx_bd</span><span class="o">-&gt;</span><span class="n">addr_hi</span><span class="p">,</span> <span class="n">h_tx_bd</span><span class="o">-&gt;</span><span class="n">addr_lo</span><span class="p">,</span> <span class="n">h_tx_bd</span><span class="o">-&gt;</span><span class="n">nbd</span><span class="p">);</span>

	<span class="cm">/* now get a new data BD</span>
<span class="cm">	 * (after the pbd) and fill it */</span>
	<span class="n">bd_prod</span> <span class="o">=</span> <span class="n">TX_BD</span><span class="p">(</span><span class="n">NEXT_TX_IDX</span><span class="p">(</span><span class="n">bd_prod</span><span class="p">));</span>
	<span class="n">d_tx_bd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_desc_ring</span><span class="p">[</span><span class="n">bd_prod</span><span class="p">].</span><span class="n">reg_bd</span><span class="p">;</span>

	<span class="n">mapping</span> <span class="o">=</span> <span class="n">HILO_U64</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">h_tx_bd</span><span class="o">-&gt;</span><span class="n">addr_hi</span><span class="p">),</span>
			   <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">h_tx_bd</span><span class="o">-&gt;</span><span class="n">addr_lo</span><span class="p">))</span> <span class="o">+</span> <span class="n">hlen</span><span class="p">;</span>

	<span class="n">d_tx_bd</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">U64_HI</span><span class="p">(</span><span class="n">mapping</span><span class="p">));</span>
	<span class="n">d_tx_bd</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">U64_LO</span><span class="p">(</span><span class="n">mapping</span><span class="p">));</span>
	<span class="n">d_tx_bd</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">old_len</span> <span class="o">-</span> <span class="n">hlen</span><span class="p">);</span>

	<span class="cm">/* this marks the BD as one that has no individual mapping */</span>
	<span class="n">tx_buf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">BNX2X_TSO_SPLIT_BD</span><span class="p">;</span>

	<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_TX_QUEUED</span><span class="p">,</span>
	   <span class="s">&quot;TSO split data size is %d (%x:%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	   <span class="n">d_tx_bd</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">d_tx_bd</span><span class="o">-&gt;</span><span class="n">addr_hi</span><span class="p">,</span> <span class="n">d_tx_bd</span><span class="o">-&gt;</span><span class="n">addr_lo</span><span class="p">);</span>

	<span class="cm">/* update tx_bd */</span>
	<span class="o">*</span><span class="n">tx_bd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">eth_tx_start_bd</span> <span class="o">*</span><span class="p">)</span><span class="n">d_tx_bd</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">bd_prod</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">bnx2x_csum_fix</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">t_header</span><span class="p">,</span> <span class="n">u16</span> <span class="n">csum</span><span class="p">,</span> <span class="n">s8</span> <span class="n">fix</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fix</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">csum</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="o">~</span><span class="n">csum_fold</span><span class="p">(</span><span class="n">csum_sub</span><span class="p">(</span><span class="n">csum</span><span class="p">,</span>
				<span class="n">csum_partial</span><span class="p">(</span><span class="n">t_header</span> <span class="o">-</span> <span class="n">fix</span><span class="p">,</span> <span class="n">fix</span><span class="p">,</span> <span class="mi">0</span><span class="p">)));</span>

	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fix</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">csum</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="o">~</span><span class="n">csum_fold</span><span class="p">(</span><span class="n">csum_add</span><span class="p">(</span><span class="n">csum</span><span class="p">,</span>
				<span class="n">csum_partial</span><span class="p">(</span><span class="n">t_header</span><span class="p">,</span> <span class="o">-</span><span class="n">fix</span><span class="p">,</span> <span class="mi">0</span><span class="p">)));</span>

	<span class="k">return</span> <span class="n">swab16</span><span class="p">(</span><span class="n">csum</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">bnx2x_xmit_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">!=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">XMIT_PLAIN</span><span class="p">;</span>

	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vlan_get_protocol</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IPV6</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">XMIT_CSUM_V6</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nexthdr</span> <span class="o">==</span> <span class="n">IPPROTO_TCP</span><span class="p">)</span>
				<span class="n">rc</span> <span class="o">|=</span> <span class="n">XMIT_CSUM_TCP</span><span class="p">;</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">XMIT_CSUM_V4</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_TCP</span><span class="p">)</span>
				<span class="n">rc</span> <span class="o">|=</span> <span class="n">XMIT_CSUM_TCP</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_is_gso_v6</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="n">rc</span> <span class="o">|=</span> <span class="n">XMIT_GSO_V6</span> <span class="o">|</span> <span class="n">XMIT_CSUM_TCP</span> <span class="o">|</span> <span class="n">XMIT_CSUM_V6</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">skb_is_gso</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="n">rc</span> <span class="o">|=</span> <span class="n">XMIT_GSO_V4</span> <span class="o">|</span> <span class="n">XMIT_CSUM_V4</span> <span class="o">|</span> <span class="n">XMIT_CSUM_TCP</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if (MAX_SKB_FRAGS &gt;= MAX_FETCH_BD - 3)</span>
<span class="cm">/* check if packet requires linearization (packet is too fragmented)</span>
<span class="cm">   no need to check fragmentation if page size &gt; 8K (there will be no</span>
<span class="cm">   violation to FW restrictions) */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bnx2x_pkt_req_lin</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="n">xmit_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">to_copy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">first_bd_sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* 3 = 1 (for linear data BD) + 2 (for PBD and last BD) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">MAX_FETCH_BD</span> <span class="o">-</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">xmit_type</span> <span class="o">&amp;</span> <span class="n">XMIT_GSO</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">lso_mss</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">;</span>
			<span class="cm">/* Check if LSO packet needs to be copied:</span>
<span class="cm">			   3 = 1 (for headers BD) + 2 (for PBD and last BD) */</span>
			<span class="kt">int</span> <span class="n">wnd_size</span> <span class="o">=</span> <span class="n">MAX_FETCH_BD</span> <span class="o">-</span> <span class="mi">3</span><span class="p">;</span>
			<span class="cm">/* Number of windows to check */</span>
			<span class="kt">int</span> <span class="n">num_wnds</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">-</span> <span class="n">wnd_size</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">wnd_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">frag_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">wnd_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/* Headers length */</span>
			<span class="n">hlen</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">skb_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="o">+</span>
				<span class="n">tcp_hdrlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

			<span class="cm">/* Amount of data (w/o headers) on linear part of SKB*/</span>
			<span class="n">first_bd_sz</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="n">hlen</span><span class="p">;</span>

			<span class="n">wnd_sum</span>  <span class="o">=</span> <span class="n">first_bd_sz</span><span class="p">;</span>

			<span class="cm">/* Calculate the first sum - it&#39;s special */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">frag_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">frag_idx</span> <span class="o">&lt;</span> <span class="n">wnd_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">frag_idx</span><span class="o">++</span><span class="p">)</span>
				<span class="n">wnd_sum</span> <span class="o">+=</span>
					<span class="n">skb_frag_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">frag_idx</span><span class="p">]);</span>

			<span class="cm">/* If there was data on linear skb data - check it */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">first_bd_sz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">wnd_sum</span> <span class="o">&lt;</span> <span class="n">lso_mss</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">to_copy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">exit_lbl</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">wnd_sum</span> <span class="o">-=</span> <span class="n">first_bd_sz</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Others are easier: run through the frag list and</span>
<span class="cm">			   check all windows */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">wnd_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">wnd_idx</span> <span class="o">&lt;=</span> <span class="n">num_wnds</span><span class="p">;</span> <span class="n">wnd_idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">wnd_sum</span> <span class="o">+=</span>
			  <span class="n">skb_frag_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">wnd_idx</span> <span class="o">+</span> <span class="n">wnd_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">wnd_sum</span> <span class="o">&lt;</span> <span class="n">lso_mss</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">to_copy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">wnd_sum</span> <span class="o">-=</span>
					<span class="n">skb_frag_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">wnd_idx</span><span class="p">]);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* in non-LSO too fragmented packet should always</span>
<span class="cm">			   be linearized */</span>
			<span class="n">to_copy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">exit_lbl:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">to_copy</span><span class="p">))</span>
		<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_TX_QUEUED</span><span class="p">,</span>
		   <span class="s">&quot;Linearization IS REQUIRED for %s packet. num_frags %d  hlen %d  first_bd_sz %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="p">(</span><span class="n">xmit_type</span> <span class="o">&amp;</span> <span class="n">XMIT_GSO</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;LSO&quot;</span> <span class="o">:</span> <span class="s">&quot;non-LSO&quot;</span><span class="p">,</span>
		   <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">,</span> <span class="n">hlen</span><span class="p">,</span> <span class="n">first_bd_sz</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">to_copy</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bnx2x_set_pbd_gso_e2</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">parsing_data</span><span class="p">,</span>
					<span class="n">u32</span> <span class="n">xmit_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">parsing_data</span> <span class="o">|=</span> <span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span> <span class="o">&lt;&lt;</span>
			      <span class="n">ETH_TX_PARSE_BD_E2_LSO_MSS_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
			      <span class="n">ETH_TX_PARSE_BD_E2_LSO_MSS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">xmit_type</span> <span class="o">&amp;</span> <span class="n">XMIT_GSO_V6</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nexthdr</span> <span class="o">==</span> <span class="n">NEXTHDR_IPV6</span><span class="p">))</span>
		<span class="o">*</span><span class="n">parsing_data</span> <span class="o">|=</span> <span class="n">ETH_TX_PARSE_BD_E2_IPV6_WITH_EXT_HDR</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bnx2x_set_pbd_gso - update PBD in GSO case.</span>
<span class="cm"> *</span>
<span class="cm"> * @skb:	packet skb</span>
<span class="cm"> * @pbd:	parse BD</span>
<span class="cm"> * @xmit_type:	xmit flags</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bnx2x_set_pbd_gso</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">eth_tx_parse_bd_e1x</span> <span class="o">*</span><span class="n">pbd</span><span class="p">,</span>
				     <span class="n">u32</span> <span class="n">xmit_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pbd</span><span class="o">-&gt;</span><span class="n">lso_mss</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">);</span>
	<span class="n">pbd</span><span class="o">-&gt;</span><span class="n">tcp_send_seq</span> <span class="o">=</span> <span class="n">swab32</span><span class="p">(</span><span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>
	<span class="n">pbd</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">=</span> <span class="n">pbd_tcp_flags</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xmit_type</span> <span class="o">&amp;</span> <span class="n">XMIT_GSO_V4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pbd</span><span class="o">-&gt;</span><span class="n">ip_id</span> <span class="o">=</span> <span class="n">swab16</span><span class="p">(</span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
		<span class="n">pbd</span><span class="o">-&gt;</span><span class="n">tcp_pseudo_csum</span> <span class="o">=</span>
			<span class="n">swab16</span><span class="p">(</span><span class="o">~</span><span class="n">csum_tcpudp_magic</span><span class="p">(</span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span>
						  <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span>
						  <span class="mi">0</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

	<span class="p">}</span> <span class="k">else</span>
		<span class="n">pbd</span><span class="o">-&gt;</span><span class="n">tcp_pseudo_csum</span> <span class="o">=</span>
			<span class="n">swab16</span><span class="p">(</span><span class="o">~</span><span class="n">csum_ipv6_magic</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span>
						<span class="mi">0</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

	<span class="n">pbd</span><span class="o">-&gt;</span><span class="n">global_data</span> <span class="o">|=</span> <span class="n">ETH_TX_PARSE_BD_E1X_PSEUDO_CS_WITHOUT_LEN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bnx2x_set_pbd_csum_e2 - update PBD with checksum and return header length</span>
<span class="cm"> *</span>
<span class="cm"> * @bp:			driver handle</span>
<span class="cm"> * @skb:		packet skb</span>
<span class="cm"> * @parsing_data:	data to be updated</span>
<span class="cm"> * @xmit_type:		xmit flags</span>
<span class="cm"> *</span>
<span class="cm"> * 57712 related</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>  <span class="n">u8</span> <span class="nf">bnx2x_set_pbd_csum_e2</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">parsing_data</span><span class="p">,</span> <span class="n">u32</span> <span class="n">xmit_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">parsing_data</span> <span class="o">|=</span>
			<span class="p">((((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">skb_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
			<span class="n">ETH_TX_PARSE_BD_E2_TCP_HDR_START_OFFSET_W_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
			<span class="n">ETH_TX_PARSE_BD_E2_TCP_HDR_START_OFFSET_W</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xmit_type</span> <span class="o">&amp;</span> <span class="n">XMIT_CSUM_TCP</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">parsing_data</span> <span class="o">|=</span> <span class="p">((</span><span class="n">tcp_hdrlen</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
			<span class="n">ETH_TX_PARSE_BD_E2_TCP_HDR_LENGTH_DW_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
			<span class="n">ETH_TX_PARSE_BD_E2_TCP_HDR_LENGTH_DW</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">skb_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">+</span> <span class="n">tcp_hdrlen</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/* We support checksum offload for TCP and UDP only.</span>
<span class="cm">		 * No need to pass the UDP header length - it&#39;s a constant.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">skb_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">+</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">udphdr</span><span class="p">)</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bnx2x_set_sbd_csum</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">eth_tx_start_bd</span> <span class="o">*</span><span class="n">tx_start_bd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">xmit_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tx_start_bd</span><span class="o">-&gt;</span><span class="n">bd_flags</span><span class="p">.</span><span class="n">as_bitfield</span> <span class="o">|=</span> <span class="n">ETH_TX_BD_FLAGS_L4_CSUM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xmit_type</span> <span class="o">&amp;</span> <span class="n">XMIT_CSUM_V4</span><span class="p">)</span>
		<span class="n">tx_start_bd</span><span class="o">-&gt;</span><span class="n">bd_flags</span><span class="p">.</span><span class="n">as_bitfield</span> <span class="o">|=</span>
					<span class="n">ETH_TX_BD_FLAGS_IP_CSUM</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tx_start_bd</span><span class="o">-&gt;</span><span class="n">bd_flags</span><span class="p">.</span><span class="n">as_bitfield</span> <span class="o">|=</span>
					<span class="n">ETH_TX_BD_FLAGS_IPV6</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">xmit_type</span> <span class="o">&amp;</span> <span class="n">XMIT_CSUM_TCP</span><span class="p">))</span>
		<span class="n">tx_start_bd</span><span class="o">-&gt;</span><span class="n">bd_flags</span><span class="p">.</span><span class="n">as_bitfield</span> <span class="o">|=</span> <span class="n">ETH_TX_BD_FLAGS_IS_UDP</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bnx2x_set_pbd_csum - update PBD with checksum and return header length</span>
<span class="cm"> *</span>
<span class="cm"> * @bp:		driver handle</span>
<span class="cm"> * @skb:	packet skb</span>
<span class="cm"> * @pbd:	parse BD to be updated</span>
<span class="cm"> * @xmit_type:	xmit flags</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">bnx2x_set_pbd_csum</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">eth_tx_parse_bd_e1x</span> <span class="o">*</span><span class="n">pbd</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">xmit_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">hlen</span> <span class="o">=</span> <span class="p">(</span><span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* for now NS flag is not used in Linux */</span>
	<span class="n">pbd</span><span class="o">-&gt;</span><span class="n">global_data</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">hlen</span> <span class="o">|</span> <span class="p">((</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">ETH_P_8021Q</span><span class="p">))</span> <span class="o">&lt;&lt;</span>
			 <span class="n">ETH_TX_PARSE_BD_E1X_LLC_SNAP_EN_SHIFT</span><span class="p">));</span>

	<span class="n">pbd</span><span class="o">-&gt;</span><span class="n">ip_hlen_w</span> <span class="o">=</span> <span class="p">(</span><span class="n">skb_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span>
			<span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">hlen</span> <span class="o">+=</span> <span class="n">pbd</span><span class="o">-&gt;</span><span class="n">ip_hlen_w</span><span class="p">;</span>

	<span class="cm">/* We support checksum offload for TCP and UDP only */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xmit_type</span> <span class="o">&amp;</span> <span class="n">XMIT_CSUM_TCP</span><span class="p">)</span>
		<span class="n">hlen</span> <span class="o">+=</span> <span class="n">tcp_hdrlen</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">hlen</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">udphdr</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">pbd</span><span class="o">-&gt;</span><span class="n">total_hlen_w</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">hlen</span><span class="p">);</span>
	<span class="n">hlen</span> <span class="o">=</span> <span class="n">hlen</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xmit_type</span> <span class="o">&amp;</span> <span class="n">XMIT_CSUM_TCP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pbd</span><span class="o">-&gt;</span><span class="n">tcp_pseudo_csum</span> <span class="o">=</span> <span class="n">swab16</span><span class="p">(</span><span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">check</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">s8</span> <span class="n">fix</span> <span class="o">=</span> <span class="n">SKB_CS_OFF</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span> <span class="cm">/* signed! */</span>

		<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_TX_QUEUED</span><span class="p">,</span>
		   <span class="s">&quot;hlen %d  fix %d  csum before fix %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">pbd</span><span class="o">-&gt;</span><span class="n">total_hlen_w</span><span class="p">),</span> <span class="n">fix</span><span class="p">,</span> <span class="n">SKB_CS</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

		<span class="cm">/* HW bug: fixup the CSUM */</span>
		<span class="n">pbd</span><span class="o">-&gt;</span><span class="n">tcp_pseudo_csum</span> <span class="o">=</span>
			<span class="n">bnx2x_csum_fix</span><span class="p">(</span><span class="n">skb_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span>
				       <span class="n">SKB_CS</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">fix</span><span class="p">);</span>

		<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_TX_QUEUED</span><span class="p">,</span> <span class="s">&quot;csum after fix %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">pbd</span><span class="o">-&gt;</span><span class="n">tcp_pseudo_csum</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">hlen</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* called with netif_tx_lock</span>
<span class="cm"> * bnx2x_tx_int() runs without netif_tx_lock unless it needs to call</span>
<span class="cm"> * netif_wake_queue()</span>
<span class="cm"> */</span>
<span class="n">netdev_tx_t</span> <span class="nf">bnx2x_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bnx2x_fp_txdata</span> <span class="o">*</span><span class="n">txdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sw_tx_bd</span> <span class="o">*</span><span class="n">tx_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eth_tx_start_bd</span> <span class="o">*</span><span class="n">tx_start_bd</span><span class="p">,</span> <span class="o">*</span><span class="n">first_bd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eth_tx_bd</span> <span class="o">*</span><span class="n">tx_data_bd</span><span class="p">,</span> <span class="o">*</span><span class="n">total_pkt_bd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eth_tx_parse_bd_e1x</span> <span class="o">*</span><span class="n">pbd_e1x</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eth_tx_parse_bd_e2</span> <span class="o">*</span><span class="n">pbd_e2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pbd_e2_parsing_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pkt_prod</span><span class="p">,</span> <span class="n">bd_prod</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nbd</span><span class="p">,</span> <span class="n">txq_index</span><span class="p">,</span> <span class="n">fp_index</span><span class="p">,</span> <span class="n">txdata_index</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">mapping</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">xmit_type</span> <span class="o">=</span> <span class="n">bnx2x_xmit_type</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">hlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">pkt_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">eth</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">mac_type</span> <span class="o">=</span> <span class="n">UNICAST_ADDRESS</span><span class="p">;</span>

<span class="cp">#ifdef BNX2X_STOP_ON_ERROR</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">panic</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">txq_index</span> <span class="o">=</span> <span class="n">skb_get_queue_mapping</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">txq</span> <span class="o">=</span> <span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">txq_index</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">txq_index</span> <span class="o">&gt;=</span> <span class="n">MAX_ETH_TXQ_IDX</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">+</span> <span class="n">FCOE_PRESENT</span><span class="p">);</span>

	<span class="cm">/* decode the fastpath index and the cos index from the txq */</span>
	<span class="n">fp_index</span> <span class="o">=</span> <span class="n">TXQ_TO_FP</span><span class="p">(</span><span class="n">txq_index</span><span class="p">);</span>
	<span class="n">txdata_index</span> <span class="o">=</span> <span class="n">TXQ_TO_COS</span><span class="p">(</span><span class="n">txq_index</span><span class="p">);</span>

<span class="cp">#ifdef BCM_CNIC</span>
	<span class="cm">/*</span>
<span class="cm">	 * Override the above for the FCoE queue:</span>
<span class="cm">	 *   - FCoE fp entry is right after the ETH entries.</span>
<span class="cm">	 *   - FCoE L2 queue uses bp-&gt;txdata[0] only.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">NO_FCOE</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">txq_index</span> <span class="o">==</span>
				      <span class="n">bnx2x_fcoe_tx</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">txq_index</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">fp_index</span> <span class="o">=</span> <span class="n">FCOE_IDX</span><span class="p">;</span>
		<span class="n">txdata_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* enable this debug print to view the transmission queue being used</span>
<span class="cm">	DP(NETIF_MSG_TX_QUEUED, &quot;indices: txq %d, fp %d, txdata %d\n&quot;,</span>
<span class="cm">	   txq_index, fp_index, txdata_index); */</span>

	<span class="cm">/* locate the fastpath and the txdata */</span>
	<span class="n">fp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">[</span><span class="n">fp_index</span><span class="p">];</span>
	<span class="n">txdata</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">txdata</span><span class="p">[</span><span class="n">txdata_index</span><span class="p">];</span>

	<span class="cm">/* enable this debug print to view the tranmission details</span>
<span class="cm">	DP(NETIF_MSG_TX_QUEUED,</span>
<span class="cm">	   &quot;transmitting packet cid %d fp index %d txdata_index %d tx_data ptr %p fp pointer %p\n&quot;,</span>
<span class="cm">	   txdata-&gt;cid, fp_index, txdata_index, txdata, fp); */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">bnx2x_tx_avail</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">txdata</span><span class="p">)</span> <span class="o">&lt;</span>
		     <span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">fp</span><span class="o">-&gt;</span><span class="n">eth_q_stats</span><span class="p">.</span><span class="n">driver_xoff</span><span class="o">++</span><span class="p">;</span>
		<span class="n">netif_tx_stop_queue</span><span class="p">(</span><span class="n">txq</span><span class="p">);</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;BUG! Tx ring full when queue awake!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_TX_QUEUED</span><span class="p">,</span>
	   <span class="s">&quot;queue[%d]: SKB: summed %x  protocol %x protocol(%x,%x) gso type %x  xmit_type %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	   <span class="n">txq_index</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">,</span> <span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nexthdr</span><span class="p">,</span>
	   <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">,</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_type</span><span class="p">,</span> <span class="n">xmit_type</span><span class="p">);</span>

	<span class="n">eth</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* set flag according to packet type (UNICAST_ADDRESS is default)*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_multicast_ether_addr</span><span class="p">(</span><span class="n">eth</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_broadcast_ether_addr</span><span class="p">(</span><span class="n">eth</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">))</span>
			<span class="n">mac_type</span> <span class="o">=</span> <span class="n">BROADCAST_ADDRESS</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">mac_type</span> <span class="o">=</span> <span class="n">MULTICAST_ADDRESS</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#if (MAX_SKB_FRAGS &gt;= MAX_FETCH_BD - 3)</span>
	<span class="cm">/* First, check if we need to linearize the skb (due to FW</span>
<span class="cm">	   restrictions). No need to check fragmentation if page size &gt; 8K</span>
<span class="cm">	   (there will be no violation to FW restrictions) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bnx2x_pkt_req_lin</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">xmit_type</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Statistics of linearization */</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">lin_cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb_linearize</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_TX_QUEUED</span><span class="p">,</span>
			   <span class="s">&quot;SKB linearization failed - silently dropping this SKB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="cm">/* Map skb linear data for DMA */</span>
	<span class="n">mapping</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
				 <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">mapping</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_TX_QUEUED</span><span class="p">,</span>
		   <span class="s">&quot;SKB mapping failed - silently dropping this SKB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	Please read carefully. First we use one BD which we mark as start,</span>
<span class="cm">	then we have a parsing info BD (used for TSO or xsum),</span>
<span class="cm">	and only then we have the rest of the TSO BDs.</span>
<span class="cm">	(don&#39;t forget to mark the last one as last,</span>
<span class="cm">	and to unmap only AFTER you write to the BD ...)</span>
<span class="cm">	And above all, all pdb sizes are in words - NOT DWORDS!</span>
<span class="cm">	*/</span>

	<span class="cm">/* get current pkt produced now - advance it just before sending packet</span>
<span class="cm">	 * since mapping of pages may fail and cause packet to be dropped</span>
<span class="cm">	 */</span>
	<span class="n">pkt_prod</span> <span class="o">=</span> <span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_pkt_prod</span><span class="p">;</span>
	<span class="n">bd_prod</span> <span class="o">=</span> <span class="n">TX_BD</span><span class="p">(</span><span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_bd_prod</span><span class="p">);</span>

	<span class="cm">/* get a tx_buf and first BD</span>
<span class="cm">	 * tx_start_bd may be changed during SPLIT,</span>
<span class="cm">	 * but first_bd will always stay first</span>
<span class="cm">	 */</span>
	<span class="n">tx_buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_buf_ring</span><span class="p">[</span><span class="n">TX_BD</span><span class="p">(</span><span class="n">pkt_prod</span><span class="p">)];</span>
	<span class="n">tx_start_bd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_desc_ring</span><span class="p">[</span><span class="n">bd_prod</span><span class="p">].</span><span class="n">start_bd</span><span class="p">;</span>
	<span class="n">first_bd</span> <span class="o">=</span> <span class="n">tx_start_bd</span><span class="p">;</span>

	<span class="n">tx_start_bd</span><span class="o">-&gt;</span><span class="n">bd_flags</span><span class="p">.</span><span class="n">as_bitfield</span> <span class="o">=</span> <span class="n">ETH_TX_BD_FLAGS_START_BD</span><span class="p">;</span>
	<span class="n">SET_FLAG</span><span class="p">(</span><span class="n">tx_start_bd</span><span class="o">-&gt;</span><span class="n">general_data</span><span class="p">,</span> <span class="n">ETH_TX_START_BD_ETH_ADDR_TYPE</span><span class="p">,</span>
		 <span class="n">mac_type</span><span class="p">);</span>

	<span class="cm">/* header nbd */</span>
	<span class="n">SET_FLAG</span><span class="p">(</span><span class="n">tx_start_bd</span><span class="o">-&gt;</span><span class="n">general_data</span><span class="p">,</span> <span class="n">ETH_TX_START_BD_HDR_NBDS</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* remember the first BD of the packet */</span>
	<span class="n">tx_buf</span><span class="o">-&gt;</span><span class="n">first_bd</span> <span class="o">=</span> <span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_bd_prod</span><span class="p">;</span>
	<span class="n">tx_buf</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="n">tx_buf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_TX_QUEUED</span><span class="p">,</span>
	   <span class="s">&quot;sending pkt %u @%p  next_idx %u  bd %u @%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	   <span class="n">pkt_prod</span><span class="p">,</span> <span class="n">tx_buf</span><span class="p">,</span> <span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_pkt_prod</span><span class="p">,</span> <span class="n">bd_prod</span><span class="p">,</span> <span class="n">tx_start_bd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vlan_tx_tag_present</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tx_start_bd</span><span class="o">-&gt;</span><span class="n">vlan_or_ethertype</span> <span class="o">=</span>
		    <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">vlan_tx_tag_get</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
		<span class="n">tx_start_bd</span><span class="o">-&gt;</span><span class="n">bd_flags</span><span class="p">.</span><span class="n">as_bitfield</span> <span class="o">|=</span>
		    <span class="p">(</span><span class="n">X_ETH_OUTBAND_VLAN</span> <span class="o">&lt;&lt;</span> <span class="n">ETH_TX_BD_FLAGS_VLAN_MODE_SHIFT</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">tx_start_bd</span><span class="o">-&gt;</span><span class="n">vlan_or_ethertype</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">pkt_prod</span><span class="p">);</span>

	<span class="cm">/* turn on parsing and get a BD */</span>
	<span class="n">bd_prod</span> <span class="o">=</span> <span class="n">TX_BD</span><span class="p">(</span><span class="n">NEXT_TX_IDX</span><span class="p">(</span><span class="n">bd_prod</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xmit_type</span> <span class="o">&amp;</span> <span class="n">XMIT_CSUM</span><span class="p">)</span>
		<span class="n">bnx2x_set_sbd_csum</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">tx_start_bd</span><span class="p">,</span> <span class="n">xmit_type</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CHIP_IS_E1x</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pbd_e2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_desc_ring</span><span class="p">[</span><span class="n">bd_prod</span><span class="p">].</span><span class="n">parse_bd_e2</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">pbd_e2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">eth_tx_parse_bd_e2</span><span class="p">));</span>
		<span class="cm">/* Set PBD in checksum offload case */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xmit_type</span> <span class="o">&amp;</span> <span class="n">XMIT_CSUM</span><span class="p">)</span>
			<span class="n">hlen</span> <span class="o">=</span> <span class="n">bnx2x_set_pbd_csum_e2</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">pbd_e2_parsing_data</span><span class="p">,</span>
						     <span class="n">xmit_type</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_MF_SI</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * fill in the MAC addresses in the PBD - for local</span>
<span class="cm">			 * switching</span>
<span class="cm">			 */</span>
			<span class="n">bnx2x_set_fw_mac_addr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pbd_e2</span><span class="o">-&gt;</span><span class="n">src_mac_addr_hi</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">pbd_e2</span><span class="o">-&gt;</span><span class="n">src_mac_addr_mid</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">pbd_e2</span><span class="o">-&gt;</span><span class="n">src_mac_addr_lo</span><span class="p">,</span>
					      <span class="n">eth</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">);</span>
			<span class="n">bnx2x_set_fw_mac_addr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pbd_e2</span><span class="o">-&gt;</span><span class="n">dst_mac_addr_hi</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">pbd_e2</span><span class="o">-&gt;</span><span class="n">dst_mac_addr_mid</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">pbd_e2</span><span class="o">-&gt;</span><span class="n">dst_mac_addr_lo</span><span class="p">,</span>
					      <span class="n">eth</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pbd_e1x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_desc_ring</span><span class="p">[</span><span class="n">bd_prod</span><span class="p">].</span><span class="n">parse_bd_e1x</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">pbd_e1x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">eth_tx_parse_bd_e1x</span><span class="p">));</span>
		<span class="cm">/* Set PBD in checksum offload case */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xmit_type</span> <span class="o">&amp;</span> <span class="n">XMIT_CSUM</span><span class="p">)</span>
			<span class="n">hlen</span> <span class="o">=</span> <span class="n">bnx2x_set_pbd_csum</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">pbd_e1x</span><span class="p">,</span> <span class="n">xmit_type</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="cm">/* Setup the data pointer of the first BD of the packet */</span>
	<span class="n">tx_start_bd</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">U64_HI</span><span class="p">(</span><span class="n">mapping</span><span class="p">));</span>
	<span class="n">tx_start_bd</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">U64_LO</span><span class="p">(</span><span class="n">mapping</span><span class="p">));</span>
	<span class="n">nbd</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* start_bd + pbd + frags (updated when pages are mapped) */</span>
	<span class="n">tx_start_bd</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
	<span class="n">pkt_size</span> <span class="o">=</span> <span class="n">tx_start_bd</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">;</span>

	<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_TX_QUEUED</span><span class="p">,</span>
	   <span class="s">&quot;first bd @%p  addr (%x:%x)  nbd %d  nbytes %d  flags %x  vlan %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	   <span class="n">tx_start_bd</span><span class="p">,</span> <span class="n">tx_start_bd</span><span class="o">-&gt;</span><span class="n">addr_hi</span><span class="p">,</span> <span class="n">tx_start_bd</span><span class="o">-&gt;</span><span class="n">addr_lo</span><span class="p">,</span>
	   <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">tx_start_bd</span><span class="o">-&gt;</span><span class="n">nbd</span><span class="p">),</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">tx_start_bd</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">),</span>
	   <span class="n">tx_start_bd</span><span class="o">-&gt;</span><span class="n">bd_flags</span><span class="p">.</span><span class="n">as_bitfield</span><span class="p">,</span>
	   <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">tx_start_bd</span><span class="o">-&gt;</span><span class="n">vlan_or_ethertype</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xmit_type</span> <span class="o">&amp;</span> <span class="n">XMIT_GSO</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_TX_QUEUED</span><span class="p">,</span>
		   <span class="s">&quot;TSO packet len %d  hlen %d  total len %d  tso size %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">hlen</span><span class="p">,</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span>
		   <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">);</span>

		<span class="n">tx_start_bd</span><span class="o">-&gt;</span><span class="n">bd_flags</span><span class="p">.</span><span class="n">as_bitfield</span> <span class="o">|=</span> <span class="n">ETH_TX_BD_FLAGS_SW_LSO</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">hlen</span><span class="p">))</span>
			<span class="n">bd_prod</span> <span class="o">=</span> <span class="n">bnx2x_tx_split</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">txdata</span><span class="p">,</span> <span class="n">tx_buf</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">tx_start_bd</span><span class="p">,</span> <span class="n">hlen</span><span class="p">,</span>
						 <span class="n">bd_prod</span><span class="p">,</span> <span class="o">++</span><span class="n">nbd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CHIP_IS_E1x</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span>
			<span class="n">bnx2x_set_pbd_gso_e2</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pbd_e2_parsing_data</span><span class="p">,</span>
					     <span class="n">xmit_type</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">bnx2x_set_pbd_gso</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pbd_e1x</span><span class="p">,</span> <span class="n">xmit_type</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Set the PBD&#39;s parsing_data field if not zero</span>
<span class="cm">	 * (for the chips newer than 57711).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pbd_e2_parsing_data</span><span class="p">)</span>
		<span class="n">pbd_e2</span><span class="o">-&gt;</span><span class="n">parsing_data</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">pbd_e2_parsing_data</span><span class="p">);</span>

	<span class="n">tx_data_bd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">eth_tx_bd</span> <span class="o">*</span><span class="p">)</span><span class="n">tx_start_bd</span><span class="p">;</span>

	<span class="cm">/* Handle fragmented skb */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">mapping</span> <span class="o">=</span> <span class="n">skb_frag_dma_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">frag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					   <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">),</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">mapping</span><span class="p">)))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pkts_compl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bytes_compl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_TX_QUEUED</span><span class="p">,</span>
			   <span class="s">&quot;Unable to map page - dropping packet...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="cm">/* we need unmap all buffers already mapped</span>
<span class="cm">			 * for this SKB;</span>
<span class="cm">			 * first_bd-&gt;nbd need to be properly updated</span>
<span class="cm">			 * before call to bnx2x_free_tx_pkt</span>
<span class="cm">			 */</span>
			<span class="n">first_bd</span><span class="o">-&gt;</span><span class="n">nbd</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">nbd</span><span class="p">);</span>
			<span class="n">bnx2x_free_tx_pkt</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">txdata</span><span class="p">,</span>
					  <span class="n">TX_BD</span><span class="p">(</span><span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_pkt_prod</span><span class="p">),</span>
					  <span class="o">&amp;</span><span class="n">pkts_compl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bytes_compl</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">bd_prod</span> <span class="o">=</span> <span class="n">TX_BD</span><span class="p">(</span><span class="n">NEXT_TX_IDX</span><span class="p">(</span><span class="n">bd_prod</span><span class="p">));</span>
		<span class="n">tx_data_bd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_desc_ring</span><span class="p">[</span><span class="n">bd_prod</span><span class="p">].</span><span class="n">reg_bd</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">total_pkt_bd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">total_pkt_bd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_desc_ring</span><span class="p">[</span><span class="n">bd_prod</span><span class="p">].</span><span class="n">reg_bd</span><span class="p">;</span>

		<span class="n">tx_data_bd</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">U64_HI</span><span class="p">(</span><span class="n">mapping</span><span class="p">));</span>
		<span class="n">tx_data_bd</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">U64_LO</span><span class="p">(</span><span class="n">mapping</span><span class="p">));</span>
		<span class="n">tx_data_bd</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">));</span>
		<span class="n">le16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pkt_size</span><span class="p">,</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">));</span>
		<span class="n">nbd</span><span class="o">++</span><span class="p">;</span>

		<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_TX_QUEUED</span><span class="p">,</span>
		   <span class="s">&quot;frag %d  bd @%p  addr (%x:%x)  nbytes %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">i</span><span class="p">,</span> <span class="n">tx_data_bd</span><span class="p">,</span> <span class="n">tx_data_bd</span><span class="o">-&gt;</span><span class="n">addr_hi</span><span class="p">,</span> <span class="n">tx_data_bd</span><span class="o">-&gt;</span><span class="n">addr_lo</span><span class="p">,</span>
		   <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">tx_data_bd</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_TX_QUEUED</span><span class="p">,</span> <span class="s">&quot;last bd @%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tx_data_bd</span><span class="p">);</span>

	<span class="cm">/* update with actual num BDs */</span>
	<span class="n">first_bd</span><span class="o">-&gt;</span><span class="n">nbd</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">nbd</span><span class="p">);</span>

	<span class="n">bd_prod</span> <span class="o">=</span> <span class="n">TX_BD</span><span class="p">(</span><span class="n">NEXT_TX_IDX</span><span class="p">(</span><span class="n">bd_prod</span><span class="p">));</span>

	<span class="cm">/* now send a tx doorbell, counting the next BD</span>
<span class="cm">	 * if the packet contains or ends with it</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TX_BD_POFF</span><span class="p">(</span><span class="n">bd_prod</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nbd</span><span class="p">)</span>
		<span class="n">nbd</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* total_pkt_bytes should be set on the first data BD if</span>
<span class="cm">	 * it&#39;s not an LSO packet and there is more than one</span>
<span class="cm">	 * data BD. In this case pkt_size is limited by an MTU value.</span>
<span class="cm">	 * However we prefer to set it for an LSO packet (while we don&#39;t</span>
<span class="cm">	 * have to) in order to save some CPU cycles in a none-LSO</span>
<span class="cm">	 * case, when we much more care about them.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">total_pkt_bd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">total_pkt_bd</span><span class="o">-&gt;</span><span class="n">total_pkt_bytes</span> <span class="o">=</span> <span class="n">pkt_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pbd_e1x</span><span class="p">)</span>
		<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_TX_QUEUED</span><span class="p">,</span>
		   <span class="s">&quot;PBD (E1X) @%p  ip_data %x  ip_hlen %u  ip_id %u  lso_mss %u  tcp_flags %x  xsum %x  seq %u  hlen %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">pbd_e1x</span><span class="p">,</span> <span class="n">pbd_e1x</span><span class="o">-&gt;</span><span class="n">global_data</span><span class="p">,</span> <span class="n">pbd_e1x</span><span class="o">-&gt;</span><span class="n">ip_hlen_w</span><span class="p">,</span>
		   <span class="n">pbd_e1x</span><span class="o">-&gt;</span><span class="n">ip_id</span><span class="p">,</span> <span class="n">pbd_e1x</span><span class="o">-&gt;</span><span class="n">lso_mss</span><span class="p">,</span> <span class="n">pbd_e1x</span><span class="o">-&gt;</span><span class="n">tcp_flags</span><span class="p">,</span>
		   <span class="n">pbd_e1x</span><span class="o">-&gt;</span><span class="n">tcp_pseudo_csum</span><span class="p">,</span> <span class="n">pbd_e1x</span><span class="o">-&gt;</span><span class="n">tcp_send_seq</span><span class="p">,</span>
		    <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">pbd_e1x</span><span class="o">-&gt;</span><span class="n">total_hlen_w</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pbd_e2</span><span class="p">)</span>
		<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_TX_QUEUED</span><span class="p">,</span>
		   <span class="s">&quot;PBD (E2) @%p  dst %x %x %x src %x %x %x parsing_data %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">pbd_e2</span><span class="p">,</span> <span class="n">pbd_e2</span><span class="o">-&gt;</span><span class="n">dst_mac_addr_hi</span><span class="p">,</span> <span class="n">pbd_e2</span><span class="o">-&gt;</span><span class="n">dst_mac_addr_mid</span><span class="p">,</span>
		   <span class="n">pbd_e2</span><span class="o">-&gt;</span><span class="n">dst_mac_addr_lo</span><span class="p">,</span> <span class="n">pbd_e2</span><span class="o">-&gt;</span><span class="n">src_mac_addr_hi</span><span class="p">,</span>
		   <span class="n">pbd_e2</span><span class="o">-&gt;</span><span class="n">src_mac_addr_mid</span><span class="p">,</span> <span class="n">pbd_e2</span><span class="o">-&gt;</span><span class="n">src_mac_addr_lo</span><span class="p">,</span>
		   <span class="n">pbd_e2</span><span class="o">-&gt;</span><span class="n">parsing_data</span><span class="p">);</span>
	<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_TX_QUEUED</span><span class="p">,</span> <span class="s">&quot;doorbell: nbd %d  bd %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nbd</span><span class="p">,</span> <span class="n">bd_prod</span><span class="p">);</span>

	<span class="n">netdev_tx_sent_queue</span><span class="p">(</span><span class="n">txq</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="n">skb_tx_timestamp</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_pkt_prod</span><span class="o">++</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Make sure that the BD data is updated before updating the producer</span>
<span class="cm">	 * since FW might read the BD right after the producer is updated.</span>
<span class="cm">	 * This is only applicable for weak-ordered memory model archs such</span>
<span class="cm">	 * as IA-64. The following barrier is also mandatory since FW will</span>
<span class="cm">	 * assumes packets must have BDs.</span>
<span class="cm">	 */</span>
	<span class="n">wmb</span><span class="p">();</span>

	<span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_db</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">prod</span> <span class="o">+=</span> <span class="n">nbd</span><span class="p">;</span>
	<span class="n">barrier</span><span class="p">();</span>

	<span class="n">DOORBELL</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">txdata</span><span class="o">-&gt;</span><span class="n">cid</span><span class="p">,</span> <span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_db</span><span class="p">.</span><span class="n">raw</span><span class="p">);</span>

	<span class="n">mmiowb</span><span class="p">();</span>

	<span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_bd_prod</span> <span class="o">+=</span> <span class="n">nbd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">bnx2x_tx_avail</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">txdata</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">MAX_SKB_FRAGS</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netif_tx_stop_queue</span><span class="p">(</span><span class="n">txq</span><span class="p">);</span>

		<span class="cm">/* paired memory barrier is in bnx2x_tx_int(), we have to keep</span>
<span class="cm">		 * ordering of set_bit() in netif_tx_stop_queue() and read of</span>
<span class="cm">		 * fp-&gt;bd_tx_cons */</span>
		<span class="n">smp_mb</span><span class="p">();</span>

		<span class="n">fp</span><span class="o">-&gt;</span><span class="n">eth_q_stats</span><span class="p">.</span><span class="n">driver_xoff</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bnx2x_tx_avail</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">txdata</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">MAX_SKB_FRAGS</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">netif_tx_wake_queue</span><span class="p">(</span><span class="n">txq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_pkt</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bnx2x_setup_tc - routine to configure net_device for multi tc</span>
<span class="cm"> *</span>
<span class="cm"> * @netdev: net device to configure</span>
<span class="cm"> * @tc: number of traffic classes to enable</span>
<span class="cm"> *</span>
<span class="cm"> * callback connected to the ndo_setup_tc function pointer</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bnx2x_setup_tc</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">num_tc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cos</span><span class="p">,</span> <span class="n">prio</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* setup tc must be called under rtnl lock */</span>
	<span class="n">ASSERT_RTNL</span><span class="p">();</span>

	<span class="cm">/* no traffic classes requested. aborting */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num_tc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_reset_tc</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* requested to support too many traffic classes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_tc</span> <span class="o">&gt;</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">max_cos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;support for too many traffic classes requested: %d. max supported is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">num_tc</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">max_cos</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* declare amount of supported traffic classes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netdev_set_num_tc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">num_tc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;failed to declare %d traffic classes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">num_tc</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* configure priority to traffic class mapping */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">prio</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">prio</span> <span class="o">&lt;</span> <span class="n">BNX2X_MAX_PRIORITY</span><span class="p">;</span> <span class="n">prio</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_set_prio_tc_map</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">prio</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">prio_to_cos</span><span class="p">[</span><span class="n">prio</span><span class="p">]);</span>
		<span class="n">DP</span><span class="p">(</span><span class="n">BNX2X_MSG_SP</span> <span class="o">|</span> <span class="n">NETIF_MSG_IFUP</span><span class="p">,</span>
		   <span class="s">&quot;mapping priority %d to tc %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">prio</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">prio_to_cos</span><span class="p">[</span><span class="n">prio</span><span class="p">]);</span>
	<span class="p">}</span>


	<span class="cm">/* Use this configuration to diffrentiate tc0 from other COSes</span>
<span class="cm">	   This can be used for ets or pfc, and save the effort of setting</span>
<span class="cm">	   up a multio class queue disc or negotiating DCBX with a switch</span>
<span class="cm">	netdev_set_prio_tc_map(dev, 0, 0);</span>
<span class="cm">	DP(BNX2X_MSG_SP, &quot;mapping priority %d to tc %d\n&quot;, 0, 0);</span>
<span class="cm">	for (prio = 1; prio &lt; 16; prio++) {</span>
<span class="cm">		netdev_set_prio_tc_map(dev, prio, 1);</span>
<span class="cm">		DP(BNX2X_MSG_SP, &quot;mapping priority %d to tc %d\n&quot;, prio, 1);</span>
<span class="cm">	} */</span>

	<span class="cm">/* configure traffic class to transmission queue mapping */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cos</span> <span class="o">&lt;</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">max_cos</span><span class="p">;</span> <span class="n">cos</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">BNX2X_NUM_ETH_QUEUES</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">cos</span> <span class="o">*</span> <span class="n">MAX_TXQS_PER_COS</span><span class="p">;</span>
		<span class="n">netdev_set_tc_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">DP</span><span class="p">(</span><span class="n">BNX2X_MSG_SP</span> <span class="o">|</span> <span class="n">NETIF_MSG_IFUP</span><span class="p">,</span>
		   <span class="s">&quot;mapping tc %d to offset %d count %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">cos</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* called with rtnl_lock */</span>
<span class="kt">int</span> <span class="nf">bnx2x_change_mac_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bnx2x_is_valid_ether_addr</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;Requested MAC address is not valid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef BCM_CNIC</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">IS_MF_STORAGE_SD</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">||</span> <span class="n">IS_MF_FCOE_AFEX</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">is_zero_ether_addr</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;Can&#39;t configure non-zero address on iSCSI or FCoE functions in MF-SD mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>  <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">bnx2x_set_eth_mac</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_assign_type</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NET_ADDR_RANDOM</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">bnx2x_set_eth_mac</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bnx2x_free_fp_mem_at</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fp_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">host_hc_status_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp_index</span><span class="p">,</span> <span class="n">status_blk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">[</span><span class="n">fp_index</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">cos</span><span class="p">;</span>

	<span class="cm">/* Common */</span>
<span class="cp">#ifdef BCM_CNIC</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_FCOE_IDX</span><span class="p">(</span><span class="n">fp_index</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">host_hc_status_block</span><span class="p">));</span>
		<span class="n">fp</span><span class="o">-&gt;</span><span class="n">status_blk_mapping</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#endif</span>
		<span class="cm">/* status blocks */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CHIP_IS_E1x</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span>
			<span class="n">BNX2X_PCI_FREE</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">e2_sb</span><span class="p">,</span>
				       <span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp_index</span><span class="p">,</span>
						<span class="n">status_blk_mapping</span><span class="p">),</span>
				       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">host_hc_status_block_e2</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">BNX2X_PCI_FREE</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">e1x_sb</span><span class="p">,</span>
				       <span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp_index</span><span class="p">,</span>
						<span class="n">status_blk_mapping</span><span class="p">),</span>
				       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">host_hc_status_block_e1x</span><span class="p">));</span>
<span class="cp">#ifdef BCM_CNIC</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="cm">/* Rx */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skip_rx_queue</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp_index</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bnx2x_free_rx_bds</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

		<span class="cm">/* fastpath rx rings: rx_buf rx_desc rx_comp */</span>
		<span class="n">BNX2X_FREE</span><span class="p">(</span><span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp_index</span><span class="p">,</span> <span class="n">rx_buf_ring</span><span class="p">));</span>
		<span class="n">BNX2X_PCI_FREE</span><span class="p">(</span><span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp_index</span><span class="p">,</span> <span class="n">rx_desc_ring</span><span class="p">),</span>
			       <span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp_index</span><span class="p">,</span> <span class="n">rx_desc_mapping</span><span class="p">),</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">eth_rx_bd</span><span class="p">)</span> <span class="o">*</span> <span class="n">NUM_RX_BD</span><span class="p">);</span>

		<span class="n">BNX2X_PCI_FREE</span><span class="p">(</span><span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp_index</span><span class="p">,</span> <span class="n">rx_comp_ring</span><span class="p">),</span>
			       <span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp_index</span><span class="p">,</span> <span class="n">rx_comp_mapping</span><span class="p">),</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">eth_fast_path_rx_cqe</span><span class="p">)</span> <span class="o">*</span>
			       <span class="n">NUM_RCQ_BD</span><span class="p">);</span>

		<span class="cm">/* SGE ring */</span>
		<span class="n">BNX2X_FREE</span><span class="p">(</span><span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp_index</span><span class="p">,</span> <span class="n">rx_page_ring</span><span class="p">));</span>
		<span class="n">BNX2X_PCI_FREE</span><span class="p">(</span><span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp_index</span><span class="p">,</span> <span class="n">rx_sge_ring</span><span class="p">),</span>
			       <span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp_index</span><span class="p">,</span> <span class="n">rx_sge_mapping</span><span class="p">),</span>
			       <span class="n">BCM_PAGE_SIZE</span> <span class="o">*</span> <span class="n">NUM_RX_SGE_PAGES</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Tx */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skip_tx_queue</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp_index</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* fastpath tx rings: tx_buf tx_desc */</span>
		<span class="n">for_each_cos_in_tx_queue</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">cos</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">bnx2x_fp_txdata</span> <span class="o">*</span><span class="n">txdata</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">txdata</span><span class="p">[</span><span class="n">cos</span><span class="p">];</span>

			<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_IFDOWN</span><span class="p">,</span>
			   <span class="s">&quot;freeing tx memory of fp %d cos %d cid %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">fp_index</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">txdata</span><span class="o">-&gt;</span><span class="n">cid</span><span class="p">);</span>

			<span class="n">BNX2X_FREE</span><span class="p">(</span><span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_buf_ring</span><span class="p">);</span>
			<span class="n">BNX2X_PCI_FREE</span><span class="p">(</span><span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_desc_ring</span><span class="p">,</span>
				<span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_desc_mapping</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">eth_tx_bd_types</span><span class="p">)</span> <span class="o">*</span> <span class="n">NUM_TX_BD</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* end of fastpath */</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bnx2x_free_fp_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">for_each_queue</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
		<span class="n">bnx2x_free_fp_mem_at</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_sb_shortcuts</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">host_hc_status_block</span> <span class="n">status_blk</span> <span class="o">=</span> <span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">status_blk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CHIP_IS_E1x</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">sb_index_values</span><span class="p">)</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="n">status_blk</span><span class="p">.</span><span class="n">e2_sb</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">.</span><span class="n">index_values</span><span class="p">;</span>
		<span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">sb_running_index</span><span class="p">)</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="n">status_blk</span><span class="p">.</span><span class="n">e2_sb</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">.</span><span class="n">running_index</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">sb_index_values</span><span class="p">)</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="n">status_blk</span><span class="p">.</span><span class="n">e1x_sb</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">.</span><span class="n">index_values</span><span class="p">;</span>
		<span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">sb_running_index</span><span class="p">)</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="n">status_blk</span><span class="p">.</span><span class="n">e1x_sb</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">.</span><span class="n">running_index</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Returns the number of actually allocated BDs */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bnx2x_alloc_rx_bds</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">rx_ring_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ring_prod</span><span class="p">,</span> <span class="n">cqe_ring_prod</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">failure_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_comp_cons</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cqe_ring_prod</span> <span class="o">=</span> <span class="n">ring_prod</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* This routine is called only during fo init so</span>
<span class="cm">	 * fp-&gt;eth_q_stats.rx_skb_alloc_failed = 0</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rx_ring_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bnx2x_alloc_rx_data</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">ring_prod</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">failure_cnt</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ring_prod</span> <span class="o">=</span> <span class="n">NEXT_RX_IDX</span><span class="p">(</span><span class="n">ring_prod</span><span class="p">);</span>
		<span class="n">cqe_ring_prod</span> <span class="o">=</span> <span class="n">NEXT_RCQ_IDX</span><span class="p">(</span><span class="n">cqe_ring_prod</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ring_prod</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">failure_cnt</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">failure_cnt</span><span class="p">)</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;was only able to allocate %d rx skbs on queue[%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">i</span> <span class="o">-</span> <span class="n">failure_cnt</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>

	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_bd_prod</span> <span class="o">=</span> <span class="n">ring_prod</span><span class="p">;</span>
	<span class="cm">/* Limit the CQE producer by the CQE ring size */</span>
	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_comp_prod</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u16</span><span class="p">,</span> <span class="n">NUM_RCQ_RINGS</span><span class="o">*</span><span class="n">RCQ_DESC_CNT</span><span class="p">,</span>
			       <span class="n">cqe_ring_prod</span><span class="p">);</span>
	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_pkt</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_calls</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">eth_q_stats</span><span class="p">.</span><span class="n">rx_skb_alloc_failed</span> <span class="o">+=</span> <span class="n">failure_cnt</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="n">failure_cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bnx2x_set_next_page_rx_cq</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">NUM_RCQ_RINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">eth_rx_cqe_next_page</span> <span class="o">*</span><span class="n">nextpg</span><span class="p">;</span>

		<span class="n">nextpg</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">eth_rx_cqe_next_page</span> <span class="o">*</span><span class="p">)</span>
			<span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_comp_ring</span><span class="p">[</span><span class="n">RCQ_DESC_CNT</span> <span class="o">*</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
		<span class="n">nextpg</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span>
			<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">U64_HI</span><span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_comp_mapping</span> <span class="o">+</span>
				   <span class="n">BCM_PAGE_SIZE</span><span class="o">*</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">NUM_RCQ_RINGS</span><span class="p">)));</span>
		<span class="n">nextpg</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span>
			<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">U64_LO</span><span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rx_comp_mapping</span> <span class="o">+</span>
				   <span class="n">BCM_PAGE_SIZE</span><span class="o">*</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">NUM_RCQ_RINGS</span><span class="p">)));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bnx2x_alloc_fp_mem_at</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">host_hc_status_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ring_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cos</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rx_ring_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef BCM_CNIC</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">IS_MF_STORAGE_SD</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">||</span> <span class="n">IS_MF_FCOE_AFEX</span><span class="p">(</span><span class="n">bp</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">rx_ring_size</span> <span class="o">=</span> <span class="n">MIN_RX_SIZE_NONTPA</span><span class="p">;</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span> <span class="o">=</span> <span class="n">rx_ring_size</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">cfg</span> <span class="o">=</span> <span class="n">SHMEM_RD</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span>
			     <span class="n">dev_info</span><span class="p">.</span><span class="n">port_hw_config</span><span class="p">[</span><span class="n">BP_PORT</span><span class="p">(</span><span class="n">bp</span><span class="p">)].</span><span class="n">default_cfg</span><span class="p">);</span>

		<span class="n">rx_ring_size</span> <span class="o">=</span> <span class="n">MAX_RX_AVAIL</span><span class="o">/</span><span class="n">BNX2X_NUM_RX_QUEUES</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

		<span class="cm">/* Dercease ring size for 1G functions */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cfg</span> <span class="o">&amp;</span> <span class="n">PORT_HW_CFG_NET_SERDES_IF_MASK</span><span class="p">)</span> <span class="o">==</span>
		    <span class="n">PORT_HW_CFG_NET_SERDES_IF_SGMII</span><span class="p">)</span>
			<span class="n">rx_ring_size</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>

		<span class="cm">/* allocate at least number of buffers required by FW */</span>
		<span class="n">rx_ring_size</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">disable_tpa</span> <span class="o">?</span> <span class="n">MIN_RX_SIZE_NONTPA</span> <span class="o">:</span>
				     <span class="n">MIN_RX_SIZE_TPA</span><span class="p">,</span> <span class="n">rx_ring_size</span><span class="p">);</span>

		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span> <span class="o">=</span> <span class="n">rx_ring_size</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="cm">/* if rx_ring_size specified - use it */</span>
		<span class="n">rx_ring_size</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">;</span>

	<span class="cm">/* Common */</span>
	<span class="n">sb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">status_blk</span><span class="p">);</span>
<span class="cp">#ifdef BCM_CNIC</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_FCOE_IDX</span><span class="p">(</span><span class="n">index</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#endif</span>
		<span class="cm">/* status blocks */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CHIP_IS_E1x</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span>
			<span class="n">BNX2X_PCI_ALLOC</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">e2_sb</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">status_blk_mapping</span><span class="p">),</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">host_hc_status_block_e2</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">BNX2X_PCI_ALLOC</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">e1x_sb</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">status_blk_mapping</span><span class="p">),</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">host_hc_status_block_e1x</span><span class="p">));</span>
<span class="cp">#ifdef BCM_CNIC</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* FCoE Queue uses Default SB and doesn&#39;t ACK the SB, thus no need to</span>
<span class="cm">	 * set shortcuts for it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_FCOE_IDX</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
		<span class="n">set_sb_shortcuts</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

	<span class="cm">/* Tx */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skip_tx_queue</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* fastpath tx rings: tx_buf tx_desc */</span>
		<span class="n">for_each_cos_in_tx_queue</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">cos</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">bnx2x_fp_txdata</span> <span class="o">*</span><span class="n">txdata</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">txdata</span><span class="p">[</span><span class="n">cos</span><span class="p">];</span>

			<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_IFUP</span><span class="p">,</span>
			   <span class="s">&quot;allocating tx memory of fp %d cos %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">index</span><span class="p">,</span> <span class="n">cos</span><span class="p">);</span>

			<span class="n">BNX2X_ALLOC</span><span class="p">(</span><span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_buf_ring</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sw_tx_bd</span><span class="p">)</span> <span class="o">*</span> <span class="n">NUM_TX_BD</span><span class="p">);</span>
			<span class="n">BNX2X_PCI_ALLOC</span><span class="p">(</span><span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_desc_ring</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">txdata</span><span class="o">-&gt;</span><span class="n">tx_desc_mapping</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">eth_tx_bd_types</span><span class="p">)</span> <span class="o">*</span> <span class="n">NUM_TX_BD</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Rx */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skip_rx_queue</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* fastpath rx rings: rx_buf rx_desc rx_comp */</span>
		<span class="n">BNX2X_ALLOC</span><span class="p">(</span><span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">rx_buf_ring</span><span class="p">),</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sw_rx_bd</span><span class="p">)</span> <span class="o">*</span> <span class="n">NUM_RX_BD</span><span class="p">);</span>
		<span class="n">BNX2X_PCI_ALLOC</span><span class="p">(</span><span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">rx_desc_ring</span><span class="p">),</span>
				<span class="o">&amp;</span><span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">rx_desc_mapping</span><span class="p">),</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">eth_rx_bd</span><span class="p">)</span> <span class="o">*</span> <span class="n">NUM_RX_BD</span><span class="p">);</span>

		<span class="n">BNX2X_PCI_ALLOC</span><span class="p">(</span><span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">rx_comp_ring</span><span class="p">),</span>
				<span class="o">&amp;</span><span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">rx_comp_mapping</span><span class="p">),</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">eth_fast_path_rx_cqe</span><span class="p">)</span> <span class="o">*</span>
				<span class="n">NUM_RCQ_BD</span><span class="p">);</span>

		<span class="cm">/* SGE ring */</span>
		<span class="n">BNX2X_ALLOC</span><span class="p">(</span><span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">rx_page_ring</span><span class="p">),</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sw_rx_page</span><span class="p">)</span> <span class="o">*</span> <span class="n">NUM_RX_SGE</span><span class="p">);</span>
		<span class="n">BNX2X_PCI_ALLOC</span><span class="p">(</span><span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">rx_sge_ring</span><span class="p">),</span>
				<span class="o">&amp;</span><span class="n">bnx2x_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">rx_sge_mapping</span><span class="p">),</span>
				<span class="n">BCM_PAGE_SIZE</span> <span class="o">*</span> <span class="n">NUM_RX_SGE_PAGES</span><span class="p">);</span>
		<span class="cm">/* RX BD ring */</span>
		<span class="n">bnx2x_set_next_page_rx_bd</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

		<span class="cm">/* CQ ring */</span>
		<span class="n">bnx2x_set_next_page_rx_cq</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

		<span class="cm">/* BDs */</span>
		<span class="n">ring_size</span> <span class="o">=</span> <span class="n">bnx2x_alloc_rx_bds</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">rx_ring_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ring_size</span> <span class="o">&lt;</span> <span class="n">rx_ring_size</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">alloc_mem_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/* handles low memory cases */</span>
<span class="nl">alloc_mem_err:</span>
	<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;Unable to allocate full memory for queue %d (size %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">index</span><span class="p">,</span> <span class="n">ring_size</span><span class="p">);</span>
	<span class="cm">/* FW will drop all packets if queue is not big enough,</span>
<span class="cm">	 * In these cases we disable the queue</span>
<span class="cm">	 * Min size is different for OOO, TPA and non-TPA queues</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ring_size</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">disable_tpa</span> <span class="o">?</span>
				<span class="n">MIN_RX_SIZE_NONTPA</span> <span class="o">:</span> <span class="n">MIN_RX_SIZE_TPA</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* release memory allocated for this queue */</span>
			<span class="n">bnx2x_free_fp_mem_at</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bnx2x_alloc_fp_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * 1. Allocate FP for leading - fatal if error</span>
<span class="cm">	 * 2. {CNIC} Allocate FCoE FP - fatal if error</span>
<span class="cm">	 * 3. {CNIC} Allocate OOO + FWD - disable OOO if error</span>
<span class="cm">	 * 4. Allocate RSS - fix number of queues if error</span>
<span class="cm">	 */</span>

	<span class="cm">/* leading */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bnx2x_alloc_fp_mem_at</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

<span class="cp">#ifdef BCM_CNIC</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NO_FCOE</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span>
		<span class="cm">/* FCoE */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bnx2x_alloc_fp_mem_at</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">FCOE_IDX</span><span class="p">))</span>
			<span class="cm">/* we will fail load process instead of mark</span>
<span class="cm">			 * NO_FCOE_FLAG</span>
<span class="cm">			 */</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* RSS */</span>
	<span class="n">for_each_nondefault_eth_queue</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bnx2x_alloc_fp_mem_at</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* handle memory failures */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">BNX2X_NUM_ETH_QUEUES</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">BNX2X_NUM_ETH_QUEUES</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#ifdef BCM_CNIC</span>
		<span class="cm">/**</span>
<span class="cm">		 * move non eth FPs next to last eth FP</span>
<span class="cm">		 * must be done in that order</span>
<span class="cm">		 * FCOE_IDX &lt; FWD_IDX &lt; OOO_IDX</span>
<span class="cm">		 */</span>

		<span class="cm">/* move FCoE fp even NO_FCOE_FLAG is on */</span>
		<span class="n">bnx2x_move_fp</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">FCOE_IDX</span><span class="p">,</span> <span class="n">FCOE_IDX</span> <span class="o">-</span> <span class="n">delta</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">num_queues</span> <span class="o">-=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;Adjusted num of queues from %d to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">bp</span><span class="o">-&gt;</span><span class="n">num_queues</span> <span class="o">+</span> <span class="n">delta</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">num_queues</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bnx2x_free_mem_bp</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">msix_table</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">ilt</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">bnx2x_alloc_mem_bp</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2x_fastpath</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msix_entry</span> <span class="o">*</span><span class="n">tbl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bnx2x_ilt</span> <span class="o">*</span><span class="n">ilt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">msix_table_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The biggest MSI-X table we might need is as a maximum number of fast</span>
<span class="cm">	 * path IGU SBs plus default SB (for PF).</span>
<span class="cm">	 */</span>
	<span class="n">msix_table_size</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">igu_sb_cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* fp array: RSS plus CNIC related L2 queues */</span>
	<span class="n">fp</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">BNX2X_MAX_RSS_COUNT</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">+</span> <span class="n">NON_ETH_CONTEXT_USE</span><span class="p">,</span>
		     <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">alloc_err</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>

	<span class="cm">/* msix table */</span>
	<span class="n">tbl</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">msix_table_size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tbl</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tbl</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">alloc_err</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">msix_table</span> <span class="o">=</span> <span class="n">tbl</span><span class="p">;</span>

	<span class="cm">/* ilt */</span>
	<span class="n">ilt</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ilt</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ilt</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">alloc_err</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">ilt</span> <span class="o">=</span> <span class="n">ilt</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">alloc_err:</span>
	<span class="n">bnx2x_free_mem_bp</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bnx2x_reload_if_running</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bnx2x_nic_unload</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">UNLOAD_NORMAL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bnx2x_nic_load</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">LOAD_NORMAL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bnx2x_get_cur_phy_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">sel_phy_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">link_params</span><span class="p">.</span><span class="n">num_phys</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">INT_PHY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">link_vars</span><span class="p">.</span><span class="n">link_up</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sel_phy_idx</span> <span class="o">=</span> <span class="n">EXT_PHY1</span><span class="p">;</span>
		<span class="cm">/* In case link is SERDES, check if the EXT_PHY2 is the one */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">link_vars</span><span class="p">.</span><span class="n">link_status</span> <span class="o">&amp;</span> <span class="n">LINK_STATUS_SERDES_LINK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">link_params</span><span class="p">.</span><span class="n">phy</span><span class="p">[</span><span class="n">EXT_PHY2</span><span class="p">].</span><span class="n">supported</span> <span class="o">&amp;</span> <span class="n">SUPPORTED_FIBRE</span><span class="p">))</span>
			<span class="n">sel_phy_idx</span> <span class="o">=</span> <span class="n">EXT_PHY2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">bnx2x_phy_selection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">link_params</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">PORT_HW_CFG_PHY_SELECTION_HARDWARE_DEFAULT</span>:
		<span class="k">case</span> <span class="n">PORT_HW_CFG_PHY_SELECTION_FIRST_PHY</span>:
		<span class="k">case</span> <span class="n">PORT_HW_CFG_PHY_SELECTION_FIRST_PHY_PRIORITY</span>:
		       <span class="n">sel_phy_idx</span> <span class="o">=</span> <span class="n">EXT_PHY1</span><span class="p">;</span>
		       <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">PORT_HW_CFG_PHY_SELECTION_SECOND_PHY</span>:
		<span class="k">case</span> <span class="n">PORT_HW_CFG_PHY_SELECTION_SECOND_PHY_PRIORITY</span>:
		       <span class="n">sel_phy_idx</span> <span class="o">=</span> <span class="n">EXT_PHY2</span><span class="p">;</span>
		       <span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sel_phy_idx</span><span class="p">;</span>

<span class="p">}</span>
<span class="kt">int</span> <span class="nf">bnx2x_get_link_cfg_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">sel_phy_idx</span> <span class="o">=</span> <span class="n">bnx2x_get_cur_phy_idx</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The selected actived PHY is always after swapping (in case PHY</span>
<span class="cm">	 * swapping is enabled). So when swapping is enabled, we need to reverse</span>
<span class="cm">	 * the configuration</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">link_params</span><span class="p">.</span><span class="n">multi_phy_config</span> <span class="o">&amp;</span>
	    <span class="n">PORT_HW_CFG_PHY_SWAPPED_ENABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sel_phy_idx</span> <span class="o">==</span> <span class="n">EXT_PHY1</span><span class="p">)</span>
			<span class="n">sel_phy_idx</span> <span class="o">=</span> <span class="n">EXT_PHY2</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sel_phy_idx</span> <span class="o">==</span> <span class="n">EXT_PHY2</span><span class="p">)</span>
			<span class="n">sel_phy_idx</span> <span class="o">=</span> <span class="n">EXT_PHY1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">LINK_CONFIG_IDX</span><span class="p">(</span><span class="n">sel_phy_idx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if defined(NETDEV_FCOE_WWNN) &amp;&amp; defined(BCM_CNIC)</span>
<span class="kt">int</span> <span class="nf">bnx2x_fcoe_get_wwn</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">wwn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cnic_eth_dev</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cnic_eth_dev</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NETDEV_FCOE_WWNN</span>:
		<span class="o">*</span><span class="n">wwn</span> <span class="o">=</span> <span class="n">HILO_U64</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">fcoe_wwn_node_name_hi</span><span class="p">,</span>
				<span class="n">cp</span><span class="o">-&gt;</span><span class="n">fcoe_wwn_node_name_lo</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NETDEV_FCOE_WWPN</span>:
		<span class="o">*</span><span class="n">wwn</span> <span class="o">=</span> <span class="n">HILO_U64</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">fcoe_wwn_port_name_hi</span><span class="p">,</span>
				<span class="n">cp</span><span class="o">-&gt;</span><span class="n">fcoe_wwn_port_name_lo</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;Wrong WWN type requested - %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* called with rtnl_lock */</span>
<span class="kt">int</span> <span class="nf">bnx2x_change_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">recovery_state</span> <span class="o">!=</span> <span class="n">BNX2X_RECOVERY_DONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;Can&#39;t perform change MTU during parity recovery</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">new_mtu</span> <span class="o">&gt;</span> <span class="n">ETH_MAX_JUMBO_PACKET_SIZE</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">new_mtu</span> <span class="o">+</span> <span class="n">ETH_HLEN</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ETH_MIN_PACKET_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;Can&#39;t support requested MTU size</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* This does not race with packet allocation</span>
<span class="cm">	 * because the actual alloc size is</span>
<span class="cm">	 * only updated as part of load</span>
<span class="cm">	 */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">new_mtu</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">bnx2x_reload_if_running</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">netdev_features_t</span> <span class="nf">bnx2x_fix_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				     <span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* TPA requires Rx CSUM offloading */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXCSUM</span><span class="p">)</span> <span class="o">||</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">disable_tpa</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NETIF_F_LRO</span><span class="p">;</span>
		<span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NETIF_F_GRO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">features</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bnx2x_set_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">bnx2x_reload</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_LRO</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">TPA_ENABLE_FLAG</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TPA_ENABLE_FLAG</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_GRO</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">GRO_ENABLE_FLAG</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">GRO_ENABLE_FLAG</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_LOOPBACK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">link_params</span><span class="p">.</span><span class="n">loopback_mode</span> <span class="o">!=</span> <span class="n">LOOPBACK_BMAC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">link_params</span><span class="p">.</span><span class="n">loopback_mode</span> <span class="o">=</span> <span class="n">LOOPBACK_BMAC</span><span class="p">;</span>
			<span class="n">bnx2x_reload</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">link_params</span><span class="p">.</span><span class="n">loopback_mode</span> <span class="o">!=</span> <span class="n">LOOPBACK_NONE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">link_params</span><span class="p">.</span><span class="n">loopback_mode</span> <span class="o">=</span> <span class="n">LOOPBACK_NONE</span><span class="p">;</span>
			<span class="n">bnx2x_reload</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">^</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
		<span class="n">bnx2x_reload</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bnx2x_reload</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">recovery_state</span> <span class="o">==</span> <span class="n">BNX2X_RECOVERY_DONE</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">bnx2x_reload_if_running</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="cm">/* else: bnx2x_nic_load() will be called at end of recovery */</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bnx2x_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

<span class="cp">#ifdef BNX2X_STOP_ON_ERROR</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">panic</span><span class="p">)</span>
		<span class="n">bnx2x_panic</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="n">smp_mb__before_clear_bit</span><span class="p">();</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">BNX2X_SP_RTNL_TX_TIMEOUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">sp_rtnl_state</span><span class="p">);</span>
	<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span>

	<span class="cm">/* This allows the netif to be shutdown gracefully before resetting */</span>
	<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">sp_rtnl_task</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bnx2x_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BAD net device from bnx2x_init_one</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">rtnl_lock</span><span class="p">();</span>

	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rtnl_unlock</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">netif_device_detach</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">bnx2x_nic_unload</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">UNLOAD_CLOSE</span><span class="p">);</span>

	<span class="n">bnx2x_set_power_state</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">pci_choose_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">state</span><span class="p">));</span>

	<span class="n">rtnl_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bnx2x_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BAD net device from bnx2x_init_one</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">recovery_state</span> <span class="o">!=</span> <span class="n">BNX2X_RECOVERY_DONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BNX2X_ERR</span><span class="p">(</span><span class="s">&quot;Handling parity error recovery. Try again later</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rtnl_lock</span><span class="p">();</span>

	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rtnl_unlock</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bnx2x_set_power_state</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">);</span>
	<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">bnx2x_nic_load</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">LOAD_OPEN</span><span class="p">);</span>

	<span class="n">rtnl_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">bnx2x_set_ctx_validation</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">eth_context</span> <span class="o">*</span><span class="n">cxt</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">cid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* ustorm cxt validation */</span>
	<span class="n">cxt</span><span class="o">-&gt;</span><span class="n">ustorm_ag_context</span><span class="p">.</span><span class="n">cdu_usage</span> <span class="o">=</span>
		<span class="n">CDU_RSRVD_VALUE_TYPE_A</span><span class="p">(</span><span class="n">HW_CID</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">cid</span><span class="p">),</span>
			<span class="n">CDU_REGION_NUMBER_UCM_AG</span><span class="p">,</span> <span class="n">ETH_CONNECTION_TYPE</span><span class="p">);</span>
	<span class="cm">/* xcontext validation */</span>
	<span class="n">cxt</span><span class="o">-&gt;</span><span class="n">xstorm_ag_context</span><span class="p">.</span><span class="n">cdu_reserved</span> <span class="o">=</span>
		<span class="n">CDU_RSRVD_VALUE_TYPE_A</span><span class="p">(</span><span class="n">HW_CID</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">cid</span><span class="p">),</span>
			<span class="n">CDU_REGION_NUMBER_XCM_AG</span><span class="p">,</span> <span class="n">ETH_CONNECTION_TYPE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">storm_memset_hc_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">u8</span> <span class="n">port</span><span class="p">,</span>
				    <span class="n">u8</span> <span class="n">fw_sb_id</span><span class="p">,</span> <span class="n">u8</span> <span class="n">sb_index</span><span class="p">,</span>
				    <span class="n">u8</span> <span class="n">ticks</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">u32</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">BAR_CSTRORM_INTMEM</span> <span class="o">+</span>
		   <span class="n">CSTORM_STATUS_BLOCK_DATA_TIMEOUT_OFFSET</span><span class="p">(</span><span class="n">fw_sb_id</span><span class="p">,</span> <span class="n">sb_index</span><span class="p">);</span>
	<span class="n">REG_WR8</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ticks</span><span class="p">);</span>
	<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_IFUP</span><span class="p">,</span>
	   <span class="s">&quot;port %x fw_sb_id %d sb_index %d ticks %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	   <span class="n">port</span><span class="p">,</span> <span class="n">fw_sb_id</span><span class="p">,</span> <span class="n">sb_index</span><span class="p">,</span> <span class="n">ticks</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">storm_memset_hc_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">u8</span> <span class="n">port</span><span class="p">,</span>
				    <span class="n">u16</span> <span class="n">fw_sb_id</span><span class="p">,</span> <span class="n">u8</span> <span class="n">sb_index</span><span class="p">,</span>
				    <span class="n">u8</span> <span class="n">disable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">enable_flag</span> <span class="o">=</span> <span class="n">disable</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">HC_INDEX_DATA_HC_ENABLED_SHIFT</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">BAR_CSTRORM_INTMEM</span> <span class="o">+</span>
		   <span class="n">CSTORM_STATUS_BLOCK_DATA_FLAGS_OFFSET</span><span class="p">(</span><span class="n">fw_sb_id</span><span class="p">,</span> <span class="n">sb_index</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">REG_RD16</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="cm">/* clear and set */</span>
	<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HC_INDEX_DATA_HC_ENABLED</span><span class="p">;</span>
	<span class="n">flags</span> <span class="o">|=</span> <span class="n">enable_flag</span><span class="p">;</span>
	<span class="n">REG_WR16</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">DP</span><span class="p">(</span><span class="n">NETIF_MSG_IFUP</span><span class="p">,</span>
	   <span class="s">&quot;port %x fw_sb_id %d sb_index %d disable %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	   <span class="n">port</span><span class="p">,</span> <span class="n">fw_sb_id</span><span class="p">,</span> <span class="n">sb_index</span><span class="p">,</span> <span class="n">disable</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bnx2x_update_coalesce_sb_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2x</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">u8</span> <span class="n">fw_sb_id</span><span class="p">,</span>
				    <span class="n">u8</span> <span class="n">sb_index</span><span class="p">,</span> <span class="n">u8</span> <span class="n">disable</span><span class="p">,</span> <span class="n">u16</span> <span class="n">usec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="n">BP_PORT</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">ticks</span> <span class="o">=</span> <span class="n">usec</span> <span class="o">/</span> <span class="n">BNX2X_BTR</span><span class="p">;</span>

	<span class="n">storm_memset_hc_timeout</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">fw_sb_id</span><span class="p">,</span> <span class="n">sb_index</span><span class="p">,</span> <span class="n">ticks</span><span class="p">);</span>

	<span class="n">disable</span> <span class="o">=</span> <span class="n">disable</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="p">(</span><span class="n">usec</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">storm_memset_hc_disable</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">fw_sb_id</span><span class="p">,</span> <span class="n">sb_index</span><span class="p">,</span> <span class="n">disable</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
