<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › broadcom › sb1250-mac.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>sb1250-mac.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2001,2002,2003,2004 Broadcom Corporation</span>
<span class="cm"> * Copyright (c) 2006, 2007  Maciej W. Rozycki</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version 2</span>
<span class="cm"> * of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * This driver is designed for the Broadcom SiByte SOC built-in</span>
<span class="cm"> * Ethernet controllers. Written by Mitch Lichtenberg at Broadcom Corp.</span>
<span class="cm"> *</span>
<span class="cm"> * Updated to the driver model and the PHY abstraction layer</span>
<span class="cm"> * by Maciej W. Rozycki.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/mii.h&gt;</span>
<span class="cp">#include &lt;linux/phy.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/prefetch.h&gt;</span>

<span class="cp">#include &lt;asm/cache.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;	</span><span class="cm">/* Processor type for cache alignment. */</span><span class="cp"></span>

<span class="cm">/* Operational parameters that usually are not changed. */</span>

<span class="cp">#define CONFIG_SBMAC_COALESCE</span>

<span class="cm">/* Time in jiffies before concluding the transmitter is hung. */</span>
<span class="cp">#define TX_TIMEOUT  (2*HZ)</span>


<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Mitch Lichtenberg (Broadcom Corp.)&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Broadcom SiByte SOC GB Ethernet driver&quot;</span><span class="p">);</span>

<span class="cm">/* A few user-configurable values which may be modified when a driver</span>
<span class="cm">   module is loaded. */</span>

<span class="cm">/* 1 normal messages, 0 quiet .. 7 verbose. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">debug</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="s">&quot;Debug messages&quot;</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SBMAC_COALESCE</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">int_pktcnt_tx</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">int_pktcnt_tx</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">int_pktcnt_tx</span><span class="p">,</span> <span class="s">&quot;TX packet count&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">int_timeout_tx</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">int_timeout_tx</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">int_timeout_tx</span><span class="p">,</span> <span class="s">&quot;TX timeout value&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">int_pktcnt_rx</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">int_pktcnt_rx</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">int_pktcnt_rx</span><span class="p">,</span> <span class="s">&quot;RX packet count&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">int_timeout_rx</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">int_timeout_rx</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">int_timeout_rx</span><span class="p">,</span> <span class="s">&quot;RX timeout value&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;asm/sibyte/board.h&gt;</span>
<span class="cp">#include &lt;asm/sibyte/sb1250.h&gt;</span>
<span class="cp">#if defined(CONFIG_SIBYTE_BCM1x55) || defined(CONFIG_SIBYTE_BCM1x80)</span>
<span class="cp">#include &lt;asm/sibyte/bcm1480_regs.h&gt;</span>
<span class="cp">#include &lt;asm/sibyte/bcm1480_int.h&gt;</span>
<span class="cp">#define R_MAC_DMA_OODPKTLOST_RX	R_MAC_DMA_OODPKTLOST</span>
<span class="cp">#elif defined(CONFIG_SIBYTE_SB1250) || defined(CONFIG_SIBYTE_BCM112X)</span>
<span class="cp">#include &lt;asm/sibyte/sb1250_regs.h&gt;</span>
<span class="cp">#include &lt;asm/sibyte/sb1250_int.h&gt;</span>
<span class="cp">#else</span>
<span class="cp">#error invalid SiByte MAC configuration</span>
<span class="cp">#endif</span>
<span class="cp">#include &lt;asm/sibyte/sb1250_scd.h&gt;</span>
<span class="cp">#include &lt;asm/sibyte/sb1250_mac.h&gt;</span>
<span class="cp">#include &lt;asm/sibyte/sb1250_dma.h&gt;</span>

<span class="cp">#if defined(CONFIG_SIBYTE_BCM1x55) || defined(CONFIG_SIBYTE_BCM1x80)</span>
<span class="cp">#define UNIT_INT(n)		(K_BCM1480_INT_MAC_0 + ((n) * 2))</span>
<span class="cp">#elif defined(CONFIG_SIBYTE_SB1250) || defined(CONFIG_SIBYTE_BCM112X)</span>
<span class="cp">#define UNIT_INT(n)		(K_INT_MAC_0 + (n))</span>
<span class="cp">#else</span>
<span class="cp">#error invalid SiByte MAC configuration</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef K_INT_PHY</span>
<span class="cp">#define SBMAC_PHY_INT			K_INT_PHY</span>
<span class="cp">#else</span>
<span class="cp">#define SBMAC_PHY_INT			PHY_POLL</span>
<span class="cp">#endif</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> *  Simple types</span>
<span class="cm"> ********************************************************************* */</span>

<span class="k">enum</span> <span class="n">sbmac_speed</span> <span class="p">{</span>
	<span class="n">sbmac_speed_none</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">sbmac_speed_10</span> <span class="o">=</span> <span class="n">SPEED_10</span><span class="p">,</span>
	<span class="n">sbmac_speed_100</span> <span class="o">=</span> <span class="n">SPEED_100</span><span class="p">,</span>
	<span class="n">sbmac_speed_1000</span> <span class="o">=</span> <span class="n">SPEED_1000</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">sbmac_duplex</span> <span class="p">{</span>
	<span class="n">sbmac_duplex_none</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
	<span class="n">sbmac_duplex_half</span> <span class="o">=</span> <span class="n">DUPLEX_HALF</span><span class="p">,</span>
	<span class="n">sbmac_duplex_full</span> <span class="o">=</span> <span class="n">DUPLEX_FULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">sbmac_fc</span> <span class="p">{</span>
	<span class="n">sbmac_fc_none</span><span class="p">,</span>
	<span class="n">sbmac_fc_disabled</span><span class="p">,</span>
	<span class="n">sbmac_fc_frame</span><span class="p">,</span>
	<span class="n">sbmac_fc_collision</span><span class="p">,</span>
	<span class="n">sbmac_fc_carrier</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">sbmac_state</span> <span class="p">{</span>
	<span class="n">sbmac_state_uninit</span><span class="p">,</span>
	<span class="n">sbmac_state_off</span><span class="p">,</span>
	<span class="n">sbmac_state_on</span><span class="p">,</span>
	<span class="n">sbmac_state_broken</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/**********************************************************************</span>
<span class="cm"> *  Macros</span>
<span class="cm"> ********************************************************************* */</span>


<span class="cp">#define SBDMA_NEXTBUF(d,f) ((((d)-&gt;f+1) == (d)-&gt;sbdma_dscrtable_end) ? \</span>
<span class="cp">			  (d)-&gt;sbdma_dscrtable : (d)-&gt;f+1)</span>


<span class="cp">#define NUMCACHEBLKS(x) (((x)+SMP_CACHE_BYTES-1)/SMP_CACHE_BYTES)</span>

<span class="cp">#define SBMAC_MAX_TXDESCR	256</span>
<span class="cp">#define SBMAC_MAX_RXDESCR	256</span>

<span class="cp">#define ENET_PACKET_SIZE	1518</span>
<span class="cm">/*#define ENET_PACKET_SIZE	9216 */</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> *  DMA Descriptor structure</span>
<span class="cm"> ********************************************************************* */</span>

<span class="k">struct</span> <span class="n">sbdmadscr</span> <span class="p">{</span>
	<span class="kt">uint64_t</span>  <span class="n">dscr_a</span><span class="p">;</span>
	<span class="kt">uint64_t</span>  <span class="n">dscr_b</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> *  DMA Controller structure</span>
<span class="cm"> ********************************************************************* */</span>

<span class="k">struct</span> <span class="n">sbmacdma</span> <span class="p">{</span>

	<span class="cm">/*</span>
<span class="cm">	 * This stuff is used to identify the channel and the registers</span>
<span class="cm">	 * associated with it.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">sbmac_softc</span>	<span class="o">*</span><span class="n">sbdma_eth</span><span class="p">;</span>	<span class="cm">/* back pointer to associated</span>
<span class="cm">						   MAC */</span>
	<span class="kt">int</span>			<span class="n">sbdma_channel</span><span class="p">;</span>	<span class="cm">/* channel number */</span>
	<span class="kt">int</span>			<span class="n">sbdma_txdir</span><span class="p">;</span>	<span class="cm">/* direction (1=transmit) */</span>
	<span class="kt">int</span>			<span class="n">sbdma_maxdescr</span><span class="p">;</span>	<span class="cm">/* total # of descriptors</span>
<span class="cm">						   in ring */</span>
<span class="cp">#ifdef CONFIG_SBMAC_COALESCE</span>
	<span class="kt">int</span>			<span class="n">sbdma_int_pktcnt</span><span class="p">;</span>
						<span class="cm">/* # descriptors rx/tx</span>
<span class="cm">						   before interrupt */</span>
	<span class="kt">int</span>			<span class="n">sbdma_int_timeout</span><span class="p">;</span>
						<span class="cm">/* # usec rx/tx interrupt */</span>
<span class="cp">#endif</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">sbdma_config0</span><span class="p">;</span>	<span class="cm">/* DMA config register 0 */</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">sbdma_config1</span><span class="p">;</span>	<span class="cm">/* DMA config register 1 */</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">sbdma_dscrbase</span><span class="p">;</span>
						<span class="cm">/* descriptor base address */</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">sbdma_dscrcnt</span><span class="p">;</span>	<span class="cm">/* descriptor count register */</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">sbdma_curdscr</span><span class="p">;</span>	<span class="cm">/* current descriptor</span>
<span class="cm">						   address */</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">sbdma_oodpktlost</span><span class="p">;</span>
						<span class="cm">/* pkt drop (rx only) */</span>

	<span class="cm">/*</span>
<span class="cm">	 * This stuff is for maintenance of the ring</span>
<span class="cm">	 */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">sbdma_dscrtable_unaligned</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sbdmadscr</span>	<span class="o">*</span><span class="n">sbdma_dscrtable</span><span class="p">;</span>
						<span class="cm">/* base of descriptor table */</span>
	<span class="k">struct</span> <span class="n">sbdmadscr</span>	<span class="o">*</span><span class="n">sbdma_dscrtable_end</span><span class="p">;</span>
						<span class="cm">/* end of descriptor table */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>		<span class="o">**</span><span class="n">sbdma_ctxtable</span><span class="p">;</span>
						<span class="cm">/* context table, one</span>
<span class="cm">						   per descr */</span>
	<span class="n">dma_addr_t</span>		<span class="n">sbdma_dscrtable_phys</span><span class="p">;</span>
						<span class="cm">/* and also the phys addr */</span>
	<span class="k">struct</span> <span class="n">sbdmadscr</span>	<span class="o">*</span><span class="n">sbdma_addptr</span><span class="p">;</span>	<span class="cm">/* next dscr for sw to add */</span>
	<span class="k">struct</span> <span class="n">sbdmadscr</span>	<span class="o">*</span><span class="n">sbdma_remptr</span><span class="p">;</span>	<span class="cm">/* next dscr for sw</span>
<span class="cm">						   to remove */</span>
<span class="p">};</span>


<span class="cm">/**********************************************************************</span>
<span class="cm"> *  Ethernet softc structure</span>
<span class="cm"> ********************************************************************* */</span>

<span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="p">{</span>

	<span class="cm">/*</span>
<span class="cm">	 * Linux-specific things</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">net_device</span>	<span class="o">*</span><span class="n">sbm_dev</span><span class="p">;</span>	<span class="cm">/* pointer to linux device */</span>
	<span class="k">struct</span> <span class="n">napi_struct</span>	<span class="n">napi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">phy_device</span>	<span class="o">*</span><span class="n">phy_dev</span><span class="p">;</span>	<span class="cm">/* the associated PHY device */</span>
	<span class="k">struct</span> <span class="n">mii_bus</span>		<span class="o">*</span><span class="n">mii_bus</span><span class="p">;</span>	<span class="cm">/* the MII bus */</span>
	<span class="kt">int</span>			<span class="n">phy_irq</span><span class="p">[</span><span class="n">PHY_MAX_ADDR</span><span class="p">];</span>
	<span class="n">spinlock_t</span>		<span class="n">sbm_lock</span><span class="p">;</span>	<span class="cm">/* spin lock */</span>
	<span class="kt">int</span>			<span class="n">sbm_devflags</span><span class="p">;</span>	<span class="cm">/* current device flags */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Controller-specific things</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">sbm_base</span><span class="p">;</span>	<span class="cm">/* MAC&#39;s base address */</span>
	<span class="k">enum</span> <span class="n">sbmac_state</span>	<span class="n">sbm_state</span><span class="p">;</span>	<span class="cm">/* current state */</span>

	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">sbm_macenable</span><span class="p">;</span>	<span class="cm">/* MAC Enable Register */</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">sbm_maccfg</span><span class="p">;</span>	<span class="cm">/* MAC Config Register */</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">sbm_fifocfg</span><span class="p">;</span>	<span class="cm">/* FIFO Config Register */</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">sbm_framecfg</span><span class="p">;</span>	<span class="cm">/* Frame Config Register */</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">sbm_rxfilter</span><span class="p">;</span>	<span class="cm">/* Receive Filter Register */</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">sbm_isr</span><span class="p">;</span>	<span class="cm">/* Interrupt Status Register */</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">sbm_imr</span><span class="p">;</span>	<span class="cm">/* Interrupt Mask Register */</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">sbm_mdio</span><span class="p">;</span>	<span class="cm">/* MDIO Register */</span>

	<span class="k">enum</span> <span class="n">sbmac_speed</span>	<span class="n">sbm_speed</span><span class="p">;</span>	<span class="cm">/* current speed */</span>
	<span class="k">enum</span> <span class="n">sbmac_duplex</span>	<span class="n">sbm_duplex</span><span class="p">;</span>	<span class="cm">/* current duplex */</span>
	<span class="k">enum</span> <span class="n">sbmac_fc</span>		<span class="n">sbm_fc</span><span class="p">;</span>		<span class="cm">/* cur. flow control setting */</span>
	<span class="kt">int</span>			<span class="n">sbm_pause</span><span class="p">;</span>	<span class="cm">/* current pause setting */</span>
	<span class="kt">int</span>			<span class="n">sbm_link</span><span class="p">;</span>	<span class="cm">/* current link state */</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">sbm_hwaddr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">sbmacdma</span>		<span class="n">sbm_txdma</span><span class="p">;</span>	<span class="cm">/* only channel 0 for now */</span>
	<span class="k">struct</span> <span class="n">sbmacdma</span>		<span class="n">sbm_rxdma</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rx_hw_checksum</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sbe_idx</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/**********************************************************************</span>
<span class="cm"> *  Externs</span>
<span class="cm"> ********************************************************************* */</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> *  Prototypes</span>
<span class="cm"> ********************************************************************* */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">sbdma_initctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmacdma</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chan</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">txrx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxdescr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sbdma_channel_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmacdma</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rxtx</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sbdma_add_rcvbuffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sbmacdma</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">m</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sbdma_add_txbuffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmacdma</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">m</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sbdma_emptyring</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmacdma</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sbdma_fillring</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sbmacdma</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sbdma_rx_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sbmacdma</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">work_to_do</span><span class="p">,</span> <span class="kt">int</span> <span class="n">poll</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sbdma_tx_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sbmacdma</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">poll</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sbmac_initctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sbmac_channel_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sbmac_channel_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">sbmac_state</span> <span class="n">sbmac_set_channel_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="p">,</span>
						<span class="k">enum</span> <span class="n">sbmac_state</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sbmac_promiscuous_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">onoff</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">uint64_t</span> <span class="n">sbmac_addr2reg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">sbmac_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_instance</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sbmac_start_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sbmac_setmulti</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sbmac_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pldev</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">base</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sbmac_set_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">enum</span> <span class="n">sbmac_speed</span> <span class="n">speed</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sbmac_set_duplex</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">enum</span> <span class="n">sbmac_duplex</span> <span class="n">duplex</span><span class="p">,</span>
			    <span class="k">enum</span> <span class="n">sbmac_fc</span> <span class="n">fc</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sbmac_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sbmac_tx_timeout</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sbmac_set_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sbmac_mii_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sbmac_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sbmac_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">sbmac_mii_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sbmac_mii_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">sbmac_mii_sync</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">sbm_mdio</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sbmac_mii_senddata</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">sbm_mdio</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">bitcnt</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sbmac_mii_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phyaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">regidx</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sbmac_mii_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phyaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">regidx</span><span class="p">,</span>
			   <span class="n">u16</span> <span class="n">val</span><span class="p">);</span>


<span class="cm">/**********************************************************************</span>
<span class="cm"> *  Globals</span>
<span class="cm"> ********************************************************************* */</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">sbmac_string</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;sb1250-mac&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">sbmac_mdio_string</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;sb1250-mac-mdio&quot;</span><span class="p">;</span>


<span class="cm">/**********************************************************************</span>
<span class="cm"> *  MDIO constants</span>
<span class="cm"> ********************************************************************* */</span>

<span class="cp">#define	MII_COMMAND_START	0x01</span>
<span class="cp">#define	MII_COMMAND_READ	0x02</span>
<span class="cp">#define	MII_COMMAND_WRITE	0x01</span>
<span class="cp">#define	MII_COMMAND_ACK		0x02</span>

<span class="cp">#define M_MAC_MDIO_DIR_OUTPUT	0		</span><span class="cm">/* for clarity */</span><span class="cp"></span>

<span class="cp">#define ENABLE 		1</span>
<span class="cp">#define DISABLE		0</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> *  SBMAC_MII_SYNC(sbm_mdio)</span>
<span class="cm"> *</span>
<span class="cm"> *  Synchronize with the MII - send a pattern of bits to the MII</span>
<span class="cm"> *  that will guarantee that it is ready to accept a command.</span>
<span class="cm"> *</span>
<span class="cm"> *  Input parameters:</span>
<span class="cm"> *  	   sbm_mdio - address of the MAC&#39;s MDIO register</span>
<span class="cm"> *</span>
<span class="cm"> *  Return value:</span>
<span class="cm"> *  	   nothing</span>
<span class="cm"> ********************************************************************* */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sbmac_mii_sync</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">sbm_mdio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mac_mdio_genc</span><span class="p">;</span>

	<span class="n">mac_mdio_genc</span> <span class="o">=</span> <span class="n">__raw_readq</span><span class="p">(</span><span class="n">sbm_mdio</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">M_MAC_GENC</span><span class="p">;</span>

	<span class="n">bits</span> <span class="o">=</span> <span class="n">M_MAC_MDIO_DIR_OUTPUT</span> <span class="o">|</span> <span class="n">M_MAC_MDIO_OUT</span><span class="p">;</span>

	<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">bits</span> <span class="o">|</span> <span class="n">mac_mdio_genc</span><span class="p">,</span> <span class="n">sbm_mdio</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">bits</span> <span class="o">|</span> <span class="n">M_MAC_MDC</span> <span class="o">|</span> <span class="n">mac_mdio_genc</span><span class="p">,</span> <span class="n">sbm_mdio</span><span class="p">);</span>
		<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">bits</span> <span class="o">|</span> <span class="n">mac_mdio_genc</span><span class="p">,</span> <span class="n">sbm_mdio</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> *  SBMAC_MII_SENDDATA(sbm_mdio, data, bitcnt)</span>
<span class="cm"> *</span>
<span class="cm"> *  Send some bits to the MII.  The bits to be sent are right-</span>
<span class="cm"> *  justified in the &#39;data&#39; parameter.</span>
<span class="cm"> *</span>
<span class="cm"> *  Input parameters:</span>
<span class="cm"> *  	   sbm_mdio - address of the MAC&#39;s MDIO register</span>
<span class="cm"> *  	   data     - data to send</span>
<span class="cm"> *  	   bitcnt   - number of bits to send</span>
<span class="cm"> ********************************************************************* */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sbmac_mii_senddata</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">sbm_mdio</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">bitcnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">bits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">curmask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mac_mdio_genc</span><span class="p">;</span>

	<span class="n">mac_mdio_genc</span> <span class="o">=</span> <span class="n">__raw_readq</span><span class="p">(</span><span class="n">sbm_mdio</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">M_MAC_GENC</span><span class="p">;</span>

	<span class="n">bits</span> <span class="o">=</span> <span class="n">M_MAC_MDIO_DIR_OUTPUT</span><span class="p">;</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">bits</span> <span class="o">|</span> <span class="n">mac_mdio_genc</span><span class="p">,</span> <span class="n">sbm_mdio</span><span class="p">);</span>

	<span class="n">curmask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">bitcnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bitcnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">curmask</span><span class="p">)</span>
			<span class="n">bits</span> <span class="o">|=</span> <span class="n">M_MAC_MDIO_OUT</span><span class="p">;</span>
		<span class="k">else</span> <span class="n">bits</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">M_MAC_MDIO_OUT</span><span class="p">;</span>
		<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">bits</span> <span class="o">|</span> <span class="n">mac_mdio_genc</span><span class="p">,</span> <span class="n">sbm_mdio</span><span class="p">);</span>
		<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">bits</span> <span class="o">|</span> <span class="n">M_MAC_MDC</span> <span class="o">|</span> <span class="n">mac_mdio_genc</span><span class="p">,</span> <span class="n">sbm_mdio</span><span class="p">);</span>
		<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">bits</span> <span class="o">|</span> <span class="n">mac_mdio_genc</span><span class="p">,</span> <span class="n">sbm_mdio</span><span class="p">);</span>
		<span class="n">curmask</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>



<span class="cm">/**********************************************************************</span>
<span class="cm"> *  SBMAC_MII_READ(bus, phyaddr, regidx)</span>
<span class="cm"> *  Read a PHY register.</span>
<span class="cm"> *</span>
<span class="cm"> *  Input parameters:</span>
<span class="cm"> *  	   bus     - MDIO bus handle</span>
<span class="cm"> *  	   phyaddr - PHY&#39;s address</span>
<span class="cm"> *  	   regnum  - index of register to read</span>
<span class="cm"> *</span>
<span class="cm"> *  Return value:</span>
<span class="cm"> *  	   value read, or 0xffff if an error occurred.</span>
<span class="cm"> ********************************************************************* */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sbmac_mii_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phyaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">regidx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="p">)</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">sbm_mdio</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_mdio</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">regval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mac_mdio_genc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Synchronize ourselves so that the PHY knows the next</span>
<span class="cm">	 * thing coming down is a command</span>
<span class="cm">	 */</span>
	<span class="n">sbmac_mii_sync</span><span class="p">(</span><span class="n">sbm_mdio</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Send the data to the PHY.  The sequence is</span>
<span class="cm">	 * a &quot;start&quot; command (2 bits)</span>
<span class="cm">	 * a &quot;read&quot; command (2 bits)</span>
<span class="cm">	 * the PHY addr (5 bits)</span>
<span class="cm">	 * the register index (5 bits)</span>
<span class="cm">	 */</span>
	<span class="n">sbmac_mii_senddata</span><span class="p">(</span><span class="n">sbm_mdio</span><span class="p">,</span> <span class="n">MII_COMMAND_START</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">sbmac_mii_senddata</span><span class="p">(</span><span class="n">sbm_mdio</span><span class="p">,</span> <span class="n">MII_COMMAND_READ</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">sbmac_mii_senddata</span><span class="p">(</span><span class="n">sbm_mdio</span><span class="p">,</span> <span class="n">phyaddr</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
	<span class="n">sbmac_mii_senddata</span><span class="p">(</span><span class="n">sbm_mdio</span><span class="p">,</span> <span class="n">regidx</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

	<span class="n">mac_mdio_genc</span> <span class="o">=</span> <span class="n">__raw_readq</span><span class="p">(</span><span class="n">sbm_mdio</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">M_MAC_GENC</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Switch the port around without a clock transition.</span>
<span class="cm">	 */</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">M_MAC_MDIO_DIR_INPUT</span> <span class="o">|</span> <span class="n">mac_mdio_genc</span><span class="p">,</span> <span class="n">sbm_mdio</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Send out a clock pulse to signal we want the status</span>
<span class="cm">	 */</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">M_MAC_MDIO_DIR_INPUT</span> <span class="o">|</span> <span class="n">M_MAC_MDC</span> <span class="o">|</span> <span class="n">mac_mdio_genc</span><span class="p">,</span>
		     <span class="n">sbm_mdio</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">M_MAC_MDIO_DIR_INPUT</span> <span class="o">|</span> <span class="n">mac_mdio_genc</span><span class="p">,</span> <span class="n">sbm_mdio</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If an error occurred, the PHY will signal &#39;1&#39; back</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">__raw_readq</span><span class="p">(</span><span class="n">sbm_mdio</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">M_MAC_MDIO_IN</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Issue an &#39;idle&#39; clock pulse, but keep the direction</span>
<span class="cm">	 * the same.</span>
<span class="cm">	 */</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">M_MAC_MDIO_DIR_INPUT</span> <span class="o">|</span> <span class="n">M_MAC_MDC</span> <span class="o">|</span> <span class="n">mac_mdio_genc</span><span class="p">,</span>
		     <span class="n">sbm_mdio</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">M_MAC_MDIO_DIR_INPUT</span> <span class="o">|</span> <span class="n">mac_mdio_genc</span><span class="p">,</span> <span class="n">sbm_mdio</span><span class="p">);</span>

	<span class="n">regval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regval</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">__raw_readq</span><span class="p">(</span><span class="n">sbm_mdio</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">M_MAC_MDIO_IN</span><span class="p">)</span>
				<span class="n">regval</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">M_MAC_MDIO_DIR_INPUT</span> <span class="o">|</span> <span class="n">M_MAC_MDC</span> <span class="o">|</span> <span class="n">mac_mdio_genc</span><span class="p">,</span>
			     <span class="n">sbm_mdio</span><span class="p">);</span>
		<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">M_MAC_MDIO_DIR_INPUT</span> <span class="o">|</span> <span class="n">mac_mdio_genc</span><span class="p">,</span> <span class="n">sbm_mdio</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Switch back to output */</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">M_MAC_MDIO_DIR_OUTPUT</span> <span class="o">|</span> <span class="n">mac_mdio_genc</span><span class="p">,</span> <span class="n">sbm_mdio</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">regval</span><span class="p">;</span>
	<span class="k">return</span> <span class="mh">0xffff</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**********************************************************************</span>
<span class="cm"> *  SBMAC_MII_WRITE(bus, phyaddr, regidx, regval)</span>
<span class="cm"> *</span>
<span class="cm"> *  Write a value to a PHY register.</span>
<span class="cm"> *</span>
<span class="cm"> *  Input parameters:</span>
<span class="cm"> *  	   bus     - MDIO bus handle</span>
<span class="cm"> *  	   phyaddr - PHY to use</span>
<span class="cm"> *  	   regidx  - register within the PHY</span>
<span class="cm"> *  	   regval  - data to write to register</span>
<span class="cm"> *</span>
<span class="cm"> *  Return value:</span>
<span class="cm"> *  	   0 for success</span>
<span class="cm"> ********************************************************************* */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sbmac_mii_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phyaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">regidx</span><span class="p">,</span>
			   <span class="n">u16</span> <span class="n">regval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="p">)</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">sbm_mdio</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_mdio</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mac_mdio_genc</span><span class="p">;</span>

	<span class="n">sbmac_mii_sync</span><span class="p">(</span><span class="n">sbm_mdio</span><span class="p">);</span>

	<span class="n">sbmac_mii_senddata</span><span class="p">(</span><span class="n">sbm_mdio</span><span class="p">,</span> <span class="n">MII_COMMAND_START</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">sbmac_mii_senddata</span><span class="p">(</span><span class="n">sbm_mdio</span><span class="p">,</span> <span class="n">MII_COMMAND_WRITE</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">sbmac_mii_senddata</span><span class="p">(</span><span class="n">sbm_mdio</span><span class="p">,</span> <span class="n">phyaddr</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
	<span class="n">sbmac_mii_senddata</span><span class="p">(</span><span class="n">sbm_mdio</span><span class="p">,</span> <span class="n">regidx</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
	<span class="n">sbmac_mii_senddata</span><span class="p">(</span><span class="n">sbm_mdio</span><span class="p">,</span> <span class="n">MII_COMMAND_ACK</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">sbmac_mii_senddata</span><span class="p">(</span><span class="n">sbm_mdio</span><span class="p">,</span> <span class="n">regval</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>

	<span class="n">mac_mdio_genc</span> <span class="o">=</span> <span class="n">__raw_readq</span><span class="p">(</span><span class="n">sbm_mdio</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">M_MAC_GENC</span><span class="p">;</span>

	<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">M_MAC_MDIO_DIR_OUTPUT</span> <span class="o">|</span> <span class="n">mac_mdio_genc</span><span class="p">,</span> <span class="n">sbm_mdio</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/**********************************************************************</span>
<span class="cm"> *  SBDMA_INITCTX(d,s,chan,txrx,maxdescr)</span>
<span class="cm"> *</span>
<span class="cm"> *  Initialize a DMA channel context.  Since there are potentially</span>
<span class="cm"> *  eight DMA channels per MAC, it&#39;s nice to do this in a standard</span>
<span class="cm"> *  way.</span>
<span class="cm"> *</span>
<span class="cm"> *  Input parameters:</span>
<span class="cm"> *  	   d - struct sbmacdma (DMA channel context)</span>
<span class="cm"> *  	   s - struct sbmac_softc (pointer to a MAC)</span>
<span class="cm"> *  	   chan - channel number (0..1 right now)</span>
<span class="cm"> *  	   txrx - Identifies DMA_TX or DMA_RX for channel direction</span>
<span class="cm"> *      maxdescr - number of descriptors</span>
<span class="cm"> *</span>
<span class="cm"> *  Return value:</span>
<span class="cm"> *  	   nothing</span>
<span class="cm"> ********************************************************************* */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sbdma_initctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmacdma</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chan</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">txrx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxdescr</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SBMAC_COALESCE</span>
	<span class="kt">int</span> <span class="n">int_pktcnt</span><span class="p">,</span> <span class="n">int_timeout</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save away interesting stuff in the structure</span>
<span class="cm">	 */</span>

	<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_eth</span>       <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_channel</span>   <span class="o">=</span> <span class="n">chan</span><span class="p">;</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_txdir</span>     <span class="o">=</span> <span class="n">txrx</span><span class="p">;</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/* RMON clearing */</span>
<span class="c">	s-&gt;sbe_idx =(s-&gt;sbm_base - A_MAC_BASE_0)/MAC_SPACING;</span>
<span class="cp">#endif</span>

	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_RMON_TX_BYTES</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_RMON_COLLISIONS</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_RMON_LATE_COL</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_RMON_EX_COL</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_RMON_FCS_ERROR</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_RMON_TX_ABORT</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_RMON_TX_BAD</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_RMON_TX_GOOD</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_RMON_TX_RUNT</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_RMON_TX_OVERSIZE</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_RMON_RX_BYTES</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_RMON_RX_MCAST</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_RMON_RX_BCAST</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_RMON_RX_BAD</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_RMON_RX_GOOD</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_RMON_RX_RUNT</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_RMON_RX_OVERSIZE</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_RMON_RX_FCS_ERROR</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_RMON_RX_LENGTH_ERROR</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_RMON_RX_CODE_ERROR</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_RMON_RX_ALIGN_ERROR</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * initialize register pointers</span>
<span class="cm">	 */</span>

	<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_config0</span> <span class="o">=</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_DMA_REGISTER</span><span class="p">(</span><span class="n">txrx</span><span class="p">,</span><span class="n">chan</span><span class="p">,</span><span class="n">R_MAC_DMA_CONFIG0</span><span class="p">);</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_config1</span> <span class="o">=</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_DMA_REGISTER</span><span class="p">(</span><span class="n">txrx</span><span class="p">,</span><span class="n">chan</span><span class="p">,</span><span class="n">R_MAC_DMA_CONFIG1</span><span class="p">);</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrbase</span> <span class="o">=</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_DMA_REGISTER</span><span class="p">(</span><span class="n">txrx</span><span class="p">,</span><span class="n">chan</span><span class="p">,</span><span class="n">R_MAC_DMA_DSCR_BASE</span><span class="p">);</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrcnt</span> <span class="o">=</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_DMA_REGISTER</span><span class="p">(</span><span class="n">txrx</span><span class="p">,</span><span class="n">chan</span><span class="p">,</span><span class="n">R_MAC_DMA_DSCR_CNT</span><span class="p">);</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_curdscr</span> <span class="o">=</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_DMA_REGISTER</span><span class="p">(</span><span class="n">txrx</span><span class="p">,</span><span class="n">chan</span><span class="p">,</span><span class="n">R_MAC_DMA_CUR_DSCRADDR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_txdir</span><span class="p">)</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_oodpktlost</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_oodpktlost</span> <span class="o">=</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_DMA_REGISTER</span><span class="p">(</span><span class="n">txrx</span><span class="p">,</span><span class="n">chan</span><span class="p">,</span><span class="n">R_MAC_DMA_OODPKTLOST_RX</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate memory for the ring</span>
<span class="cm">	 */</span>

	<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_maxdescr</span> <span class="o">=</span> <span class="n">maxdescr</span><span class="p">;</span>

	<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrtable_unaligned</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_maxdescr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
					       <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrtable</span><span class="p">),</span>
					       <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The descriptor table must be aligned to at least 16 bytes or the</span>
<span class="cm">	 * MAC will corrupt it.</span>
<span class="cm">	 */</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrtable</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sbdmadscr</span> <span class="o">*</span><span class="p">)</span>
			     <span class="n">ALIGN</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrtable_unaligned</span><span class="p">,</span>
				   <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrtable</span><span class="p">));</span>

	<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrtable_end</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrtable</span> <span class="o">+</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_maxdescr</span><span class="p">;</span>

	<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrtable_phys</span> <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrtable</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * And context table</span>
<span class="cm">	 */</span>

	<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_ctxtable</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_maxdescr</span><span class="p">,</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_ctxtable</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SBMAC_COALESCE</span>
	<span class="cm">/*</span>
<span class="cm">	 * Setup Rx/Tx DMA coalescing defaults</span>
<span class="cm">	 */</span>

	<span class="n">int_pktcnt</span> <span class="o">=</span> <span class="p">(</span><span class="n">txrx</span> <span class="o">==</span> <span class="n">DMA_TX</span><span class="p">)</span> <span class="o">?</span> <span class="n">int_pktcnt_tx</span> <span class="o">:</span> <span class="n">int_pktcnt_rx</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">int_pktcnt</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_int_pktcnt</span> <span class="o">=</span> <span class="n">int_pktcnt</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_int_pktcnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">int_timeout</span> <span class="o">=</span> <span class="p">(</span><span class="n">txrx</span> <span class="o">==</span> <span class="n">DMA_TX</span><span class="p">)</span> <span class="o">?</span> <span class="n">int_timeout_tx</span> <span class="o">:</span> <span class="n">int_timeout_rx</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">int_timeout</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_int_timeout</span> <span class="o">=</span> <span class="n">int_timeout</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_int_timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

<span class="p">}</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> *  SBDMA_CHANNEL_START(d)</span>
<span class="cm"> *</span>
<span class="cm"> *  Initialize the hardware registers for a DMA channel.</span>
<span class="cm"> *</span>
<span class="cm"> *  Input parameters:</span>
<span class="cm"> *  	   d - DMA channel to init (context must be previously init&#39;d</span>
<span class="cm"> *         rxtx - DMA_RX or DMA_TX depending on what type of channel</span>
<span class="cm"> *</span>
<span class="cm"> *  Return value:</span>
<span class="cm"> *  	   nothing</span>
<span class="cm"> ********************************************************************* */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sbdma_channel_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmacdma</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rxtx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Turn on the DMA channel</span>
<span class="cm">	 */</span>

<span class="cp">#ifdef CONFIG_SBMAC_COALESCE</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">V_DMA_INT_TIMEOUT</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_int_timeout</span><span class="p">)</span> <span class="o">|</span>
		       <span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_config1</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">M_DMA_EOP_INT_EN</span> <span class="o">|</span>
		       <span class="n">V_DMA_RINGSZ</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_maxdescr</span><span class="p">)</span> <span class="o">|</span>
		       <span class="n">V_DMA_INT_PKTCNT</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_int_pktcnt</span><span class="p">)</span> <span class="o">|</span>
		       <span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_config0</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_config1</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">V_DMA_RINGSZ</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_maxdescr</span><span class="p">)</span> <span class="o">|</span>
		       <span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_config0</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrtable_phys</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrbase</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize ring pointers</span>
<span class="cm">	 */</span>

	<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_addptr</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrtable</span><span class="p">;</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_remptr</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrtable</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> *  SBDMA_CHANNEL_STOP(d)</span>
<span class="cm"> *</span>
<span class="cm"> *  Initialize the hardware registers for a DMA channel.</span>
<span class="cm"> *</span>
<span class="cm"> *  Input parameters:</span>
<span class="cm"> *  	   d - DMA channel to init (context must be previously init&#39;d</span>
<span class="cm"> *</span>
<span class="cm"> *  Return value:</span>
<span class="cm"> *  	   nothing</span>
<span class="cm"> ********************************************************************* */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sbdma_channel_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmacdma</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Turn off the DMA channel</span>
<span class="cm">	 */</span>

	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_config1</span><span class="p">);</span>

	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrbase</span><span class="p">);</span>

	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_config0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Zero ring pointers</span>
<span class="cm">	 */</span>

	<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_addptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_remptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sbdma_align_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">power2</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">newaddr</span> <span class="o">=</span> <span class="n">PTR_ALIGN</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">power2</span><span class="p">);</span>

	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">newaddr</span> <span class="o">-</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**********************************************************************</span>
<span class="cm"> *  SBDMA_ADD_RCVBUFFER(d,sb)</span>
<span class="cm"> *</span>
<span class="cm"> *  Add a buffer to the specified DMA channel.   For receive channels,</span>
<span class="cm"> *  this queues a buffer for inbound packets.</span>
<span class="cm"> *</span>
<span class="cm"> *  Input parameters:</span>
<span class="cm"> *	   sc - softc structure</span>
<span class="cm"> *  	    d - DMA channel descriptor</span>
<span class="cm"> * 	   sb - sk_buff to add, or NULL if we should allocate one</span>
<span class="cm"> *</span>
<span class="cm"> *  Return value:</span>
<span class="cm"> *  	   0 if buffer could not be added (ring is full)</span>
<span class="cm"> *  	   1 if buffer added successfully</span>
<span class="cm"> ********************************************************************* */</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">sbdma_add_rcvbuffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sbmacdma</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sbdmadscr</span> <span class="o">*</span><span class="n">dsc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sbdmadscr</span> <span class="o">*</span><span class="n">nextdsc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">sb_new</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pktsize</span> <span class="o">=</span> <span class="n">ENET_PACKET_SIZE</span><span class="p">;</span>

	<span class="cm">/* get pointer to our current place in the ring */</span>

	<span class="n">dsc</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_addptr</span><span class="p">;</span>
	<span class="n">nextdsc</span> <span class="o">=</span> <span class="n">SBDMA_NEXTBUF</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">sbdma_addptr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * figure out if the ring is full - if the next descriptor</span>
<span class="cm">	 * is the same as the one that we&#39;re going to remove from</span>
<span class="cm">	 * the ring, the ring is full</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nextdsc</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_remptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate a sk_buff if we don&#39;t already have one.</span>
<span class="cm">	 * If we do have an sk_buff, reset it so that it&#39;s empty.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: sk_buffs don&#39;t seem to be guaranteed to have any sort</span>
<span class="cm">	 * of alignment when they are allocated.  Therefore, allocate enough</span>
<span class="cm">	 * extra space to make sure that:</span>
<span class="cm">	 *</span>
<span class="cm">	 *    1. the data does not start in the middle of a cache line.</span>
<span class="cm">	 *    2. The data does not end in the middle of a cache line</span>
<span class="cm">	 *    3. The buffer can be aligned such that the IP addresses are</span>
<span class="cm">	 *       naturally aligned.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  Remember, the SOCs MAC writes whole cache lines at a time,</span>
<span class="cm">	 *  without reading the old contents first.  So, if the sk_buff&#39;s</span>
<span class="cm">	 *  data portion starts in the middle of a cache line, the SOC</span>
<span class="cm">	 *  DMA will trash the beginning (and ending) portions.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sb_new</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ENET_PACKET_SIZE</span> <span class="o">+</span>
					       <span class="n">SMP_CACHE_BYTES</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span>
					       <span class="n">NET_IP_ALIGN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sb_new</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: sk_buff allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_eth</span><span class="o">-&gt;</span><span class="n">sbm_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sbdma_align_skb</span><span class="p">(</span><span class="n">sb_new</span><span class="p">,</span> <span class="n">SMP_CACHE_BYTES</span><span class="p">,</span> <span class="n">NET_IP_ALIGN</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">sb_new</span> <span class="o">=</span> <span class="n">sb</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * nothing special to reinit buffer, it&#39;s already aligned</span>
<span class="cm">		 * and sb-&gt;data already points to a good place.</span>
<span class="cm">		 */</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * fill in the descriptor</span>
<span class="cm">	 */</span>

<span class="cp">#ifdef CONFIG_SBMAC_COALESCE</span>
	<span class="cm">/*</span>
<span class="cm">	 * Do not interrupt per DMA transfer.</span>
<span class="cm">	 */</span>
	<span class="n">dsc</span><span class="o">-&gt;</span><span class="n">dscr_a</span> <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">sb_new</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">V_DMA_DSCRA_A_SIZE</span><span class="p">(</span><span class="n">NUMCACHEBLKS</span><span class="p">(</span><span class="n">pktsize</span> <span class="o">+</span> <span class="n">NET_IP_ALIGN</span><span class="p">))</span> <span class="o">|</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">dsc</span><span class="o">-&gt;</span><span class="n">dscr_a</span> <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">sb_new</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">V_DMA_DSCRA_A_SIZE</span><span class="p">(</span><span class="n">NUMCACHEBLKS</span><span class="p">(</span><span class="n">pktsize</span> <span class="o">+</span> <span class="n">NET_IP_ALIGN</span><span class="p">))</span> <span class="o">|</span>
		<span class="n">M_DMA_DSCRA_INTERRUPT</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* receiving: no options */</span>
	<span class="n">dsc</span><span class="o">-&gt;</span><span class="n">dscr_b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * fill in the context</span>
<span class="cm">	 */</span>

	<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_ctxtable</span><span class="p">[</span><span class="n">dsc</span><span class="o">-</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrtable</span><span class="p">]</span> <span class="o">=</span> <span class="n">sb_new</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * point at next packet</span>
<span class="cm">	 */</span>

	<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_addptr</span> <span class="o">=</span> <span class="n">nextdsc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Give the buffer to the DMA engine.</span>
<span class="cm">	 */</span>

	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrcnt</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>					<span class="cm">/* we did it */</span>
<span class="p">}</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> *  SBDMA_ADD_TXBUFFER(d,sb)</span>
<span class="cm"> *</span>
<span class="cm"> *  Add a transmit buffer to the specified DMA channel, causing a</span>
<span class="cm"> *  transmit to start.</span>
<span class="cm"> *</span>
<span class="cm"> *  Input parameters:</span>
<span class="cm"> *  	   d - DMA channel descriptor</span>
<span class="cm"> * 	   sb - sk_buff to add</span>
<span class="cm"> *</span>
<span class="cm"> *  Return value:</span>
<span class="cm"> *  	   0 transmit queued successfully</span>
<span class="cm"> *  	   otherwise error code</span>
<span class="cm"> ********************************************************************* */</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">sbdma_add_txbuffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmacdma</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sbdmadscr</span> <span class="o">*</span><span class="n">dsc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sbdmadscr</span> <span class="o">*</span><span class="n">nextdsc</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">phys</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">ncb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">length</span><span class="p">;</span>

	<span class="cm">/* get pointer to our current place in the ring */</span>

	<span class="n">dsc</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_addptr</span><span class="p">;</span>
	<span class="n">nextdsc</span> <span class="o">=</span> <span class="n">SBDMA_NEXTBUF</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">sbdma_addptr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * figure out if the ring is full - if the next descriptor</span>
<span class="cm">	 * is the same as the one that we&#39;re going to remove from</span>
<span class="cm">	 * the ring, the ring is full</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nextdsc</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_remptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Under Linux, it&#39;s not necessary to copy/coalesce buffers</span>
<span class="cm">	 * like it is on NetBSD.  We think they&#39;re all contiguous,</span>
<span class="cm">	 * but that may not be true for GBE.</span>
<span class="cm">	 */</span>

	<span class="n">length</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * fill in the descriptor.  Note that the number of cache</span>
<span class="cm">	 * blocks in the descriptor is the number of blocks</span>
<span class="cm">	 * *spanned*, so we need to add in the offset (if any)</span>
<span class="cm">	 * while doing the calculation.</span>
<span class="cm">	 */</span>

	<span class="n">phys</span> <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">ncb</span> <span class="o">=</span> <span class="n">NUMCACHEBLKS</span><span class="p">(</span><span class="n">length</span><span class="o">+</span><span class="p">(</span><span class="n">phys</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SMP_CACHE_BYTES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)));</span>

	<span class="n">dsc</span><span class="o">-&gt;</span><span class="n">dscr_a</span> <span class="o">=</span> <span class="n">phys</span> <span class="o">|</span>
		<span class="n">V_DMA_DSCRA_A_SIZE</span><span class="p">(</span><span class="n">ncb</span><span class="p">)</span> <span class="o">|</span>
<span class="cp">#ifndef CONFIG_SBMAC_COALESCE</span>
		<span class="n">M_DMA_DSCRA_INTERRUPT</span> <span class="o">|</span>
<span class="cp">#endif</span>
		<span class="n">M_DMA_ETHTX_SOP</span><span class="p">;</span>

	<span class="cm">/* transmitting: set outbound options and length */</span>

	<span class="n">dsc</span><span class="o">-&gt;</span><span class="n">dscr_b</span> <span class="o">=</span> <span class="n">V_DMA_DSCRB_OPTIONS</span><span class="p">(</span><span class="n">K_DMA_ETHTX_APPENDCRC_APPENDPAD</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">V_DMA_DSCRB_PKT_SIZE</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * fill in the context</span>
<span class="cm">	 */</span>

	<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_ctxtable</span><span class="p">[</span><span class="n">dsc</span><span class="o">-</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrtable</span><span class="p">]</span> <span class="o">=</span> <span class="n">sb</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * point at next packet</span>
<span class="cm">	 */</span>

	<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_addptr</span> <span class="o">=</span> <span class="n">nextdsc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Give the buffer to the DMA engine.</span>
<span class="cm">	 */</span>

	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrcnt</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>					<span class="cm">/* we did it */</span>
<span class="p">}</span>




<span class="cm">/**********************************************************************</span>
<span class="cm"> *  SBDMA_EMPTYRING(d)</span>
<span class="cm"> *</span>
<span class="cm"> *  Free all allocated sk_buffs on the specified DMA channel;</span>
<span class="cm"> *</span>
<span class="cm"> *  Input parameters:</span>
<span class="cm"> *  	   d  - DMA channel</span>
<span class="cm"> *</span>
<span class="cm"> *  Return value:</span>
<span class="cm"> *  	   nothing</span>
<span class="cm"> ********************************************************************* */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sbdma_emptyring</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmacdma</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_maxdescr</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sb</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_ctxtable</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
			<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_ctxtable</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/**********************************************************************</span>
<span class="cm"> *  SBDMA_FILLRING(d)</span>
<span class="cm"> *</span>
<span class="cm"> *  Fill the specified DMA channel (must be receive channel)</span>
<span class="cm"> *  with sk_buffs</span>
<span class="cm"> *</span>
<span class="cm"> *  Input parameters:</span>
<span class="cm"> *	   sc - softc structure</span>
<span class="cm"> *  	    d - DMA channel</span>
<span class="cm"> *</span>
<span class="cm"> *  Return value:</span>
<span class="cm"> *  	   nothing</span>
<span class="cm"> ********************************************************************* */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sbdma_fillring</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sbmacdma</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">SBMAC_MAX_RXDESCR</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sbdma_add_rcvbuffer</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sbmac_netpoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>

	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_imr</span><span class="p">);</span>

	<span class="n">sbmac_intr</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SBMAC_COALESCE</span>
	<span class="n">__raw_writeq</span><span class="p">(((</span><span class="n">M_MAC_INT_EOP_COUNT</span> <span class="o">|</span> <span class="n">M_MAC_INT_EOP_TIMER</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">S_MAC_TX_CH0</span><span class="p">)</span> <span class="o">|</span>
	<span class="p">((</span><span class="n">M_MAC_INT_EOP_COUNT</span> <span class="o">|</span> <span class="n">M_MAC_INT_EOP_TIMER</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">S_MAC_RX_CH0</span><span class="p">),</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_imr</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">__raw_writeq</span><span class="p">((</span><span class="n">M_MAC_INT_CHANNEL</span> <span class="o">&lt;&lt;</span> <span class="n">S_MAC_TX_CH0</span><span class="p">)</span> <span class="o">|</span>
	<span class="p">(</span><span class="n">M_MAC_INT_CHANNEL</span> <span class="o">&lt;&lt;</span> <span class="n">S_MAC_RX_CH0</span><span class="p">),</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_imr</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> *  SBDMA_RX_PROCESS(sc,d,work_to_do,poll)</span>
<span class="cm"> *</span>
<span class="cm"> *  Process &quot;completed&quot; receive buffers on the specified DMA channel.</span>
<span class="cm"> *</span>
<span class="cm"> *  Input parameters:</span>
<span class="cm"> *            sc - softc structure</span>
<span class="cm"> *  	       d - DMA channel context</span>
<span class="cm"> *    work_to_do - no. of packets to process before enabling interrupt</span>
<span class="cm"> *                 again (for NAPI)</span>
<span class="cm"> *          poll - 1: using polling (for NAPI)</span>
<span class="cm"> *</span>
<span class="cm"> *  Return value:</span>
<span class="cm"> *  	   nothing</span>
<span class="cm"> ********************************************************************* */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sbdma_rx_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sbmacdma</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">work_to_do</span><span class="p">,</span> <span class="kt">int</span> <span class="n">poll</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">curidx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hwidx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sbdmadscr</span> <span class="o">*</span><span class="n">dsc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">work_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dropped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">prefetch</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>

<span class="nl">again:</span>
	<span class="cm">/* Check if the HW dropped any frames */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_fifo_errors</span>
	    <span class="o">+=</span> <span class="n">__raw_readq</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_rxdma</span><span class="p">.</span><span class="n">sbdma_oodpktlost</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_rxdma</span><span class="p">.</span><span class="n">sbdma_oodpktlost</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">work_to_do</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * figure out where we are (as an index) and where</span>
<span class="cm">		 * the hardware is (also as an index)</span>
<span class="cm">		 *</span>
<span class="cm">		 * This could be done faster if (for example) the</span>
<span class="cm">		 * descriptor table was page-aligned and contiguous in</span>
<span class="cm">		 * both virtual and physical memory -- you could then</span>
<span class="cm">		 * just compare the low-order bits of the virtual address</span>
<span class="cm">		 * (sbdma_remptr) and the physical address (sbdma_curdscr CSR)</span>
<span class="cm">		 */</span>

		<span class="n">dsc</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_remptr</span><span class="p">;</span>
		<span class="n">curidx</span> <span class="o">=</span> <span class="n">dsc</span> <span class="o">-</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrtable</span><span class="p">;</span>

		<span class="n">prefetch</span><span class="p">(</span><span class="n">dsc</span><span class="p">);</span>
		<span class="n">prefetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_ctxtable</span><span class="p">[</span><span class="n">curidx</span><span class="p">]);</span>

		<span class="n">hwidx</span> <span class="o">=</span> <span class="p">((</span><span class="n">__raw_readq</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_curdscr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">M_DMA_CURDSCR_ADDR</span><span class="p">)</span> <span class="o">-</span>
			 <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrtable_phys</span><span class="p">)</span> <span class="o">/</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrtable</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If they&#39;re the same, that means we&#39;ve processed all</span>
<span class="cm">		 * of the descriptors up to (but not including) the one that</span>
<span class="cm">		 * the hardware is working on right now.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">curidx</span> <span class="o">==</span> <span class="n">hwidx</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Otherwise, get the packet&#39;s sk_buff ptr back</span>
<span class="cm">		 */</span>

		<span class="n">sb</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_ctxtable</span><span class="p">[</span><span class="n">curidx</span><span class="p">];</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_ctxtable</span><span class="p">[</span><span class="n">curidx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">G_DMA_DSCRB_PKT_SIZE</span><span class="p">(</span><span class="n">dsc</span><span class="o">-&gt;</span><span class="n">dscr_b</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check packet status.  If good, process it.</span>
<span class="cm">		 * If not, silently drop it and put it back on the</span>
<span class="cm">		 * receive ring.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dsc</span><span class="o">-&gt;</span><span class="n">dscr_a</span> <span class="o">&amp;</span> <span class="n">M_DMA_ETHRX_BAD</span><span class="p">)))</span> <span class="p">{</span>

			<span class="cm">/*</span>
<span class="cm">			 * Add a new buffer to replace the old one.  If we fail</span>
<span class="cm">			 * to allocate a buffer, we&#39;re going to drop this</span>
<span class="cm">			 * packet and put it right back on the receive ring.</span>
<span class="cm">			 */</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sbdma_add_rcvbuffer</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span>
				     <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
				<span class="cm">/* Re-add old buffer */</span>
				<span class="n">sbdma_add_rcvbuffer</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">sb</span><span class="p">);</span>
				<span class="cm">/* No point in continuing at the moment */</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;dropped packet (1)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_remptr</span> <span class="o">=</span> <span class="n">SBDMA_NEXTBUF</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">sbdma_remptr</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Set length into the packet</span>
<span class="cm">				 */</span>
				<span class="n">skb_put</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span><span class="n">len</span><span class="p">);</span>

				<span class="cm">/*</span>
<span class="cm">				 * Buffer has been replaced on the</span>
<span class="cm">				 * receive ring.  Pass the buffer to</span>
<span class="cm">				 * the kernel</span>
<span class="cm">				 */</span>
				<span class="n">sb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_eth</span><span class="o">-&gt;</span><span class="n">sbm_dev</span><span class="p">);</span>
				<span class="cm">/* Check hw IPv4/TCP checksum if supported */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">rx_hw_checksum</span> <span class="o">==</span> <span class="n">ENABLE</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">dsc</span><span class="o">-&gt;</span><span class="n">dscr_a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">M_DMA_ETHRX_BADIP4CS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					    <span class="o">!</span><span class="p">((</span><span class="n">dsc</span><span class="o">-&gt;</span><span class="n">dscr_a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">M_DMA_ETHRX_BADTCPCS</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">sb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_UNNECESSARY</span><span class="p">;</span>
						<span class="cm">/* don&#39;t need to set sb-&gt;csum */</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="n">skb_checksum_none_assert</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="n">prefetch</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
				<span class="n">prefetch</span><span class="p">((</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span><span class="o">+</span><span class="mi">32</span><span class="p">));</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">poll</span><span class="p">)</span>
					<span class="n">dropped</span> <span class="o">=</span> <span class="n">netif_receive_skb</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">dropped</span> <span class="o">=</span> <span class="n">netif_rx</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">dropped</span> <span class="o">==</span> <span class="n">NET_RX_DROP</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
					<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_remptr</span> <span class="o">=</span> <span class="n">SBDMA_NEXTBUF</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">sbdma_remptr</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Packet was mangled somehow.  Just drop it and</span>
<span class="cm">			 * put it back on the receive ring.</span>
<span class="cm">			 */</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="n">sbdma_add_rcvbuffer</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">sb</span><span class="p">);</span>
		<span class="p">}</span>


		<span class="cm">/*</span>
<span class="cm">		 * .. and advance to the next buffer.</span>
<span class="cm">		 */</span>

		<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_remptr</span> <span class="o">=</span> <span class="n">SBDMA_NEXTBUF</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">sbdma_remptr</span><span class="p">);</span>
		<span class="n">work_done</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">poll</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">work_to_do</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span> <span class="cm">/* collect fifo drop statistics again */</span>
	<span class="p">}</span>
<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">work_done</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> *  SBDMA_TX_PROCESS(sc,d)</span>
<span class="cm"> *</span>
<span class="cm"> *  Process &quot;completed&quot; transmit buffers on the specified DMA channel.</span>
<span class="cm"> *  This is normally called within the interrupt service routine.</span>
<span class="cm"> *  Note that this isn&#39;t really ideal for priority channels, since</span>
<span class="cm"> *  it processes all of the packets on a given channel before</span>
<span class="cm"> *  returning.</span>
<span class="cm"> *</span>
<span class="cm"> *  Input parameters:</span>
<span class="cm"> *      sc - softc structure</span>
<span class="cm"> *  	 d - DMA channel context</span>
<span class="cm"> *    poll - 1: using polling (for NAPI)</span>
<span class="cm"> *</span>
<span class="cm"> *  Return value:</span>
<span class="cm"> *  	   nothing</span>
<span class="cm"> ********************************************************************* */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sbdma_tx_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sbmacdma</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">poll</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">curidx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hwidx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sbdmadscr</span> <span class="o">*</span><span class="n">dsc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">packets_handled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_lock</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_remptr</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_addptr</span><span class="p">)</span>
	  <span class="k">goto</span> <span class="n">end_unlock</span><span class="p">;</span>

	<span class="n">hwidx</span> <span class="o">=</span> <span class="p">((</span><span class="n">__raw_readq</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_curdscr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">M_DMA_CURDSCR_ADDR</span><span class="p">)</span> <span class="o">-</span>
		 <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrtable_phys</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrtable</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * figure out where we are (as an index) and where</span>
<span class="cm">		 * the hardware is (also as an index)</span>
<span class="cm">		 *</span>
<span class="cm">		 * This could be done faster if (for example) the</span>
<span class="cm">		 * descriptor table was page-aligned and contiguous in</span>
<span class="cm">		 * both virtual and physical memory -- you could then</span>
<span class="cm">		 * just compare the low-order bits of the virtual address</span>
<span class="cm">		 * (sbdma_remptr) and the physical address (sbdma_curdscr CSR)</span>
<span class="cm">		 */</span>

		<span class="n">curidx</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_remptr</span> <span class="o">-</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrtable</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If they&#39;re the same, that means we&#39;ve processed all</span>
<span class="cm">		 * of the descriptors up to (but not including) the one that</span>
<span class="cm">		 * the hardware is working on right now.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">curidx</span> <span class="o">==</span> <span class="n">hwidx</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Otherwise, get the packet&#39;s sk_buff ptr back</span>
<span class="cm">		 */</span>

		<span class="n">dsc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrtable</span><span class="p">[</span><span class="n">curidx</span><span class="p">]);</span>
		<span class="n">sb</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_ctxtable</span><span class="p">[</span><span class="n">curidx</span><span class="p">];</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_ctxtable</span><span class="p">[</span><span class="n">curidx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Stats</span>
<span class="cm">		 */</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * for transmits, we just free buffers.</span>
<span class="cm">		 */</span>

		<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * .. and advance to the next buffer.</span>
<span class="cm">		 */</span>

		<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_remptr</span> <span class="o">=</span> <span class="n">SBDMA_NEXTBUF</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">sbdma_remptr</span><span class="p">);</span>

		<span class="n">packets_handled</span><span class="o">++</span><span class="p">;</span>

	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Decide if we should wake up the protocol or not.</span>
<span class="cm">	 * Other drivers seem to do this when we reach a low</span>
<span class="cm">	 * watermark on the transmit queue.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">packets_handled</span><span class="p">)</span>
		<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_eth</span><span class="o">-&gt;</span><span class="n">sbm_dev</span><span class="p">);</span>

<span class="nl">end_unlock:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_lock</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>

<span class="p">}</span>



<span class="cm">/**********************************************************************</span>
<span class="cm"> *  SBMAC_INITCTX(s)</span>
<span class="cm"> *</span>
<span class="cm"> *  Initialize an Ethernet context structure - this is called</span>
<span class="cm"> *  once per MAC on the 1250.  Memory is allocated here, so don&#39;t</span>
<span class="cm"> *  call it again from inside the ioctl routines that bring the</span>
<span class="cm"> *  interface up/down</span>
<span class="cm"> *</span>
<span class="cm"> *  Input parameters:</span>
<span class="cm"> *  	   s - sbmac context structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Return value:</span>
<span class="cm"> *  	   0</span>
<span class="cm"> ********************************************************************* */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sbmac_initctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/*</span>
<span class="cm">	 * figure out the addresses of some ports</span>
<span class="cm">	 */</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_macenable</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_ENABLE</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_maccfg</span>    <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_CFG</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_fifocfg</span>   <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_THRSH_CFG</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_framecfg</span>  <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_FRAMECFG</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_rxfilter</span>  <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_ADFILTER_CFG</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_isr</span>       <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_STATUS</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_imr</span>       <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_INT_MASK</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_mdio</span>      <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_MDIO</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the DMA channels.  Right now, only one per MAC is used</span>
<span class="cm">	 * Note: Only do this _once_, as it allocates memory from the kernel!</span>
<span class="cm">	 */</span>

	<span class="n">sbdma_initctx</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_txdma</span><span class="p">),</span><span class="n">s</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">DMA_TX</span><span class="p">,</span><span class="n">SBMAC_MAX_TXDESCR</span><span class="p">);</span>
	<span class="n">sbdma_initctx</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_rxdma</span><span class="p">),</span><span class="n">s</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">DMA_RX</span><span class="p">,</span><span class="n">SBMAC_MAX_RXDESCR</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * initial state is OFF</span>
<span class="cm">	 */</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_state</span> <span class="o">=</span> <span class="n">sbmac_state_off</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">sbdma_uninitctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmacdma</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrtable_unaligned</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrtable_unaligned</span><span class="p">);</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrtable_unaligned</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_dscrtable</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_ctxtable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_ctxtable</span><span class="p">);</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">sbdma_ctxtable</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">sbmac_uninitctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sbdma_uninitctx</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_txdma</span><span class="p">));</span>
	<span class="n">sbdma_uninitctx</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_rxdma</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/**********************************************************************</span>
<span class="cm"> *  SBMAC_CHANNEL_START(s)</span>
<span class="cm"> *</span>
<span class="cm"> *  Start packet processing on this MAC.</span>
<span class="cm"> *</span>
<span class="cm"> *  Input parameters:</span>
<span class="cm"> *  	   s - sbmac structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Return value:</span>
<span class="cm"> *  	   nothing</span>
<span class="cm"> ********************************************************************* */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sbmac_channel_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">reg</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">cfg</span><span class="p">,</span><span class="n">fifo</span><span class="p">,</span><span class="n">framecfg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">th_value</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t do this if running</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_state</span> <span class="o">==</span> <span class="n">sbmac_state_on</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Bring the controller out of reset, but leave it off.</span>
<span class="cm">	 */</span>

	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_macenable</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ignore all received packets</span>
<span class="cm">	 */</span>

	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_rxfilter</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate values for various control registers.</span>
<span class="cm">	 */</span>

	<span class="n">cfg</span> <span class="o">=</span> <span class="n">M_MAC_RETRY_EN</span> <span class="o">|</span>
		<span class="n">M_MAC_TX_HOLD_SOP_EN</span> <span class="o">|</span>
		<span class="n">V_MAC_TX_PAUSE_CNT_16K</span> <span class="o">|</span>
		<span class="n">M_MAC_AP_STAT_EN</span> <span class="o">|</span>
		<span class="n">M_MAC_FAST_SYNC</span> <span class="o">|</span>
		<span class="n">M_MAC_SS_EN</span> <span class="o">|</span>
		<span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Be sure that RD_THRSH+WR_THRSH &lt;= 32 for pass1 pars</span>
<span class="cm">	 * and make sure that RD_THRSH + WR_THRSH &lt;=128 for pass2 and above</span>
<span class="cm">	 * Use a larger RD_THRSH for gigabit</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">soc_type</span> <span class="o">==</span> <span class="n">K_SYS_SOC_TYPE_BCM1250</span> <span class="o">&amp;&amp;</span> <span class="n">periph_rev</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">th_value</span> <span class="o">=</span> <span class="mi">28</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">th_value</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

	<span class="n">fifo</span> <span class="o">=</span> <span class="n">V_MAC_TX_WR_THRSH</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">|</span>	<span class="cm">/* Must be &#39;4&#39; or &#39;8&#39; */</span>
		<span class="p">((</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_speed</span> <span class="o">==</span> <span class="n">sbmac_speed_1000</span><span class="p">)</span>
		 <span class="o">?</span> <span class="n">V_MAC_TX_RD_THRSH</span><span class="p">(</span><span class="n">th_value</span><span class="p">)</span> <span class="o">:</span> <span class="n">V_MAC_TX_RD_THRSH</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span> <span class="o">|</span>
		<span class="n">V_MAC_TX_RL_THRSH</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">V_MAC_RX_PL_THRSH</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">V_MAC_RX_RD_THRSH</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">|</span>	<span class="cm">/* Must be &#39;4&#39; */</span>
		<span class="n">V_MAC_RX_RL_THRSH</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
		<span class="mi">0</span><span class="p">;</span>

	<span class="n">framecfg</span> <span class="o">=</span> <span class="n">V_MAC_MIN_FRAMESZ_DEFAULT</span> <span class="o">|</span>
		<span class="n">V_MAC_MAX_FRAMESZ_DEFAULT</span> <span class="o">|</span>
		<span class="n">V_MAC_BACKOFF_SEL</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear out the hash address map</span>
<span class="cm">	 */</span>

	<span class="n">port</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_HASH_BASE</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">MAC_HASH_COUNT</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
		<span class="n">port</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear out the exact-match table</span>
<span class="cm">	 */</span>

	<span class="n">port</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_ADDR_BASE</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">MAC_ADDR_COUNT</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
		<span class="n">port</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear out the DMA Channel mapping table registers</span>
<span class="cm">	 */</span>

	<span class="n">port</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_CHUP0_BASE</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">MAC_CHMAP_COUNT</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
		<span class="n">port</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">);</span>
	<span class="p">}</span>


	<span class="n">port</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_CHLO0_BASE</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">MAC_CHMAP_COUNT</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
		<span class="n">port</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Program the hardware address.  It goes into the hardware-address</span>
<span class="cm">	 * register as well as the first filter register.</span>
<span class="cm">	 */</span>

	<span class="n">reg</span> <span class="o">=</span> <span class="n">sbmac_addr2reg</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_hwaddr</span><span class="p">);</span>

	<span class="n">port</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_ADDR_BASE</span><span class="p">;</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="n">port</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_ETHERNET_ADDR</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SB1_PASS_1_WORKAROUNDS</span>
	<span class="cm">/*</span>
<span class="cm">	 * Pass1 SOCs do not receive packets addressed to the</span>
<span class="cm">	 * destination address in the R_MAC_ETHERNET_ADDR register.</span>
<span class="cm">	 * Set the value to zero.</span>
<span class="cm">	 */</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the receive filter for no packets, and write values</span>
<span class="cm">	 * to the various config registers</span>
<span class="cm">	 */</span>

	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_rxfilter</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_imr</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">framecfg</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_framecfg</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">fifo</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_fifocfg</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_maccfg</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize DMA channels (rings should be ok now)</span>
<span class="cm">	 */</span>

	<span class="n">sbdma_channel_start</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_rxdma</span><span class="p">),</span> <span class="n">DMA_RX</span><span class="p">);</span>
	<span class="n">sbdma_channel_start</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_txdma</span><span class="p">),</span> <span class="n">DMA_TX</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Configure the speed, duplex, and flow control</span>
<span class="cm">	 */</span>

	<span class="n">sbmac_set_speed</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_speed</span><span class="p">);</span>
	<span class="n">sbmac_set_duplex</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_duplex</span><span class="p">,</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_fc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fill the receive ring</span>
<span class="cm">	 */</span>

	<span class="n">sbdma_fillring</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_rxdma</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Turn on the rest of the bits in the enable register</span>
<span class="cm">	 */</span>

<span class="cp">#if defined(CONFIG_SIBYTE_BCM1x55) || defined(CONFIG_SIBYTE_BCM1x80)</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">M_MAC_RXDMA_EN0</span> <span class="o">|</span>
		       <span class="n">M_MAC_TXDMA_EN0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_macenable</span><span class="p">);</span>
<span class="cp">#elif defined(CONFIG_SIBYTE_SB1250) || defined(CONFIG_SIBYTE_BCM112X)</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">M_MAC_RXDMA_EN0</span> <span class="o">|</span>
		       <span class="n">M_MAC_TXDMA_EN0</span> <span class="o">|</span>
		       <span class="n">M_MAC_RX_ENABLE</span> <span class="o">|</span>
		       <span class="n">M_MAC_TX_ENABLE</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_macenable</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#error invalid SiByte MAC configuration</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SBMAC_COALESCE</span>
	<span class="n">__raw_writeq</span><span class="p">(((</span><span class="n">M_MAC_INT_EOP_COUNT</span> <span class="o">|</span> <span class="n">M_MAC_INT_EOP_TIMER</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">S_MAC_TX_CH0</span><span class="p">)</span> <span class="o">|</span>
		       <span class="p">((</span><span class="n">M_MAC_INT_EOP_COUNT</span> <span class="o">|</span> <span class="n">M_MAC_INT_EOP_TIMER</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">S_MAC_RX_CH0</span><span class="p">),</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_imr</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">__raw_writeq</span><span class="p">((</span><span class="n">M_MAC_INT_CHANNEL</span> <span class="o">&lt;&lt;</span> <span class="n">S_MAC_TX_CH0</span><span class="p">)</span> <span class="o">|</span>
		       <span class="p">(</span><span class="n">M_MAC_INT_CHANNEL</span> <span class="o">&lt;&lt;</span> <span class="n">S_MAC_RX_CH0</span><span class="p">),</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_imr</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enable receiving unicasts and broadcasts</span>
<span class="cm">	 */</span>

	<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">M_MAC_UCAST_EN</span> <span class="o">|</span> <span class="n">M_MAC_BCAST_EN</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_rxfilter</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we&#39;re running now.</span>
<span class="cm">	 */</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_state</span> <span class="o">=</span> <span class="n">sbmac_state_on</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Program multicast addresses</span>
<span class="cm">	 */</span>

	<span class="n">sbmac_setmulti</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If channel was in promiscuous mode before, turn that on</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_devflags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sbmac_promiscuous_mode</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>


<span class="cm">/**********************************************************************</span>
<span class="cm"> *  SBMAC_CHANNEL_STOP(s)</span>
<span class="cm"> *</span>
<span class="cm"> *  Stop packet processing on this MAC.</span>
<span class="cm"> *</span>
<span class="cm"> *  Input parameters:</span>
<span class="cm"> *  	   s - sbmac structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Return value:</span>
<span class="cm"> *  	   nothing</span>
<span class="cm"> ********************************************************************* */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sbmac_channel_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* don&#39;t do this if already stopped */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_state</span> <span class="o">==</span> <span class="n">sbmac_state_off</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* don&#39;t accept any packets, disable all interrupts */</span>

	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_rxfilter</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_imr</span><span class="p">);</span>

	<span class="cm">/* Turn off ticker */</span>

	<span class="cm">/* XXX */</span>

	<span class="cm">/* turn off receiver and transmitter */</span>

	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_macenable</span><span class="p">);</span>

	<span class="cm">/* We&#39;re stopped now. */</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_state</span> <span class="o">=</span> <span class="n">sbmac_state_off</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Stop DMA channels (rings should be ok now)</span>
<span class="cm">	 */</span>

	<span class="n">sbdma_channel_stop</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_rxdma</span><span class="p">));</span>
	<span class="n">sbdma_channel_stop</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_txdma</span><span class="p">));</span>

	<span class="cm">/* Empty the receive and transmit rings */</span>

	<span class="n">sbdma_emptyring</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_rxdma</span><span class="p">));</span>
	<span class="n">sbdma_emptyring</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_txdma</span><span class="p">));</span>

<span class="p">}</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> *  SBMAC_SET_CHANNEL_STATE(state)</span>
<span class="cm"> *</span>
<span class="cm"> *  Set the channel&#39;s state ON or OFF</span>
<span class="cm"> *</span>
<span class="cm"> *  Input parameters:</span>
<span class="cm"> *  	   state - new state</span>
<span class="cm"> *</span>
<span class="cm"> *  Return value:</span>
<span class="cm"> *  	   old state</span>
<span class="cm"> ********************************************************************* */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">sbmac_state</span> <span class="nf">sbmac_set_channel_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span>
						<span class="k">enum</span> <span class="n">sbmac_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">sbmac_state</span> <span class="n">oldstate</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_state</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If same as previous state, return</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">oldstate</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">oldstate</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If new state is ON, turn channel on</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">sbmac_state_on</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sbmac_channel_start</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">sbmac_channel_stop</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Return previous state</span>
<span class="cm">	 */</span>

	<span class="k">return</span> <span class="n">oldstate</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**********************************************************************</span>
<span class="cm"> *  SBMAC_PROMISCUOUS_MODE(sc,onoff)</span>
<span class="cm"> *</span>
<span class="cm"> *  Turn on or off promiscuous mode</span>
<span class="cm"> *</span>
<span class="cm"> *  Input parameters:</span>
<span class="cm"> *  	   sc - softc</span>
<span class="cm"> *      onoff - 1 to turn on, 0 to turn off</span>
<span class="cm"> *</span>
<span class="cm"> *  Return value:</span>
<span class="cm"> *  	   nothing</span>
<span class="cm"> ********************************************************************* */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sbmac_promiscuous_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span><span class="kt">int</span> <span class="n">onoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">reg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_state</span> <span class="o">!=</span> <span class="n">sbmac_state_on</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">onoff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">__raw_readq</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_rxfilter</span><span class="p">);</span>
		<span class="n">reg</span> <span class="o">|=</span> <span class="n">M_MAC_ALLPKT_EN</span><span class="p">;</span>
		<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_rxfilter</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">__raw_readq</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_rxfilter</span><span class="p">);</span>
		<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">M_MAC_ALLPKT_EN</span><span class="p">;</span>
		<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_rxfilter</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> *  SBMAC_SETIPHDR_OFFSET(sc,onoff)</span>
<span class="cm"> *</span>
<span class="cm"> *  Set the iphdr offset as 15 assuming ethernet encapsulation</span>
<span class="cm"> *</span>
<span class="cm"> *  Input parameters:</span>
<span class="cm"> *  	   sc - softc</span>
<span class="cm"> *</span>
<span class="cm"> *  Return value:</span>
<span class="cm"> *  	   nothing</span>
<span class="cm"> ********************************************************************* */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sbmac_set_iphdr_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">reg</span><span class="p">;</span>

	<span class="cm">/* Hard code the off set to 15 for now */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">__raw_readq</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_rxfilter</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">M_MAC_IPHDR_OFFSET</span> <span class="o">|</span> <span class="n">V_MAC_IPHDR_OFFSET</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_rxfilter</span><span class="p">);</span>

	<span class="cm">/* BCM1250 pass1 didn&#39;t have hardware checksum.  Everything</span>
<span class="cm">	   later does.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">soc_type</span> <span class="o">==</span> <span class="n">K_SYS_SOC_TYPE_BCM1250</span> <span class="o">&amp;&amp;</span> <span class="n">periph_rev</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">rx_hw_checksum</span> <span class="o">=</span> <span class="n">DISABLE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">rx_hw_checksum</span> <span class="o">=</span> <span class="n">ENABLE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/**********************************************************************</span>
<span class="cm"> *  SBMAC_ADDR2REG(ptr)</span>
<span class="cm"> *</span>
<span class="cm"> *  Convert six bytes into the 64-bit register value that</span>
<span class="cm"> *  we typically write into the SBMAC&#39;s address/mcast registers</span>
<span class="cm"> *</span>
<span class="cm"> *  Input parameters:</span>
<span class="cm"> *  	   ptr - pointer to 6 bytes</span>
<span class="cm"> *</span>
<span class="cm"> *  Return value:</span>
<span class="cm"> *  	   register value</span>
<span class="cm"> ********************************************************************* */</span>

<span class="k">static</span> <span class="kt">uint64_t</span> <span class="nf">sbmac_addr2reg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ptr</span> <span class="o">+=</span> <span class="mi">6</span><span class="p">;</span>

	<span class="n">reg</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">ptr</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">reg</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">ptr</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">reg</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">ptr</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">reg</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">ptr</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">reg</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">ptr</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">reg</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">ptr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">reg</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**********************************************************************</span>
<span class="cm"> *  SBMAC_SET_SPEED(s,speed)</span>
<span class="cm"> *</span>
<span class="cm"> *  Configure LAN speed for the specified MAC.</span>
<span class="cm"> *  Warning: must be called when MAC is off!</span>
<span class="cm"> *</span>
<span class="cm"> *  Input parameters:</span>
<span class="cm"> *  	   s - sbmac structure</span>
<span class="cm"> *  	   speed - speed to set MAC to (see enum sbmac_speed)</span>
<span class="cm"> *</span>
<span class="cm"> *  Return value:</span>
<span class="cm"> *  	   1 if successful</span>
<span class="cm"> *      0 indicates invalid parameters</span>
<span class="cm"> ********************************************************************* */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sbmac_set_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">enum</span> <span class="n">sbmac_speed</span> <span class="n">speed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">cfg</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">framecfg</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save new current values</span>
<span class="cm">	 */</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_speed</span> <span class="o">=</span> <span class="n">speed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_state</span> <span class="o">==</span> <span class="n">sbmac_state_on</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* save for next restart */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read current register values</span>
<span class="cm">	 */</span>

	<span class="n">cfg</span> <span class="o">=</span> <span class="n">__raw_readq</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_maccfg</span><span class="p">);</span>
	<span class="n">framecfg</span> <span class="o">=</span> <span class="n">__raw_readq</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_framecfg</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Mask out the stuff we want to change</span>
<span class="cm">	 */</span>

	<span class="n">cfg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">M_MAC_BURST_EN</span> <span class="o">|</span> <span class="n">M_MAC_SPEED_SEL</span><span class="p">);</span>
	<span class="n">framecfg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">M_MAC_IFG_RX</span> <span class="o">|</span> <span class="n">M_MAC_IFG_TX</span> <span class="o">|</span> <span class="n">M_MAC_IFG_THRSH</span> <span class="o">|</span>
		      <span class="n">M_MAC_SLOT_SIZE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now add in the new bits</span>
<span class="cm">	 */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">sbmac_speed_10</span>:
		<span class="n">framecfg</span> <span class="o">|=</span> <span class="n">V_MAC_IFG_RX_10</span> <span class="o">|</span>
			<span class="n">V_MAC_IFG_TX_10</span> <span class="o">|</span>
			<span class="n">K_MAC_IFG_THRSH_10</span> <span class="o">|</span>
			<span class="n">V_MAC_SLOT_SIZE_10</span><span class="p">;</span>
		<span class="n">cfg</span> <span class="o">|=</span> <span class="n">V_MAC_SPEED_SEL_10MBPS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">sbmac_speed_100</span>:
		<span class="n">framecfg</span> <span class="o">|=</span> <span class="n">V_MAC_IFG_RX_100</span> <span class="o">|</span>
			<span class="n">V_MAC_IFG_TX_100</span> <span class="o">|</span>
			<span class="n">V_MAC_IFG_THRSH_100</span> <span class="o">|</span>
			<span class="n">V_MAC_SLOT_SIZE_100</span><span class="p">;</span>
		<span class="n">cfg</span> <span class="o">|=</span> <span class="n">V_MAC_SPEED_SEL_100MBPS</span> <span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">sbmac_speed_1000</span>:
		<span class="n">framecfg</span> <span class="o">|=</span> <span class="n">V_MAC_IFG_RX_1000</span> <span class="o">|</span>
			<span class="n">V_MAC_IFG_TX_1000</span> <span class="o">|</span>
			<span class="n">V_MAC_IFG_THRSH_1000</span> <span class="o">|</span>
			<span class="n">V_MAC_SLOT_SIZE_1000</span><span class="p">;</span>
		<span class="n">cfg</span> <span class="o">|=</span> <span class="n">V_MAC_SPEED_SEL_1000MBPS</span> <span class="o">|</span> <span class="n">M_MAC_BURST_EN</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Send the bits back to the hardware</span>
<span class="cm">	 */</span>

	<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">framecfg</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_framecfg</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_maccfg</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> *  SBMAC_SET_DUPLEX(s,duplex,fc)</span>
<span class="cm"> *</span>
<span class="cm"> *  Set Ethernet duplex and flow control options for this MAC</span>
<span class="cm"> *  Warning: must be called when MAC is off!</span>
<span class="cm"> *</span>
<span class="cm"> *  Input parameters:</span>
<span class="cm"> *  	   s - sbmac structure</span>
<span class="cm"> *  	   duplex - duplex setting (see enum sbmac_duplex)</span>
<span class="cm"> *  	   fc - flow control setting (see enum sbmac_fc)</span>
<span class="cm"> *</span>
<span class="cm"> *  Return value:</span>
<span class="cm"> *  	   1 if ok</span>
<span class="cm"> *  	   0 if an invalid parameter combination was specified</span>
<span class="cm"> ********************************************************************* */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sbmac_set_duplex</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">enum</span> <span class="n">sbmac_duplex</span> <span class="n">duplex</span><span class="p">,</span>
			    <span class="k">enum</span> <span class="n">sbmac_fc</span> <span class="n">fc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">cfg</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save new current values</span>
<span class="cm">	 */</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_duplex</span> <span class="o">=</span> <span class="n">duplex</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_fc</span> <span class="o">=</span> <span class="n">fc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_state</span> <span class="o">==</span> <span class="n">sbmac_state_on</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* save for next restart */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read current register values</span>
<span class="cm">	 */</span>

	<span class="n">cfg</span> <span class="o">=</span> <span class="n">__raw_readq</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_maccfg</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Mask off the stuff we&#39;re about to change</span>
<span class="cm">	 */</span>

	<span class="n">cfg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">M_MAC_FC_SEL</span> <span class="o">|</span> <span class="n">M_MAC_FC_CMD</span> <span class="o">|</span> <span class="n">M_MAC_HDX_EN</span><span class="p">);</span>


	<span class="k">switch</span> <span class="p">(</span><span class="n">duplex</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">sbmac_duplex_half</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">fc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">sbmac_fc_disabled</span>:
			<span class="n">cfg</span> <span class="o">|=</span> <span class="n">M_MAC_HDX_EN</span> <span class="o">|</span> <span class="n">V_MAC_FC_CMD_DISABLED</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">sbmac_fc_collision</span>:
			<span class="n">cfg</span> <span class="o">|=</span> <span class="n">M_MAC_HDX_EN</span> <span class="o">|</span> <span class="n">V_MAC_FC_CMD_ENABLED</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">sbmac_fc_carrier</span>:
			<span class="n">cfg</span> <span class="o">|=</span> <span class="n">M_MAC_HDX_EN</span> <span class="o">|</span> <span class="n">V_MAC_FC_CMD_ENAB_FALSECARR</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">sbmac_fc_frame</span>:		<span class="cm">/* not valid in half duplex */</span>
		<span class="nl">default:</span>			<span class="cm">/* invalid selection */</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">sbmac_duplex_full</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">fc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">sbmac_fc_disabled</span>:
			<span class="n">cfg</span> <span class="o">|=</span> <span class="n">V_MAC_FC_CMD_DISABLED</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">sbmac_fc_frame</span>:
			<span class="n">cfg</span> <span class="o">|=</span> <span class="n">V_MAC_FC_CMD_ENABLED</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">sbmac_fc_collision</span>:	<span class="cm">/* not valid in full duplex */</span>
		<span class="k">case</span> <span class="n">sbmac_fc_carrier</span>:		<span class="cm">/* not valid in full duplex */</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Send the bits back to the hardware</span>
<span class="cm">	 */</span>

	<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sbm_maccfg</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>




<span class="cm">/**********************************************************************</span>
<span class="cm"> *  SBMAC_INTR()</span>
<span class="cm"> *</span>
<span class="cm"> *  Interrupt handler for MAC interrupts</span>
<span class="cm"> *</span>
<span class="cm"> *  Input parameters:</span>
<span class="cm"> *  	   MAC structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Return value:</span>
<span class="cm"> *  	   nothing</span>
<span class="cm"> ********************************************************************* */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">sbmac_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span><span class="kt">void</span> <span class="o">*</span><span class="n">dev_instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">)</span> <span class="n">dev_instance</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">uint64_t</span> <span class="n">isr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">handled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read the ISR (this clears the bits in the real</span>
<span class="cm">	 * register, except for counter addr)</span>
<span class="cm">	 */</span>

	<span class="n">isr</span> <span class="o">=</span> <span class="n">__raw_readq</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_isr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">M_MAC_COUNTER_ADDR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">isr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_RETVAL</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">handled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Transmits on channel 0</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">isr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">M_MAC_INT_CHANNEL</span> <span class="o">&lt;&lt;</span> <span class="n">S_MAC_TX_CH0</span><span class="p">))</span>
		<span class="n">sbdma_tx_process</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span><span class="o">&amp;</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_txdma</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">isr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">M_MAC_INT_CHANNEL</span> <span class="o">&lt;&lt;</span> <span class="n">S_MAC_RX_CH0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">napi_schedule_prep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_imr</span><span class="p">);</span>
			<span class="n">__napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
			<span class="cm">/* Depend on the exit from poll to reenable intr */</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* may leave some packets behind */</span>
			<span class="n">sbdma_rx_process</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span><span class="o">&amp;</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_rxdma</span><span class="p">),</span>
					 <span class="n">SBMAC_MAX_RXDESCR</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">IRQ_RETVAL</span><span class="p">(</span><span class="n">handled</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> *  SBMAC_START_TX(skb,dev)</span>
<span class="cm"> *</span>
<span class="cm"> *  Start output on the specified interface.  Basically, we</span>
<span class="cm"> *  queue as many buffers as we can until the ring fills up, or</span>
<span class="cm"> *  we run off the end of the queue, whichever comes first.</span>
<span class="cm"> *</span>
<span class="cm"> *  Input parameters:</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  Return value:</span>
<span class="cm"> *  	   nothing</span>
<span class="cm"> ********************************************************************* */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sbmac_start_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* lock eth irq */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Put the buffer on the transmit ring.  If we</span>
<span class="cm">	 * don&#39;t have room, stop the queue.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sbdma_add_txbuffer</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_txdma</span><span class="p">),</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* XXX save skb that we could not send */</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> *  SBMAC_SETMULTI(sc)</span>
<span class="cm"> *</span>
<span class="cm"> *  Reprogram the multicast table into the hardware, given</span>
<span class="cm"> *  the list of multicasts associated with the interface</span>
<span class="cm"> *  structure.</span>
<span class="cm"> *</span>
<span class="cm"> *  Input parameters:</span>
<span class="cm"> *  	   sc - softc</span>
<span class="cm"> *</span>
<span class="cm"> *  Return value:</span>
<span class="cm"> *  	   nothing</span>
<span class="cm"> ********************************************************************* */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sbmac_setmulti</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">reg</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_dev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear out entire multicast table.  We do this by nuking</span>
<span class="cm">	 * the entire hash table and all the direct matches except</span>
<span class="cm">	 * the first one, which is used for our station address</span>
<span class="cm">	 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">MAC_ADDR_COUNT</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">port</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_ADDR_BASE</span><span class="o">+</span><span class="p">(</span><span class="n">idx</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">));</span>
		<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">MAC_HASH_COUNT</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">port</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_HASH_BASE</span><span class="o">+</span><span class="p">(</span><span class="n">idx</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">));</span>
		<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear the filter to say we don&#39;t want any multicasts.</span>
<span class="cm">	 */</span>

	<span class="n">reg</span> <span class="o">=</span> <span class="n">__raw_readq</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_rxfilter</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">M_MAC_MCAST_INV</span> <span class="o">|</span> <span class="n">M_MAC_MCAST_EN</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_rxfilter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Enable ALL multicasts.  Do this by inverting the</span>
<span class="cm">		 * multicast enable bit.</span>
<span class="cm">		 */</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">__raw_readq</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_rxfilter</span><span class="p">);</span>
		<span class="n">reg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">M_MAC_MCAST_INV</span> <span class="o">|</span> <span class="n">M_MAC_MCAST_EN</span><span class="p">);</span>
		<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_rxfilter</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/*</span>
<span class="cm">	 * Progam new multicast entries.  For now, only use the</span>
<span class="cm">	 * perfect filter.  In the future we&#39;ll need to use the</span>
<span class="cm">	 * hash filter if the perfect filter overflows</span>
<span class="cm">	 */</span>

	<span class="cm">/* XXX only using perfect filter for now, need to use hash</span>
<span class="cm">	 * XXX if the table overflows */</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* skip station address */</span>
	<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="n">MAC_ADDR_COUNT</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">sbmac_addr2reg</span><span class="p">(</span><span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">port</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_ADDR_BASE</span><span class="o">+</span><span class="p">(</span><span class="n">idx</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">));</span>
		<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
		<span class="n">idx</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enable the &quot;accept multicast bits&quot; if we programmed at least one</span>
<span class="cm">	 * multicast.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">__raw_readq</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_rxfilter</span><span class="p">);</span>
		<span class="n">reg</span> <span class="o">|=</span> <span class="n">M_MAC_MCAST_EN</span><span class="p">;</span>
		<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_rxfilter</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sb1250_change_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">_dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_mtu</span> <span class="o">&gt;</span>  <span class="n">ENET_PACKET_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">_dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">new_mtu</span><span class="p">;</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;changing the mtu to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">new_mtu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">sbmac_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>		<span class="o">=</span> <span class="n">sbmac_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">sbmac_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">sbmac_start_tx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">sbmac_set_rx_mode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span>		<span class="o">=</span> <span class="n">sbmac_tx_timeout</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span>		<span class="o">=</span> <span class="n">sbmac_mii_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>		<span class="o">=</span> <span class="n">sb1250_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_validate_addr</span>	<span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span>	<span class="o">=</span> <span class="n">eth_mac_addr</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
	<span class="p">.</span><span class="n">ndo_poll_controller</span>	<span class="o">=</span> <span class="n">sbmac_netpoll</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> *  SBMAC_INIT(dev)</span>
<span class="cm"> *</span>
<span class="cm"> *  Attach routine - init hardware and hook ourselves into linux</span>
<span class="cm"> *</span>
<span class="cm"> *  Input parameters:</span>
<span class="cm"> *  	   dev - net_device structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Return value:</span>
<span class="cm"> *  	   status</span>
<span class="cm"> ********************************************************************* */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sbmac_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pldev</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pldev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">pldev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">eaddr</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">ea_reg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbe_idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>

	<span class="n">eaddr</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_hwaddr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read the ethernet address.  The firmware left this programmed</span>
<span class="cm">	 * for us in the ethernet address register for each mac.</span>
<span class="cm">	 */</span>

	<span class="n">ea_reg</span> <span class="o">=</span> <span class="n">__raw_readq</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_ETHERNET_ADDR</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_ETHERNET_ADDR</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eaddr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span> <span class="p">(</span><span class="n">ea_reg</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
		<span class="n">ea_reg</span> <span class="o">&gt;&gt;=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">eaddr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize context (get pointers to registers and stuff), then</span>
<span class="cm">	 * allocate the memory for the descriptor tables.</span>
<span class="cm">	 */</span>

	<span class="n">sbmac_initctx</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up Linux device callins</span>
<span class="cm">	 */</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_lock</span><span class="p">));</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sbmac_netdev_ops</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="n">TX_TIMEOUT</span><span class="p">;</span>

	<span class="n">netif_napi_add</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">,</span> <span class="n">sbmac_poll</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span>		<span class="o">=</span> <span class="n">UNIT_INT</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>

	<span class="cm">/* This is needed for PASS2 for Rx H/W checksum feature */</span>
	<span class="n">sbmac_set_iphdr_offset</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">mii_bus</span> <span class="o">=</span> <span class="n">mdiobus_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">mii_bus</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">uninit_ctx</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">sbmac_mdio_string</span><span class="p">;</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">MII_BUS_ID_SIZE</span><span class="p">,</span> <span class="s">&quot;%s-%x&quot;</span><span class="p">,</span>
		<span class="n">pldev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="n">sc</span><span class="p">;</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">=</span> <span class="n">sbmac_mii_read</span><span class="p">;</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">=</span> <span class="n">sbmac_mii_write</span><span class="p">;</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">phy_irq</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PHY_MAX_ADDR</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">SBMAC_PHY_INT</span><span class="p">;</span>

	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pldev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Probe PHY address</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">mdiobus_register</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: unable to register MDIO bus</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free_mdio</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pldev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s.%d: unable to register netdev</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">sbmac_string</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">unreg_mdio</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s.%d: registered as %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sbmac_string</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">rx_hw_checksum</span> <span class="o">==</span> <span class="n">ENABLE</span><span class="p">)</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: enabling TCP rcv checksum</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Display Ethernet address (this is called during the config</span>
<span class="cm">	 * process so we need to finish off the config message that</span>
<span class="cm">	 * was being displayed)</span>
<span class="cm">	 */</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: SiByte Ethernet at 0x%08Lx, address: %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">eaddr</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">unreg_mdio:</span>
	<span class="n">mdiobus_unregister</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="p">);</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pldev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="nl">free_mdio:</span>
	<span class="n">mdiobus_free</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="p">);</span>
<span class="nl">uninit_ctx:</span>
	<span class="n">sbmac_uninitctx</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">sbmac_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: sbmac_open() irq %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * map/route interrupt (clear status first, in case something</span>
<span class="cm">	 * weird is pending; we haven&#39;t initialized the mac registers</span>
<span class="cm">	 * yet)</span>
<span class="cm">	 */</span>

	<span class="n">__raw_readq</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_isr</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">sbmac_intr</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: unable to get IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_speed</span> <span class="o">=</span> <span class="n">sbmac_speed_none</span><span class="p">;</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_duplex</span> <span class="o">=</span> <span class="n">sbmac_duplex_none</span><span class="p">;</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_fc</span> <span class="o">=</span> <span class="n">sbmac_fc_none</span><span class="p">;</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_pause</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_link</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Attach to the PHY</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sbmac_mii_probe</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unregister</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Turn on the channel</span>
<span class="cm">	 */</span>

	<span class="n">sbmac_set_channel_state</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span><span class="n">sbmac_state_on</span><span class="p">);</span>

	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">sbmac_set_rx_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">phy_start</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">phy_dev</span><span class="p">);</span>

	<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_unregister:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="nl">out_err:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sbmac_mii_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phy_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PHY_MAX_ADDR</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phy_dev</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="o">-&gt;</span><span class="n">phy_map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phy_dev</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phy_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: no PHY found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">phy_dev</span> <span class="o">=</span> <span class="n">phy_connect</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phy_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">sbmac_mii_poll</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			      <span class="n">PHY_INTERFACE_MODE_GMII</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">phy_dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: could not attach to PHY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">phy_dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Remove any features not supported by the controller */</span>
	<span class="n">phy_dev</span><span class="o">-&gt;</span><span class="n">supported</span> <span class="o">&amp;=</span> <span class="n">SUPPORTED_10baseT_Half</span> <span class="o">|</span>
			      <span class="n">SUPPORTED_10baseT_Full</span> <span class="o">|</span>
			      <span class="n">SUPPORTED_100baseT_Half</span> <span class="o">|</span>
			      <span class="n">SUPPORTED_100baseT_Full</span> <span class="o">|</span>
			      <span class="n">SUPPORTED_1000baseT_Half</span> <span class="o">|</span>
			      <span class="n">SUPPORTED_1000baseT_Full</span> <span class="o">|</span>
			      <span class="n">SUPPORTED_Autoneg</span> <span class="o">|</span>
			      <span class="n">SUPPORTED_MII</span> <span class="o">|</span>
			      <span class="n">SUPPORTED_Pause</span> <span class="o">|</span>
			      <span class="n">SUPPORTED_Asym_Pause</span><span class="p">;</span>
	<span class="n">phy_dev</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">=</span> <span class="n">phy_dev</span><span class="o">-&gt;</span><span class="n">supported</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: attached PHY driver [%s] (mii_bus:phy_addr=%s, irq=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">phy_dev</span><span class="o">-&gt;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		<span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phy_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="n">phy_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">phy_dev</span> <span class="o">=</span> <span class="n">phy_dev</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">sbmac_mii_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phy_dev</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">phy_dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sbmac_fc</span> <span class="n">fc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">link_chg</span><span class="p">,</span> <span class="n">speed_chg</span><span class="p">,</span> <span class="n">duplex_chg</span><span class="p">,</span> <span class="n">pause_chg</span><span class="p">,</span> <span class="n">fc_chg</span><span class="p">;</span>

	<span class="n">link_chg</span> <span class="o">=</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_link</span> <span class="o">!=</span> <span class="n">phy_dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
	<span class="n">speed_chg</span> <span class="o">=</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_speed</span> <span class="o">!=</span> <span class="n">phy_dev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">);</span>
	<span class="n">duplex_chg</span> <span class="o">=</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_duplex</span> <span class="o">!=</span> <span class="n">phy_dev</span><span class="o">-&gt;</span><span class="n">duplex</span><span class="p">);</span>
	<span class="n">pause_chg</span> <span class="o">=</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_pause</span> <span class="o">!=</span> <span class="n">phy_dev</span><span class="o">-&gt;</span><span class="n">pause</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">link_chg</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">speed_chg</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">duplex_chg</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pause_chg</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>					<span class="cm">/* Hmmm... */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phy_dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">link_chg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_link</span> <span class="o">=</span> <span class="n">phy_dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_speed</span> <span class="o">=</span> <span class="n">sbmac_speed_none</span><span class="p">;</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_duplex</span> <span class="o">=</span> <span class="n">sbmac_duplex_none</span><span class="p">;</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_fc</span> <span class="o">=</span> <span class="n">sbmac_fc_disabled</span><span class="p">;</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_pause</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: link unavailable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phy_dev</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">==</span> <span class="n">DUPLEX_FULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phy_dev</span><span class="o">-&gt;</span><span class="n">pause</span><span class="p">)</span>
			<span class="n">fc</span> <span class="o">=</span> <span class="n">sbmac_fc_frame</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">fc</span> <span class="o">=</span> <span class="n">sbmac_fc_disabled</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">fc</span> <span class="o">=</span> <span class="n">sbmac_fc_collision</span><span class="p">;</span>
	<span class="n">fc_chg</span> <span class="o">=</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_fc</span> <span class="o">!=</span> <span class="n">fc</span><span class="p">);</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: link available: %dbase-%cD</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">phy_dev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">,</span>
		<span class="n">phy_dev</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">==</span> <span class="n">DUPLEX_FULL</span> <span class="o">?</span> <span class="sc">&#39;F&#39;</span> <span class="o">:</span> <span class="sc">&#39;H&#39;</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_speed</span> <span class="o">=</span> <span class="n">phy_dev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">;</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_duplex</span> <span class="o">=</span> <span class="n">phy_dev</span><span class="o">-&gt;</span><span class="n">duplex</span><span class="p">;</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_fc</span> <span class="o">=</span> <span class="n">fc</span><span class="p">;</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_pause</span> <span class="o">=</span> <span class="n">phy_dev</span><span class="o">-&gt;</span><span class="n">pause</span><span class="p">;</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_link</span> <span class="o">=</span> <span class="n">phy_dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">speed_chg</span> <span class="o">||</span> <span class="n">duplex_chg</span> <span class="o">||</span> <span class="n">fc_chg</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_state</span> <span class="o">!=</span> <span class="n">sbmac_state_off</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * something changed, restart the channel</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: restarting channel &quot;</span>
				 <span class="s">&quot;because PHY state changed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">sbmac_channel_stop</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
		<span class="n">sbmac_channel_start</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">sbmac_tx_timeout</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>


	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span> <span class="cm">/* prevent tx timeout */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: Transmit timed out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>




<span class="k">static</span> <span class="kt">void</span> <span class="nf">sbmac_set_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">^</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_devflags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Promiscuous changed.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sbmac_promiscuous_mode</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">sbmac_promiscuous_mode</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Program the multicasts.  Do this every time.</span>
<span class="cm">	 */</span>

	<span class="n">sbmac_setmulti</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sbmac_mii_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">phy_dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">phy_mii_ioctl</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">phy_dev</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sbmac_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

	<span class="n">phy_stop</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">phy_dev</span><span class="p">);</span>

	<span class="n">sbmac_set_channel_state</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">sbmac_state_off</span><span class="p">);</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: Shutting down ethercard</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">phy_disconnect</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">phy_dev</span><span class="p">);</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">phy_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">sbdma_emptyring</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_txdma</span><span class="p">));</span>
	<span class="n">sbdma_emptyring</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_rxdma</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sbmac_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sbmac_softc</span><span class="p">,</span> <span class="n">napi</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">work_done</span><span class="p">;</span>

	<span class="n">work_done</span> <span class="o">=</span> <span class="n">sbdma_rx_process</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_rxdma</span><span class="p">),</span> <span class="n">budget</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">sbdma_tx_process</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_txdma</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">work_done</span> <span class="o">&lt;</span> <span class="n">budget</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SBMAC_COALESCE</span>
		<span class="n">__raw_writeq</span><span class="p">(((</span><span class="n">M_MAC_INT_EOP_COUNT</span> <span class="o">|</span> <span class="n">M_MAC_INT_EOP_TIMER</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">S_MAC_TX_CH0</span><span class="p">)</span> <span class="o">|</span>
			     <span class="p">((</span><span class="n">M_MAC_INT_EOP_COUNT</span> <span class="o">|</span> <span class="n">M_MAC_INT_EOP_TIMER</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">S_MAC_RX_CH0</span><span class="p">),</span>
			     <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_imr</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="n">__raw_writeq</span><span class="p">((</span><span class="n">M_MAC_INT_CHANNEL</span> <span class="o">&lt;&lt;</span> <span class="n">S_MAC_TX_CH0</span><span class="p">)</span> <span class="o">|</span>
			     <span class="p">(</span><span class="n">M_MAC_INT_CHANNEL</span> <span class="o">&lt;&lt;</span> <span class="n">S_MAC_RX_CH0</span><span class="p">),</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_imr</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">work_done</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">sbmac_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pldev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">sbm_base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">sbmac_orig_hwaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pldev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">);</span>
	<span class="n">sbm_base</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sbm_base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: unable to map device registers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pldev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The R_MAC_ETHERNET_ADDR register will be set to some nonzero</span>
<span class="cm">	 * value for us by the firmware if we&#39;re going to use this MAC.</span>
<span class="cm">	 * If we find a zero, skip this MAC.</span>
<span class="cm">	 */</span>
	<span class="n">sbmac_orig_hwaddr</span> <span class="o">=</span> <span class="n">__raw_readq</span><span class="p">(</span><span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_ETHERNET_ADDR</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: %sconfiguring MAC at 0x%08Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pldev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span>
		 <span class="n">sbmac_orig_hwaddr</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;not &quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbmac_orig_hwaddr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unmap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Okay, cool.  Initialize this MAC.</span>
<span class="cm">	 */</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_etherdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sbmac_softc</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unmap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pldev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pldev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">sc</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_base</span> <span class="o">=</span> <span class="n">sbm_base</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sbmac_init</span><span class="p">(</span><span class="n">pldev</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_kfree</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_kfree:</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">sbmac_orig_hwaddr</span><span class="p">,</span> <span class="n">sbm_base</span> <span class="o">+</span> <span class="n">R_MAC_ETHERNET_ADDR</span><span class="p">);</span>

<span class="nl">out_unmap:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">sbm_base</span><span class="p">);</span>

<span class="nl">out_out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__exit</span> <span class="nf">sbmac_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pldev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pldev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sbmac_softc</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">sbmac_uninitctx</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="n">mdiobus_unregister</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="p">);</span>
	<span class="n">mdiobus_free</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sbm_base</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">sbmac_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">sbmac_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">__exit_p</span><span class="p">(</span><span class="n">sbmac_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">sbmac_string</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span>  <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="n">module_platform_driver</span><span class="p">(</span><span class="n">sbmac_driver</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
