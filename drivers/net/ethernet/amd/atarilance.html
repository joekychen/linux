<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › amd › atarilance.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>atarilance.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* atarilance.c: Ethernet driver for VME Lance cards on the Atari */</span>
<span class="cm">/*</span>
<span class="cm">	Written 1995/96 by Roman Hodek (Roman.Hodek@informatik.uni-erlangen.de)</span>

<span class="cm">	This software may be used and distributed according to the terms</span>
<span class="cm">	of the GNU General Public License, incorporated herein by reference.</span>

<span class="cm">	This drivers was written with the following sources of reference:</span>
<span class="cm">	 - The driver for the Riebl Lance card by the TU Vienna.</span>
<span class="cm">	 - The modified TUW driver for PAM&#39;s VME cards</span>
<span class="cm">	 - The PC-Linux driver for Lance cards (but this is for bus master</span>
<span class="cm">       cards, not the shared memory ones)</span>
<span class="cm">	 - The Amiga Ariadne driver</span>

<span class="cm">	v1.0: (in 1.2.13pl4/0.9.13)</span>
<span class="cm">	      Initial version</span>
<span class="cm">	v1.1: (in 1.2.13pl5)</span>
<span class="cm">	      more comments</span>
<span class="cm">		  deleted some debugging stuff</span>
<span class="cm">		  optimized register access (keep AREG pointing to CSR0)</span>
<span class="cm">		  following AMD, CSR0_STRT should be set only after IDON is detected</span>
<span class="cm">		  use memcpy() for data transfers, that also employs long word moves</span>
<span class="cm">		  better probe procedure for 24-bit systems</span>
<span class="cm">          non-VME-RieblCards need extra delays in memcpy</span>
<span class="cm">		  must also do write test, since 0xfxe00000 may hit ROM</span>
<span class="cm">		  use 8/32 tx/rx buffers, which should give better NFS performance;</span>
<span class="cm">		    this is made possible by shifting the last packet buffer after the</span>
<span class="cm">		    RieblCard reserved area</span>
<span class="cm">    v1.2: (in 1.2.13pl8)</span>
<span class="cm">	      again fixed probing for the Falcon; 0xfe01000 hits phys. 0x00010000</span>
<span class="cm">		  and thus RAM, in case of no Lance found all memory contents have to</span>
<span class="cm">		  be restored!</span>
<span class="cm">		  Now possible to compile as module.</span>
<span class="cm">	v1.3: 03/30/96 Jes Sorensen, Roman (in 1.3)</span>
<span class="cm">	      Several little 1.3 adaptions</span>
<span class="cm">		  When the lance is stopped it jumps back into little-endian</span>
<span class="cm">		  mode. It is therefore necessary to put it back where it</span>
<span class="cm">		  belongs, in big endian mode, in order to make things work.</span>
<span class="cm">		  This might be the reason why multicast-mode didn&#39;t work</span>
<span class="cm">		  before, but I&#39;m not able to test it as I only got an Amiga</span>
<span class="cm">		  (we had similar problems with the A2065 driver).</span>

<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">version</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;atarilance.c: v1.3 04/04/96 &quot;</span>
					   <span class="s">&quot;Roman.Hodek@informatik.uni-erlangen.de</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/stddef.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>

<span class="cp">#include &lt;asm/setup.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/atarihw.h&gt;</span>
<span class="cp">#include &lt;asm/atariints.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="cm">/* Debug level:</span>
<span class="cm"> *  0 = silent, print only serious errors</span>
<span class="cm"> *  1 = normal, print error messages</span>
<span class="cm"> *  2 = debug, print debug infos</span>
<span class="cm"> *  3 = debug, print even more debug infos (packet data)</span>
<span class="cm"> */</span>

<span class="cp">#define	LANCE_DEBUG	1</span>

<span class="cp">#ifdef LANCE_DEBUG</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lance_debug</span> <span class="o">=</span> <span class="n">LANCE_DEBUG</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lance_debug</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">lance_debug</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">lance_debug</span><span class="p">,</span> <span class="s">&quot;atarilance debug level (0-3)&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="cm">/* Print debug messages on probing? */</span>
<span class="cp">#undef LANCE_DEBUG_PROBE</span>

<span class="cp">#define	DPRINTK(n,a)							\</span>
<span class="cp">	do {										\</span>
<span class="cp">		if (lance_debug &gt;= n)					\</span>
<span class="cp">			printk a;							\</span>
<span class="cp">	} while( 0 )</span>

<span class="cp">#ifdef LANCE_DEBUG_PROBE</span>
<span class="cp"># define PROBE_PRINT(a)	printk a</span>
<span class="cp">#else</span>
<span class="cp"># define PROBE_PRINT(a)</span>
<span class="cp">#endif</span>

<span class="cm">/* These define the number of Rx and Tx buffers as log2. (Only powers</span>
<span class="cm"> * of two are valid)</span>
<span class="cm"> * Much more rx buffers (32) are reserved than tx buffers (8), since receiving</span>
<span class="cm"> * is more time critical then sending and packets may have to remain in the</span>
<span class="cm"> * board&#39;s memory when main memory is low.</span>
<span class="cm"> */</span>

<span class="cp">#define TX_LOG_RING_SIZE			3</span>
<span class="cp">#define RX_LOG_RING_SIZE			5</span>

<span class="cm">/* These are the derived values */</span>

<span class="cp">#define TX_RING_SIZE			(1 &lt;&lt; TX_LOG_RING_SIZE)</span>
<span class="cp">#define TX_RING_LEN_BITS		(TX_LOG_RING_SIZE &lt;&lt; 5)</span>
<span class="cp">#define	TX_RING_MOD_MASK		(TX_RING_SIZE - 1)</span>

<span class="cp">#define RX_RING_SIZE			(1 &lt;&lt; RX_LOG_RING_SIZE)</span>
<span class="cp">#define RX_RING_LEN_BITS		(RX_LOG_RING_SIZE &lt;&lt; 5)</span>
<span class="cp">#define	RX_RING_MOD_MASK		(RX_RING_SIZE - 1)</span>

<span class="cp">#define TX_TIMEOUT	(HZ/5)</span>

<span class="cm">/* The LANCE Rx and Tx ring descriptors. */</span>
<span class="k">struct</span> <span class="n">lance_rx_head</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>			<span class="n">base</span><span class="p">;</span>		<span class="cm">/* Low word of base addr */</span>
	<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">flag</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>			<span class="n">base_hi</span><span class="p">;</span>	<span class="cm">/* High word of base addr (unused) */</span>
	<span class="kt">short</span>					<span class="n">buf_length</span><span class="p">;</span>	<span class="cm">/* This length is 2s complement! */</span>
	<span class="k">volatile</span> <span class="kt">short</span>			<span class="n">msg_length</span><span class="p">;</span>	<span class="cm">/* This length is &quot;normal&quot;. */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">lance_tx_head</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>			<span class="n">base</span><span class="p">;</span>		<span class="cm">/* Low word of base addr */</span>
	<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">flag</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>			<span class="n">base_hi</span><span class="p">;</span>	<span class="cm">/* High word of base addr (unused) */</span>
	<span class="kt">short</span>					<span class="n">length</span><span class="p">;</span>		<span class="cm">/* Length is 2s complement! */</span>
	<span class="k">volatile</span> <span class="kt">short</span>			<span class="n">misc</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ringdesc</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">adr_lo</span><span class="p">;</span>		<span class="cm">/* Low 16 bits of address */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">len</span><span class="p">;</span>		<span class="cm">/* Length bits */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">adr_hi</span><span class="p">;</span>		<span class="cm">/* High 8 bits of address (unused) */</span>
<span class="p">};</span>

<span class="cm">/* The LANCE initialization block, described in databook. */</span>
<span class="k">struct</span> <span class="n">lance_init_block</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">mode</span><span class="p">;</span>		<span class="cm">/* Pre-set mode */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">hwaddr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>	<span class="cm">/* Physical ethernet address */</span>
	<span class="kt">unsigned</span>		<span class="n">filter</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* Multicast filter (unused). */</span>
	<span class="cm">/* Receive and transmit ring base, along with length bits. */</span>
	<span class="k">struct</span> <span class="n">ringdesc</span>	<span class="n">rx_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ringdesc</span>	<span class="n">tx_ring</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* The whole layout of the Lance shared memory */</span>
<span class="k">struct</span> <span class="n">lance_memory</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">lance_init_block</span>	<span class="n">init</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lance_tx_head</span>	<span class="n">tx_head</span><span class="p">[</span><span class="n">TX_RING_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">lance_rx_head</span>	<span class="n">rx_head</span><span class="p">[</span><span class="n">RX_RING_SIZE</span><span class="p">];</span>
	<span class="kt">char</span>					<span class="n">packet_area</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* packet data follow after the</span>
<span class="cm">											 * init block and the ring</span>
<span class="cm">											 * descriptors and are located</span>
<span class="cm">											 * at runtime */</span>
<span class="p">};</span>

<span class="cm">/* RieblCard specifics:</span>
<span class="cm"> * The original TOS driver for these cards reserves the area from offset</span>
<span class="cm"> * 0xee70 to 0xeebb for storing configuration data. Of interest to us is the</span>
<span class="cm"> * Ethernet address there, and the magic for verifying the data&#39;s validity.</span>
<span class="cm"> * The reserved area isn&#39;t touch by packet buffers. Furthermore, offset 0xfffe</span>
<span class="cm"> * is reserved for the interrupt vector number.</span>
<span class="cm"> */</span>
<span class="cp">#define	RIEBL_RSVD_START	0xee70</span>
<span class="cp">#define	RIEBL_RSVD_END		0xeec0</span>
<span class="cp">#define RIEBL_MAGIC			0x09051990</span>
<span class="cp">#define RIEBL_MAGIC_ADDR	((unsigned long *)(((char *)MEM) + 0xee8a))</span>
<span class="cp">#define RIEBL_HWADDR_ADDR	((unsigned char *)(((char *)MEM) + 0xee8e))</span>
<span class="cp">#define RIEBL_IVEC_ADDR		((unsigned short *)(((char *)MEM) + 0xfffe))</span>

<span class="cm">/* This is a default address for the old RieblCards without a battery</span>
<span class="cm"> * that have no ethernet address at boot time. 00:00:36:04 is the</span>
<span class="cm"> * prefix for Riebl cards, the 00:00 at the end is arbitrary.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">OldRieblDefHwaddr</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x36</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span>
<span class="p">};</span>


<span class="cm">/* I/O registers of the Lance chip */</span>

<span class="k">struct</span> <span class="n">lance_ioreg</span> <span class="p">{</span>
<span class="cm">/* base+0x0 */</span>	<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">data</span><span class="p">;</span>
<span class="cm">/* base+0x2 */</span>	<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">addr</span><span class="p">;</span>
				<span class="kt">unsigned</span> <span class="kt">char</span>			<span class="n">_dummy1</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="cm">/* base+0x7 */</span>	<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">ivec</span><span class="p">;</span>
				<span class="kt">unsigned</span> <span class="kt">char</span>			<span class="n">_dummy2</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="cm">/* base+0xd */</span>	<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">eeprom</span><span class="p">;</span>
				<span class="kt">unsigned</span> <span class="kt">char</span>			<span class="n">_dummy3</span><span class="p">;</span>
<span class="cm">/* base+0xf */</span>	<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">mem</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Types of boards this driver supports */</span>

<span class="k">enum</span> <span class="n">lance_type</span> <span class="p">{</span>
	<span class="n">OLD_RIEBL</span><span class="p">,</span>		<span class="cm">/* old Riebl card without battery */</span>
	<span class="n">NEW_RIEBL</span><span class="p">,</span>		<span class="cm">/* new Riebl card with battery */</span>
	<span class="n">PAM_CARD</span>		<span class="cm">/* PAM card with EEPROM */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">lance_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;Riebl-Card (without battery)&quot;</span><span class="p">,</span>
	<span class="s">&quot;Riebl-Card (with battery)&quot;</span><span class="p">,</span>
	<span class="s">&quot;PAM intern card&quot;</span>
<span class="p">};</span>

<span class="cm">/* The driver&#39;s private device structure */</span>

<span class="k">struct</span> <span class="n">lance_private</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">lance_type</span>		<span class="n">cardtype</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lance_ioreg</span>	<span class="o">*</span><span class="n">iobase</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lance_memory</span>	<span class="o">*</span><span class="n">mem</span><span class="p">;</span>
	<span class="kt">int</span>		 	<span class="n">cur_rx</span><span class="p">,</span> <span class="n">cur_tx</span><span class="p">;</span>	<span class="cm">/* The next free ring entry */</span>
	<span class="kt">int</span>			<span class="n">dirty_tx</span><span class="p">;</span>		<span class="cm">/* Ring entries to be freed. */</span>
				<span class="cm">/* copy function */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">memcpy_f</span><span class="p">)(</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span> <span class="p">);</span>
<span class="cm">/* This must be long for set_bit() */</span>
	<span class="kt">long</span>			<span class="n">tx_full</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">devlock</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* I/O register access macros */</span>

<span class="cp">#define	MEM		lp-&gt;mem</span>
<span class="cp">#define	DREG	IO-&gt;data</span>
<span class="cp">#define	AREG	IO-&gt;addr</span>
<span class="cp">#define	REGA(a)	(*( AREG = (a), &amp;DREG ))</span>

<span class="cm">/* Definitions for packet buffer access: */</span>
<span class="cp">#define PKT_BUF_SZ		1544</span>
<span class="cm">/* Get the address of a packet buffer corresponding to a given buffer head */</span>
<span class="cp">#define	PKTBUF_ADDR(head)	(((unsigned char *)(MEM)) + (head)-&gt;base)</span>

<span class="cm">/* Possible memory/IO addresses for probing */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">lance_addr</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">memaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">ioaddr</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">slow_flag</span><span class="p">;</span>
<span class="p">}</span> <span class="n">lance_addr_list</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="mh">0xfe010000</span><span class="p">,</span> <span class="mh">0xfe00fff0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>	<span class="cm">/* RieblCard VME in TT */</span>
	<span class="p">{</span> <span class="mh">0xffc10000</span><span class="p">,</span> <span class="mh">0xffc0fff0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>	<span class="cm">/* RieblCard VME in MegaSTE</span>
<span class="cm">									   (highest byte stripped) */</span>
	<span class="p">{</span> <span class="mh">0xffe00000</span><span class="p">,</span> <span class="mh">0xffff7000</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* RieblCard in ST</span>
<span class="cm">									   (highest byte stripped) */</span>
	<span class="p">{</span> <span class="mh">0xffd00000</span><span class="p">,</span> <span class="mh">0xffff7000</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* RieblCard in ST with hw modif. to</span>
<span class="cm">									   avoid conflict with ROM</span>
<span class="cm">									   (highest byte stripped) */</span>
	<span class="p">{</span> <span class="mh">0xffcf0000</span><span class="p">,</span> <span class="mh">0xffcffff0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>	<span class="cm">/* PAMCard VME in TT and MSTE</span>
<span class="cm">									   (highest byte stripped) */</span>
	<span class="p">{</span> <span class="mh">0xfecf0000</span><span class="p">,</span> <span class="mh">0xfecffff0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>	<span class="cm">/* Rhotron&#39;s PAMCard VME in TT and MSTE</span>
<span class="cm">									   (highest byte stripped) */</span>
<span class="p">};</span>

<span class="cp">#define	N_LANCE_ADDR	ARRAY_SIZE(lance_addr_list)</span>


<span class="cm">/* Definitions for the Lance */</span>

<span class="cm">/* tx_head flags */</span>
<span class="cp">#define TMD1_ENP		0x01	</span><span class="cm">/* end of packet */</span><span class="cp"></span>
<span class="cp">#define TMD1_STP		0x02	</span><span class="cm">/* start of packet */</span><span class="cp"></span>
<span class="cp">#define TMD1_DEF		0x04	</span><span class="cm">/* deferred */</span><span class="cp"></span>
<span class="cp">#define TMD1_ONE		0x08	</span><span class="cm">/* one retry needed */</span><span class="cp"></span>
<span class="cp">#define TMD1_MORE		0x10	</span><span class="cm">/* more than one retry needed */</span><span class="cp"></span>
<span class="cp">#define TMD1_ERR		0x40	</span><span class="cm">/* error summary */</span><span class="cp"></span>
<span class="cp">#define TMD1_OWN 		0x80	</span><span class="cm">/* ownership (set: chip owns) */</span><span class="cp"></span>

<span class="cp">#define TMD1_OWN_CHIP	TMD1_OWN</span>
<span class="cp">#define TMD1_OWN_HOST	0</span>

<span class="cm">/* tx_head misc field */</span>
<span class="cp">#define TMD3_TDR		0x03FF	</span><span class="cm">/* Time Domain Reflectometry counter */</span><span class="cp"></span>
<span class="cp">#define TMD3_RTRY		0x0400	</span><span class="cm">/* failed after 16 retries */</span><span class="cp"></span>
<span class="cp">#define TMD3_LCAR		0x0800	</span><span class="cm">/* carrier lost */</span><span class="cp"></span>
<span class="cp">#define TMD3_LCOL		0x1000	</span><span class="cm">/* late collision */</span><span class="cp"></span>
<span class="cp">#define TMD3_UFLO		0x4000	</span><span class="cm">/* underflow (late memory) */</span><span class="cp"></span>
<span class="cp">#define TMD3_BUFF		0x8000	</span><span class="cm">/* buffering error (no ENP) */</span><span class="cp"></span>

<span class="cm">/* rx_head flags */</span>
<span class="cp">#define RMD1_ENP		0x01	</span><span class="cm">/* end of packet */</span><span class="cp"></span>
<span class="cp">#define RMD1_STP		0x02	</span><span class="cm">/* start of packet */</span><span class="cp"></span>
<span class="cp">#define RMD1_BUFF		0x04	</span><span class="cm">/* buffer error */</span><span class="cp"></span>
<span class="cp">#define RMD1_CRC		0x08	</span><span class="cm">/* CRC error */</span><span class="cp"></span>
<span class="cp">#define RMD1_OFLO		0x10	</span><span class="cm">/* overflow */</span><span class="cp"></span>
<span class="cp">#define RMD1_FRAM		0x20	</span><span class="cm">/* framing error */</span><span class="cp"></span>
<span class="cp">#define RMD1_ERR		0x40	</span><span class="cm">/* error summary */</span><span class="cp"></span>
<span class="cp">#define RMD1_OWN 		0x80	</span><span class="cm">/* ownership (set: ship owns) */</span><span class="cp"></span>

<span class="cp">#define RMD1_OWN_CHIP	RMD1_OWN</span>
<span class="cp">#define RMD1_OWN_HOST	0</span>

<span class="cm">/* register names */</span>
<span class="cp">#define CSR0	0		</span><span class="cm">/* mode/status */</span><span class="cp"></span>
<span class="cp">#define CSR1	1		</span><span class="cm">/* init block addr (low) */</span><span class="cp"></span>
<span class="cp">#define CSR2	2		</span><span class="cm">/* init block addr (high) */</span><span class="cp"></span>
<span class="cp">#define CSR3	3		</span><span class="cm">/* misc */</span><span class="cp"></span>
<span class="cp">#define CSR8	8	  	</span><span class="cm">/* address filter */</span><span class="cp"></span>
<span class="cp">#define CSR15	15		</span><span class="cm">/* promiscuous mode */</span><span class="cp"></span>

<span class="cm">/* CSR0 */</span>
<span class="cm">/* (R=readable, W=writeable, S=set on write, C=clear on write) */</span>
<span class="cp">#define CSR0_INIT	0x0001		</span><span class="cm">/* initialize (RS) */</span><span class="cp"></span>
<span class="cp">#define CSR0_STRT	0x0002		</span><span class="cm">/* start (RS) */</span><span class="cp"></span>
<span class="cp">#define CSR0_STOP	0x0004		</span><span class="cm">/* stop (RS) */</span><span class="cp"></span>
<span class="cp">#define CSR0_TDMD	0x0008		</span><span class="cm">/* transmit demand (RS) */</span><span class="cp"></span>
<span class="cp">#define CSR0_TXON	0x0010		</span><span class="cm">/* transmitter on (R) */</span><span class="cp"></span>
<span class="cp">#define CSR0_RXON	0x0020		</span><span class="cm">/* receiver on (R) */</span><span class="cp"></span>
<span class="cp">#define CSR0_INEA	0x0040		</span><span class="cm">/* interrupt enable (RW) */</span><span class="cp"></span>
<span class="cp">#define CSR0_INTR	0x0080		</span><span class="cm">/* interrupt active (R) */</span><span class="cp"></span>
<span class="cp">#define CSR0_IDON	0x0100		</span><span class="cm">/* initialization done (RC) */</span><span class="cp"></span>
<span class="cp">#define CSR0_TINT	0x0200		</span><span class="cm">/* transmitter interrupt (RC) */</span><span class="cp"></span>
<span class="cp">#define CSR0_RINT	0x0400		</span><span class="cm">/* receiver interrupt (RC) */</span><span class="cp"></span>
<span class="cp">#define CSR0_MERR	0x0800		</span><span class="cm">/* memory error (RC) */</span><span class="cp"></span>
<span class="cp">#define CSR0_MISS	0x1000		</span><span class="cm">/* missed frame (RC) */</span><span class="cp"></span>
<span class="cp">#define CSR0_CERR	0x2000		</span><span class="cm">/* carrier error (no heartbeat :-) (RC) */</span><span class="cp"></span>
<span class="cp">#define CSR0_BABL	0x4000		</span><span class="cm">/* babble: tx-ed too many bits (RC) */</span><span class="cp"></span>
<span class="cp">#define CSR0_ERR	0x8000		</span><span class="cm">/* error (RC) */</span><span class="cp"></span>

<span class="cm">/* CSR3 */</span>
<span class="cp">#define CSR3_BCON	0x0001		</span><span class="cm">/* byte control */</span><span class="cp"></span>
<span class="cp">#define CSR3_ACON	0x0002		</span><span class="cm">/* ALE control */</span><span class="cp"></span>
<span class="cp">#define CSR3_BSWP	0x0004		</span><span class="cm">/* byte swap (1=big endian) */</span><span class="cp"></span>



<span class="cm">/***************************** Prototypes *****************************/</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lance_probe1</span><span class="p">(</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lance_addr</span>
                                   <span class="o">*</span><span class="n">init_rec</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lance_open</span><span class="p">(</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">lance_init_ring</span><span class="p">(</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lance_start_xmit</span><span class="p">(</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">lance_interrupt</span><span class="p">(</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lance_rx</span><span class="p">(</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lance_close</span><span class="p">(</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">set_multicast_list</span><span class="p">(</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lance_set_mac_address</span><span class="p">(</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">lance_tx_timeout</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/************************* End of Prototypes **************************/</span>





<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">slow_memcpy</span><span class="p">(</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span> <span class="p">)</span>

<span class="p">{</span>	<span class="kt">char</span> <span class="o">*</span><span class="n">cto</span> <span class="o">=</span> <span class="n">dst</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cfrom</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>

	<span class="k">while</span><span class="p">(</span> <span class="n">len</span><span class="o">--</span> <span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">cto</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">cfrom</span><span class="o">++</span><span class="p">;</span>
		<span class="n">MFPDELAY</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dst</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">atarilance_probe</span><span class="p">(</span><span class="kt">int</span> <span class="n">unit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">found</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MACH_IS_ATARI</span> <span class="o">||</span> <span class="n">found</span><span class="p">)</span>
		<span class="cm">/* Assume there&#39;s only one board possible... That seems true, since</span>
<span class="cm">		 * the Riebl/PAM board&#39;s address cannot be changed. */</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_etherdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lance_private</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unit</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;eth%d&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="p">);</span>
		<span class="n">netdev_boot_setup_check</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_LANCE_ADDR</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lance_probe1</span><span class="p">(</span> <span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lance_addr_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">))</span> <span class="p">{</span>
			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
			<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* Derived from hwreg_present() in atari/config.c: */</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">addr_accessible</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">void</span> <span class="o">*</span><span class="n">regp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wordflag</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">writeflag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="kt">long</span>	<span class="o">*</span><span class="n">vbr</span><span class="p">,</span> <span class="n">save_berr</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span> <span class="s">&quot;movec	%/vbr,%0&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">vbr</span><span class="p">)</span> <span class="o">:</span> <span class="p">);</span>
	<span class="n">save_berr</span> <span class="o">=</span> <span class="n">vbr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span>
	<span class="p">(</span>	<span class="s">&quot;movel	%/sp,%/d1</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;movel	#Lberr,%2@</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;moveq	#0,%0</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;tstl   %3</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;bne	1f</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;moveb	%1@,%/d0</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;nop	</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;bra	2f</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;1:		 movew	%1@,%/d0</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;nop	</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;2:		 tstl   %4</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;beq	2f</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;tstl	%3</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;bne	1f</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;clrb	%1@</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;nop	</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;moveb	%/d0,%1@</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;nop	</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;bra	2f</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;1:		 clrw	%1@</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;nop	</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;movew	%/d0,%1@</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;nop	</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;2:		 moveq	#1,%0</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;Lberr:	 movel	%/d1,%/sp&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=&amp;d&quot;</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;a&quot;</span> <span class="p">(</span><span class="n">regp</span><span class="p">),</span> <span class="s">&quot;a&quot;</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">vbr</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="s">&quot;rm&quot;</span> <span class="p">(</span><span class="n">wordflag</span><span class="p">),</span> <span class="s">&quot;rm&quot;</span> <span class="p">(</span><span class="n">writeflag</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;d0&quot;</span><span class="p">,</span> <span class="s">&quot;d1&quot;</span><span class="p">,</span> <span class="s">&quot;memory&quot;</span>
	<span class="p">);</span>

	<span class="n">vbr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">save_berr</span><span class="p">;</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">lance_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>		<span class="o">=</span> <span class="n">lance_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">lance_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">lance_start_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">set_multicast_list</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span>	<span class="o">=</span> <span class="n">lance_set_mac_address</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span>		<span class="o">=</span> <span class="n">lance_tx_timeout</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_validate_addr</span>	<span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>		<span class="o">=</span> <span class="n">eth_change_mtu</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init</span> <span class="nf">lance_probe1</span><span class="p">(</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">lance_addr</span> <span class="o">*</span><span class="n">init_rec</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="n">memaddr</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="p">)</span><span class="n">init_rec</span><span class="o">-&gt;</span><span class="n">memaddr</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="p">)</span><span class="n">init_rec</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lance_private</span>	<span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lance_ioreg</span>		<span class="o">*</span><span class="n">IO</span><span class="p">;</span>
	<span class="kt">int</span> 					<span class="n">i</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> 				<span class="n">did_version</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>			<span class="n">save1</span><span class="p">,</span> <span class="n">save2</span><span class="p">;</span>

	<span class="n">PROBE_PRINT</span><span class="p">((</span> <span class="s">&quot;Probing for Lance card at mem %#lx io %#lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">memaddr</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">ioaddr</span> <span class="p">));</span>

	<span class="cm">/* Test whether memory readable and writable */</span>
	<span class="n">PROBE_PRINT</span><span class="p">((</span> <span class="s">&quot;lance_probe1: testing memory to be accessible</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr_accessible</span><span class="p">(</span> <span class="n">memaddr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="p">))</span> <span class="k">goto</span> <span class="n">probe_fail</span><span class="p">;</span>

	<span class="cm">/* Written values should come back... */</span>
	<span class="n">PROBE_PRINT</span><span class="p">((</span> <span class="s">&quot;lance_probe1: testing memory to be writable (1)</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">));</span>
	<span class="n">save1</span> <span class="o">=</span> <span class="o">*</span><span class="n">memaddr</span><span class="p">;</span>
	<span class="o">*</span><span class="n">memaddr</span> <span class="o">=</span> <span class="mh">0x0001</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">memaddr</span> <span class="o">!=</span> <span class="mh">0x0001</span><span class="p">)</span> <span class="k">goto</span> <span class="n">probe_fail</span><span class="p">;</span>
	<span class="n">PROBE_PRINT</span><span class="p">((</span> <span class="s">&quot;lance_probe1: testing memory to be writable (2)</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">));</span>
	<span class="o">*</span><span class="n">memaddr</span> <span class="o">=</span> <span class="mh">0x0000</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">memaddr</span> <span class="o">!=</span> <span class="mh">0x0000</span><span class="p">)</span> <span class="k">goto</span> <span class="n">probe_fail</span><span class="p">;</span>
	<span class="o">*</span><span class="n">memaddr</span> <span class="o">=</span> <span class="n">save1</span><span class="p">;</span>

	<span class="cm">/* First port should be readable and writable */</span>
	<span class="n">PROBE_PRINT</span><span class="p">((</span> <span class="s">&quot;lance_probe1: testing ioport to be accessible</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr_accessible</span><span class="p">(</span> <span class="n">ioaddr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="p">))</span> <span class="k">goto</span> <span class="n">probe_fail</span><span class="p">;</span>

	<span class="cm">/* and written values should be readable */</span>
	<span class="n">PROBE_PRINT</span><span class="p">((</span> <span class="s">&quot;lance_probe1: testing ioport to be writeable</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">));</span>
	<span class="n">save2</span> <span class="o">=</span> <span class="n">ioaddr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">ioaddr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0001</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioaddr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0x0001</span><span class="p">)</span> <span class="k">goto</span> <span class="n">probe_fail</span><span class="p">;</span>

	<span class="cm">/* The CSR0_INIT bit should not be readable */</span>
	<span class="n">PROBE_PRINT</span><span class="p">((</span> <span class="s">&quot;lance_probe1: testing CSR0 register function (1)</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">));</span>
	<span class="n">save1</span> <span class="o">=</span> <span class="n">ioaddr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">ioaddr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">CSR0</span><span class="p">;</span>
	<span class="n">ioaddr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">CSR0_INIT</span> <span class="o">|</span> <span class="n">CSR0_STOP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioaddr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">CSR0_STOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ioaddr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">save1</span><span class="p">;</span>
		<span class="n">ioaddr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">save2</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">probe_fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">PROBE_PRINT</span><span class="p">((</span> <span class="s">&quot;lance_probe1: testing CSR0 register function (2)</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">));</span>
	<span class="n">ioaddr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">CSR0_STOP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioaddr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">CSR0_STOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ioaddr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">save1</span><span class="p">;</span>
		<span class="n">ioaddr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">save2</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">probe_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Now ok... */</span>
	<span class="n">PROBE_PRINT</span><span class="p">((</span> <span class="s">&quot;lance_probe1: Lance card detected</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">));</span>
	<span class="k">goto</span> <span class="n">probe_ok</span><span class="p">;</span>

  <span class="nl">probe_fail:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="nl">probe_ok:</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">MEM</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lance_memory</span> <span class="o">*</span><span class="p">)</span><span class="n">memaddr</span><span class="p">;</span>
	<span class="n">IO</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lance_ioreg</span> <span class="o">*</span><span class="p">)</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ioaddr</span><span class="p">;</span> <span class="cm">/* informational only */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">memcpy_f</span> <span class="o">=</span> <span class="n">init_rec</span><span class="o">-&gt;</span><span class="n">slow_flag</span> <span class="o">?</span> <span class="n">slow_memcpy</span> <span class="o">:</span> <span class="n">memcpy</span><span class="p">;</span>

	<span class="n">REGA</span><span class="p">(</span> <span class="n">CSR0</span> <span class="p">)</span> <span class="o">=</span> <span class="n">CSR0_STOP</span><span class="p">;</span>

	<span class="cm">/* Now test for type: If the eeprom I/O port is readable, it is a</span>
<span class="cm">	 * PAM card */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr_accessible</span><span class="p">(</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">IO</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Switch back to Ram */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">IO</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">;</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">cardtype</span> <span class="o">=</span> <span class="n">PAM_CARD</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">RIEBL_MAGIC_ADDR</span> <span class="o">==</span> <span class="n">RIEBL_MAGIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">cardtype</span> <span class="o">=</span> <span class="n">NEW_RIEBL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">cardtype</span> <span class="o">=</span> <span class="n">OLD_RIEBL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">cardtype</span> <span class="o">==</span> <span class="n">PAM_CARD</span> <span class="o">||</span>
		<span class="n">memaddr</span> <span class="o">==</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="p">)</span><span class="mh">0xffe00000</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* PAMs card and Riebl on ST use level 5 autovector */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">IRQ_AUTO_5</span><span class="p">,</span> <span class="n">lance_interrupt</span><span class="p">,</span> <span class="n">IRQ_TYPE_PRIO</span><span class="p">,</span>
		            <span class="s">&quot;PAM,Riebl-ST Ethernet&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;Lance: request for irq %d failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">IRQ_AUTO_5</span> <span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">IRQ_AUTO_5</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* For VME-RieblCards, request a free VME int */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">atari_register_vme_int</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;Lance: request for VME interrupt failed</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">lance_interrupt</span><span class="p">,</span> <span class="n">IRQ_TYPE_PRIO</span><span class="p">,</span>
		            <span class="s">&quot;Riebl-VME Ethernet&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;Lance: request for irq %u failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irq</span> <span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: %s at io %#lx, mem %#lx, irq %d%s, hwaddr &quot;</span><span class="p">,</span>
		   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">lance_names</span><span class="p">[</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">cardtype</span><span class="p">],</span>
		   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ioaddr</span><span class="p">,</span>
		   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">memaddr</span><span class="p">,</span>
		   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span>
		   <span class="n">init_rec</span><span class="o">-&gt;</span><span class="n">slow_flag</span> <span class="o">?</span> <span class="s">&quot; (slow memcpy)&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span> <span class="p">);</span>

	<span class="cm">/* Get the ethernet address */</span>
	<span class="k">switch</span><span class="p">(</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">cardtype</span> <span class="p">)</span> <span class="p">{</span>
	  <span class="k">case</span> <span class="n">OLD_RIEBL</span>:
		<span class="cm">/* No ethernet address! (Set some default address) */</span>
		<span class="n">memcpy</span><span class="p">(</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">OldRieblDefHwaddr</span><span class="p">,</span> <span class="mi">6</span> <span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	  <span class="k">case</span> <span class="n">NEW_RIEBL</span>:
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">memcpy_f</span><span class="p">(</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">RIEBL_HWADDR_ADDR</span><span class="p">,</span> <span class="mi">6</span> <span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	  <span class="k">case</span> <span class="n">PAM_CARD</span>:
		<span class="n">i</span> <span class="o">=</span> <span class="n">IO</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
				<span class="p">((((</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="p">)</span><span class="n">MEM</span><span class="p">)[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">((((</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="p">)</span><span class="n">MEM</span><span class="p">)[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">));</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">IO</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">cardtype</span> <span class="o">==</span> <span class="n">OLD_RIEBL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s: Warning: This is a default ethernet address!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;      Use </span><span class="se">\&quot;</span><span class="s">ifconfig hw ether ...</span><span class="se">\&quot;</span><span class="s"> to set the address.</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">devlock</span><span class="p">);</span>

	<span class="n">MEM</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="mh">0x0000</span><span class="p">;</span>		<span class="cm">/* Disable Rx and Tx. */</span>
	<span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
		<span class="n">MEM</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">.</span><span class="n">hwaddr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="n">i</span><span class="o">^</span><span class="mi">1</span><span class="p">];</span> <span class="cm">/* &lt;- 16 bit swap! */</span>
	<span class="n">MEM</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">.</span><span class="n">filter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00000000</span><span class="p">;</span>
	<span class="n">MEM</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">.</span><span class="n">filter</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00000000</span><span class="p">;</span>
	<span class="n">MEM</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">.</span><span class="n">rx_ring</span><span class="p">.</span><span class="n">adr_lo</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span> <span class="k">struct</span> <span class="n">lance_memory</span><span class="p">,</span> <span class="n">rx_head</span> <span class="p">);</span>
	<span class="n">MEM</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">.</span><span class="n">rx_ring</span><span class="p">.</span><span class="n">adr_hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">MEM</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">.</span><span class="n">rx_ring</span><span class="p">.</span><span class="n">len</span>    <span class="o">=</span> <span class="n">RX_RING_LEN_BITS</span><span class="p">;</span>
	<span class="n">MEM</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">.</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">adr_lo</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span> <span class="k">struct</span> <span class="n">lance_memory</span><span class="p">,</span> <span class="n">tx_head</span> <span class="p">);</span>
	<span class="n">MEM</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">.</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">adr_hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">MEM</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">.</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">len</span>    <span class="o">=</span> <span class="n">TX_RING_LEN_BITS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">cardtype</span> <span class="o">==</span> <span class="n">PAM_CARD</span><span class="p">)</span>
		<span class="n">IO</span><span class="o">-&gt;</span><span class="n">ivec</span> <span class="o">=</span> <span class="n">IRQ_SOURCE_TO_VECTOR</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">RIEBL_IVEC_ADDR</span> <span class="o">=</span> <span class="n">IRQ_SOURCE_TO_VECTOR</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">did_version</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">DPRINTK</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span> <span class="n">version</span> <span class="p">));</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lance_netdev_ops</span><span class="p">;</span>

	<span class="cm">/* XXX MSch */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="n">TX_TIMEOUT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">lance_open</span><span class="p">(</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lance_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lance_ioreg</span>	 <span class="o">*</span><span class="n">IO</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">iobase</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">DPRINTK</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span> <span class="s">&quot;%s: lance_open()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="p">));</span>

	<span class="n">lance_init_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="cm">/* Re-initialize the LANCE, and start it when done. */</span>

	<span class="n">REGA</span><span class="p">(</span> <span class="n">CSR3</span> <span class="p">)</span> <span class="o">=</span> <span class="n">CSR3_BSWP</span> <span class="o">|</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">cardtype</span> <span class="o">==</span> <span class="n">PAM_CARD</span> <span class="o">?</span> <span class="n">CSR3_ACON</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">REGA</span><span class="p">(</span> <span class="n">CSR2</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">REGA</span><span class="p">(</span> <span class="n">CSR1</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">REGA</span><span class="p">(</span> <span class="n">CSR0</span> <span class="p">)</span> <span class="o">=</span> <span class="n">CSR0_INIT</span><span class="p">;</span>
	<span class="cm">/* From now on, AREG is kept to point to CSR0 */</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">DREG</span> <span class="o">&amp;</span> <span class="n">CSR0_IDON</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">DREG</span> <span class="o">&amp;</span> <span class="n">CSR0_ERR</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DPRINTK</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span> <span class="s">&quot;lance_open(): opening %s failed, i=%d, csr0=%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">DREG</span> <span class="p">));</span>
		<span class="n">DREG</span> <span class="o">=</span> <span class="n">CSR0_STOP</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">DREG</span> <span class="o">=</span> <span class="n">CSR0_IDON</span><span class="p">;</span>
	<span class="n">DREG</span> <span class="o">=</span> <span class="n">CSR0_STRT</span><span class="p">;</span>
	<span class="n">DREG</span> <span class="o">=</span> <span class="n">CSR0_INEA</span><span class="p">;</span>

	<span class="n">netif_start_queue</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">DPRINTK</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span> <span class="s">&quot;%s: LANCE is open, csr0 %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">DREG</span> <span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Initialize the LANCE Rx and Tx rings. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lance_init_ring</span><span class="p">(</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lance_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span> <span class="k">struct</span> <span class="n">lance_memory</span><span class="p">,</span> <span class="n">packet_area</span> <span class="p">);</span>

<span class="cm">/* If the packet buffer at offset &#39;o&#39; would conflict with the reserved area</span>
<span class="cm"> * of RieblCards, advance it */</span>
<span class="cp">#define	CHECK_OFFSET(o)														 \</span>
<span class="cp">	do {																	 \</span>
<span class="cp">		if (lp-&gt;cardtype == OLD_RIEBL || lp-&gt;cardtype == NEW_RIEBL) {		 \</span>
<span class="cp">			if (((o) &lt; RIEBL_RSVD_START) ? (o)+PKT_BUF_SZ &gt; RIEBL_RSVD_START \</span>
<span class="cp">										 : (o) &lt; RIEBL_RSVD_END)			 \</span>
<span class="cp">				(o) = RIEBL_RSVD_END;										 \</span>
<span class="cp">		}																	 \</span>
<span class="cp">	} while(0)</span>

	<span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">CHECK_OFFSET</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
		<span class="n">MEM</span><span class="o">-&gt;</span><span class="n">tx_head</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">MEM</span><span class="o">-&gt;</span><span class="n">tx_head</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flag</span> <span class="o">=</span> <span class="n">TMD1_OWN_HOST</span><span class="p">;</span>
 		<span class="n">MEM</span><span class="o">-&gt;</span><span class="n">tx_head</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base_hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">MEM</span><span class="o">-&gt;</span><span class="n">tx_head</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">MEM</span><span class="o">-&gt;</span><span class="n">tx_head</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">misc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">PKT_BUF_SZ</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">CHECK_OFFSET</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
		<span class="n">MEM</span><span class="o">-&gt;</span><span class="n">rx_head</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">MEM</span><span class="o">-&gt;</span><span class="n">rx_head</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flag</span> <span class="o">=</span> <span class="n">TMD1_OWN_CHIP</span><span class="p">;</span>
		<span class="n">MEM</span><span class="o">-&gt;</span><span class="n">rx_head</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base_hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">MEM</span><span class="o">-&gt;</span><span class="n">rx_head</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buf_length</span> <span class="o">=</span> <span class="o">-</span><span class="n">PKT_BUF_SZ</span><span class="p">;</span>
		<span class="n">MEM</span><span class="o">-&gt;</span><span class="n">rx_head</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">msg_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">PKT_BUF_SZ</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX */</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">lance_tx_timeout</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lance_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lance_ioreg</span>	 <span class="o">*</span><span class="n">IO</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">iobase</span><span class="p">;</span>

	<span class="n">AREG</span> <span class="o">=</span> <span class="n">CSR0</span><span class="p">;</span>
	<span class="n">DPRINTK</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span> <span class="s">&quot;%s: transmit timed out, status %04x, resetting.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">DREG</span> <span class="p">));</span>
	<span class="n">DREG</span> <span class="o">=</span> <span class="n">CSR0_STOP</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Always set BSWP after a STOP as STOP puts it back into</span>
<span class="cm">	 * little endian mode.</span>
<span class="cm">	 */</span>
	<span class="n">REGA</span><span class="p">(</span> <span class="n">CSR3</span> <span class="p">)</span> <span class="o">=</span> <span class="n">CSR3_BSWP</span> <span class="o">|</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">cardtype</span> <span class="o">==</span> <span class="n">PAM_CARD</span> <span class="o">?</span> <span class="n">CSR3_ACON</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#ifndef final_version</span>
		<span class="p">{</span>	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">DPRINTK</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span> <span class="s">&quot;Ring data: dirty_tx %d cur_tx %d%s cur_rx %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						  <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_tx</span><span class="p">,</span>
						  <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_full</span> <span class="o">?</span> <span class="s">&quot; (full)&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
						  <span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="p">));</span>
			<span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
				<span class="n">DPRINTK</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span> <span class="s">&quot;rx #%d: base=%04x blen=%04x mlen=%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							  <span class="n">i</span><span class="p">,</span> <span class="n">MEM</span><span class="o">-&gt;</span><span class="n">rx_head</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span><span class="p">,</span>
							  <span class="o">-</span><span class="n">MEM</span><span class="o">-&gt;</span><span class="n">rx_head</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buf_length</span><span class="p">,</span>
							  <span class="n">MEM</span><span class="o">-&gt;</span><span class="n">rx_head</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">msg_length</span> <span class="p">));</span>
			<span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
				<span class="n">DPRINTK</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span> <span class="s">&quot;tx #%d: base=%04x len=%04x misc=%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							  <span class="n">i</span><span class="p">,</span> <span class="n">MEM</span><span class="o">-&gt;</span><span class="n">tx_head</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span><span class="p">,</span>
							  <span class="o">-</span><span class="n">MEM</span><span class="o">-&gt;</span><span class="n">tx_head</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">,</span>
							  <span class="n">MEM</span><span class="o">-&gt;</span><span class="n">tx_head</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">misc</span> <span class="p">));</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="cm">/* XXX MSch: maybe purge/reinit ring here */</span>
	<span class="cm">/* lance_restart, essentially */</span>
	<span class="n">lance_init_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">REGA</span><span class="p">(</span> <span class="n">CSR0</span> <span class="p">)</span> <span class="o">=</span> <span class="n">CSR0_INEA</span> <span class="o">|</span> <span class="n">CSR0_INIT</span> <span class="o">|</span> <span class="n">CSR0_STRT</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span> <span class="cm">/* prevent tx timeout */</span>
	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lance_start_xmit</span><span class="p">(</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lance_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lance_ioreg</span>	 <span class="o">*</span><span class="n">IO</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">iobase</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">entry</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lance_tx_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">DPRINTK</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span> <span class="s">&quot;%s: lance_start_xmit() called, csr0 %4.4x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">DREG</span> <span class="p">));</span>


	<span class="cm">/* The old LANCE chips doesn&#39;t automatically pad buffers to min. size. */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">ETH_ZLEN</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">ETH_ZLEN</span><span class="p">;</span>
	<span class="cm">/* PAM-Card has a bug: Can only send packets with even number of bytes! */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">cardtype</span> <span class="o">==</span> <span class="n">PAM_CARD</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">len</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span>
		<span class="o">++</span><span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb_padto</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">netif_stop_queue</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Fill in a Tx ring entry */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lance_debug</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s: TX pkt type 0x%04x from %pM to %pM&quot;</span>
				<span class="s">&quot; data at 0x%08x len %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">((</span><span class="n">u_short</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="mi">6</span><span class="p">],</span>
				<span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* We&#39;re not prepared for the int until the last flags are set/reset. And</span>
<span class="cm">	 * the int may happen already after setting the OWN_CHIP... */</span>
	<span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">devlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Mask to ring buffer boundary. */</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">&amp;</span> <span class="n">TX_RING_MOD_MASK</span><span class="p">;</span>
	<span class="n">head</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">MEM</span><span class="o">-&gt;</span><span class="n">tx_head</span><span class="p">[</span><span class="n">entry</span><span class="p">]);</span>

	<span class="cm">/* Caution: the write order is important here, set the &quot;ownership&quot; bits</span>
<span class="cm">	 * last.</span>
<span class="cm">	 */</span>


	<span class="n">head</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="o">-</span><span class="n">len</span><span class="p">;</span>
	<span class="n">head</span><span class="o">-&gt;</span><span class="n">misc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">memcpy_f</span><span class="p">(</span> <span class="n">PKTBUF_ADDR</span><span class="p">(</span><span class="n">head</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="p">);</span>
	<span class="n">head</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">TMD1_OWN_CHIP</span> <span class="o">|</span> <span class="n">TMD1_ENP</span> <span class="o">|</span> <span class="n">TMD1_STP</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">dev_kfree_skb</span><span class="p">(</span> <span class="n">skb</span> <span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_tx</span><span class="o">++</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">&gt;=</span> <span class="n">TX_RING_SIZE</span> <span class="o">&amp;&amp;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">&gt;=</span> <span class="n">TX_RING_SIZE</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">-=</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">-=</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Trigger an immediate send poll. */</span>
	<span class="n">DREG</span> <span class="o">=</span> <span class="n">CSR0_INEA</span> <span class="o">|</span> <span class="n">CSR0_TDMD</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">MEM</span><span class="o">-&gt;</span><span class="n">tx_head</span><span class="p">[(</span><span class="n">entry</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">TX_RING_MOD_MASK</span><span class="p">].</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">TMD1_OWN</span><span class="p">)</span> <span class="o">==</span>
		<span class="n">TMD1_OWN_HOST</span><span class="p">)</span>
		<span class="n">netif_start_queue</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_full</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">devlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The LANCE interrupt handler. */</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">lance_interrupt</span><span class="p">(</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lance_private</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lance_ioreg</span>	 <span class="o">*</span><span class="n">IO</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">csr0</span><span class="p">,</span> <span class="n">boguscnt</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">handled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINTK</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span> <span class="s">&quot;lance_interrupt(): interrupt for unknown device.</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">));</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">IO</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">iobase</span><span class="p">;</span>
	<span class="n">spin_lock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">devlock</span><span class="p">);</span>

	<span class="n">AREG</span> <span class="o">=</span> <span class="n">CSR0</span><span class="p">;</span>

	<span class="k">while</span><span class="p">(</span> <span class="p">((</span><span class="n">csr0</span> <span class="o">=</span> <span class="n">DREG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CSR0_ERR</span> <span class="o">|</span> <span class="n">CSR0_TINT</span> <span class="o">|</span> <span class="n">CSR0_RINT</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		   <span class="o">--</span><span class="n">boguscnt</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">handled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Acknowledge all of the current interrupt sources ASAP. */</span>
		<span class="n">DREG</span> <span class="o">=</span> <span class="n">csr0</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">CSR0_INIT</span> <span class="o">|</span> <span class="n">CSR0_STRT</span> <span class="o">|</span> <span class="n">CSR0_STOP</span> <span class="o">|</span>
									<span class="n">CSR0_TDMD</span> <span class="o">|</span> <span class="n">CSR0_INEA</span><span class="p">);</span>

		<span class="n">DPRINTK</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span> <span class="s">&quot;%s: interrupt  csr0=%04x new csr=%04x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">csr0</span><span class="p">,</span> <span class="n">DREG</span> <span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">csr0</span> <span class="o">&amp;</span> <span class="n">CSR0_RINT</span><span class="p">)</span>			<span class="cm">/* Rx interrupt */</span>
			<span class="n">lance_rx</span><span class="p">(</span> <span class="n">dev</span> <span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">csr0</span> <span class="o">&amp;</span> <span class="n">CSR0_TINT</span><span class="p">)</span> <span class="p">{</span>			<span class="cm">/* Tx-done interrupt */</span>
			<span class="kt">int</span> <span class="n">dirty_tx</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span><span class="p">;</span>

			<span class="k">while</span><span class="p">(</span> <span class="n">dirty_tx</span> <span class="o">&lt;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_tx</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">dirty_tx</span> <span class="o">&amp;</span> <span class="n">TX_RING_MOD_MASK</span><span class="p">;</span>
				<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">MEM</span><span class="o">-&gt;</span><span class="n">tx_head</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">flag</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">TMD1_OWN_CHIP</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>			<span class="cm">/* It still hasn&#39;t been Txed */</span>

				<span class="n">MEM</span><span class="o">-&gt;</span><span class="n">tx_head</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">TMD1_ERR</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* There was an major error, log it. */</span>
					<span class="kt">int</span> <span class="n">err_status</span> <span class="o">=</span> <span class="n">MEM</span><span class="o">-&gt;</span><span class="n">tx_head</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">misc</span><span class="p">;</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">err_status</span> <span class="o">&amp;</span> <span class="n">TMD3_RTRY</span><span class="p">)</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_aborted_errors</span><span class="o">++</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">err_status</span> <span class="o">&amp;</span> <span class="n">TMD3_LCAR</span><span class="p">)</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_carrier_errors</span><span class="o">++</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">err_status</span> <span class="o">&amp;</span> <span class="n">TMD3_LCOL</span><span class="p">)</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_window_errors</span><span class="o">++</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">err_status</span> <span class="o">&amp;</span> <span class="n">TMD3_UFLO</span><span class="p">)</span> <span class="p">{</span>
						<span class="cm">/* Ackk!  On FIFO errors the Tx unit is turned off! */</span>
						<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
						<span class="cm">/* Remove this verbosity later! */</span>
						<span class="n">DPRINTK</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span> <span class="s">&quot;%s: Tx FIFO error! Status %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
									  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">csr0</span> <span class="p">));</span>
						<span class="cm">/* Restart the chip. */</span>
						<span class="n">DREG</span> <span class="o">=</span> <span class="n">CSR0_STRT</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TMD1_MORE</span> <span class="o">|</span> <span class="n">TMD1_ONE</span> <span class="o">|</span> <span class="n">TMD1_DEF</span><span class="p">))</span>
						<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">collisions</span><span class="o">++</span><span class="p">;</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/* XXX MSch: free skb?? */</span>
				<span class="n">dirty_tx</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>

<span class="cp">#ifndef final_version</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">-</span> <span class="n">dirty_tx</span> <span class="o">&gt;=</span> <span class="n">TX_RING_SIZE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DPRINTK</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span> <span class="s">&quot;out-of-sync dirty pointer,&quot;</span>
							  <span class="s">&quot; %d vs. %d, full=%ld.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							  <span class="n">dirty_tx</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_tx</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_full</span> <span class="p">));</span>
				<span class="n">dirty_tx</span> <span class="o">+=</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#endif</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_full</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">netif_queue_stopped</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
				<span class="n">dirty_tx</span> <span class="o">&gt;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">-</span> <span class="n">TX_RING_SIZE</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* The ring is no longer full, clear tbusy. */</span>
				<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">netif_wake_queue</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">=</span> <span class="n">dirty_tx</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Log misc errors. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">csr0</span> <span class="o">&amp;</span> <span class="n">CSR0_BABL</span><span class="p">)</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* Tx babble. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">csr0</span> <span class="o">&amp;</span> <span class="n">CSR0_MISS</span><span class="p">)</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* Missed a Rx frame. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">csr0</span> <span class="o">&amp;</span> <span class="n">CSR0_MERR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DPRINTK</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span> <span class="s">&quot;%s: Bus master arbitration failure (?!?), &quot;</span>
						  <span class="s">&quot;status %04x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">csr0</span> <span class="p">));</span>
			<span class="cm">/* Restart the chip. */</span>
			<span class="n">DREG</span> <span class="o">=</span> <span class="n">CSR0_STRT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

    <span class="cm">/* Clear any other interrupt, and set interrupt enable. */</span>
	<span class="n">DREG</span> <span class="o">=</span> <span class="n">CSR0_BABL</span> <span class="o">|</span> <span class="n">CSR0_CERR</span> <span class="o">|</span> <span class="n">CSR0_MISS</span> <span class="o">|</span> <span class="n">CSR0_MERR</span> <span class="o">|</span>
		   <span class="n">CSR0_IDON</span> <span class="o">|</span> <span class="n">CSR0_INEA</span><span class="p">;</span>

	<span class="n">DPRINTK</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span> <span class="s">&quot;%s: exiting interrupt, csr0=%#04x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">DREG</span> <span class="p">));</span>

	<span class="n">spin_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">devlock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_RETVAL</span><span class="p">(</span><span class="n">handled</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">lance_rx</span><span class="p">(</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lance_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="o">&amp;</span> <span class="n">RX_RING_MOD_MASK</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">DPRINTK</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span> <span class="s">&quot;%s: rx int, flag=%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				  <span class="n">MEM</span><span class="o">-&gt;</span><span class="n">rx_head</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">flag</span> <span class="p">));</span>

	<span class="cm">/* If we own the next entry, it&#39;s a new packet. Send it up. */</span>
	<span class="k">while</span><span class="p">(</span> <span class="p">(</span><span class="n">MEM</span><span class="o">-&gt;</span><span class="n">rx_head</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">RMD1_OWN</span><span class="p">)</span> <span class="o">==</span> <span class="n">RMD1_OWN_HOST</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">lance_rx_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">MEM</span><span class="o">-&gt;</span><span class="n">rx_head</span><span class="p">[</span><span class="n">entry</span><span class="p">]);</span>
		<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="p">(</span><span class="n">RMD1_ENP</span><span class="o">|</span><span class="n">RMD1_STP</span><span class="p">))</span> <span class="p">{</span>		<span class="cm">/* There was an error. */</span>
			<span class="cm">/* There is a tricky error noted by John Murphy,</span>
<span class="cm">			   &lt;murf@perftech.com&gt; to Russ Nelson: Even with full-sized</span>
<span class="cm">			   buffers it&#39;s possible for a jabber packet to use two</span>
<span class="cm">			   buffers, with only the last correctly noting the error. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RMD1_ENP</span><span class="p">)</span>	<span class="cm">/* Only count a general error at the */</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* end of a packet.*/</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RMD1_FRAM</span><span class="p">)</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_frame_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RMD1_OFLO</span><span class="p">)</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_over_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RMD1_CRC</span><span class="p">)</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_crc_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RMD1_BUFF</span><span class="p">)</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="n">head</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">RMD1_ENP</span><span class="o">|</span><span class="n">RMD1_STP</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Malloc up new buffer, compatible with net-3. */</span>
			<span class="kt">short</span> <span class="n">pkt_len</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">msg_length</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">pkt_len</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s: Runt packet!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="p">);</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pkt_len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">DPRINTK</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span> <span class="s">&quot;%s: Memory squeeze, deferring packet.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="p">));</span>
					<span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">MEM</span><span class="o">-&gt;</span><span class="n">rx_head</span><span class="p">[(</span><span class="n">entry</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RX_RING_MOD_MASK</span><span class="p">].</span><span class="n">flag</span> <span class="o">&amp;</span>
							<span class="n">RMD1_OWN_CHIP</span><span class="p">)</span>
							<span class="k">break</span><span class="p">;</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">RX_RING_SIZE</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
						<span class="n">head</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">RMD1_OWN_CHIP</span><span class="p">;</span>
						<span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_rx</span><span class="o">++</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">lance_debug</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">u_char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">PKTBUF_ADDR</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>

					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: RX pkt type 0x%04x from %pM to %pM &quot;</span>
						   <span class="s">&quot;data %02x %02x %02x %02x %02x %02x %02x %02x &quot;</span>
						   <span class="s">&quot;len %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">((</span><span class="n">u_short</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">)[</span><span class="mi">6</span><span class="p">],</span>
						   <span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">data</span><span class="p">,</span>
						   <span class="n">data</span><span class="p">[</span><span class="mi">15</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">17</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">18</span><span class="p">],</span>
						   <span class="n">data</span><span class="p">[</span><span class="mi">19</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">20</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">21</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">22</span><span class="p">],</span>
						   <span class="n">pkt_len</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="n">skb_reserve</span><span class="p">(</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>	<span class="cm">/* 16 byte align */</span>
				<span class="n">skb_put</span><span class="p">(</span> <span class="n">skb</span><span class="p">,</span> <span class="n">pkt_len</span> <span class="p">);</span>	<span class="cm">/* Make room */</span>
				<span class="n">lp</span><span class="o">-&gt;</span><span class="n">memcpy_f</span><span class="p">(</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">PKTBUF_ADDR</span><span class="p">(</span><span class="n">head</span><span class="p">),</span> <span class="n">pkt_len</span> <span class="p">);</span>
				<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span> <span class="n">skb</span><span class="p">,</span> <span class="n">dev</span> <span class="p">);</span>
				<span class="n">netif_rx</span><span class="p">(</span> <span class="n">skb</span> <span class="p">);</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">pkt_len</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">head</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">RMD1_OWN_CHIP</span><span class="p">;</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="o">++</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_rx</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RX_RING_MOD_MASK</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="o">&amp;=</span> <span class="n">RX_RING_MOD_MASK</span><span class="p">;</span>

	<span class="cm">/* From lance.c (Donald Becker): */</span>
	<span class="cm">/* We should check that at least two ring entries are free.	 If not,</span>
<span class="cm">	   we should free one and mark stats-&gt;rx_dropped++. */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">lance_close</span><span class="p">(</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lance_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lance_ioreg</span>	 <span class="o">*</span><span class="n">IO</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">iobase</span><span class="p">;</span>

	<span class="n">netif_stop_queue</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">AREG</span> <span class="o">=</span> <span class="n">CSR0</span><span class="p">;</span>

	<span class="n">DPRINTK</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span> <span class="s">&quot;%s: Shutting down ethercard, status was %2.2x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">DREG</span> <span class="p">));</span>

	<span class="cm">/* We stop the LANCE here -- it occasionally polls</span>
<span class="cm">	   memory if we don&#39;t. */</span>
	<span class="n">DREG</span> <span class="o">=</span> <span class="n">CSR0_STOP</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Set or clear the multicast filter for this adaptor.</span>
<span class="cm">   num_addrs == -1		Promiscuous mode, receive all packets</span>
<span class="cm">   num_addrs == 0		Normal mode, clear multicast list</span>
<span class="cm">   num_addrs &gt; 0		Multicast mode, receive normal and MC packets, and do</span>
<span class="cm">						best-effort filtering.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_multicast_list</span><span class="p">(</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lance_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lance_ioreg</span>	 <span class="o">*</span><span class="n">IO</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">iobase</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="cm">/* Only possible if board is already started */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* We take the simple way out and always enable promiscuous mode. */</span>
	<span class="n">DREG</span> <span class="o">=</span> <span class="n">CSR0_STOP</span><span class="p">;</span> <span class="cm">/* Temporarily stop the lance. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Log any net taps. */</span>
		<span class="n">DPRINTK</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span> <span class="s">&quot;%s: Promiscuous mode enabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="p">));</span>
		<span class="n">REGA</span><span class="p">(</span> <span class="n">CSR15</span> <span class="p">)</span> <span class="o">=</span> <span class="mh">0x8000</span><span class="p">;</span> <span class="cm">/* Set promiscuous mode */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">short</span> <span class="n">multicast_table</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">num_addrs</span> <span class="o">=</span> <span class="n">netdev_mc_count</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="cm">/* We don&#39;t use the multicast table, but rely on upper-layer</span>
<span class="cm">		 * filtering. */</span>
		<span class="n">memset</span><span class="p">(</span> <span class="n">multicast_table</span><span class="p">,</span> <span class="p">(</span><span class="n">num_addrs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">multicast_table</span><span class="p">)</span> <span class="p">);</span>
		<span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
			<span class="n">REGA</span><span class="p">(</span> <span class="n">CSR8</span><span class="o">+</span><span class="n">i</span> <span class="p">)</span> <span class="o">=</span> <span class="n">multicast_table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">REGA</span><span class="p">(</span> <span class="n">CSR15</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Unset promiscuous mode */</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Always set BSWP after a STOP as STOP puts it back into</span>
<span class="cm">	 * little endian mode.</span>
<span class="cm">	 */</span>
	<span class="n">REGA</span><span class="p">(</span> <span class="n">CSR3</span> <span class="p">)</span> <span class="o">=</span> <span class="n">CSR3_BSWP</span> <span class="o">|</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">cardtype</span> <span class="o">==</span> <span class="n">PAM_CARD</span> <span class="o">?</span> <span class="n">CSR3_ACON</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Resume normal operation and reset AREG to CSR0 */</span>
	<span class="n">REGA</span><span class="p">(</span> <span class="n">CSR0</span> <span class="p">)</span> <span class="o">=</span> <span class="n">CSR0_IDON</span> <span class="o">|</span> <span class="n">CSR0_INEA</span> <span class="o">|</span> <span class="n">CSR0_STRT</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* This is needed for old RieblCards and possible for new RieblCards */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lance_set_mac_address</span><span class="p">(</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lance_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">saddr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">cardtype</span> <span class="o">!=</span> <span class="n">OLD_RIEBL</span> <span class="o">&amp;&amp;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">cardtype</span> <span class="o">!=</span> <span class="n">NEW_RIEBL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Only possible while card isn&#39;t started */</span>
		<span class="n">DPRINTK</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span> <span class="s">&quot;%s: hwaddr can be set only while card isn&#39;t open.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">saddr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span> <span class="p">);</span>
	<span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
		<span class="n">MEM</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">.</span><span class="n">hwaddr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="n">i</span><span class="o">^</span><span class="mi">1</span><span class="p">];</span> <span class="cm">/* &lt;- 16 bit swap! */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">memcpy_f</span><span class="p">(</span> <span class="n">RIEBL_HWADDR_ADDR</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="mi">6</span> <span class="p">);</span>
	<span class="cm">/* set also the magic for future sessions */</span>
	<span class="o">*</span><span class="n">RIEBL_MAGIC_ADDR</span> <span class="o">=</span> <span class="n">RIEBL_MAGIC</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#ifdef MODULE</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">atarilance_dev</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">atarilance_module_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atarilance_dev</span> <span class="o">=</span> <span class="n">atarilance_probe</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">atarilance_dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">atarilance_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">atarilance_module_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">atarilance_dev</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">atarilance_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">atarilance_dev</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">atarilance_dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">atarilance_module_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">atarilance_module_exit</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* MODULE */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * Local variables:</span>
<span class="cm"> *  c-indent-level: 4</span>
<span class="cm"> *  tab-width: 4</span>
<span class="cm"> * End:</span>
<span class="cm"> */</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
