<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › amd › lance.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>lance.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* lance.c: An AMD LANCE/PCnet ethernet driver for Linux. */</span>
<span class="cm">/*</span>
<span class="cm">	Written/copyright 1993-1998 by Donald Becker.</span>

<span class="cm">	Copyright 1993 United States Government as represented by the</span>
<span class="cm">	Director, National Security Agency.</span>
<span class="cm">	This software may be used and distributed according to the terms</span>
<span class="cm">	of the GNU General Public License, incorporated herein by reference.</span>

<span class="cm">	This driver is for the Allied Telesis AT1500 and HP J2405A, and should work</span>
<span class="cm">	with most other LANCE-based bus-master (NE2100/NE2500) ethercards.</span>

<span class="cm">	The author may be reached as becker@scyld.com, or C/O</span>
<span class="cm">	Scyld Computing Corporation</span>
<span class="cm">	410 Severn Ave., Suite 210</span>
<span class="cm">	Annapolis MD 21403</span>

<span class="cm">	Andrey V. Savochkin:</span>
<span class="cm">	- alignment problem with 1.3.* kernel and some minor changes.</span>
<span class="cm">	Thomas Bogendoerfer (tsbogend@bigbug.franken.de):</span>
<span class="cm">	- added support for Linux/Alpha, but removed most of it, because</span>
<span class="cm">        it worked only for the PCI chip.</span>
<span class="cm">      - added hook for the 32bit lance driver</span>
<span class="cm">      - added PCnetPCI II (79C970A) to chip table</span>
<span class="cm">	Paul Gortmaker (gpg109@rsphy1.anu.edu.au):</span>
<span class="cm">	- hopefully fix above so Linux/Alpha can use ISA cards too.</span>
<span class="cm">    8/20/96 Fixed 7990 autoIRQ failure and reversed unneeded alignment -djb</span>
<span class="cm">    v1.12 10/27/97 Module support -djb</span>
<span class="cm">    v1.14  2/3/98 Module support modified, made PCI support optional -djb</span>
<span class="cm">    v1.15 5/27/99 Fixed bug in the cleanup_module(). dev-&gt;priv was freed</span>
<span class="cm">                  before unregister_netdev() which caused NULL pointer</span>
<span class="cm">                  reference later in the chain (in rtnetlink_fill_ifinfo())</span>
<span class="cm">                  -- Mika Kuoppala &lt;miku@iki.fi&gt;</span>

<span class="cm">    Forward ported v1.14 to 2.1.129, merged the PCI and misc changes from</span>
<span class="cm">    the 2.1 version of the old driver - Alan Cox</span>

<span class="cm">    Get rid of check_region, check kmalloc return in lance_probe1</span>
<span class="cm">    Arnaldo Carvalho de Melo &lt;acme@conectiva.com.br&gt; - 11/01/2001</span>

<span class="cm">	Reworked detection, added support for Racal InterLan EtherBlaster cards</span>
<span class="cm">	Vesselin Kostadinov &lt;vesok at yahoo dot com &gt; - 22/4/2004</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">version</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;lance.c:v1.16 2006/11/09 dplatt@3do.com, becker@cesdis.gsfc.nasa.gov</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/dma.h&gt;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lance_portlist</span><span class="p">[]</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x300</span><span class="p">,</span> <span class="mh">0x320</span><span class="p">,</span> <span class="mh">0x340</span><span class="p">,</span> <span class="mh">0x360</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lance_probe1</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ioaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">options</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">do_lance_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">card</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">id_offset14</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">id_offset15</span><span class="p">;</span>
<span class="p">}</span> <span class="n">cards</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>	<span class="c1">//&quot;normal&quot;</span>
		<span class="p">.</span><span class="n">id_offset14</span> <span class="o">=</span> <span class="mh">0x57</span><span class="p">,</span>
		<span class="p">.</span><span class="n">id_offset15</span> <span class="o">=</span> <span class="mh">0x57</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="c1">//NI6510EB</span>
		<span class="p">.</span><span class="n">id_offset14</span> <span class="o">=</span> <span class="mh">0x52</span><span class="p">,</span>
		<span class="p">.</span><span class="n">id_offset15</span> <span class="o">=</span> <span class="mh">0x44</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="c1">//Racal InterLan EtherBlaster</span>
		<span class="p">.</span><span class="n">id_offset14</span> <span class="o">=</span> <span class="mh">0x52</span><span class="p">,</span>
		<span class="p">.</span><span class="n">id_offset15</span> <span class="o">=</span> <span class="mh">0x49</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>
<span class="cp">#define NUM_CARDS 3</span>

<span class="cp">#ifdef LANCE_DEBUG</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lance_debug</span> <span class="o">=</span> <span class="n">LANCE_DEBUG</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lance_debug</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">				Theory of Operation</span>

<span class="cm">I. Board Compatibility</span>

<span class="cm">This device driver is designed for the AMD 79C960, the &quot;PCnet-ISA</span>
<span class="cm">single-chip ethernet controller for ISA&quot;.  This chip is used in a wide</span>
<span class="cm">variety of boards from vendors such as Allied Telesis, HP, Kingston,</span>
<span class="cm">and Boca.  This driver is also intended to work with older AMD 7990</span>
<span class="cm">designs, such as the NE1500 and NE2100, and newer 79C961.  For convenience,</span>
<span class="cm">I use the name LANCE to refer to all of the AMD chips, even though it properly</span>
<span class="cm">refers only to the original 7990.</span>

<span class="cm">II. Board-specific settings</span>

<span class="cm">The driver is designed to work the boards that use the faster</span>
<span class="cm">bus-master mode, rather than in shared memory mode.	 (Only older designs</span>
<span class="cm">have on-board buffer memory needed to support the slower shared memory mode.)</span>

<span class="cm">Most ISA boards have jumpered settings for the I/O base, IRQ line, and DMA</span>
<span class="cm">channel.  This driver probes the likely base addresses:</span>
<span class="cm">{0x300, 0x320, 0x340, 0x360}.</span>
<span class="cm">After the board is found it generates a DMA-timeout interrupt and uses</span>
<span class="cm">autoIRQ to find the IRQ line.  The DMA channel can be set with the low bits</span>
<span class="cm">of the otherwise-unused dev-&gt;mem_start value (aka PARAM1).  If unset it is</span>
<span class="cm">probed for by enabling each free DMA channel in turn and checking if</span>
<span class="cm">initialization succeeds.</span>

<span class="cm">The HP-J2405A board is an exception: with this board it is easy to read the</span>
<span class="cm">EEPROM-set values for the base, IRQ, and DMA.  (Of course you must already</span>
<span class="cm">_know_ the base address -- that field is for writing the EEPROM.)</span>

<span class="cm">III. Driver operation</span>

<span class="cm">IIIa. Ring buffers</span>
<span class="cm">The LANCE uses ring buffers of Tx and Rx descriptors.  Each entry describes</span>
<span class="cm">the base and length of the data buffer, along with status bits.	 The length</span>
<span class="cm">of these buffers is set by LANCE_LOG_{RX,TX}_BUFFERS, which is log_2() of</span>
<span class="cm">the buffer length (rather than being directly the buffer length) for</span>
<span class="cm">implementation ease.  The current values are 2 (Tx) and 4 (Rx), which leads to</span>
<span class="cm">ring sizes of 4 (Tx) and 16 (Rx).  Increasing the number of ring entries</span>
<span class="cm">needlessly uses extra space and reduces the chance that an upper layer will</span>
<span class="cm">be able to reorder queued Tx packets based on priority.	 Decreasing the number</span>
<span class="cm">of entries makes it more difficult to achieve back-to-back packet transmission</span>
<span class="cm">and increases the chance that Rx ring will overflow.  (Consider the worst case</span>
<span class="cm">of receiving back-to-back minimum-sized packets.)</span>

<span class="cm">The LANCE has the capability to &quot;chain&quot; both Rx and Tx buffers, but this driver</span>
<span class="cm">statically allocates full-sized (slightly oversized -- PKT_BUF_SZ) buffers to</span>
<span class="cm">avoid the administrative overhead. For the Rx side this avoids dynamically</span>
<span class="cm">allocating full-sized buffers &quot;just in case&quot;, at the expense of a</span>
<span class="cm">memory-to-memory data copy for each packet received.  For most systems this</span>
<span class="cm">is a good tradeoff: the Rx buffer will always be in low memory, the copy</span>
<span class="cm">is inexpensive, and it primes the cache for later packet processing.  For Tx</span>
<span class="cm">the buffers are only used when needed as low-memory bounce buffers.</span>

<span class="cm">IIIB. 16M memory limitations.</span>
<span class="cm">For the ISA bus master mode all structures used directly by the LANCE,</span>
<span class="cm">the initialization block, Rx and Tx rings, and data buffers, must be</span>
<span class="cm">accessible from the ISA bus, i.e. in the lower 16M of real memory.</span>
<span class="cm">This is a problem for current Linux kernels on &gt;16M machines. The network</span>
<span class="cm">devices are initialized after memory initialization, and the kernel doles out</span>
<span class="cm">memory from the top of memory downward.	 The current solution is to have a</span>
<span class="cm">special network initialization routine that&#39;s called before memory</span>
<span class="cm">initialization; this will eventually be generalized for all network devices.</span>
<span class="cm">As mentioned before, low-memory &quot;bounce-buffers&quot; are used when needed.</span>

<span class="cm">IIIC. Synchronization</span>
<span class="cm">The driver runs as two independent, single-threaded flows of control.  One</span>
<span class="cm">is the send-packet routine, which enforces single-threaded use by the</span>
<span class="cm">dev-&gt;tbusy flag.  The other thread is the interrupt handler, which is single</span>
<span class="cm">threaded by the hardware and other software.</span>

<span class="cm">The send packet thread has partial control over the Tx ring and &#39;dev-&gt;tbusy&#39;</span>
<span class="cm">flag.  It sets the tbusy flag whenever it&#39;s queuing a Tx packet. If the next</span>
<span class="cm">queue slot is empty, it clears the tbusy flag when finished otherwise it sets</span>
<span class="cm">the &#39;lp-&gt;tx_full&#39; flag.</span>

<span class="cm">The interrupt handler has exclusive control over the Rx ring and records stats</span>
<span class="cm">from the Tx ring. (The Tx-done interrupt can&#39;t be selectively turned off, so</span>
<span class="cm">we can&#39;t avoid the interrupt overhead by having the Tx routine reap the Tx</span>
<span class="cm">stats.)	 After reaping the stats, it marks the queue entry as empty by setting</span>
<span class="cm">the &#39;base&#39; to zero. Iff the &#39;lp-&gt;tx_full&#39; flag is set, it clears both the</span>
<span class="cm">tx_full and tbusy flags.</span>

<span class="cm">*/</span>

<span class="cm">/* Set the number of Tx and Rx buffers, using Log_2(# buffers).</span>
<span class="cm">   Reasonable default values are 16 Tx buffers, and 16 Rx buffers.</span>
<span class="cm">   That translates to 4 and 4 (16 == 2^^4).</span>
<span class="cm">   This is a compile-time option for efficiency.</span>
<span class="cm">   */</span>
<span class="cp">#ifndef LANCE_LOG_TX_BUFFERS</span>
<span class="cp">#define LANCE_LOG_TX_BUFFERS 4</span>
<span class="cp">#define LANCE_LOG_RX_BUFFERS 4</span>
<span class="cp">#endif</span>

<span class="cp">#define TX_RING_SIZE			(1 &lt;&lt; (LANCE_LOG_TX_BUFFERS))</span>
<span class="cp">#define TX_RING_MOD_MASK		(TX_RING_SIZE - 1)</span>
<span class="cp">#define TX_RING_LEN_BITS		((LANCE_LOG_TX_BUFFERS) &lt;&lt; 29)</span>

<span class="cp">#define RX_RING_SIZE			(1 &lt;&lt; (LANCE_LOG_RX_BUFFERS))</span>
<span class="cp">#define RX_RING_MOD_MASK		(RX_RING_SIZE - 1)</span>
<span class="cp">#define RX_RING_LEN_BITS		((LANCE_LOG_RX_BUFFERS) &lt;&lt; 29)</span>

<span class="cp">#define PKT_BUF_SZ		1544</span>

<span class="cm">/* Offsets from base I/O address. */</span>
<span class="cp">#define LANCE_DATA 0x10</span>
<span class="cp">#define LANCE_ADDR 0x12</span>
<span class="cp">#define LANCE_RESET 0x14</span>
<span class="cp">#define LANCE_BUS_IF 0x16</span>
<span class="cp">#define LANCE_TOTAL_SIZE 0x18</span>

<span class="cp">#define TX_TIMEOUT	(HZ/5)</span>

<span class="cm">/* The LANCE Rx and Tx ring descriptors. */</span>
<span class="k">struct</span> <span class="n">lance_rx_head</span> <span class="p">{</span>
	<span class="n">s32</span> <span class="n">base</span><span class="p">;</span>
	<span class="n">s16</span> <span class="n">buf_length</span><span class="p">;</span>			<span class="cm">/* This length is 2s complement (negative)! */</span>
	<span class="n">s16</span> <span class="n">msg_length</span><span class="p">;</span>			<span class="cm">/* This length is &quot;normal&quot;. */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">lance_tx_head</span> <span class="p">{</span>
	<span class="n">s32</span> <span class="n">base</span><span class="p">;</span>
	<span class="n">s16</span> <span class="n">length</span><span class="p">;</span>				<span class="cm">/* Length is 2s complement (negative)! */</span>
	<span class="n">s16</span> <span class="n">misc</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* The LANCE initialization block, described in databook. */</span>
<span class="k">struct</span> <span class="n">lance_init_block</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">mode</span><span class="p">;</span>		<span class="cm">/* Pre-set mode (reg. 15) */</span>
	<span class="n">u8</span>  <span class="n">phys_addr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span> <span class="cm">/* Physical ethernet address */</span>
	<span class="n">u32</span> <span class="n">filter</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>			<span class="cm">/* Multicast filter (unused). */</span>
	<span class="cm">/* Receive and transmit ring base, along with extra bits. */</span>
	<span class="n">u32</span>  <span class="n">rx_ring</span><span class="p">;</span>			<span class="cm">/* Tx and Rx ring base pointers */</span>
	<span class="n">u32</span>  <span class="n">tx_ring</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">lance_private</span> <span class="p">{</span>
	<span class="cm">/* The Tx and Rx ring entries must be aligned on 8-byte boundaries. */</span>
	<span class="k">struct</span> <span class="n">lance_rx_head</span> <span class="n">rx_ring</span><span class="p">[</span><span class="n">RX_RING_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">lance_tx_head</span> <span class="n">tx_ring</span><span class="p">[</span><span class="n">TX_RING_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">lance_init_block</span>	<span class="n">init_block</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="cm">/* The saved address of a sent-in-place packet/buffer, for skfree(). */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span><span class="o">*</span> <span class="n">tx_skbuff</span><span class="p">[</span><span class="n">TX_RING_SIZE</span><span class="p">];</span>
	<span class="cm">/* The addresses of receive-in-place skbuffs. */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span><span class="o">*</span> <span class="n">rx_skbuff</span><span class="p">[</span><span class="n">RX_RING_SIZE</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rx_buffs</span><span class="p">;</span>		<span class="cm">/* Address of Rx and Tx buffers. */</span>
	<span class="cm">/* Tx low-memory &quot;bounce buffer&quot; address. */</span>
	<span class="kt">char</span> <span class="p">(</span><span class="o">*</span><span class="n">tx_bounce_buffs</span><span class="p">)[</span><span class="n">PKT_BUF_SZ</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">cur_rx</span><span class="p">,</span> <span class="n">cur_tx</span><span class="p">;</span>			<span class="cm">/* The next free ring entry */</span>
	<span class="kt">int</span> <span class="n">dirty_rx</span><span class="p">,</span> <span class="n">dirty_tx</span><span class="p">;</span>		<span class="cm">/* The ring entries to be free()ed. */</span>
	<span class="kt">int</span> <span class="n">dma</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">chip_version</span><span class="p">;</span>	<span class="cm">/* See lance_chip_type. */</span>
	<span class="n">spinlock_t</span> <span class="n">devlock</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define LANCE_MUST_PAD          0x00000001</span>
<span class="cp">#define LANCE_ENABLE_AUTOSELECT 0x00000002</span>
<span class="cp">#define LANCE_MUST_REINIT_RING  0x00000004</span>
<span class="cp">#define LANCE_MUST_UNRESET      0x00000008</span>
<span class="cp">#define LANCE_HAS_MISSED_FRAME  0x00000010</span>

<span class="cm">/* A mapping from the chip ID number to the part number and features.</span>
<span class="cm">   These are from the datasheets -- in real life the &#39;970 version</span>
<span class="cm">   reportedly has the same ID as the &#39;965. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lance_chip_type</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">id_number</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span> <span class="n">chip_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="mh">0x0000</span><span class="p">,</span> <span class="s">&quot;LANCE 7990&quot;</span><span class="p">,</span>				<span class="cm">/* Ancient lance chip.  */</span>
		<span class="n">LANCE_MUST_PAD</span> <span class="o">+</span> <span class="n">LANCE_MUST_UNRESET</span><span class="p">},</span>
	<span class="p">{</span><span class="mh">0x0003</span><span class="p">,</span> <span class="s">&quot;PCnet/ISA 79C960&quot;</span><span class="p">,</span>		<span class="cm">/* 79C960 PCnet/ISA.  */</span>
		<span class="n">LANCE_ENABLE_AUTOSELECT</span> <span class="o">+</span> <span class="n">LANCE_MUST_REINIT_RING</span> <span class="o">+</span>
			<span class="n">LANCE_HAS_MISSED_FRAME</span><span class="p">},</span>
	<span class="p">{</span><span class="mh">0x2260</span><span class="p">,</span> <span class="s">&quot;PCnet/ISA+ 79C961&quot;</span><span class="p">,</span>		<span class="cm">/* 79C961 PCnet/ISA+, Plug-n-Play.  */</span>
		<span class="n">LANCE_ENABLE_AUTOSELECT</span> <span class="o">+</span> <span class="n">LANCE_MUST_REINIT_RING</span> <span class="o">+</span>
			<span class="n">LANCE_HAS_MISSED_FRAME</span><span class="p">},</span>
	<span class="p">{</span><span class="mh">0x2420</span><span class="p">,</span> <span class="s">&quot;PCnet/PCI 79C970&quot;</span><span class="p">,</span>		<span class="cm">/* 79C970 or 79C974 PCnet-SCSI, PCI. */</span>
		<span class="n">LANCE_ENABLE_AUTOSELECT</span> <span class="o">+</span> <span class="n">LANCE_MUST_REINIT_RING</span> <span class="o">+</span>
			<span class="n">LANCE_HAS_MISSED_FRAME</span><span class="p">},</span>
	<span class="cm">/* Bug: the PCnet/PCI actually uses the PCnet/VLB ID number, so just call</span>
<span class="cm">		it the PCnet32. */</span>
	<span class="p">{</span><span class="mh">0x2430</span><span class="p">,</span> <span class="s">&quot;PCnet32&quot;</span><span class="p">,</span>					<span class="cm">/* 79C965 PCnet for VL bus. */</span>
		<span class="n">LANCE_ENABLE_AUTOSELECT</span> <span class="o">+</span> <span class="n">LANCE_MUST_REINIT_RING</span> <span class="o">+</span>
			<span class="n">LANCE_HAS_MISSED_FRAME</span><span class="p">},</span>
        <span class="p">{</span><span class="mh">0x2621</span><span class="p">,</span> <span class="s">&quot;PCnet/PCI-II 79C970A&quot;</span><span class="p">,</span>        <span class="cm">/* 79C970A PCInetPCI II. */</span>
                <span class="n">LANCE_ENABLE_AUTOSELECT</span> <span class="o">+</span> <span class="n">LANCE_MUST_REINIT_RING</span> <span class="o">+</span>
                        <span class="n">LANCE_HAS_MISSED_FRAME</span><span class="p">},</span>
	<span class="p">{</span><span class="mh">0x0</span><span class="p">,</span> 	 <span class="s">&quot;PCnet (unknown)&quot;</span><span class="p">,</span>
		<span class="n">LANCE_ENABLE_AUTOSELECT</span> <span class="o">+</span> <span class="n">LANCE_MUST_REINIT_RING</span> <span class="o">+</span>
			<span class="n">LANCE_HAS_MISSED_FRAME</span><span class="p">},</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span><span class="n">OLD_LANCE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PCNET_ISA</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">PCNET_ISAP</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">PCNET_PCI</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">PCNET_VLB</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">PCNET_PCI_II</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">LANCE_UNKNOWN</span><span class="o">=</span><span class="mi">6</span><span class="p">};</span>


<span class="cm">/* Non-zero if lance_probe1() needs to allocate low-memory bounce buffers.</span>
<span class="cm">   Assume yes until we know the memory size. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">lance_need_isa_bounce_buffers</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">lance_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">lance_init_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mode</span><span class="p">);</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="n">lance_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lance_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">lance_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lance_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="n">lance_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">set_multicast_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">lance_tx_timeout</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>



<span class="cp">#ifdef MODULE</span>
<span class="cp">#define MAX_CARDS		8	</span><span class="cm">/* Max number of interfaces (cards) per module */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev_lance</span><span class="p">[</span><span class="n">MAX_CARDS</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">io</span><span class="p">[</span><span class="n">MAX_CARDS</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dma</span><span class="p">[</span><span class="n">MAX_CARDS</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">[</span><span class="n">MAX_CARDS</span><span class="p">];</span>

<span class="n">module_param_array</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">lance_debug</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="s">&quot;LANCE/PCnet I/O base address(es),required&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span> <span class="s">&quot;LANCE/PCnet ISA DMA channel (ignored for some devices)&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="s">&quot;LANCE/PCnet IRQ number (ignored for some devices)&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">lance_debug</span><span class="p">,</span> <span class="s">&quot;LANCE/PCnet debug level (0-7)&quot;</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">this_dev</span><span class="p">,</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">this_dev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">this_dev</span> <span class="o">&lt;</span> <span class="n">MAX_CARDS</span><span class="p">;</span> <span class="n">this_dev</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">io</span><span class="p">[</span><span class="n">this_dev</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>  <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">this_dev</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="cm">/* only complain once */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;lance.c: Module autoprobing not allowed. Append </span><span class="se">\&quot;</span><span class="s">io=0xNNN</span><span class="se">\&quot;</span><span class="s"> value(s).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_etherdev</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">[</span><span class="n">this_dev</span><span class="p">];</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">io</span><span class="p">[</span><span class="n">this_dev</span><span class="p">];</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma</span><span class="p">[</span><span class="n">this_dev</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">do_lance_probe</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_lance</span><span class="p">[</span><span class="n">found</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cleanup_card</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lance_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ml_priv</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">free_dma</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">release_region</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">,</span> <span class="n">LANCE_TOTAL_SIZE</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_bounce_buffs</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_buffs</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__exit</span> <span class="nf">cleanup_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">this_dev</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">this_dev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">this_dev</span> <span class="o">&lt;</span> <span class="n">MAX_CARDS</span><span class="p">;</span> <span class="n">this_dev</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_lance</span><span class="p">[</span><span class="n">this_dev</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">cleanup_card</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* MODULE */</span><span class="cp"></span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>


<span class="cm">/* Starting in v2.1.*, the LANCE/PCnet probe is now similar to the other</span>
<span class="cm">   board probes now that kmalloc() can allocate ISA DMA-able regions.</span>
<span class="cm">   This also allows the LANCE driver to be used as a module.</span>
<span class="cm">   */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">do_lance_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">high_memory</span> <span class="o">&lt;=</span> <span class="n">phys_to_virt</span><span class="p">(</span><span class="mi">16</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">))</span>
		<span class="n">lance_need_isa_bounce_buffers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="n">lance_portlist</span><span class="p">;</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">request_region</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">LANCE_TOTAL_SIZE</span><span class="p">,</span>
							<span class="s">&quot;lance-probe&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Detect the card with minimal I/O reads */</span>
			<span class="kt">char</span> <span class="n">offset14</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="mi">14</span><span class="p">);</span>
			<span class="kt">int</span> <span class="n">card</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">card</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">card</span> <span class="o">&lt;</span> <span class="n">NUM_CARDS</span><span class="p">;</span> <span class="o">++</span><span class="n">card</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cards</span><span class="p">[</span><span class="n">card</span><span class="p">].</span><span class="n">id_offset14</span> <span class="o">==</span> <span class="n">offset14</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">card</span> <span class="o">&lt;</span> <span class="n">NUM_CARDS</span><span class="p">)</span> <span class="p">{</span><span class="cm">/*yes, the first byte matches*/</span>
				<span class="kt">char</span> <span class="n">offset15</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="mi">15</span><span class="p">);</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">card</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">card</span> <span class="o">&lt;</span> <span class="n">NUM_CARDS</span><span class="p">;</span> <span class="o">++</span><span class="n">card</span><span class="p">)</span>
					<span class="k">if</span> <span class="p">((</span><span class="n">cards</span><span class="p">[</span><span class="n">card</span><span class="p">].</span><span class="n">id_offset14</span> <span class="o">==</span> <span class="n">offset14</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
						<span class="p">(</span><span class="n">cards</span><span class="p">[</span><span class="n">card</span><span class="p">].</span><span class="n">id_offset15</span> <span class="o">==</span> <span class="n">offset15</span><span class="p">))</span>
						<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">card</span> <span class="o">&lt;</span> <span class="n">NUM_CARDS</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*Signature OK*/</span>
				<span class="n">result</span> <span class="o">=</span> <span class="n">lance_probe1</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ioaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">struct</span> <span class="n">lance_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ml_priv</span><span class="p">;</span>
					<span class="kt">int</span> <span class="n">ver</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">chip_version</span><span class="p">;</span>

					<span class="n">r</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">chip_table</span><span class="p">[</span><span class="n">ver</span><span class="p">].</span><span class="n">name</span><span class="p">;</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">release_region</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">LANCE_TOTAL_SIZE</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef MODULE</span>
<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">lance_probe</span><span class="p">(</span><span class="kt">int</span> <span class="n">unit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_etherdev</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;eth%d&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="p">);</span>
	<span class="n">netdev_boot_setup_check</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">do_lance_probe</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">lance_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span> 		<span class="o">=</span> <span class="n">lance_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">lance_start_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">lance_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_stats</span>		<span class="o">=</span> <span class="n">lance_get_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">set_multicast_list</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span>		<span class="o">=</span> <span class="n">lance_tx_timeout</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>		<span class="o">=</span> <span class="n">eth_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span> 	<span class="o">=</span> <span class="n">eth_mac_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_validate_addr</span>	<span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">lance_probe1</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ioaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">options</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lance_private</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dma_channels</span><span class="p">;</span>	<span class="cm">/* Mark spuriously-busy DMA channels */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">reset_val</span><span class="p">,</span> <span class="n">lance_version</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">chipname</span><span class="p">;</span>
	<span class="cm">/* Flags for specific chips or boards. */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">hpJ2405A</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* HP ISA adaptor */</span>
	<span class="kt">int</span> <span class="n">hp_builtin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* HP on-board ethernet. */</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">did_version</span><span class="p">;</span>		<span class="cm">/* Already printed version info. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">bios</span><span class="p">;</span>

	<span class="cm">/* First we look for special cases.</span>
<span class="cm">	   Check for HP&#39;s on-board ethernet by looking for &#39;HP&#39; in the BIOS.</span>
<span class="cm">	   There are two HP versions, check the BIOS for the configuration port.</span>
<span class="cm">	   This method provided by L. Julliard, Laurent_Julliard@grenoble.hp.com.</span>
<span class="cm">	   */</span>
	<span class="n">bios</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0xf00f0</span><span class="p">,</span> <span class="mh">0x14</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bios</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">readw</span><span class="p">(</span><span class="n">bios</span> <span class="o">+</span> <span class="mh">0x12</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x5048</span><span class="p">)</span>  <span class="p">{</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">short</span> <span class="n">ioaddr_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x300</span><span class="p">,</span> <span class="mh">0x320</span><span class="p">,</span> <span class="mh">0x340</span><span class="p">,</span> <span class="mh">0x360</span><span class="p">};</span>
		<span class="kt">int</span> <span class="n">hp_port</span> <span class="o">=</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">bios</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>  <span class="o">?</span> <span class="mh">0x499</span> <span class="o">:</span> <span class="mh">0x99</span><span class="p">;</span>
		<span class="cm">/* We can have boards other than the built-in!  Verify this is on-board. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">inb</span><span class="p">(</span><span class="n">hp_port</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xc0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x80</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ioaddr_table</span><span class="p">[</span><span class="n">inb</span><span class="p">(</span><span class="n">hp_port</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">ioaddr</span><span class="p">)</span>
			<span class="n">hp_builtin</span> <span class="o">=</span> <span class="n">hp_port</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">bios</span><span class="p">);</span>
	<span class="cm">/* We also recognize the HP Vectra on-board here, but check below. */</span>
	<span class="n">hpJ2405A</span> <span class="o">=</span> <span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x08</span> <span class="o">&amp;&amp;</span> <span class="n">inb</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x00</span> <span class="o">&amp;&amp;</span>
		    <span class="n">inb</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x09</span><span class="p">);</span>

	<span class="cm">/* Reset the LANCE.	 */</span>
	<span class="n">reset_val</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_RESET</span><span class="p">);</span> <span class="cm">/* Reset the LANCE */</span>

	<span class="cm">/* The Un-Reset needed is only needed for the real NE2100, and will</span>
<span class="cm">	   confuse the HP board. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hpJ2405A</span><span class="p">)</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">reset_val</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_RESET</span><span class="p">);</span>

	<span class="n">outw</span><span class="p">(</span><span class="mh">0x0000</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">);</span> <span class="cm">/* Switch to window 0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x0004</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* Get the version of the chip. */</span>
	<span class="n">outw</span><span class="p">(</span><span class="mi">88</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">88</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lance_version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>			<span class="cm">/* Good, it&#39;s a newer chip. */</span>
		<span class="kt">int</span> <span class="n">chip_version</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">);</span>
		<span class="n">outw</span><span class="p">(</span><span class="mi">89</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">);</span>
		<span class="n">chip_version</span> <span class="o">|=</span> <span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lance_debug</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  LANCE chip version is %#x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chip_version</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">chip_version</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x003</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="n">chip_version</span> <span class="o">=</span> <span class="p">(</span><span class="n">chip_version</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">lance_version</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">chip_table</span><span class="p">[</span><span class="n">lance_version</span><span class="p">].</span><span class="n">id_number</span><span class="p">;</span> <span class="n">lance_version</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chip_table</span><span class="p">[</span><span class="n">lance_version</span><span class="p">].</span><span class="n">id_number</span> <span class="o">==</span> <span class="n">chip_version</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* We can&#39;t allocate private data from alloc_etherdev() because it must</span>
<span class="cm">	   a ISA DMA-able region. */</span>
	<span class="n">chipname</span> <span class="o">=</span> <span class="n">chip_table</span><span class="p">[</span><span class="n">lance_version</span><span class="p">].</span><span class="n">name</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: %s at %#3x, &quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">chipname</span><span class="p">,</span> <span class="n">ioaddr</span><span class="p">);</span>

	<span class="cm">/* There is a 16 byte station address PROM at the base address.</span>
<span class="cm">	   The first six bytes are the station address. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%pM&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">ioaddr</span><span class="p">;</span>
	<span class="cm">/* Make certain the data structures used by the LANCE are aligned and DMAble. */</span>

	<span class="n">lp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lp</span><span class="p">),</span> <span class="n">GFP_DMA</span> <span class="o">|</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">lp</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lance_debug</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">)</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot; (#0x%05lx)&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lp</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ml_priv</span> <span class="o">=</span> <span class="n">lp</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">chipname</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_buffs</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">kmalloc</span><span class="p">(</span><span class="n">PKT_BUF_SZ</span><span class="o">*</span><span class="n">RX_RING_SIZE</span><span class="p">,</span>
						  <span class="n">GFP_DMA</span> <span class="o">|</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_buffs</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_lp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lance_need_isa_bounce_buffers</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_bounce_buffs</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">PKT_BUF_SZ</span><span class="o">*</span><span class="n">TX_RING_SIZE</span><span class="p">,</span>
						  <span class="n">GFP_DMA</span> <span class="o">|</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_bounce_buffs</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_rx</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_bounce_buffs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">chip_version</span> <span class="o">=</span> <span class="n">lance_version</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">devlock</span><span class="p">);</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="mh">0x0003</span><span class="p">;</span>		<span class="cm">/* Disable Rx and Tx. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">.</span><span class="n">phys_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">.</span><span class="n">filter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00000000</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">.</span><span class="n">filter</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00000000</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">.</span><span class="n">rx_ring</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">isa_virt_to_bus</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffff</span><span class="p">)</span> <span class="o">|</span> <span class="n">RX_RING_LEN_BITS</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">.</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">isa_virt_to_bus</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffff</span><span class="p">)</span> <span class="o">|</span> <span class="n">TX_RING_LEN_BITS</span><span class="p">;</span>

	<span class="n">outw</span><span class="p">(</span><span class="mh">0x0001</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">);</span>
	<span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">((</span><span class="kt">short</span><span class="p">)</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">isa_virt_to_bus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">),</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span><span class="mh">0x0002</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">);</span>
	<span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(((</span><span class="n">u32</span><span class="p">)</span><span class="n">isa_virt_to_bus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span><span class="mh">0x0000</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">);</span>
	<span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>					<span class="cm">/* Set iff PCI card. */</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>			<span class="cm">/* Native bus-master, no DMA channel needed. */</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hp_builtin</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">dma_tbl</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">irq_tbl</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">port_val</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">hp_builtin</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma_tbl</span><span class="p">[(</span><span class="n">port_val</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">];</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq_tbl</span><span class="p">[(</span><span class="n">port_val</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">];</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; HP Vectra IRQ %d DMA %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hpJ2405A</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">dma_tbl</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">};</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">irq_tbl</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">15</span><span class="p">};</span>
		<span class="kt">short</span> <span class="n">reset_val</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_RESET</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma_tbl</span><span class="p">[(</span><span class="n">reset_val</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">];</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq_tbl</span><span class="p">[(</span><span class="n">reset_val</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">];</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; HP J2405A IRQ %d DMA %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lance_version</span> <span class="o">==</span> <span class="n">PCNET_ISAP</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* The plug-n-play version. */</span>
		<span class="kt">short</span> <span class="n">bus_info</span><span class="p">;</span>
		<span class="n">outw</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">);</span>
		<span class="n">bus_info</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_BUS_IF</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">bus_info</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="p">(</span><span class="n">bus_info</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* The DMA channel may be passed in PARAM1. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read the DMA channel status register, so that we can avoid</span>
<span class="cm">		   stuck DMA channels in the DMA detection below. */</span>
		<span class="n">dma_channels</span> <span class="o">=</span> <span class="p">((</span><span class="n">inb</span><span class="p">(</span><span class="n">DMA1_STAT_REG</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">DMA2_STAT_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; assigned IRQ %d&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lance_version</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>  <span class="p">{</span>	<span class="cm">/* 7990 boards need DMA detection first. */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_mask</span><span class="p">;</span>

		<span class="cm">/* To auto-IRQ we enable the initialization-done and DMA error</span>
<span class="cm">		   interrupts. For ISA boards we get a DMA error, but VLB and PCI</span>
<span class="cm">		   boards will work. */</span>
		<span class="n">irq_mask</span> <span class="o">=</span> <span class="n">probe_irq_on</span><span class="p">();</span>

		<span class="cm">/* Trigger an initialization just for the interrupt. */</span>
		<span class="n">outw</span><span class="p">(</span><span class="mh">0x0041</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">);</span>

		<span class="n">mdelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">probe_irq_off</span><span class="p">(</span><span class="n">irq_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;, probed IRQ %d&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;, failed to detect IRQ line.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_tx</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Check for the initialization done bit, 0x0100, which means</span>
<span class="cm">		   that we don&#39;t need a DMA channel. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0100</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;, no DMA needed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">request_dma</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span> <span class="n">chipname</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;DMA %d allocation failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_tx</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;, assigned DMA %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>			<span class="cm">/* OK, we have to auto-DMA. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">dmas</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>
			<span class="kt">int</span> <span class="n">dma</span> <span class="o">=</span> <span class="n">dmas</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="kt">int</span> <span class="n">boguscnt</span><span class="p">;</span>

			<span class="cm">/* Don&#39;t enable a permanently busy DMA channel, or the machine</span>
<span class="cm">			   will hang. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma_channels</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">outw</span><span class="p">(</span><span class="mh">0x7f04</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">);</span> <span class="cm">/* Clear the memory error bits. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">request_dma</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span> <span class="n">chipname</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">flags</span><span class="o">=</span><span class="n">claim_dma_lock</span><span class="p">();</span>
			<span class="n">set_dma_mode</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span> <span class="n">DMA_MODE_CASCADE</span><span class="p">);</span>
			<span class="n">enable_dma</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
			<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

			<span class="cm">/* Trigger an initialization. */</span>
			<span class="n">outw</span><span class="p">(</span><span class="mh">0x0001</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">boguscnt</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">boguscnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">boguscnt</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0900</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0100</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma</span><span class="p">;</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;, DMA %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">flags</span><span class="o">=</span><span class="n">claim_dma_lock</span><span class="p">();</span>
				<span class="n">disable_dma</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
				<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
				<span class="n">free_dma</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>			<span class="cm">/* Failure: bail. */</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;DMA detection failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_tx</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lance_version</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We may auto-IRQ now that we have a DMA channel. */</span>
		<span class="cm">/* Trigger an initialization just for the interrupt. */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_mask</span><span class="p">;</span>

		<span class="n">irq_mask</span> <span class="o">=</span> <span class="n">probe_irq_on</span><span class="p">();</span>
		<span class="n">outw</span><span class="p">(</span><span class="mh">0x0041</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">);</span>

		<span class="n">mdelay</span><span class="p">(</span><span class="mi">40</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">probe_irq_off</span><span class="p">(</span><span class="n">irq_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  Failed to detect the 7990 IRQ line.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_dma</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  Auto-IRQ detected IRQ%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip_table</span><span class="p">[</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">chip_version</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LANCE_ENABLE_AUTOSELECT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Turn on auto-select of media (10baseT or BNC) so that the user</span>
<span class="cm">		   can watch the LEDs even if the board isn&#39;t opened. */</span>
		<span class="n">outw</span><span class="p">(</span><span class="mh">0x0002</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">);</span>
		<span class="cm">/* Don&#39;t touch 10base2 power bit. */</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_BUS_IF</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x0002</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_BUS_IF</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lance_debug</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="o">&amp;&amp;</span>  <span class="n">did_version</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">version</span><span class="p">);</span>

	<span class="cm">/* The LANCE-specific entries in the device structure. */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lance_netdev_ops</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="n">TX_TIMEOUT</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_dma</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_dma:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">free_dma</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
<span class="nl">out_tx:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_bounce_buffs</span><span class="p">);</span>
<span class="nl">out_rx:</span>
	<span class="n">kfree</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_buffs</span><span class="p">);</span>
<span class="nl">out_lp:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lance_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lance_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ml_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
		<span class="n">request_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">lance_interrupt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We used to allocate DMA here, but that was silly.</span>
<span class="cm">	   DMA lines can&#39;t be shared!  We now permanently allocate them. */</span>

	<span class="cm">/* Reset the LANCE */</span>
	<span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_RESET</span><span class="p">);</span>

	<span class="cm">/* The DMA controller is used as a no-operation slave, &quot;cascade mode&quot;. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="o">=</span><span class="n">claim_dma_lock</span><span class="p">();</span>
		<span class="n">enable_dma</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
		<span class="n">set_dma_mode</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span> <span class="n">DMA_MODE_CASCADE</span><span class="p">);</span>
		<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Un-Reset the LANCE, needed only for the NE2100. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip_table</span><span class="p">[</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">chip_version</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LANCE_MUST_UNRESET</span><span class="p">)</span>
		<span class="n">outw</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_RESET</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip_table</span><span class="p">[</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">chip_version</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LANCE_ENABLE_AUTOSELECT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This is 79C960-specific: Turn on auto-select of media (AUI, BNC). */</span>
		<span class="n">outw</span><span class="p">(</span><span class="mh">0x0002</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">);</span>
		<span class="cm">/* Only touch autoselect bit. */</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_BUS_IF</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x0002</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_BUS_IF</span><span class="p">);</span>
 	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lance_debug</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: lance_open() irq %d dma %d tx/rx rings %#x/%#x init %#x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
		           <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">isa_virt_to_bus</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">),</span>
		           <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">isa_virt_to_bus</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">),</span>
			   <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">isa_virt_to_bus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">));</span>

	<span class="n">lance_init_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="cm">/* Re-initialize the LANCE, and start it when done. */</span>
	<span class="n">outw</span><span class="p">(</span><span class="mh">0x0001</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">((</span><span class="kt">short</span><span class="p">)</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">isa_virt_to_bus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">),</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span><span class="mh">0x0002</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(((</span><span class="n">u32</span><span class="p">)</span><span class="n">isa_virt_to_bus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">);</span>

	<span class="n">outw</span><span class="p">(</span><span class="mh">0x0004</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span><span class="mh">0x0915</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">);</span>

	<span class="n">outw</span><span class="p">(</span><span class="mh">0x0000</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span><span class="mh">0x0001</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">);</span>

	<span class="n">netif_start_queue</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0100</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We used to clear the InitDone bit, 0x0100, here but Mark Stockton</span>
<span class="cm">	 * reports that doing so triggers a bug in the &#39;974.</span>
<span class="cm">	 */</span>
 	<span class="n">outw</span><span class="p">(</span><span class="mh">0x0042</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lance_debug</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: LANCE open after %d ticks, init block %#x csr0 %4.4x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">isa_virt_to_bus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">),</span> <span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>					<span class="cm">/* Always succeed */</span>
<span class="p">}</span>

<span class="cm">/* The LANCE has been halted for one reason or another (busmaster memory</span>
<span class="cm">   arbitration error, Tx FIFO underflow, driver stopped it to reconfigure,</span>
<span class="cm">   etc.).  Modern LANCE variants always reload their ring-buffer</span>
<span class="cm">   configuration when restarted, so we must reinitialize our ring</span>
<span class="cm">   context before restarting.  As part of this reinitialization,</span>
<span class="cm">   find all packets still on the Tx ring and pretend that they had been</span>
<span class="cm">   sent (in effect, drop the packets on the floor) - the higher-level</span>
<span class="cm">   protocols will time out and retransmit.  It&#39;d be better to shuffle</span>
<span class="cm">   these skbs to a temp list and then actually re-Tx them after</span>
<span class="cm">   restarting the chip, but I&#39;m too lazy to do so right now.  dplatt@3do.com</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lance_purge_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lance_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ml_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Free all the skbuffs in the Rx and Tx queues. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* Not owned by LANCE chip. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
			<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/* Initialize the LANCE Rx and Tx rings. */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lance_init_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lance_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ml_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty_rx</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">rx_buff</span><span class="p">;</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">PKT_BUF_SZ</span><span class="p">,</span> <span class="n">GFP_DMA</span> <span class="o">|</span> <span class="n">gfp</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
			<span class="n">rx_buff</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">rx_buff</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">PKT_BUF_SZ</span><span class="p">,</span> <span class="n">GFP_DMA</span> <span class="o">|</span> <span class="n">gfp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rx_buff</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">isa_virt_to_bus</span><span class="p">(</span><span class="n">rx_buff</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x80000000</span><span class="p">;</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buf_length</span> <span class="o">=</span> <span class="o">-</span><span class="n">PKT_BUF_SZ</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* The Tx buffer address is filled in as needed, but we do need to clear</span>
<span class="cm">	   the upper ownership bit. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="mh">0x0000</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">.</span><span class="n">phys_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">.</span><span class="n">filter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00000000</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">.</span><span class="n">filter</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00000000</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">.</span><span class="n">rx_ring</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">isa_virt_to_bus</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffff</span><span class="p">)</span> <span class="o">|</span> <span class="n">RX_RING_LEN_BITS</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">.</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">isa_virt_to_bus</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffff</span><span class="p">)</span> <span class="o">|</span> <span class="n">TX_RING_LEN_BITS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lance_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">csr0_bits</span><span class="p">,</span> <span class="kt">int</span> <span class="n">must_reinit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lance_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ml_priv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">must_reinit</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">chip_table</span><span class="p">[</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">chip_version</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LANCE_MUST_REINIT_RING</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lance_purge_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">lance_init_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">outw</span><span class="p">(</span><span class="mh">0x0000</span><span class="p">,</span>    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LANCE_ADDR</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">csr0_bits</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LANCE_DATA</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">lance_tx_timeout</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lance_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lance_private</span> <span class="o">*</span><span class="p">)</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ml_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>

	<span class="n">outw</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">LANCE_ADDR</span><span class="p">);</span>
	<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;%s: transmit timed out, status %4.4x, resetting.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">inw</span> <span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">LANCE_DATA</span><span class="p">));</span>
	<span class="n">outw</span> <span class="p">(</span><span class="mh">0x0004</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">LANCE_DATA</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#ifndef final_version</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lance_debug</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot; Ring data dump: dirty_tx %d cur_tx %d%s cur_rx %d.&quot;</span><span class="p">,</span>
		  <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_tx</span><span class="p">,</span> <span class="n">netif_queue_stopped</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; (full)&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_rx</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;%s %08x %04x %04x&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x3</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s"> &quot;</span><span class="p">,</span>
			 <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span><span class="p">,</span> <span class="o">-</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buf_length</span><span class="p">,</span>
				<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">msg_length</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;%s %08x %04x %04x&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x3</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s"> &quot;</span><span class="p">,</span>
			     <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span><span class="p">,</span> <span class="o">-</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">,</span>
				<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">misc</span><span class="p">);</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">lance_restart</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0043</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span> <span class="cm">/* prevent tx timeout */</span>
	<span class="n">netif_wake_queue</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">lance_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lance_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ml_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">devlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lance_debug</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outw</span><span class="p">(</span><span class="mh">0x0000</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: lance_start_xmit() called, csr0 %4.4x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			   <span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">));</span>
		<span class="n">outw</span><span class="p">(</span><span class="mh">0x0000</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Fill in a Tx ring entry */</span>

	<span class="cm">/* Mask to ring buffer boundary. */</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">&amp;</span> <span class="n">TX_RING_MOD_MASK</span><span class="p">;</span>

	<span class="cm">/* Caution: the write order is important here, set the base address</span>
<span class="cm">	   with the &quot;ownership&quot; bits last. */</span>

	<span class="cm">/* The old LANCE chips doesn&#39;t automatically pad buffers to min. size. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip_table</span><span class="p">[</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">chip_version</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LANCE_MUST_PAD</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">ETH_ZLEN</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb_padto</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ETH_ZLEN</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETH_ZLEN</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="o">-</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="o">-</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">misc</span> <span class="o">=</span> <span class="mh">0x0000</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="cm">/* If any part of this buffer is &gt;16M we must copy it to a low-memory</span>
<span class="cm">	   buffer. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">isa_virt_to_bus</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mh">0x01000000</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lance_debug</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: bouncing a high-memory packet (%#x).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">isa_virt_to_bus</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">));</span>
		<span class="n">skb_copy_from_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_bounce_buffs</span><span class="p">[</span><span class="n">entry</span><span class="p">],</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span>
			<span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">isa_virt_to_bus</span><span class="p">((</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_bounce_buffs</span> <span class="o">+</span> <span class="n">entry</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xffffff</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x83000000</span><span class="p">;</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">isa_virt_to_bus</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffff</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x83000000</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_tx</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Trigger an immediate send poll. */</span>
	<span class="n">outw</span><span class="p">(</span><span class="mh">0x0000</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span><span class="mh">0x0048</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">-</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">TX_RING_SIZE</span><span class="p">)</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">devlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The LANCE interrupt handler. */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">lance_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lance_private</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">csr0</span><span class="p">,</span> <span class="n">ioaddr</span><span class="p">,</span> <span class="n">boguscnt</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">must_restart</span><span class="p">;</span>

	<span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ml_priv</span><span class="p">;</span>

	<span class="n">spin_lock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">devlock</span><span class="p">);</span>

	<span class="n">outw</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LANCE_ADDR</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">csr0</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LANCE_DATA</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x8600</span> <span class="o">&amp;&amp;</span>
	       <span class="o">--</span><span class="n">boguscnt</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Acknowledge all of the current interrupt sources ASAP. */</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">csr0</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x004f</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LANCE_DATA</span><span class="p">);</span>

		<span class="n">must_restart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lance_debug</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: interrupt  csr0=%#2.2x new csr=%#2.2x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">csr0</span><span class="p">,</span> <span class="n">inw</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LANCE_DATA</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">csr0</span> <span class="o">&amp;</span> <span class="mh">0x0400</span><span class="p">)</span>			<span class="cm">/* Rx interrupt */</span>
			<span class="n">lance_rx</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">csr0</span> <span class="o">&amp;</span> <span class="mh">0x0200</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* Tx-done interrupt */</span>
			<span class="kt">int</span> <span class="n">dirty_tx</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span><span class="p">;</span>

			<span class="k">while</span> <span class="p">(</span><span class="n">dirty_tx</span> <span class="o">&lt;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_tx</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">dirty_tx</span> <span class="o">&amp;</span> <span class="n">TX_RING_MOD_MASK</span><span class="p">;</span>
				<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">base</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>			<span class="cm">/* It still hasn&#39;t been Txed */</span>

				<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x40000000</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* There was an major error, log it. */</span>
					<span class="kt">int</span> <span class="n">err_status</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">misc</span><span class="p">;</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">err_status</span> <span class="o">&amp;</span> <span class="mh">0x0400</span><span class="p">)</span>
						<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_aborted_errors</span><span class="o">++</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">err_status</span> <span class="o">&amp;</span> <span class="mh">0x0800</span><span class="p">)</span>
						<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_carrier_errors</span><span class="o">++</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">err_status</span> <span class="o">&amp;</span> <span class="mh">0x1000</span><span class="p">)</span>
						<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_window_errors</span><span class="o">++</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">err_status</span> <span class="o">&amp;</span> <span class="mh">0x4000</span><span class="p">)</span> <span class="p">{</span>
						<span class="cm">/* Ackk!  On FIFO errors the Tx unit is turned off! */</span>
						<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
						<span class="cm">/* Remove this verbosity later! */</span>
						<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Tx FIFO error! Status %4.4x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">csr0</span><span class="p">);</span>
						<span class="cm">/* Restart the chip. */</span>
						<span class="n">must_restart</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x18000000</span><span class="p">)</span>
						<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">collisions</span><span class="o">++</span><span class="p">;</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/* We must free the original skb if it&#39;s not a data-only copy</span>
<span class="cm">				   in the bounce buffer. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">])</span> <span class="p">{</span>
					<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]);</span>
					<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">dirty_tx</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>

<span class="cp">#ifndef final_version</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">-</span> <span class="n">dirty_tx</span> <span class="o">&gt;=</span> <span class="n">TX_RING_SIZE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;out-of-sync dirty pointer, %d vs. %d, full=%s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">dirty_tx</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_tx</span><span class="p">,</span>
					   <span class="n">netif_queue_stopped</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;yes&quot;</span> <span class="o">:</span> <span class="s">&quot;no&quot;</span><span class="p">);</span>
				<span class="n">dirty_tx</span> <span class="o">+=</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#endif</span>

			<span class="cm">/* if the ring is no longer full, accept more packets */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">netif_queue_stopped</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">dirty_tx</span> <span class="o">&gt;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">-</span> <span class="n">TX_RING_SIZE</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
				<span class="n">netif_wake_queue</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>

			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">=</span> <span class="n">dirty_tx</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Log misc errors. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">csr0</span> <span class="o">&amp;</span> <span class="mh">0x4000</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* Tx babble. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">csr0</span> <span class="o">&amp;</span> <span class="mh">0x1000</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* Missed a Rx frame. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">csr0</span> <span class="o">&amp;</span> <span class="mh">0x0800</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Bus master arbitration failure, status %4.4x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">csr0</span><span class="p">);</span>
			<span class="cm">/* Restart the chip. */</span>
			<span class="n">must_restart</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">must_restart</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* stop the chip to clear the error condition, then restart */</span>
			<span class="n">outw</span><span class="p">(</span><span class="mh">0x0000</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LANCE_ADDR</span><span class="p">);</span>
			<span class="n">outw</span><span class="p">(</span><span class="mh">0x0004</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LANCE_DATA</span><span class="p">);</span>
			<span class="n">lance_restart</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0002</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Clear any other interrupt, and set interrupt enable. */</span>
	<span class="n">outw</span><span class="p">(</span><span class="mh">0x0000</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LANCE_ADDR</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span><span class="mh">0x7940</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LANCE_DATA</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lance_debug</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: exiting interrupt, csr%d=%#4.4x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">LANCE_ADDR</span><span class="p">),</span>
			   <span class="n">inw</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">LANCE_DATA</span><span class="p">));</span>

	<span class="n">spin_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">devlock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lance_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lance_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ml_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="o">&amp;</span> <span class="n">RX_RING_MOD_MASK</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* If we own the next entry, it&#39;s a new packet. Send it up. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">base</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">base</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mh">0x03</span><span class="p">)</span> <span class="p">{</span>			<span class="cm">/* There was an error. */</span>
			<span class="cm">/* There is a tricky error noted by John Murphy,</span>
<span class="cm">			   &lt;murf@perftech.com&gt; to Russ Nelson: Even with full-sized</span>
<span class="cm">			   buffers it&#39;s possible for a jabber packet to use two</span>
<span class="cm">			   buffers, with only the last correctly noting the error. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span>	<span class="cm">/* Only count a general error at the */</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* end of a packet.*/</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_frame_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_over_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x08</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_crc_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x04</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">base</span> <span class="o">&amp;=</span> <span class="mh">0x03ffffff</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="cm">/* Malloc up new buffer, compatible with net3. */</span>
			<span class="kt">short</span> <span class="n">pkt_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">msg_length</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">)</span><span class="o">-</span><span class="mi">4</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

			<span class="k">if</span><span class="p">(</span><span class="n">pkt_len</span><span class="o">&lt;</span><span class="mi">60</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Runt packet!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span>
			<span class="p">{</span>
				<span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">pkt_len</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Memory squeeze, deferring packet.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
					<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[(</span><span class="n">entry</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RX_RING_MOD_MASK</span><span class="p">].</span><span class="n">base</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
							<span class="k">break</span><span class="p">;</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">RX_RING_SIZE</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
					<span class="p">{</span>
						<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
						<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">base</span> <span class="o">|=</span> <span class="mh">0x80000000</span><span class="p">;</span>
						<span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_rx</span><span class="o">++</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>	<span class="cm">/* 16 byte align */</span>
				<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span><span class="n">pkt_len</span><span class="p">);</span>	<span class="cm">/* Make room */</span>
				<span class="n">skb_copy_to_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">isa_bus_to_virt</span><span class="p">((</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">base</span> <span class="o">&amp;</span> <span class="mh">0x00ffffff</span><span class="p">)),</span>
					<span class="n">pkt_len</span><span class="p">);</span>
				<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="o">=</span><span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span><span class="n">dev</span><span class="p">);</span>
				<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">pkt_len</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* The docs say that the buffer length isn&#39;t touched, but Andrew Boyd</span>
<span class="cm">		   of QNX reports that some revs of the 79C965 clear it. */</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">buf_length</span> <span class="o">=</span> <span class="o">-</span><span class="n">PKT_BUF_SZ</span><span class="p">;</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">base</span> <span class="o">|=</span> <span class="mh">0x80000000</span><span class="p">;</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="o">++</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_rx</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RX_RING_MOD_MASK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We should check that at least two ring entries are free.	 If not,</span>
<span class="cm">	   we should free one and mark stats-&gt;rx_dropped++. */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lance_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lance_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ml_priv</span><span class="p">;</span>

	<span class="n">netif_stop_queue</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip_table</span><span class="p">[</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">chip_version</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LANCE_HAS_MISSED_FRAME</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outw</span><span class="p">(</span><span class="mi">112</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_missed_errors</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">outw</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lance_debug</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Shutting down ethercard, status was %2.2x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">));</span>

	<span class="cm">/* We stop the LANCE here -- it occasionally polls</span>
<span class="cm">	   memory if we don&#39;t. */</span>
	<span class="n">outw</span><span class="p">(</span><span class="mh">0x0004</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="o">=</span><span class="n">claim_dma_lock</span><span class="p">();</span>
		<span class="n">disable_dma</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
		<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">lance_purge_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="nf">lance_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lance_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ml_priv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip_table</span><span class="p">[</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">chip_version</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LANCE_HAS_MISSED_FRAME</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">short</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
		<span class="kt">short</span> <span class="n">saved_addr</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">devlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">saved_addr</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">);</span>
		<span class="n">outw</span><span class="p">(</span><span class="mi">112</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_missed_errors</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">);</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">saved_addr</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">devlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Set or clear the multicast filter for this adaptor.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_multicast_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">short</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>

	<span class="n">outw</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span><span class="mh">0x0004</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">);</span> <span class="cm">/* Temporarily stop the lance.	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="o">&amp;</span><span class="n">IFF_PROMISC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outw</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">);</span>
		<span class="n">outw</span><span class="p">(</span><span class="mh">0x8000</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">);</span> <span class="cm">/* Set promiscuous mode */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">short</span> <span class="n">multicast_table</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">num_addrs</span><span class="o">=</span><span class="n">netdev_mc_count</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="o">&amp;</span><span class="n">IFF_ALLMULTI</span><span class="p">)</span>
			<span class="n">num_addrs</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* FIXIT: We don&#39;t use the multicast table, but rely on upper-layer filtering. */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">multicast_table</span><span class="p">,</span> <span class="p">(</span><span class="n">num_addrs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">multicast_table</span><span class="p">));</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">outw</span><span class="p">(</span><span class="mi">8</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">);</span>
			<span class="n">outw</span><span class="p">(</span><span class="n">multicast_table</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">outw</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_ADDR</span><span class="p">);</span>
		<span class="n">outw</span><span class="p">(</span><span class="mh">0x0000</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">LANCE_DATA</span><span class="p">);</span> <span class="cm">/* Unset promiscuous mode */</span>
	<span class="p">}</span>

	<span class="n">lance_restart</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0142</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/*  Resume normal operation */</span>

<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
