<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › amd › pcnet32.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>pcnet32.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* pcnet32.c: An AMD PCnet32 ethernet driver for linux. */</span>
<span class="cm">/*</span>
<span class="cm"> *	Copyright 1996-1999 Thomas Bogendoerfer</span>
<span class="cm"> *</span>
<span class="cm"> *	Derived from the lance driver written 1993,1994,1995 by Donald Becker.</span>
<span class="cm"> *</span>
<span class="cm"> *	Copyright 1993 United States Government as represented by the</span>
<span class="cm"> *	Director, National Security Agency.</span>
<span class="cm"> *</span>
<span class="cm"> *	This software may be used and distributed according to the terms</span>
<span class="cm"> *	of the GNU General Public License, incorporated herein by reference.</span>
<span class="cm"> *</span>
<span class="cm"> *	This driver is for PCnet32 and PCnetPCI based ethercards</span>
<span class="cm"> */</span>
<span class="cm">/**************************************************************************</span>
<span class="cm"> *  23 Oct, 2000.</span>
<span class="cm"> *  Fixed a few bugs, related to running the controller in 32bit mode.</span>
<span class="cm"> *</span>
<span class="cm"> *  Carsten Langgaard, carstenl@mips.com</span>
<span class="cm"> *  Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *************************************************************************/</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#define DRV_NAME	&quot;pcnet32&quot;</span>
<span class="cp">#define DRV_VERSION	&quot;1.35&quot;</span>
<span class="cp">#define DRV_RELDATE	&quot;21.Apr.2008&quot;</span>
<span class="cp">#define PFX		DRV_NAME &quot;: &quot;</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">version</span> <span class="o">=</span>
    <span class="n">DRV_NAME</span> <span class="s">&quot;.c:v&quot;</span> <span class="n">DRV_VERSION</span> <span class="s">&quot; &quot;</span> <span class="n">DRV_RELDATE</span> <span class="s">&quot; tsbogend@alpha.franken.de</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/mii.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/if_ether.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>

<span class="cp">#include &lt;asm/dma.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * PCI device identifiers for &quot;new style&quot; Linux PCI Device Drivers</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">pcnet32_pci_tbl</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_AMD_LANCE_HOME</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_AMD_LANCE</span><span class="p">),</span> <span class="p">},</span>

	<span class="cm">/*</span>
<span class="cm">	 * Adapters that were sold with IBM&#39;s RS/6000 or pSeries hardware have</span>
<span class="cm">	 * the incorrect vendor id.</span>
<span class="cm">	 */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_TRIDENT</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_AMD_LANCE</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCI_CLASS_NETWORK_ETHERNET</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span> <span class="p">.</span><span class="n">class_mask</span> <span class="o">=</span> <span class="mh">0xffff00</span><span class="p">,</span> <span class="p">},</span>

	<span class="p">{</span> <span class="p">}</span>	<span class="cm">/* terminate list */</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">pcnet32_pci_tbl</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">cards_found</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * VLB I/O addresses</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pcnet32_portlist</span><span class="p">[]</span> <span class="o">=</span>
    <span class="p">{</span> <span class="mh">0x300</span><span class="p">,</span> <span class="mh">0x320</span><span class="p">,</span> <span class="mh">0x340</span><span class="p">,</span> <span class="mh">0x360</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">pcnet32_debug</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">tx_start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Mapping -- 0:20, 1:64, 2:128, 3:~220 (depends on chip vers) */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pcnet32vlb</span><span class="p">;</span>		<span class="cm">/* check for VLB cards ? */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">pcnet32_dev</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">max_interrupt_work</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rx_copybreak</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>

<span class="cp">#define PCNET32_PORT_AUI      0x00</span>
<span class="cp">#define PCNET32_PORT_10BT     0x01</span>
<span class="cp">#define PCNET32_PORT_GPSI     0x02</span>
<span class="cp">#define PCNET32_PORT_MII      0x03</span>

<span class="cp">#define PCNET32_PORT_PORTSEL  0x03</span>
<span class="cp">#define PCNET32_PORT_ASEL     0x04</span>
<span class="cp">#define PCNET32_PORT_100      0x40</span>
<span class="cp">#define PCNET32_PORT_FD	      0x80</span>

<span class="cp">#define PCNET32_DMA_MASK 0xffffffff</span>

<span class="cp">#define PCNET32_WATCHDOG_TIMEOUT (jiffies + (2 * HZ))</span>
<span class="cp">#define PCNET32_BLINK_TIMEOUT	(jiffies + (HZ/4))</span>

<span class="cm">/*</span>
<span class="cm"> * table to translate option values from tulip</span>
<span class="cm"> * to internal options</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">options_mapping</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">PCNET32_PORT_ASEL</span><span class="p">,</span>			<span class="cm">/*  0 Auto-select      */</span>
	<span class="n">PCNET32_PORT_AUI</span><span class="p">,</span>			<span class="cm">/*  1 BNC/AUI          */</span>
	<span class="n">PCNET32_PORT_AUI</span><span class="p">,</span>			<span class="cm">/*  2 AUI/BNC          */</span>
	<span class="n">PCNET32_PORT_ASEL</span><span class="p">,</span>			<span class="cm">/*  3 not supported    */</span>
	<span class="n">PCNET32_PORT_10BT</span> <span class="o">|</span> <span class="n">PCNET32_PORT_FD</span><span class="p">,</span>	<span class="cm">/*  4 10baseT-FD       */</span>
	<span class="n">PCNET32_PORT_ASEL</span><span class="p">,</span>			<span class="cm">/*  5 not supported    */</span>
	<span class="n">PCNET32_PORT_ASEL</span><span class="p">,</span>			<span class="cm">/*  6 not supported    */</span>
	<span class="n">PCNET32_PORT_ASEL</span><span class="p">,</span>			<span class="cm">/*  7 not supported    */</span>
	<span class="n">PCNET32_PORT_ASEL</span><span class="p">,</span>			<span class="cm">/*  8 not supported    */</span>
	<span class="n">PCNET32_PORT_MII</span><span class="p">,</span>			<span class="cm">/*  9 MII 10baseT      */</span>
	<span class="n">PCNET32_PORT_MII</span> <span class="o">|</span> <span class="n">PCNET32_PORT_FD</span><span class="p">,</span>	<span class="cm">/* 10 MII 10baseT-FD   */</span>
	<span class="n">PCNET32_PORT_MII</span><span class="p">,</span>			<span class="cm">/* 11 MII (autosel)    */</span>
	<span class="n">PCNET32_PORT_10BT</span><span class="p">,</span>			<span class="cm">/* 12 10BaseT          */</span>
	<span class="n">PCNET32_PORT_MII</span> <span class="o">|</span> <span class="n">PCNET32_PORT_100</span><span class="p">,</span>	<span class="cm">/* 13 MII 100BaseTx    */</span>
						<span class="cm">/* 14 MII 100BaseTx-FD */</span>
	<span class="n">PCNET32_PORT_MII</span> <span class="o">|</span> <span class="n">PCNET32_PORT_100</span> <span class="o">|</span> <span class="n">PCNET32_PORT_FD</span><span class="p">,</span>
	<span class="n">PCNET32_PORT_ASEL</span>			<span class="cm">/* 15 not supported    */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">pcnet32_gstrings_test</span><span class="p">[][</span><span class="n">ETH_GSTRING_LEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;Loopback test  (offline)&quot;</span>
<span class="p">};</span>

<span class="cp">#define PCNET32_TEST_LEN	ARRAY_SIZE(pcnet32_gstrings_test)</span>

<span class="cp">#define PCNET32_NUM_REGS 136</span>

<span class="cp">#define MAX_UNITS 8		</span><span class="cm">/* More are supported, limit only on options */</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">options</span><span class="p">[</span><span class="n">MAX_UNITS</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">full_duplex</span><span class="p">[</span><span class="n">MAX_UNITS</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">homepna</span><span class="p">[</span><span class="n">MAX_UNITS</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> *				Theory of Operation</span>
<span class="cm"> *</span>
<span class="cm"> * This driver uses the same software structure as the normal lance</span>
<span class="cm"> * driver. So look for a verbose description in lance.c. The differences</span>
<span class="cm"> * to the normal lance driver is the use of the 32bit mode of PCnet32</span>
<span class="cm"> * and PCnetPCI chips. Because these chips are 32bit chips, there is no</span>
<span class="cm"> * 16MB limitation and we don&#39;t need bounce buffers.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Set the number of Tx and Rx buffers, using Log_2(# buffers).</span>
<span class="cm"> * Reasonable default values are 4 Tx buffers, and 16 Rx buffers.</span>
<span class="cm"> * That translates to 2 (4 == 2^^2) and 4 (16 == 2^^4).</span>
<span class="cm"> */</span>
<span class="cp">#ifndef PCNET32_LOG_TX_BUFFERS</span>
<span class="cp">#define PCNET32_LOG_TX_BUFFERS		4</span>
<span class="cp">#define PCNET32_LOG_RX_BUFFERS		5</span>
<span class="cp">#define PCNET32_LOG_MAX_TX_BUFFERS	9	</span><span class="cm">/* 2^9 == 512 */</span><span class="cp"></span>
<span class="cp">#define PCNET32_LOG_MAX_RX_BUFFERS	9</span>
<span class="cp">#endif</span>

<span class="cp">#define TX_RING_SIZE		(1 &lt;&lt; (PCNET32_LOG_TX_BUFFERS))</span>
<span class="cp">#define TX_MAX_RING_SIZE	(1 &lt;&lt; (PCNET32_LOG_MAX_TX_BUFFERS))</span>

<span class="cp">#define RX_RING_SIZE		(1 &lt;&lt; (PCNET32_LOG_RX_BUFFERS))</span>
<span class="cp">#define RX_MAX_RING_SIZE	(1 &lt;&lt; (PCNET32_LOG_MAX_RX_BUFFERS))</span>

<span class="cp">#define PKT_BUF_SKB		1544</span>
<span class="cm">/* actual buffer length after being aligned */</span>
<span class="cp">#define PKT_BUF_SIZE		(PKT_BUF_SKB - NET_IP_ALIGN)</span>
<span class="cm">/* chip wants twos complement of the (aligned) buffer length */</span>
<span class="cp">#define NEG_BUF_SIZE		(NET_IP_ALIGN - PKT_BUF_SKB)</span>

<span class="cm">/* Offsets from base I/O address. */</span>
<span class="cp">#define PCNET32_WIO_RDP		0x10</span>
<span class="cp">#define PCNET32_WIO_RAP		0x12</span>
<span class="cp">#define PCNET32_WIO_RESET	0x14</span>
<span class="cp">#define PCNET32_WIO_BDP		0x16</span>

<span class="cp">#define PCNET32_DWIO_RDP	0x10</span>
<span class="cp">#define PCNET32_DWIO_RAP	0x14</span>
<span class="cp">#define PCNET32_DWIO_RESET	0x18</span>
<span class="cp">#define PCNET32_DWIO_BDP	0x1C</span>

<span class="cp">#define PCNET32_TOTAL_SIZE	0x20</span>

<span class="cp">#define CSR0		0</span>
<span class="cp">#define CSR0_INIT	0x1</span>
<span class="cp">#define CSR0_START	0x2</span>
<span class="cp">#define CSR0_STOP	0x4</span>
<span class="cp">#define CSR0_TXPOLL	0x8</span>
<span class="cp">#define CSR0_INTEN	0x40</span>
<span class="cp">#define CSR0_IDON	0x0100</span>
<span class="cp">#define CSR0_NORMAL	(CSR0_START | CSR0_INTEN)</span>
<span class="cp">#define PCNET32_INIT_LOW	1</span>
<span class="cp">#define PCNET32_INIT_HIGH	2</span>
<span class="cp">#define CSR3		3</span>
<span class="cp">#define CSR4		4</span>
<span class="cp">#define CSR5		5</span>
<span class="cp">#define CSR5_SUSPEND	0x0001</span>
<span class="cp">#define CSR15		15</span>
<span class="cp">#define PCNET32_MC_FILTER	8</span>

<span class="cp">#define PCNET32_79C970A	0x2621</span>

<span class="cm">/* The PCNET32 Rx and Tx ring descriptors. */</span>
<span class="k">struct</span> <span class="n">pcnet32_rx_head</span> <span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">base</span><span class="p">;</span>
	<span class="n">__le16</span>	<span class="n">buf_length</span><span class="p">;</span>	<span class="cm">/* two`s complement of length */</span>
	<span class="n">__le16</span>	<span class="n">status</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">msg_length</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">reserved</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pcnet32_tx_head</span> <span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">base</span><span class="p">;</span>
	<span class="n">__le16</span>	<span class="n">length</span><span class="p">;</span>		<span class="cm">/* two`s complement of length */</span>
	<span class="n">__le16</span>	<span class="n">status</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">misc</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">reserved</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* The PCNET32 32-Bit initialization block, described in databook. */</span>
<span class="k">struct</span> <span class="n">pcnet32_init_block</span> <span class="p">{</span>
	<span class="n">__le16</span>	<span class="n">mode</span><span class="p">;</span>
	<span class="n">__le16</span>	<span class="n">tlen_rlen</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">phys_addr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">__le16</span>	<span class="n">reserved</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">filter</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="cm">/* Receive and transmit ring base, along with extra bits. */</span>
	<span class="n">__le32</span>	<span class="n">rx_ring</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">tx_ring</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* PCnet32 access functions */</span>
<span class="k">struct</span> <span class="n">pcnet32_access</span> <span class="p">{</span>
	<span class="n">u16</span>	<span class="p">(</span><span class="o">*</span><span class="n">read_csr</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">write_csr</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">u16</span><span class="p">);</span>
	<span class="n">u16</span>	<span class="p">(</span><span class="o">*</span><span class="n">read_bcr</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">write_bcr</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">u16</span><span class="p">);</span>
	<span class="n">u16</span>	<span class="p">(</span><span class="o">*</span><span class="n">read_rap</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">write_rap</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">u16</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">reset</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The first field of pcnet32_private is read by the ethernet device</span>
<span class="cm"> * so the structure should be allocated using pci_alloc_consistent().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_init_block</span> <span class="o">*</span><span class="n">init_block</span><span class="p">;</span>
	<span class="cm">/* The Tx and Rx ring entries must be aligned on 16-byte boundaries in 32bit mode. */</span>
	<span class="k">struct</span> <span class="n">pcnet32_rx_head</span>	<span class="o">*</span><span class="n">rx_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcnet32_tx_head</span>	<span class="o">*</span><span class="n">tx_ring</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">init_dma_addr</span><span class="p">;</span><span class="cm">/* DMA address of beginning of the init block,</span>
<span class="cm">				   returned by pci_alloc_consistent */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span>		<span class="o">*</span><span class="n">pci_dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="cm">/* The saved address of a sent-in-place packet/buffer, for skfree(). */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>		<span class="o">**</span><span class="n">tx_skbuff</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>		<span class="o">**</span><span class="n">rx_skbuff</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="o">*</span><span class="n">tx_dma_addr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="o">*</span><span class="n">rx_dma_addr</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pcnet32_access</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>		<span class="cm">/* Guard lock */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">cur_rx</span><span class="p">,</span> <span class="n">cur_tx</span><span class="p">;</span>	<span class="cm">/* The next free ring entry */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">rx_ring_size</span><span class="p">;</span>	<span class="cm">/* current rx ring size */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">tx_ring_size</span><span class="p">;</span>	<span class="cm">/* current tx ring size */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">rx_mod_mask</span><span class="p">;</span>	<span class="cm">/* rx ring modular mask */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">tx_mod_mask</span><span class="p">;</span>	<span class="cm">/* tx ring modular mask */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">rx_len_bits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">tx_len_bits</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">rx_ring_dma_addr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">tx_ring_dma_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">dirty_rx</span><span class="p">,</span>	<span class="cm">/* ring entries to be freed. */</span>
				<span class="n">dirty_tx</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">net_device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">napi_struct</span>	<span class="n">napi</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="n">tx_full</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="n">phycount</span><span class="p">;</span>	<span class="cm">/* number of phys found */</span>
	<span class="kt">int</span>			<span class="n">options</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">shared_irq</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>	<span class="cm">/* shared irq possible */</span>
				<span class="nl">dxsuflo:</span><span class="mi">1</span><span class="p">,</span>   <span class="cm">/* disable transmit stop on uflo */</span>
				<span class="nl">mii:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* mii port available */</span>
	<span class="k">struct</span> <span class="n">net_device</span>	<span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mii_if_info</span>	<span class="n">mii_if</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">watchdog_timer</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">msg_enable</span><span class="p">;</span>	<span class="cm">/* debug message level */</span>

	<span class="cm">/* each bit indicates an available PHY */</span>
	<span class="n">u32</span>			<span class="n">phymask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">chip_version</span><span class="p">;</span>	<span class="cm">/* which variant this is */</span>

	<span class="cm">/* saved registers during ethtool blink */</span>
	<span class="n">u16</span> 			<span class="n">save_regs</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">pcnet32_probe_pci</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pcnet32_probe1</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pcnet32_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pcnet32_init_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="n">pcnet32_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pcnet32_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">pcnet32_interrupt</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pcnet32_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="n">pcnet32_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pcnet32_load_multicast</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pcnet32_set_multicast_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pcnet32_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pcnet32_watchdog</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mdio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg_num</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mdio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg_num</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pcnet32_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">csr0_bits</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pcnet32_ethtool_test</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ethtool_test</span> <span class="o">*</span><span class="n">eth_test</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span> <span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pcnet32_loopback_test</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="o">*</span> <span class="n">data1</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pcnet32_get_regs_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pcnet32_get_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
			     <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pcnet32_purge_tx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pcnet32_alloc_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pcnet32_free_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pcnet32_check_media</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">verbose</span><span class="p">);</span>

<span class="k">static</span> <span class="n">u16</span> <span class="nf">pcnet32_wio_read_csr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">PCNET32_WIO_RAP</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">inw</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">PCNET32_WIO_RDP</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_wio_write_csr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">PCNET32_WIO_RAP</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">PCNET32_WIO_RDP</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u16</span> <span class="nf">pcnet32_wio_read_bcr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">PCNET32_WIO_RAP</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">inw</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">PCNET32_WIO_BDP</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_wio_write_bcr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">PCNET32_WIO_RAP</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">PCNET32_WIO_BDP</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u16</span> <span class="nf">pcnet32_wio_read_rap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">inw</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">PCNET32_WIO_RAP</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_wio_write_rap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">PCNET32_WIO_RAP</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_wio_reset</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">inw</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">PCNET32_WIO_RESET</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcnet32_wio_check</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outw</span><span class="p">(</span><span class="mi">88</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">PCNET32_WIO_RAP</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">inw</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">PCNET32_WIO_RAP</span><span class="p">)</span> <span class="o">==</span> <span class="mi">88</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pcnet32_access</span> <span class="n">pcnet32_wio</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read_csr</span> <span class="o">=</span> <span class="n">pcnet32_wio_read_csr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_csr</span> <span class="o">=</span> <span class="n">pcnet32_wio_write_csr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_bcr</span> <span class="o">=</span> <span class="n">pcnet32_wio_read_bcr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_bcr</span> <span class="o">=</span> <span class="n">pcnet32_wio_write_bcr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_rap</span> <span class="o">=</span> <span class="n">pcnet32_wio_read_rap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_rap</span> <span class="o">=</span> <span class="n">pcnet32_wio_write_rap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset</span> <span class="o">=</span> <span class="n">pcnet32_wio_reset</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">u16</span> <span class="nf">pcnet32_dwio_read_csr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outl</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">PCNET32_DWIO_RAP</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">inl</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">PCNET32_DWIO_RDP</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_dwio_write_csr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outl</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">PCNET32_DWIO_RAP</span><span class="p">);</span>
	<span class="n">outl</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">PCNET32_DWIO_RDP</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u16</span> <span class="nf">pcnet32_dwio_read_bcr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outl</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">PCNET32_DWIO_RAP</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">inl</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">PCNET32_DWIO_BDP</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_dwio_write_bcr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outl</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">PCNET32_DWIO_RAP</span><span class="p">);</span>
	<span class="n">outl</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">PCNET32_DWIO_BDP</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u16</span> <span class="nf">pcnet32_dwio_read_rap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">inl</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">PCNET32_DWIO_RAP</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_dwio_write_rap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outl</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">PCNET32_DWIO_RAP</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_dwio_reset</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">inl</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">PCNET32_DWIO_RESET</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcnet32_dwio_check</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outl</span><span class="p">(</span><span class="mi">88</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">PCNET32_DWIO_RAP</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">inl</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">PCNET32_DWIO_RAP</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">==</span> <span class="mi">88</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pcnet32_access</span> <span class="n">pcnet32_dwio</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read_csr</span> <span class="o">=</span> <span class="n">pcnet32_dwio_read_csr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_csr</span> <span class="o">=</span> <span class="n">pcnet32_dwio_write_csr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_bcr</span> <span class="o">=</span> <span class="n">pcnet32_dwio_read_bcr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_bcr</span> <span class="o">=</span> <span class="n">pcnet32_dwio_write_bcr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_rap</span> <span class="o">=</span> <span class="n">pcnet32_dwio_read_rap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_rap</span> <span class="o">=</span> <span class="n">pcnet32_dwio_write_rap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset</span> <span class="o">=</span> <span class="n">pcnet32_dwio_reset</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_netif_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span> <span class="cm">/* prevent tx timeout */</span>
	<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="n">netif_tx_disable</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_netif_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">ulong</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR3</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">&amp;=</span> <span class="mh">0x00ff</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR3</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate space for the new sized tx ring.</span>
<span class="cm"> * Free old resources</span>
<span class="cm"> * Save new resources.</span>
<span class="cm"> * Any failure keeps old resources.</span>
<span class="cm"> * Must be called with lp-&gt;lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_realloc_tx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">new_ring_dma_addr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">new_dma_addr_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcnet32_tx_head</span> <span class="o">*</span><span class="n">new_tx_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">new_skb_list</span><span class="p">;</span>

	<span class="n">pcnet32_purge_tx_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">new_tx_ring</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
					   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcnet32_tx_head</span><span class="p">)</span> <span class="o">*</span>
					   <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">size</span><span class="p">),</span>
					   <span class="o">&amp;</span><span class="n">new_ring_dma_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_tx_ring</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Consistent memory allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">new_tx_ring</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcnet32_tx_head</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">size</span><span class="p">));</span>

	<span class="n">new_dma_addr_list</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">size</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dma_addr_t</span><span class="p">),</span>
				<span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_dma_addr_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Memory allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free_new_tx_ring</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">new_skb_list</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">size</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">),</span>
				<span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_skb_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Memory allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free_new_lists</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_dma_addr</span><span class="p">);</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcnet32_tx_head</span><span class="p">)</span> <span class="o">*</span>
			    <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">,</span>
			    <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_dma_addr</span><span class="p">);</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_mod_mask</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_len_bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="n">new_tx_ring</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_dma_addr</span> <span class="o">=</span> <span class="n">new_ring_dma_addr</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_dma_addr</span> <span class="o">=</span> <span class="n">new_dma_addr_list</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span> <span class="o">=</span> <span class="n">new_skb_list</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">free_new_lists:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">new_dma_addr_list</span><span class="p">);</span>
<span class="nl">free_new_tx_ring:</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcnet32_tx_head</span><span class="p">)</span> <span class="o">*</span>
			    <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">size</span><span class="p">),</span>
			    <span class="n">new_tx_ring</span><span class="p">,</span>
			    <span class="n">new_ring_dma_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate space for the new sized rx ring.</span>
<span class="cm"> * Re-use old receive buffers.</span>
<span class="cm"> *   alloc extra buffers</span>
<span class="cm"> *   free unneeded buffers</span>
<span class="cm"> *   free unneeded buffers</span>
<span class="cm"> * Save new resources.</span>
<span class="cm"> * Any failure keeps old resources.</span>
<span class="cm"> * Must be called with lp-&gt;lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_realloc_rx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">new_ring_dma_addr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">new_dma_addr_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcnet32_rx_head</span> <span class="o">*</span><span class="n">new_rx_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">new_skb_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">new</span><span class="p">,</span> <span class="n">overlap</span><span class="p">;</span>

	<span class="n">new_rx_ring</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
					   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcnet32_rx_head</span><span class="p">)</span> <span class="o">*</span>
					   <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">size</span><span class="p">),</span>
					   <span class="o">&amp;</span><span class="n">new_ring_dma_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_rx_ring</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Consistent memory allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">new_rx_ring</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcnet32_rx_head</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">size</span><span class="p">));</span>

	<span class="n">new_dma_addr_list</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">size</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dma_addr_t</span><span class="p">),</span>
				<span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_dma_addr_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Memory allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free_new_rx_ring</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">new_skb_list</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">size</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">),</span>
				<span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_skb_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Memory allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free_new_lists</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* first copy the current receive buffers */</span>
	<span class="n">overlap</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">new</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">new</span> <span class="o">&lt;</span> <span class="n">overlap</span><span class="p">;</span> <span class="n">new</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_rx_ring</span><span class="p">[</span><span class="n">new</span><span class="p">]</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">new</span><span class="p">];</span>
		<span class="n">new_dma_addr_list</span><span class="p">[</span><span class="n">new</span><span class="p">]</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_dma_addr</span><span class="p">[</span><span class="n">new</span><span class="p">];</span>
		<span class="n">new_skb_list</span><span class="p">[</span><span class="n">new</span><span class="p">]</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">new</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="cm">/* now allocate any new buffers needed */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">new</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">new</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">rx_skbuff</span><span class="p">;</span>
		<span class="n">new_skb_list</span><span class="p">[</span><span class="n">new</span><span class="p">]</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PKT_BUF_SKB</span><span class="p">);</span>
		<span class="n">rx_skbuff</span> <span class="o">=</span> <span class="n">new_skb_list</span><span class="p">[</span><span class="n">new</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx_skbuff</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* keep the original lists and buffers */</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s netdev_alloc_skb failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">__func__</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">free_all_new</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">rx_skbuff</span><span class="p">,</span> <span class="n">NET_IP_ALIGN</span><span class="p">);</span>

		<span class="n">new_dma_addr_list</span><span class="p">[</span><span class="n">new</span><span class="p">]</span> <span class="o">=</span>
			    <span class="n">pci_map_single</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">rx_skbuff</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
					   <span class="n">PKT_BUF_SIZE</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
		<span class="n">new_rx_ring</span><span class="p">[</span><span class="n">new</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">new_dma_addr_list</span><span class="p">[</span><span class="n">new</span><span class="p">]);</span>
		<span class="n">new_rx_ring</span><span class="p">[</span><span class="n">new</span><span class="p">].</span><span class="n">buf_length</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">NEG_BUF_SIZE</span><span class="p">);</span>
		<span class="n">new_rx_ring</span><span class="p">[</span><span class="n">new</span><span class="p">].</span><span class="n">status</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x8000</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* and free any unneeded buffers */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">new</span> <span class="o">&lt;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">;</span> <span class="n">new</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">new</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_dma_addr</span><span class="p">[</span><span class="n">new</span><span class="p">],</span>
					 <span class="n">PKT_BUF_SIZE</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">new</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_dma_addr</span><span class="p">);</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcnet32_rx_head</span><span class="p">)</span> <span class="o">*</span>
			    <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">,</span>
			    <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_dma_addr</span><span class="p">);</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_mod_mask</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_len_bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span> <span class="o">=</span> <span class="n">new_rx_ring</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_dma_addr</span> <span class="o">=</span> <span class="n">new_ring_dma_addr</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_dma_addr</span> <span class="o">=</span> <span class="n">new_dma_addr_list</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span> <span class="o">=</span> <span class="n">new_skb_list</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">free_all_new:</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">new</span> <span class="o">&gt;=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_skb_list</span><span class="p">[</span><span class="n">new</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">new_dma_addr_list</span><span class="p">[</span><span class="n">new</span><span class="p">],</span>
					 <span class="n">PKT_BUF_SIZE</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">new_skb_list</span><span class="p">[</span><span class="n">new</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">new_skb_list</span><span class="p">);</span>
<span class="nl">free_new_lists:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">new_dma_addr_list</span><span class="p">);</span>
<span class="nl">free_new_rx_ring:</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcnet32_rx_head</span><span class="p">)</span> <span class="o">*</span>
			    <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">size</span><span class="p">),</span>
			    <span class="n">new_rx_ring</span><span class="p">,</span>
			    <span class="n">new_ring_dma_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_purge_rx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* free all allocated skbuffs */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* CPU owns buffer */</span>
		<span class="n">wmb</span><span class="p">();</span>		<span class="cm">/* Make sure adapter sees owner change */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_dma_addr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					 <span class="n">PKT_BUF_SIZE</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_dma_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_poll_controller</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">disable_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">pcnet32_interrupt</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">enable_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcnet32_get_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">mii_ethtool_gset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcnet32_set_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">mii_ethtool_sset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_get_drvinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ethtool_drvinfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">strlcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">));</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">DRV_VERSION</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">)</span>
		<span class="n">strlcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">),</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">),</span>
			<span class="s">&quot;VLB 0x%lx&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">pcnet32_get_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">mii_link_ok</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">chip_version</span> <span class="o">&gt;=</span> <span class="n">PCNET32_79C970A</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ulong</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>	<span class="cm">/* card base I/O address */</span>
		<span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0xc0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* can not detect link on really old chips */</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">pcnet32_get_msglevel</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">msg_enable</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_set_msglevel</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcnet32_nway_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">mii_nway_restart</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_get_ringparam</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ethtool_ringparam</span> <span class="o">*</span><span class="n">ering</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">ering</span><span class="o">-&gt;</span><span class="n">tx_max_pending</span> <span class="o">=</span> <span class="n">TX_MAX_RING_SIZE</span><span class="p">;</span>
	<span class="n">ering</span><span class="o">-&gt;</span><span class="n">tx_pending</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">;</span>
	<span class="n">ering</span><span class="o">-&gt;</span><span class="n">rx_max_pending</span> <span class="o">=</span> <span class="n">RX_MAX_RING_SIZE</span><span class="p">;</span>
	<span class="n">ering</span><span class="o">-&gt;</span><span class="n">rx_pending</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcnet32_set_ringparam</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ethtool_ringparam</span> <span class="o">*</span><span class="n">ering</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">ulong</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ering</span><span class="o">-&gt;</span><span class="n">rx_mini_pending</span> <span class="o">||</span> <span class="n">ering</span><span class="o">-&gt;</span><span class="n">rx_jumbo_pending</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">pcnet32_netif_stop</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">,</span> <span class="n">CSR0_STOP</span><span class="p">);</span>	<span class="cm">/* stop the chip */</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ering</span><span class="o">-&gt;</span><span class="n">tx_pending</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">TX_MAX_RING_SIZE</span><span class="p">);</span>

	<span class="cm">/* set the minimum ring size to 4, to allow the loopback test to work</span>
<span class="cm">	 * unchanged.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">PCNET32_LOG_MAX_TX_BUFFERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">)</span>
		<span class="n">pcnet32_realloc_tx_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">lp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ering</span><span class="o">-&gt;</span><span class="n">rx_pending</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">RX_MAX_RING_SIZE</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">PCNET32_LOG_MAX_RX_BUFFERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">)</span>
		<span class="n">pcnet32_realloc_rx_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">lp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pcnet32_netif_start</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">pcnet32_restart</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">CSR0_NORMAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">netif_info</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Ring Param Settings: RX: %d, TX: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_get_strings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">stringset</span><span class="p">,</span>
				<span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pcnet32_gstrings_test</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pcnet32_gstrings_test</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcnet32_get_sset_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">sset</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ETH_SS_TEST</span>:
		<span class="k">return</span> <span class="n">PCNET32_TEST_LEN</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_ethtool_test</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ethtool_test</span> <span class="o">*</span><span class="n">test</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">==</span> <span class="n">ETH_TEST_FL_OFFLINE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pcnet32_loopback_test</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_printk</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
				     <span class="s">&quot;Loopback test failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">test</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ETH_TEST_FL_FAILED</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">netif_printk</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
				     <span class="s">&quot;Loopback test passed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">netif_printk</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
			     <span class="s">&quot;No tests to run (specify &#39;Offline&#39; on ethtool)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>				<span class="cm">/* end pcnet32_ethtool_test */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcnet32_loopback_test</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="o">*</span> <span class="n">data1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pcnet32_access</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span>	<span class="cm">/* access to registers */</span>
	<span class="n">ulong</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>	<span class="cm">/* card base I/O address */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>	<span class="cm">/* sk buff */</span>
	<span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>		<span class="cm">/* counters */</span>
	<span class="kt">int</span> <span class="n">numbuffs</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>	<span class="cm">/* number of TX/RX buffers and descs */</span>
	<span class="n">u16</span> <span class="n">status</span> <span class="o">=</span> <span class="mh">0x8300</span><span class="p">;</span>	<span class="cm">/* TX ring status */</span>
	<span class="n">__le16</span> <span class="n">teststatus</span><span class="p">;</span>	<span class="cm">/* test of ring status */</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>			<span class="cm">/* return code */</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>		<span class="cm">/* size of packets */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">packet</span><span class="p">;</span>	<span class="cm">/* source packet data */</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">data_len</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>	<span class="cm">/* length of source packets */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ticks</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* default to fail */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">pcnet32_netif_stop</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">,</span> <span class="n">CSR0_STOP</span><span class="p">);</span>	<span class="cm">/* stop the chip */</span>

	<span class="n">numbuffs</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">numbuffs</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">min</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">));</span>

	<span class="cm">/* Reset the PCNET32 */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR4</span><span class="p">,</span> <span class="mh">0x0915</span><span class="p">);</span>	<span class="cm">/* auto tx pad */</span>

	<span class="cm">/* switch pcnet32 to 32bit mode */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="cm">/* purge &amp; init rings but don&#39;t actually restart */</span>
	<span class="n">pcnet32_restart</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">);</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">,</span> <span class="n">CSR0_STOP</span><span class="p">);</span>	<span class="cm">/* Set STOP bit */</span>

	<span class="cm">/* Initialize Transmit buffers. */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">data_len</span> <span class="o">+</span> <span class="mi">15</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">numbuffs</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_printk</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
				     <span class="s">&quot;Cannot allocate skb at line: %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">__LINE__</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">clean_up</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">packet</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>	<span class="cm">/* create space for data */</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="o">-</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">misc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* put DA and SA into the skb */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="o">*</span><span class="n">packet</span><span class="o">++</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="o">*</span><span class="n">packet</span><span class="o">++</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="cm">/* type */</span>
		<span class="o">*</span><span class="n">packet</span><span class="o">++</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">;</span>
		<span class="o">*</span><span class="n">packet</span><span class="o">++</span> <span class="o">=</span> <span class="mh">0x06</span><span class="p">;</span>
		<span class="cm">/* packet number */</span>
		<span class="o">*</span><span class="n">packet</span><span class="o">++</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
		<span class="cm">/* fill packet with data */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">data_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="o">*</span><span class="n">packet</span><span class="o">++</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_dma_addr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">pci_map_single</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
				       <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_dma_addr</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
		<span class="n">wmb</span><span class="p">();</span>	<span class="cm">/* Make sure owner changes after all others are visible */</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">status</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>	<span class="cm">/* set internal loopback in BCR32 */</span>
	<span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="n">x</span> <span class="o">|</span> <span class="mh">0x0002</span><span class="p">);</span>

	<span class="cm">/* set int loopback in CSR15 */</span>
	<span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR15</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfffc</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR15</span><span class="p">,</span> <span class="n">x</span> <span class="o">|</span> <span class="mh">0x0044</span><span class="p">);</span>

	<span class="n">teststatus</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x8000</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">,</span> <span class="n">CSR0_START</span><span class="p">);</span>	<span class="cm">/* Set STRT bit */</span>

	<span class="cm">/* Check status of descriptors */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">numbuffs</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ticks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rmb</span><span class="p">();</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">teststatus</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ticks</span> <span class="o">&lt;</span> <span class="mi">200</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">rmb</span><span class="p">();</span>
			<span class="n">ticks</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ticks</span> <span class="o">==</span> <span class="mi">200</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Desc %d failed to reset!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">,</span> <span class="n">CSR0_STOP</span><span class="p">);</span>	<span class="cm">/* Set STOP bit */</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_hw</span><span class="p">(</span><span class="n">lp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">netif_msg_pktdata</span><span class="p">(</span><span class="n">lp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netdev_printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;RX loopback packets:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">numbuffs</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netdev_printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Packet %d: &quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot; %02x&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
			<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">numbuffs</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
		<span class="n">packet</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="n">packet</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">netif_printk</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
					     <span class="s">&quot;Error in compare! %2x - %02x %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">i</span><span class="p">),</span> <span class="n">packet</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">x</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">clean_up:</span>
	<span class="o">*</span><span class="n">data1</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">pcnet32_purge_tx_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR15</span><span class="p">);</span>
	<span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR15</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x0044</span><span class="p">));</span>	<span class="cm">/* reset bits 6 and 2 */</span>

	<span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>	<span class="cm">/* reset internal loopback */</span>
	<span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x0002</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pcnet32_netif_start</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">pcnet32_restart</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">CSR0_NORMAL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pcnet32_purge_rx_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>	<span class="cm">/* return to 16bit mode */</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>				<span class="cm">/* end pcnet32_loopback_test  */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcnet32_set_phys_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">enum</span> <span class="n">ethtool_phys_id_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pcnet32_access</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span>
	<span class="n">ulong</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ETHTOOL_ID_ACTIVE</span>:
		<span class="cm">/* Save the current value of the bcrs */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">save_regs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>	<span class="cm">/* cycle on/off twice per second */</span>

	<span class="k">case</span> <span class="n">ETHTOOL_ID_ON</span>:
	<span class="k">case</span> <span class="n">ETHTOOL_ID_OFF</span>:
		<span class="cm">/* Blink the led */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">^</span> <span class="mh">0x4000</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ETHTOOL_ID_INACTIVE</span>:
		<span class="cm">/* Restore the original value of the bcrs */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">save_regs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">4</span><span class="p">]);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * lp-&gt;lock must be held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcnet32_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">can_sleep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">csr5</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pcnet32_access</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span>
	<span class="n">ulong</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ticks</span><span class="p">;</span>

	<span class="cm">/* really old chips have to be stopped. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">chip_version</span> <span class="o">&lt;</span> <span class="n">PCNET32_79C970A</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* set SUSPEND (SPND) - CSR5 bit 0 */</span>
	<span class="n">csr5</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR5</span><span class="p">);</span>
	<span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR5</span><span class="p">,</span> <span class="n">csr5</span> <span class="o">|</span> <span class="n">CSR5_SUSPEND</span><span class="p">);</span>

	<span class="cm">/* poll waiting for bit to be set */</span>
	<span class="n">ticks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CSR5_SUSPEND</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">can_sleep</span><span class="p">)</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">ticks</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ticks</span> <span class="o">&gt;</span> <span class="mi">200</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_printk</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
				     <span class="s">&quot;Error getting into suspend!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * process one receive descriptor entry</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_rx_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">pcnet32_rx_head</span> <span class="o">*</span><span class="n">rxp</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span><span class="p">)</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rxp</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rx_in_place</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">pkt_len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mh">0x03</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* There was an error. */</span>
		<span class="cm">/*</span>
<span class="cm">		 * There is a tricky error noted by John Murphy,</span>
<span class="cm">		 * &lt;murf@perftech.com&gt; to Russ Nelson: Even with full-sized</span>
<span class="cm">		 * buffers it&#39;s possible for a jabber packet to use two</span>
<span class="cm">		 * buffers, with only the last correctly noting the error.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span>	<span class="cm">/* Only count a general error at the */</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>	<span class="cm">/* end of a packet. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_frame_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_over_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x08</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_crc_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x04</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pkt_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rxp</span><span class="o">-&gt;</span><span class="n">msg_length</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/* Discard oversize frames. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pkt_len</span> <span class="o">&gt;</span> <span class="n">PKT_BUF_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Impossible packet size %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">pkt_len</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pkt_len</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">rx_err</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Runt packet!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pkt_len</span> <span class="o">&gt;</span> <span class="n">rx_copybreak</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">newskb</span><span class="p">;</span>

		<span class="n">newskb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PKT_BUF_SKB</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newskb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb_reserve</span><span class="p">(</span><span class="n">newskb</span><span class="p">,</span> <span class="n">NET_IP_ALIGN</span><span class="p">);</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">];</span>
			<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
					 <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_dma_addr</span><span class="p">[</span><span class="n">entry</span><span class="p">],</span>
					 <span class="n">PKT_BUF_SIZE</span><span class="p">,</span>
					 <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pkt_len</span><span class="p">);</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="n">newskb</span><span class="p">;</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_dma_addr</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span>
					    <span class="n">pci_map_single</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
							   <span class="n">newskb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
							   <span class="n">PKT_BUF_SIZE</span><span class="p">,</span>
							   <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="n">rxp</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_dma_addr</span><span class="p">[</span><span class="n">entry</span><span class="p">]);</span>
			<span class="n">rx_in_place</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pkt_len</span> <span class="o">+</span> <span class="n">NET_IP_ALIGN</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Memory squeeze, dropping packet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx_in_place</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">NET_IP_ALIGN</span><span class="p">);</span>
		<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pkt_len</span><span class="p">);</span>	<span class="cm">/* Make room */</span>
		<span class="n">pci_dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
					    <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_dma_addr</span><span class="p">[</span><span class="n">entry</span><span class="p">],</span>
					    <span class="n">pkt_len</span><span class="p">,</span>
					    <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
		<span class="n">skb_copy_to_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">),</span>
				 <span class="n">pkt_len</span><span class="p">);</span>
		<span class="n">pci_dma_sync_single_for_device</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
					       <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_dma_addr</span><span class="p">[</span><span class="n">entry</span><span class="p">],</span>
					       <span class="n">pkt_len</span><span class="p">,</span>
					       <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">netif_receive_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcnet32_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="o">&amp;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_mod_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcnet32_rx_head</span> <span class="o">*</span><span class="n">rxp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">npackets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If we own the next entry, it&#39;s a new packet. Send it up. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">npackets</span> <span class="o">&lt;</span> <span class="n">budget</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kt">short</span><span class="p">)</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rxp</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pcnet32_rx_entry</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">lp</span><span class="p">,</span> <span class="n">rxp</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="n">npackets</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The docs say that the buffer length isn&#39;t touched, but Andrew</span>
<span class="cm">		 * Boyd of QNX reports that some revs of the 79C965 clear it.</span>
<span class="cm">		 */</span>
		<span class="n">rxp</span><span class="o">-&gt;</span><span class="n">buf_length</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">NEG_BUF_SIZE</span><span class="p">);</span>
		<span class="n">wmb</span><span class="p">();</span>	<span class="cm">/* Make sure owner changes after others are visible */</span>
		<span class="n">rxp</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x8000</span><span class="p">);</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="o">++</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_rx</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_mod_mask</span><span class="p">;</span>
		<span class="n">rxp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">npackets</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcnet32_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dirty_tx</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">delta</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">must_restart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">dirty_tx</span> <span class="o">!=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_tx</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">dirty_tx</span> <span class="o">&amp;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_mod_mask</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span><span class="p">)</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">status</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>	<span class="cm">/* It still hasn&#39;t been Txed */</span>

		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x4000</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* There was a major error, log it. */</span>
			<span class="kt">int</span> <span class="n">err_status</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">misc</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">tx_err</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
				  <span class="s">&quot;Tx error status=%04x err_status=%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">status</span><span class="p">,</span> <span class="n">err_status</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err_status</span> <span class="o">&amp;</span> <span class="mh">0x04000000</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_aborted_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err_status</span> <span class="o">&amp;</span> <span class="mh">0x08000000</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_carrier_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err_status</span> <span class="o">&amp;</span> <span class="mh">0x10000000</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_window_errors</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#ifndef DO_DXSUFLO</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err_status</span> <span class="o">&amp;</span> <span class="mh">0x40000000</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
				<span class="cm">/* Ackk!  On FIFO errors the Tx unit is turned off! */</span>
				<span class="cm">/* Remove this verbosity later! */</span>
				<span class="n">netif_err</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">tx_err</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Tx FIFO error!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">must_restart</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#else</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err_status</span> <span class="o">&amp;</span> <span class="mh">0x40000000</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">dxsuflo</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* If controller doesn&#39;t recover ... */</span>
					<span class="cm">/* Ackk!  On FIFO errors the Tx unit is turned off! */</span>
					<span class="cm">/* Remove this verbosity later! */</span>
					<span class="n">netif_err</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">tx_err</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Tx FIFO error!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="n">must_restart</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x1800</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">collisions</span><span class="o">++</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* We must free the original skb */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
					 <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_dma_addr</span><span class="p">[</span><span class="n">entry</span><span class="p">],</span>
					 <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span><span class="o">-&gt;</span>
					 <span class="n">len</span><span class="p">,</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
			<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]);</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_dma_addr</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dirty_tx</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">-</span> <span class="n">dirty_tx</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_mod_mask</span> <span class="o">+</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;out-of-sync dirty pointer, %d vs. %d, full=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">dirty_tx</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_tx</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_full</span><span class="p">);</span>
		<span class="n">dirty_tx</span> <span class="o">+=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">;</span>
		<span class="n">delta</span> <span class="o">-=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_full</span> <span class="o">&amp;&amp;</span>
	    <span class="n">netif_queue_stopped</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">delta</span> <span class="o">&lt;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The ring is no longer full, clear tbusy. */</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">=</span> <span class="n">dirty_tx</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">must_restart</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcnet32_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pcnet32_private</span><span class="p">,</span> <span class="n">napi</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">work_done</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">work_done</span> <span class="o">=</span> <span class="n">pcnet32_rx</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">budget</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcnet32_tx</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* reset the chip to clear the error condition, then restart */</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR4</span><span class="p">,</span> <span class="mh">0x0915</span><span class="p">);</span>	<span class="cm">/* auto tx pad */</span>
		<span class="n">pcnet32_restart</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">CSR0_START</span><span class="p">);</span>
		<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">work_done</span> <span class="o">&lt;</span> <span class="n">budget</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">__napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>

		<span class="cm">/* clear interrupt masks */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR3</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">&amp;=</span> <span class="mh">0x00ff</span><span class="p">;</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR3</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

		<span class="cm">/* Set interrupt enable. */</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">,</span> <span class="n">CSR0_INTEN</span><span class="p">);</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">work_done</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define PCNET32_REGS_PER_PHY	32</span>
<span class="cp">#define PCNET32_MAX_PHYS	32</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcnet32_get_regs_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">phycount</span> <span class="o">*</span> <span class="n">PCNET32_REGS_PER_PHY</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">PCNET32_NUM_REGS</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_get_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
			     <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">csr0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">buff</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pcnet32_access</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span>
	<span class="n">ulong</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">csr0</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">csr0</span> <span class="o">&amp;</span> <span class="n">CSR0_STOP</span><span class="p">))</span>	<span class="cm">/* If not stopped */</span>
		<span class="n">pcnet32_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* read address PROM */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="o">*</span><span class="n">buff</span><span class="o">++</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="cm">/* read control and status registers */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">90</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="o">*</span><span class="n">buff</span><span class="o">++</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="o">*</span><span class="n">buff</span><span class="o">++</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">112</span><span class="p">);</span>
	<span class="o">*</span><span class="n">buff</span><span class="o">++</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">114</span><span class="p">);</span>

	<span class="cm">/* read bus configuration registers */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="o">*</span><span class="n">buff</span><span class="o">++</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="o">*</span><span class="n">buff</span><span class="o">++</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* skip bcr30 so as not to hang 79C976 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">36</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="o">*</span><span class="n">buff</span><span class="o">++</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="cm">/* read mii phy registers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">PCNET32_MAX_PHYS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">phymask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PCNET32_REGS_PER_PHY</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span>
							<span class="p">(</span><span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">|</span> <span class="n">i</span><span class="p">);</span>
					<span class="o">*</span><span class="n">buff</span><span class="o">++</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">34</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">csr0</span> <span class="o">&amp;</span> <span class="n">CSR0_STOP</span><span class="p">))</span> <span class="p">{</span>	<span class="cm">/* If not stopped */</span>
		<span class="kt">int</span> <span class="n">csr5</span><span class="p">;</span>

		<span class="cm">/* clear SUSPEND (SPND) - CSR5 bit 0 */</span>
		<span class="n">csr5</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR5</span><span class="p">);</span>
		<span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR5</span><span class="p">,</span> <span class="n">csr5</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">CSR5_SUSPEND</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ethtool_ops</span> <span class="n">pcnet32_ethtool_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_settings</span>		<span class="o">=</span> <span class="n">pcnet32_get_settings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_settings</span>		<span class="o">=</span> <span class="n">pcnet32_set_settings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_drvinfo</span>		<span class="o">=</span> <span class="n">pcnet32_get_drvinfo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_msglevel</span>		<span class="o">=</span> <span class="n">pcnet32_get_msglevel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_msglevel</span>		<span class="o">=</span> <span class="n">pcnet32_set_msglevel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nway_reset</span>		<span class="o">=</span> <span class="n">pcnet32_nway_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_link</span>		<span class="o">=</span> <span class="n">pcnet32_get_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_ringparam</span>		<span class="o">=</span> <span class="n">pcnet32_get_ringparam</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_ringparam</span>		<span class="o">=</span> <span class="n">pcnet32_set_ringparam</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_strings</span>		<span class="o">=</span> <span class="n">pcnet32_get_strings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">self_test</span>		<span class="o">=</span> <span class="n">pcnet32_ethtool_test</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_phys_id</span>		<span class="o">=</span> <span class="n">pcnet32_set_phys_id</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_regs_len</span>		<span class="o">=</span> <span class="n">pcnet32_get_regs_len</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_regs</span>		<span class="o">=</span> <span class="n">pcnet32_get_regs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_sset_count</span>		<span class="o">=</span> <span class="n">pcnet32_get_sset_count</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* only probes for non-PCI devices, the rest are handled by</span>
<span class="cm"> * pci_register_driver via pcnet32_probe_pci */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">pcnet32_probe_vlbus</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pcnet32_portlist</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="n">ioaddr</span><span class="p">;</span>

	<span class="cm">/* search for PCnet32 VLB cards at known addresses */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="n">pcnet32_portlist</span><span class="p">;</span> <span class="p">(</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">request_region</span>
		    <span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">PCNET32_TOTAL_SIZE</span><span class="p">,</span> <span class="s">&quot;pcnet32_probe_vlbus&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* check if there is really a pcnet chip on that ioaddr */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">inb</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="mi">14</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x57</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="mi">15</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x57</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pcnet32_probe1</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">release_region</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">PCNET32_TOTAL_SIZE</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">pcnet32_probe_pci</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ioaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcnet32_debug</span> <span class="o">&amp;</span> <span class="n">NETIF_MSG_PROBE</span><span class="p">)</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;failed to enable device -- err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">ioaddr</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioaddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcnet32_debug</span> <span class="o">&amp;</span> <span class="n">NETIF_MSG_PROBE</span><span class="p">)</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;card has no PCI IO resources, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_dma_supported</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCNET32_DMA_MASK</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcnet32_debug</span> <span class="o">&amp;</span> <span class="n">NETIF_MSG_PROBE</span><span class="p">)</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;architecture does not support 32bit PCI busmaster DMA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_region</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">PCNET32_TOTAL_SIZE</span><span class="p">,</span> <span class="s">&quot;pcnet32_probe_pci&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcnet32_debug</span> <span class="o">&amp;</span> <span class="n">NETIF_MSG_PROBE</span><span class="p">)</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;io address range already allocated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pcnet32_probe1</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">pcnet32_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>		<span class="o">=</span> <span class="n">pcnet32_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span> 		<span class="o">=</span> <span class="n">pcnet32_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">pcnet32_start_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span>		<span class="o">=</span> <span class="n">pcnet32_tx_timeout</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_stats</span>		<span class="o">=</span> <span class="n">pcnet32_get_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">pcnet32_set_multicast_list</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span>		<span class="o">=</span> <span class="n">pcnet32_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>		<span class="o">=</span> <span class="n">eth_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span> 	<span class="o">=</span> <span class="n">eth_mac_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_validate_addr</span>	<span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
	<span class="p">.</span><span class="n">ndo_poll_controller</span>	<span class="o">=</span> <span class="n">pcnet32_poll_controller</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/* pcnet32_probe1</span>
<span class="cm"> *  Called from both pcnet32_probe_vlbus and pcnet_probe_pci.</span>
<span class="cm"> *  pdev will be NULL when called from pcnet32_probe_vlbus.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">pcnet32_probe1</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ioaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shared</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">media</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fdx</span><span class="p">,</span> <span class="n">mii</span><span class="p">,</span> <span class="n">fset</span><span class="p">,</span> <span class="n">dxsuflo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chip_version</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">chipname</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pcnet32_access</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">promaddr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* reset the chip */</span>
	<span class="n">pcnet32_wio_reset</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">);</span>

	<span class="cm">/* NOTE: 16-bit check is first, otherwise some older PCnet chips fail */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcnet32_wio_read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">pcnet32_wio_check</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">a</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pcnet32_wio</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pcnet32_dwio_reset</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcnet32_dwio_read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span>
		    <span class="n">pcnet32_dwio_check</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">a</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pcnet32_dwio</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pcnet32_debug</span> <span class="o">&amp;</span> <span class="n">NETIF_MSG_PROBE</span><span class="p">)</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;No access methods</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_release_region</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">chip_version</span> <span class="o">=</span>
	    <span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">88</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">89</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pcnet32_debug</span> <span class="o">&amp;</span> <span class="n">NETIF_MSG_PROBE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pcnet32_debug</span> <span class="o">&amp;</span> <span class="n">NETIF_MSG_HW</span><span class="p">))</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;  PCnet chip version is %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chip_version</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">chip_version</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x003</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcnet32_debug</span> <span class="o">&amp;</span> <span class="n">NETIF_MSG_PROBE</span><span class="p">)</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Unsupported chip version</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_release_region</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* initialize variables */</span>
	<span class="n">fdx</span> <span class="o">=</span> <span class="n">mii</span> <span class="o">=</span> <span class="n">fset</span> <span class="o">=</span> <span class="n">dxsuflo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">chip_version</span> <span class="o">=</span> <span class="p">(</span><span class="n">chip_version</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">chip_version</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x2420</span>:
		<span class="n">chipname</span> <span class="o">=</span> <span class="s">&quot;PCnet/PCI 79C970&quot;</span><span class="p">;</span>	<span class="cm">/* PCI */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x2430</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">)</span>
			<span class="n">chipname</span> <span class="o">=</span> <span class="s">&quot;PCnet/PCI 79C970&quot;</span><span class="p">;</span>	<span class="cm">/* 970 gives the wrong chip id back */</span>
		<span class="k">else</span>
			<span class="n">chipname</span> <span class="o">=</span> <span class="s">&quot;PCnet/32 79C965&quot;</span><span class="p">;</span>	<span class="cm">/* 486/VL bus */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x2621</span>:
		<span class="n">chipname</span> <span class="o">=</span> <span class="s">&quot;PCnet/PCI II 79C970A&quot;</span><span class="p">;</span>	<span class="cm">/* PCI */</span>
		<span class="n">fdx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x2623</span>:
		<span class="n">chipname</span> <span class="o">=</span> <span class="s">&quot;PCnet/FAST 79C971&quot;</span><span class="p">;</span>	<span class="cm">/* PCI */</span>
		<span class="n">fdx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">mii</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">fset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x2624</span>:
		<span class="n">chipname</span> <span class="o">=</span> <span class="s">&quot;PCnet/FAST+ 79C972&quot;</span><span class="p">;</span>	<span class="cm">/* PCI */</span>
		<span class="n">fdx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">mii</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">fset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x2625</span>:
		<span class="n">chipname</span> <span class="o">=</span> <span class="s">&quot;PCnet/FAST III 79C973&quot;</span><span class="p">;</span>	<span class="cm">/* PCI */</span>
		<span class="n">fdx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">mii</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x2626</span>:
		<span class="n">chipname</span> <span class="o">=</span> <span class="s">&quot;PCnet/Home 79C978&quot;</span><span class="p">;</span>	<span class="cm">/* PCI */</span>
		<span class="n">fdx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * This is based on specs published at www.amd.com.  This section</span>
<span class="cm">		 * assumes that a card with a 79C978 wants to go into standard</span>
<span class="cm">		 * ethernet mode.  The 79C978 can also go into 1Mb HomePNA mode,</span>
<span class="cm">		 * and the module option homepna=1 can select this instead.</span>
<span class="cm">		 */</span>
		<span class="n">media</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">49</span><span class="p">);</span>
		<span class="n">media</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">3</span><span class="p">;</span>	<span class="cm">/* default to 10Mb ethernet */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cards_found</span> <span class="o">&lt;</span> <span class="n">MAX_UNITS</span> <span class="o">&amp;&amp;</span> <span class="n">homepna</span><span class="p">[</span><span class="n">cards_found</span><span class="p">])</span>
			<span class="n">media</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* switch to home wiring mode */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcnet32_debug</span> <span class="o">&amp;</span> <span class="n">NETIF_MSG_PROBE</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="n">PFX</span> <span class="s">&quot;media set to %sMbit mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="n">media</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;1&quot;</span> <span class="o">:</span> <span class="s">&quot;10&quot;</span><span class="p">);</span>
		<span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="n">media</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x2627</span>:
		<span class="n">chipname</span> <span class="o">=</span> <span class="s">&quot;PCnet/FAST III 79C975&quot;</span><span class="p">;</span>	<span class="cm">/* PCI */</span>
		<span class="n">fdx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">mii</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x2628</span>:
		<span class="n">chipname</span> <span class="o">=</span> <span class="s">&quot;PCnet/PRO 79C976&quot;</span><span class="p">;</span>
		<span class="n">fdx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">mii</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcnet32_debug</span> <span class="o">&amp;</span> <span class="n">NETIF_MSG_PROBE</span><span class="p">)</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;PCnet version %#x, no PCnet32 chip</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">chip_version</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_release_region</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  On selected chips turn on the BCR18:NOUFLO bit. This stops transmit</span>
<span class="cm">	 *  starting until the packet is loaded. Strike one for reliability, lose</span>
<span class="cm">	 *  one for latency - although on PCI this isn&#39;t a big loss. Older chips</span>
<span class="cm">	 *  have FIFO&#39;s smaller than a packet, so you can&#39;t do this.</span>
<span class="cm">	 *  Turn on BCR18:BurstRdEn and BCR18:BurstWrEn.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">18</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x0860</span><span class="p">));</span>
		<span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span>
			     <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0C00</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x0c00</span><span class="p">);</span>
		<span class="n">dxsuflo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_etherdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lp</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_release_region</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="p">)</span>
		<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pcnet32_debug</span> <span class="o">&amp;</span> <span class="n">NETIF_MSG_PROBE</span><span class="p">)</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s at %#3lx,&quot;</span><span class="p">,</span> <span class="n">chipname</span><span class="p">,</span> <span class="n">ioaddr</span><span class="p">);</span>

	<span class="cm">/* In most chips, after a chip reset, the ethernet address is read from the</span>
<span class="cm">	 * station address PROM at the base address and programmed into the</span>
<span class="cm">	 * &quot;Physical Address Registers&quot; CSR12-14.</span>
<span class="cm">	 * As a precautionary measure, we read the PROM values and complain if</span>
<span class="cm">	 * they disagree with the CSRs.  If they miscompare, and the PROM addr</span>
<span class="cm">	 * is valid, then the PROM addr is used.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0ffff</span><span class="p">;</span>
		<span class="cm">/* There may be endianness issues here. */</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0x0ff</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0ff</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* read PROM address and compare with CSR address */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">promaddr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">promaddr</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">promaddr</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pcnet32_debug</span> <span class="o">&amp;</span> <span class="n">NETIF_MSG_PROBE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot; warning: CSR address invalid,</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;    using instead PROM address of&quot;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">promaddr</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>

	<span class="cm">/* if the ethernet address is not valid, force to 00:00:00:00:00:00 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">))</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pcnet32_debug</span> <span class="o">&amp;</span> <span class="n">NETIF_MSG_PROBE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot; %pM&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>

		<span class="cm">/* Version 0x2623 and 0x2624 */</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">chip_version</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x2624</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0C00</span><span class="p">;</span>	<span class="cm">/* Check tx_start_pt */</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;    tx_start_pt(0x%04x):&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">0</span>:
				<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;  20 bytes,&quot;</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">1</span>:
				<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;  64 bytes,&quot;</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">2</span>:
				<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot; 128 bytes,&quot;</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">3</span>:
				<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;~220 bytes,&quot;</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">18</span><span class="p">);</span>	<span class="cm">/* Check Burst/Bus control */</span>
			<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot; BCR18(%x):&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">))</span>
				<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;BurstWrEn &quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">))</span>
				<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;BurstRdEn &quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">))</span>
				<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;DWordIO &quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">))</span>
				<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;NoUFlow &quot;</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">25</span><span class="p">);</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;    SRAMSIZE=0x%04x,&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">26</span><span class="p">);</span>
			<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot; SRAM_BND=0x%04x,&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">27</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">))</span>
				<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;LowLatRx&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">ioaddr</span><span class="p">;</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="cm">/* pci_alloc_consistent returns page-aligned memory, so we do not have to check the alignment */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">),</span>
					      <span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_dma_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcnet32_debug</span> <span class="o">&amp;</span> <span class="n">NETIF_MSG_PROBE</span><span class="p">)</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Consistent memory allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_free_netdev</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">chipname</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">shared_irq</span> <span class="o">=</span> <span class="n">shared</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span> <span class="o">=</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span>	<span class="cm">/* default tx ring size */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span> <span class="o">=</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span>	<span class="cm">/* default rx ring size */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_mod_mask</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_mod_mask</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_len_bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCNET32_LOG_TX_BUFFERS</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_len_bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCNET32_LOG_RX_BUFFERS</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">full_duplex</span> <span class="o">=</span> <span class="n">fdx</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">phy_id_mask</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">reg_num_mask</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">dxsuflo</span> <span class="o">=</span> <span class="n">dxsuflo</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii</span> <span class="o">=</span> <span class="n">mii</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">chip_version</span> <span class="o">=</span> <span class="n">chip_version</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">pcnet32_debug</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cards_found</span> <span class="o">&gt;=</span> <span class="n">MAX_UNITS</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="n">cards_found</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">options_mapping</span><span class="p">)))</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">=</span> <span class="n">PCNET32_PORT_ASEL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">=</span> <span class="n">options_mapping</span><span class="p">[</span><span class="n">options</span><span class="p">[</span><span class="n">cards_found</span><span class="p">]];</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">mdio_read</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">mdio_write</span> <span class="o">=</span> <span class="n">mdio_write</span><span class="p">;</span>

	<span class="cm">/* napi.weight is used in both the napi and non-napi cases */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">netif_napi_add</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">,</span> <span class="n">pcnet32_poll</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fdx</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">PCNET32_PORT_ASEL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">cards_found</span> <span class="o">&gt;=</span> <span class="n">MAX_UNITS</span><span class="p">)</span> <span class="o">||</span> <span class="n">full_duplex</span><span class="p">[</span><span class="n">cards_found</span><span class="p">]))</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">|=</span> <span class="n">PCNET32_PORT_FD</span><span class="p">;</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>

	<span class="cm">/* prior to register_netdev, dev-&gt;name is not yet correct */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcnet32_alloc_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_free_ring</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* detect special T1/E1 WAN card by checking for MAC address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x00</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xe0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x75</span><span class="p">)</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">=</span> <span class="n">PCNET32_PORT_FD</span> <span class="o">|</span> <span class="n">PCNET32_PORT_GPSI</span><span class="p">;</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0003</span><span class="p">);</span>	<span class="cm">/* Disable Rx and Tx. */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="o">-&gt;</span><span class="n">tlen_rlen</span> <span class="o">=</span>
	    <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_len_bits</span> <span class="o">|</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_len_bits</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00000000</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00000000</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="o">-&gt;</span><span class="n">rx_ring</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_dma_addr</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="o">-&gt;</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_dma_addr</span><span class="p">);</span>

	<span class="cm">/* switch pcnet32 to 32bit mode */</span>
	<span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_dma_addr</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">));</span>
	<span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_dma_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* use the IRQ provided by PCI */</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcnet32_debug</span> <span class="o">&amp;</span> <span class="n">NETIF_MSG_PROBE</span><span class="p">)</span>
			<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot; assigned IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_mask</span> <span class="o">=</span> <span class="n">probe_irq_on</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * To auto-IRQ we enable the initialization-done and DMA error</span>
<span class="cm">		 * interrupts. For ISA boards we get a DMA error, but VLB and PCI</span>
<span class="cm">		 * boards will work.</span>
<span class="cm">		 */</span>
		<span class="cm">/* Trigger an initialization just for the interrupt. */</span>
		<span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">,</span> <span class="n">CSR0_INTEN</span> <span class="o">|</span> <span class="n">CSR0_INIT</span><span class="p">);</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">probe_irq_off</span><span class="p">(</span><span class="n">irq_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pcnet32_debug</span> <span class="o">&amp;</span> <span class="n">NETIF_MSG_PROBE</span><span class="p">)</span>
				<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;, failed to detect IRQ line</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_free_ring</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcnet32_debug</span> <span class="o">&amp;</span> <span class="n">NETIF_MSG_PROBE</span><span class="p">)</span>
			<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;, probed IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Set the mii phy_id so that we can query the link state */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* lp-&gt;phycount and lp-&gt;phymask are set to 0 by memset above */</span>

		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">phy_id</span> <span class="o">=</span> <span class="p">((</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">33</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">;</span>
		<span class="cm">/* scan for PHYs */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PCNET32_MAX_PHYS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">id1</span><span class="p">,</span> <span class="n">id2</span><span class="p">;</span>

			<span class="n">id1</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">MII_PHYSID1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">id1</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">id2</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">MII_PHYSID2</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">id2</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">31</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">chip_version</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x2624</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>	<span class="cm">/* 79C971 &amp; 79C972 have phantom phy at id 31 */</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">phycount</span><span class="o">++</span><span class="p">;</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">phymask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">phy_id</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pcnet32_debug</span> <span class="o">&amp;</span> <span class="n">NETIF_MSG_PROBE</span><span class="p">)</span>
				<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Found PHY %04x:%04x at address %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">id1</span><span class="p">,</span> <span class="n">id2</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">phy_id</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">phycount</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">|=</span> <span class="n">PCNET32_PORT_MII</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pcnet32_watchdog</span><span class="p">;</span>

	<span class="cm">/* The PCNET32-specific entries in the device structure. */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pcnet32_netdev_ops</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ethtool_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pcnet32_ethtool_ops</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>

	<span class="cm">/* Fill in the generic fields of the device structure. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">register_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err_free_ring</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">pcnet32_dev</span><span class="p">;</span>
		<span class="n">pcnet32_dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pcnet32_debug</span> <span class="o">&amp;</span> <span class="n">NETIF_MSG_PROBE</span><span class="p">)</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: registered as %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">cards_found</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* enable LED writes */</span>
	<span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x1000</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_free_ring:</span>
	<span class="n">pcnet32_free_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">),</span>
			    <span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_dma_addr</span><span class="p">);</span>
<span class="nl">err_free_netdev:</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="nl">err_release_region:</span>
	<span class="n">release_region</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">PCNET32_TOTAL_SIZE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* if any allocation fails, caller must also call pcnet32_free_ring */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcnet32_alloc_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
					   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcnet32_tx_head</span><span class="p">)</span> <span class="o">*</span>
					   <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_dma_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Consistent memory allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
					   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcnet32_rx_head</span><span class="p">)</span> <span class="o">*</span>
					   <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_dma_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Consistent memory allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_dma_addr</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dma_addr_t</span><span class="p">),</span>
				  <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_dma_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Memory allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_dma_addr</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dma_addr_t</span><span class="p">),</span>
				  <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_dma_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Memory allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">),</span>
				<span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Memory allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">),</span>
				<span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Memory allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_free_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_dma_addr</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_dma_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_dma_addr</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_dma_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcnet32_tx_head</span><span class="p">)</span> <span class="o">*</span>
				    <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">,</span>
				    <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_dma_addr</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcnet32_rx_head</span><span class="p">)</span> <span class="o">*</span>
				    <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">,</span>
				    <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_dma_addr</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcnet32_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">pcnet32_interrupt</span><span class="p">,</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">shared_irq</span> <span class="o">?</span> <span class="n">IRQF_SHARED</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* Check for a valid station address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_free_irq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Reset the PCNET32 */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">);</span>

	<span class="cm">/* switch pcnet32 to 32bit mode */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">netif_printk</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">ifup</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
		     <span class="s">&quot;%s() irq %d tx/rx rings %#x/%#x init %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">__func__</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_dma_addr</span><span class="p">),</span>
		     <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_dma_addr</span><span class="p">),</span>
		     <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_dma_addr</span><span class="p">));</span>

	<span class="cm">/* set/reset autoselect bit */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">PCNET32_PORT_ASEL</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="cm">/* handle full duplex setting */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">full_duplex</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">3</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">PCNET32_PORT_FD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">==</span> <span class="p">(</span><span class="n">PCNET32_PORT_FD</span> <span class="o">|</span> <span class="n">PCNET32_PORT_AUI</span><span class="p">))</span>
				<span class="n">val</span> <span class="o">|=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">PCNET32_PORT_ASEL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* workaround of xSeries250, turn on for 79C975 only */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">chip_version</span> <span class="o">==</span> <span class="mh">0x2627</span><span class="p">)</span>
				<span class="n">val</span> <span class="o">|=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* set/reset GPSI bit in test register */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">124</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x10</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">PCNET32_PORT_PORTSEL</span><span class="p">)</span> <span class="o">==</span> <span class="n">PCNET32_PORT_GPSI</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="mh">0x10</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">124</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="cm">/* Allied Telesyn AT 2700/2701 FX are 100Mbit only and do not negotiate */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span> <span class="o">&amp;&amp;</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_vendor</span> <span class="o">==</span> <span class="n">PCI_VENDOR_ID_AT</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span> <span class="o">==</span> <span class="n">PCI_SUBDEVICE_ID_AT_2700FX</span> <span class="o">||</span>
	     <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span> <span class="o">==</span> <span class="n">PCI_SUBDEVICE_ID_AT_2701FX</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">PCNET32_PORT_ASEL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">=</span> <span class="n">PCNET32_PORT_FD</span> <span class="o">|</span> <span class="n">PCNET32_PORT_100</span><span class="p">;</span>
			<span class="n">netif_printk</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
				     <span class="s">&quot;Setting 100Mb-Full Duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">phycount</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * 24 Jun 2004 according AMD, in order to change the PHY,</span>
<span class="cm">		 * DANAS (or DISPM for 79C976) must be set; then select the speed,</span>
<span class="cm">		 * duplex, and/or enable auto negotiation, and clear DANAS</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">PCNET32_PORT_ASEL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span>
					<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x0080</span><span class="p">);</span>
			<span class="cm">/* disable Auto Negotiation, set 10Mpbs, HD */</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xb8</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">PCNET32_PORT_FD</span><span class="p">)</span>
				<span class="n">val</span> <span class="o">|=</span> <span class="mh">0x10</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">PCNET32_PORT_100</span><span class="p">)</span>
				<span class="n">val</span> <span class="o">|=</span> <span class="mh">0x08</span><span class="p">;</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">PCNET32_PORT_ASEL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span>
						<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span>
							       <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x0080</span><span class="p">);</span>
				<span class="cm">/* enable auto negotiate, setup, disable fd */</span>
				<span class="n">val</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x98</span><span class="p">;</span>
				<span class="n">val</span> <span class="o">|=</span> <span class="mh">0x20</span><span class="p">;</span>
				<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">first_phy</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">bmcr</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">bcr9</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="n">ecmd</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">ETHTOOL_GSET</span> <span class="p">};</span>

		<span class="cm">/*</span>
<span class="cm">		 * There is really no good other way to handle multiple PHYs</span>
<span class="cm">		 * other than turning off all automatics</span>
<span class="cm">		 */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">2</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">));</span>	<span class="cm">/* stop MII manager */</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">PCNET32_PORT_ASEL</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* setup ecmd */</span>
			<span class="n">ecmd</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">PORT_MII</span><span class="p">;</span>
			<span class="n">ecmd</span><span class="p">.</span><span class="n">transceiver</span> <span class="o">=</span> <span class="n">XCVR_INTERNAL</span><span class="p">;</span>
			<span class="n">ecmd</span><span class="p">.</span><span class="n">autoneg</span> <span class="o">=</span> <span class="n">AUTONEG_DISABLE</span><span class="p">;</span>
			<span class="n">ethtool_cmd_speed_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ecmd</span><span class="p">,</span>
					      <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">PCNET32_PORT_100</span><span class="p">)</span> <span class="o">?</span>
					      <span class="n">SPEED_100</span> <span class="o">:</span> <span class="n">SPEED_10</span><span class="p">);</span>
			<span class="n">bcr9</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">PCNET32_PORT_FD</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ecmd</span><span class="p">.</span><span class="n">duplex</span> <span class="o">=</span> <span class="n">DUPLEX_FULL</span><span class="p">;</span>
				<span class="n">bcr9</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">ecmd</span><span class="p">.</span><span class="n">duplex</span> <span class="o">=</span> <span class="n">DUPLEX_HALF</span><span class="p">;</span>
				<span class="n">bcr9</span> <span class="o">|=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="n">bcr9</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PCNET32_MAX_PHYS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">phymask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* isolate all but the first PHY */</span>
				<span class="n">bmcr</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">first_phy</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">first_phy</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
					<span class="n">mdio_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">,</span>
						   <span class="n">bmcr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">BMCR_ISOLATE</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">mdio_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">,</span>
						   <span class="n">bmcr</span> <span class="o">|</span> <span class="n">BMCR_ISOLATE</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="cm">/* use mii_ethtool_sset to setup PHY */</span>
				<span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">phy_id</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="n">ecmd</span><span class="p">.</span><span class="n">phy_address</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">PCNET32_PORT_ASEL</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">mii_ethtool_gset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ecmd</span><span class="p">);</span>
					<span class="n">ecmd</span><span class="p">.</span><span class="n">autoneg</span> <span class="o">=</span> <span class="n">AUTONEG_ENABLE</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">mii_ethtool_sset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ecmd</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">phy_id</span> <span class="o">=</span> <span class="n">first_phy</span><span class="p">;</span>
		<span class="n">netif_info</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Using PHY number %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">first_phy</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#ifdef DO_DXSUFLO</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">dxsuflo</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Disable transmit stop on underflow */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR3</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="mh">0x40</span><span class="p">;</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR3</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span>
	    <span class="n">cpu_to_le16</span><span class="p">((</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">PCNET32_PORT_PORTSEL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">);</span>
	<span class="n">pcnet32_load_multicast</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pcnet32_init_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_free_ring</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

	<span class="cm">/* Re-initialize the PCNET32, and start it when done. */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_dma_addr</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">));</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_dma_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">));</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR4</span><span class="p">,</span> <span class="mh">0x0915</span><span class="p">);</span>	<span class="cm">/* auto tx pad */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">,</span> <span class="n">CSR0_INIT</span><span class="p">);</span>

	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">chip_version</span> <span class="o">&gt;=</span> <span class="n">PCNET32_79C970A</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Print the link status and start the watchdog */</span>
		<span class="n">pcnet32_check_media</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">,</span> <span class="n">PCNET32_WATCHDOG_TIMEOUT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CSR0_IDON</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We used to clear the InitDone bit, 0x0100, here but Mark Stockton</span>
<span class="cm">	 * reports that doing so triggers a bug in the &#39;974.</span>
<span class="cm">	 */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">,</span> <span class="n">CSR0_NORMAL</span><span class="p">);</span>

	<span class="n">netif_printk</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">ifup</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
		     <span class="s">&quot;pcnet32 open after %d ticks, init block %#x csr0 %4.4x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">i</span><span class="p">,</span>
		     <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_dma_addr</span><span class="p">),</span>
		     <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">));</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* Always succeed */</span>

<span class="nl">err_free_ring:</span>
	<span class="cm">/* free any allocated skbuffs */</span>
	<span class="n">pcnet32_purge_rx_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Switch back to 16bit mode to avoid problems with dumb</span>
<span class="cm">	 * DOS packet driver after a warm reboot</span>
<span class="cm">	 */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

<span class="nl">err_free_irq:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The LANCE has been halted for one reason or another (busmaster memory</span>
<span class="cm"> * arbitration error, Tx FIFO underflow, driver stopped it to reconfigure,</span>
<span class="cm"> * etc.).  Modern LANCE variants always reload their ring-buffer</span>
<span class="cm"> * configuration when restarted, so we must reinitialize our ring</span>
<span class="cm"> * context before restarting.  As part of this reinitialization,</span>
<span class="cm"> * find all packets still on the Tx ring and pretend that they had been</span>
<span class="cm"> * sent (in effect, drop the packets on the floor) - the higher-level</span>
<span class="cm"> * protocols will time out and retransmit.  It&#39;d be better to shuffle</span>
<span class="cm"> * these skbs to a temp list and then actually re-Tx them after</span>
<span class="cm"> * restarting the chip, but I&#39;m too lazy to do so right now.  dplatt@3do.com</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_purge_tx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* CPU owns buffer */</span>
		<span class="n">wmb</span><span class="p">();</span>		<span class="cm">/* Make sure adapter sees owner change */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_dma_addr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					 <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
					 <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
			<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_dma_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Initialize the PCNET32 Rx and Tx rings. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcnet32_init_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty_rx</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">rx_skbuff</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rx_skbuff</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PKT_BUF_SKB</span><span class="p">);</span>
			<span class="n">rx_skbuff</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx_skbuff</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* there is not much we can do at this point */</span>
				<span class="n">netif_err</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s netdev_alloc_skb failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">__func__</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">skb_reserve</span><span class="p">(</span><span class="n">rx_skbuff</span><span class="p">,</span> <span class="n">NET_IP_ALIGN</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">rmb</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_dma_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_dma_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			    <span class="n">pci_map_single</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">rx_skbuff</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
					   <span class="n">PKT_BUF_SIZE</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_dma_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buf_length</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">NEG_BUF_SIZE</span><span class="p">);</span>
		<span class="n">wmb</span><span class="p">();</span>		<span class="cm">/* Make sure owner changes after all others are visible */</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x8000</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* The Tx buffer address is filled in as needed, but we do need to clear</span>
<span class="cm">	 * the upper ownership bit. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* CPU owns buffer */</span>
		<span class="n">wmb</span><span class="p">();</span>		<span class="cm">/* Make sure adapter sees owner change */</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_dma_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="o">-&gt;</span><span class="n">tlen_rlen</span> <span class="o">=</span>
	    <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_len_bits</span> <span class="o">|</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_len_bits</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="o">-&gt;</span><span class="n">rx_ring</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_dma_addr</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="o">-&gt;</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_dma_addr</span><span class="p">);</span>
	<span class="n">wmb</span><span class="p">();</span>			<span class="cm">/* Make sure all changes are visible */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* the pcnet32 has been issued a stop or reset.  Wait for the stop bit</span>
<span class="cm"> * then flush the pending transmit operations, re-initialize the ring,</span>
<span class="cm"> * and tell the chip to initialize.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">csr0_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* wait for stop */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CSR0_STOP</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">100</span><span class="p">)</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s timed out waiting for stop</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">__func__</span><span class="p">);</span>

	<span class="n">pcnet32_purge_tx_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcnet32_init_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* ReInit Ring */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">,</span> <span class="n">CSR0_INIT</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CSR0_IDON</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">,</span> <span class="n">csr0_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* Transmitter timeout, serious problems. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcnet32_debug</span> <span class="o">&amp;</span> <span class="n">NETIF_MSG_DRV</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: transmit timed out, status %4.4x, resetting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">));</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">,</span> <span class="n">CSR0_STOP</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_tx_err</span><span class="p">(</span><span class="n">lp</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span>
		       <span class="s">&quot; Ring data dump: dirty_tx %d cur_tx %d%s cur_rx %d.&quot;</span><span class="p">,</span>
		       <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_tx</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_full</span> <span class="o">?</span> <span class="s">&quot; (full)&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		       <span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_rx</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s %08x %04x %08x %04x&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s"> &quot;</span><span class="p">,</span>
			       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span><span class="p">),</span>
			       <span class="p">(</span><span class="o">-</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buf_length</span><span class="p">))</span> <span class="o">&amp;</span>
			       <span class="mh">0xffff</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">msg_length</span><span class="p">),</span>
			       <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status</span><span class="p">));</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s %08x %04x %08x %04x&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s"> &quot;</span><span class="p">,</span>
			       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span><span class="p">),</span>
			       <span class="p">(</span><span class="o">-</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">,</span>
			       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">misc</span><span class="p">),</span>
			       <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">pcnet32_restart</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">CSR0_NORMAL</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span> <span class="cm">/* prevent tx timeout */</span>
	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">pcnet32_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">netif_printk</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">tx_queued</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
		     <span class="s">&quot;%s() called, csr0 %4.4x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">__func__</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">));</span>

	<span class="cm">/* Default status -- will not enable Successful-TxDone</span>
<span class="cm">	 * interrupt when that option is available to us.</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="mh">0x8300</span><span class="p">;</span>

	<span class="cm">/* Fill in a Tx ring entry */</span>

	<span class="cm">/* Mask to ring buffer boundary. */</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">&amp;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_mod_mask</span><span class="p">;</span>

	<span class="cm">/* Caution: the write order is important here, set the status</span>
<span class="cm">	 * with the &quot;ownership&quot; bits last. */</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="o">-</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">misc</span> <span class="o">=</span> <span class="mh">0x00000000</span><span class="p">;</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_dma_addr</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span>
	    <span class="n">pci_map_single</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_dma_addr</span><span class="p">[</span><span class="n">entry</span><span class="p">]);</span>
	<span class="n">wmb</span><span class="p">();</span>			<span class="cm">/* Make sure owner changes after all others are visible */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">status</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">cur_tx</span><span class="o">++</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="cm">/* Trigger an immediate send poll. */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">,</span> <span class="n">CSR0_INTEN</span> <span class="o">|</span> <span class="n">CSR0_TXPOLL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[(</span><span class="n">entry</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_mod_mask</span><span class="p">].</span><span class="n">base</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_full</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The PCNET32 interrupt handler. */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span>
<span class="nf">pcnet32_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ioaddr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">csr0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">boguscnt</span> <span class="o">=</span> <span class="n">max_interrupt_work</span><span class="p">;</span>

	<span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">csr0</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">csr0</span> <span class="o">&amp;</span> <span class="mh">0x8f00</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">boguscnt</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">csr0</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>	<span class="cm">/* PCMCIA remove happened */</span>
		<span class="cm">/* Acknowledge all of the current interrupt sources ASAP. */</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">,</span> <span class="n">csr0</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x004f</span><span class="p">);</span>

		<span class="n">netif_printk</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">intr</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
			     <span class="s">&quot;interrupt  csr0=%#2.2x new csr=%#2.2x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">csr0</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">));</span>

		<span class="cm">/* Log misc errors. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">csr0</span> <span class="o">&amp;</span> <span class="mh">0x4000</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>	<span class="cm">/* Tx babble. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">csr0</span> <span class="o">&amp;</span> <span class="mh">0x1000</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This happens when our receive ring is full. This</span>
<span class="cm">			 * shouldn&#39;t be a problem as we will see normal rx</span>
<span class="cm">			 * interrupts for the frames in the receive ring.  But</span>
<span class="cm">			 * there are some PCI chipsets (I can reproduce this</span>
<span class="cm">			 * on SP3G with Intel saturn chipset) which have</span>
<span class="cm">			 * sometimes problems and will fill up the receive</span>
<span class="cm">			 * ring with error descriptors.  In this situation we</span>
<span class="cm">			 * don&#39;t get a rx interrupt, but a missed frame</span>
<span class="cm">			 * interrupt sooner or later.</span>
<span class="cm">			 */</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>	<span class="cm">/* Missed a Rx frame. */</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">csr0</span> <span class="o">&amp;</span> <span class="mh">0x0800</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Bus master arbitration failure, status %4.4x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">csr0</span><span class="p">);</span>
			<span class="cm">/* unlike for the lance, there is no restart needed */</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">napi_schedule_prep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">u16</span> <span class="n">val</span><span class="p">;</span>
			<span class="cm">/* set interrupt masks */</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR3</span><span class="p">);</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="mh">0x5f00</span><span class="p">;</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR3</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

			<span class="n">__napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">csr0</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">netif_printk</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">intr</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
		     <span class="s">&quot;exiting interrupt, csr0=%#4.4x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">));</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcnet32_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">);</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_missed_errors</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">112</span><span class="p">);</span>

	<span class="n">netif_printk</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">ifdown</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
		     <span class="s">&quot;Shutting down ethercard, status was %2.2x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">));</span>

	<span class="cm">/* We stop the PCNET32 here -- it occasionally polls memory if we don&#39;t. */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">,</span> <span class="n">CSR0_STOP</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Switch back to 16bit mode to avoid problems with dumb</span>
<span class="cm">	 * DOS packet driver after a warm reboot</span>
<span class="cm">	 */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">pcnet32_purge_rx_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pcnet32_purge_tx_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="nf">pcnet32_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_missed_errors</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">112</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* taken from the sunlance driver, which it took from the depca driver */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_load_multicast</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">volatile</span> <span class="k">struct</span> <span class="n">pcnet32_init_block</span> <span class="o">*</span><span class="n">ib</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">__le16</span> <span class="o">*</span><span class="n">mcast_table</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="n">ib</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">crc</span><span class="p">;</span>

	<span class="cm">/* set all multicast bits */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ib</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="mi">0U</span><span class="p">);</span>
		<span class="n">ib</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="mi">0U</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">PCNET32_MC_FILTER</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">PCNET32_MC_FILTER</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">PCNET32_MC_FILTER</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">PCNET32_MC_FILTER</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* clear the multicast filter */</span>
	<span class="n">ib</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ib</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Add addresses */</span>
	<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">crc</span> <span class="o">=</span> <span class="n">ether_crc_le</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">crc</span> <span class="o">=</span> <span class="n">crc</span> <span class="o">&gt;&gt;</span> <span class="mi">26</span><span class="p">;</span>
		<span class="n">mcast_table</span><span class="p">[</span><span class="n">crc</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">]</span> <span class="o">|=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">crc</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">PCNET32_MC_FILTER</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span>
				<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">mcast_table</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set or clear the multicast filter for this adaptor.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_set_multicast_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">csr15</span><span class="p">,</span> <span class="n">suspended</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">suspended</span> <span class="o">=</span> <span class="n">pcnet32_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">csr15</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR15</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Log any net taps. */</span>
		<span class="n">netif_info</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Promiscuous mode enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span>
		    <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x8000</span> <span class="o">|</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">PCNET32_PORT_PORTSEL</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
				<span class="mi">7</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR15</span><span class="p">,</span> <span class="n">csr15</span> <span class="o">|</span> <span class="mh">0x8000</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span>
		    <span class="n">cpu_to_le16</span><span class="p">((</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">PCNET32_PORT_PORTSEL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR15</span><span class="p">,</span> <span class="n">csr15</span> <span class="o">&amp;</span> <span class="mh">0x7fff</span><span class="p">);</span>
		<span class="n">pcnet32_load_multicast</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">suspended</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">csr5</span><span class="p">;</span>
		<span class="cm">/* clear SUSPEND (SPND) - CSR5 bit 0 */</span>
		<span class="n">csr5</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR5</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR5</span><span class="p">,</span> <span class="n">csr5</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">CSR5_SUSPEND</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_csr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">,</span> <span class="n">CSR0_STOP</span><span class="p">);</span>
		<span class="n">pcnet32_restart</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">CSR0_NORMAL</span><span class="p">);</span>
		<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This routine assumes that the lp-&gt;lock is held */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mdio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">val_out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="p">((</span><span class="n">phy_id</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">reg_num</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">));</span>
	<span class="n">val_out</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">34</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">val_out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This routine assumes that the lp-&gt;lock is held */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mdio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="p">((</span><span class="n">phy_id</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">reg_num</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">));</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcnet32_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* SIOC[GS]MIIxxx ioctls */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">generic_mii_ioctl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">,</span> <span class="n">if_mii</span><span class="p">(</span><span class="n">rq</span><span class="p">),</span> <span class="n">cmd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcnet32_check_otherphy</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mii_if_info</span> <span class="n">mii</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">bmcr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PCNET32_MAX_PHYS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">phy_id</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>	<span class="cm">/* skip active phy */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">phymask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mii</span><span class="p">.</span><span class="n">phy_id</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mii_link_ok</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mii</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* found PHY with active link */</span>
				<span class="n">netif_info</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Using PHY number %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">i</span><span class="p">);</span>

				<span class="cm">/* isolate inactive phy */</span>
				<span class="n">bmcr</span> <span class="o">=</span>
				    <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">phy_id</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">);</span>
				<span class="n">mdio_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">phy_id</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">,</span>
					   <span class="n">bmcr</span> <span class="o">|</span> <span class="n">BMCR_ISOLATE</span><span class="p">);</span>

				<span class="cm">/* de-isolate new phy */</span>
				<span class="n">bmcr</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">);</span>
				<span class="n">mdio_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">,</span>
					   <span class="n">bmcr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">BMCR_ISOLATE</span><span class="p">);</span>

				<span class="cm">/* set new phy address */</span>
				<span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">phy_id</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Show the status of the media.  Similar to mii_check_media however it</span>
<span class="cm"> * correctly shows the link speed for all (tested) pcnet32 variants.</span>
<span class="cm"> * Devices with no mii just report link state without speed.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller is assumed to hold and release the lp-&gt;lock.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_check_media</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">verbose</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">curr_link</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">prev_link</span> <span class="o">=</span> <span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bcr9</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curr_link</span> <span class="o">=</span> <span class="n">mii_link_ok</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ulong</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>	<span class="cm">/* card base I/O address */</span>
		<span class="n">curr_link</span> <span class="o">=</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0xc0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">curr_link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev_link</span> <span class="o">||</span> <span class="n">verbose</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">netif_info</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;link down</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">phycount</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">curr_link</span> <span class="o">=</span> <span class="n">pcnet32_check_otherphy</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">prev_link</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">verbose</span> <span class="o">||</span> <span class="o">!</span><span class="n">prev_link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_link</span><span class="p">(</span><span class="n">lp</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="n">ecmd</span> <span class="o">=</span> <span class="p">{</span>
					<span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">ETHTOOL_GSET</span> <span class="p">};</span>
				<span class="n">mii_ethtool_gset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ecmd</span><span class="p">);</span>
				<span class="n">netdev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;link up, %uMbps, %s-duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					    <span class="n">ethtool_cmd_speed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ecmd</span><span class="p">),</span>
					    <span class="p">(</span><span class="n">ecmd</span><span class="p">.</span><span class="n">duplex</span> <span class="o">==</span> <span class="n">DUPLEX_FULL</span><span class="p">)</span>
					    <span class="o">?</span> <span class="s">&quot;full&quot;</span> <span class="o">:</span> <span class="s">&quot;half&quot;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">bcr9</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">read_bcr</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">bcr9</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">!=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">full_duplex</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">full_duplex</span><span class="p">)</span>
					<span class="n">bcr9</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">bcr9</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">lp</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">write_bcr</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="n">bcr9</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">netif_info</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;link up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check for loss of link and link establishment.</span>
<span class="cm"> * Can not use mii_check_media because it does nothing if mode is forced.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcnet32_watchdog</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Print the link status if it has changed */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">pcnet32_check_media</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">,</span> <span class="n">round_jiffies</span><span class="p">(</span><span class="n">PCNET32_WATCHDOG_TIMEOUT</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcnet32_pm_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netif_device_detach</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">pcnet32_close</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pci_choose_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">state</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcnet32_pm_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">);</span>
	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pcnet32_open</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">pcnet32_remove_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">pcnet32_free_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">release_region</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">,</span> <span class="n">PCNET32_TOTAL_SIZE</span><span class="p">);</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">),</span>
				    <span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_dma_addr</span><span class="p">);</span>
		<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">pcnet32_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">DRV_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">pcnet32_probe_pci</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">pcnet32_remove_one</span><span class="p">),</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">pcnet32_pci_tbl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">pcnet32_pm_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">pcnet32_pm_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* An additional parameter that may be passed in... */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">debug</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">tx_start_pt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pcnet32_have_pci</span><span class="p">;</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="n">DRV_NAME</span> <span class="s">&quot; debug level&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">max_interrupt_work</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">max_interrupt_work</span><span class="p">,</span>
		 <span class="n">DRV_NAME</span> <span class="s">&quot; maximum events handled per interrupt&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">rx_copybreak</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">rx_copybreak</span><span class="p">,</span>
		 <span class="n">DRV_NAME</span> <span class="s">&quot; copy breakpoint for copy-only-tiny-frames&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">tx_start_pt</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">tx_start_pt</span><span class="p">,</span> <span class="n">DRV_NAME</span> <span class="s">&quot; transmit start point (0-3)&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">pcnet32vlb</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">pcnet32vlb</span><span class="p">,</span> <span class="n">DRV_NAME</span> <span class="s">&quot; Vesa local bus (VLB) support (0/1)&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">DRV_NAME</span> <span class="s">&quot; initial option setting(s) (0-15)&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">full_duplex</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">full_duplex</span><span class="p">,</span> <span class="n">DRV_NAME</span> <span class="s">&quot; full duplex setting(s) (1)&quot;</span><span class="p">);</span>
<span class="cm">/* Module Parameter for HomePNA cards added by Patrick Simmons, 2004 */</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">homepna</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">homepna</span><span class="p">,</span>
		 <span class="n">DRV_NAME</span>
		 <span class="s">&quot; mode for 79C978 cards (1 for HomePNA, 0 for Ethernet, default Ethernet&quot;</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Thomas Bogendoerfer&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Driver for PCnet32 and PCnetPCI based ethercards&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="cp">#define PCNET32_MSG_DEFAULT (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">pcnet32_init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>

	<span class="n">pcnet32_debug</span> <span class="o">=</span> <span class="n">netif_msg_init</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="n">PCNET32_MSG_DEFAULT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">tx_start_pt</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tx_start_pt</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">))</span>
		<span class="n">tx_start</span> <span class="o">=</span> <span class="n">tx_start_pt</span><span class="p">;</span>

	<span class="cm">/* find the PCI devices */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcnet32_driver</span><span class="p">))</span>
		<span class="n">pcnet32_have_pci</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* should we find any remaining VLbus devices ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcnet32vlb</span><span class="p">)</span>
		<span class="n">pcnet32_probe_vlbus</span><span class="p">(</span><span class="n">pcnet32_portlist</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cards_found</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pcnet32_debug</span> <span class="o">&amp;</span> <span class="n">NETIF_MSG_PROBE</span><span class="p">))</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%d cards_found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cards_found</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">pcnet32_have_pci</span> <span class="o">+</span> <span class="n">cards_found</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">pcnet32_cleanup_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">next_dev</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">pcnet32_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pcnet32_private</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">pcnet32_dev</span><span class="p">);</span>
		<span class="n">next_dev</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">pcnet32_dev</span><span class="p">);</span>
		<span class="n">pcnet32_free_ring</span><span class="p">(</span><span class="n">pcnet32_dev</span><span class="p">);</span>
		<span class="n">release_region</span><span class="p">(</span><span class="n">pcnet32_dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">,</span> <span class="n">PCNET32_TOTAL_SIZE</span><span class="p">);</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">),</span>
				    <span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">init_dma_addr</span><span class="p">);</span>
		<span class="n">free_netdev</span><span class="p">(</span><span class="n">pcnet32_dev</span><span class="p">);</span>
		<span class="n">pcnet32_dev</span> <span class="o">=</span> <span class="n">next_dev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pcnet32_have_pci</span><span class="p">)</span>
		<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcnet32_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">pcnet32_init_module</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">pcnet32_cleanup_module</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Local variables:</span>
<span class="cm"> *  c-indent-level: 4</span>
<span class="cm"> *  tab-width: 8</span>
<span class="cm"> * End:</span>
<span class="cm"> */</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
