<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › phy › mdio_bus.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>mdio_bus.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * drivers/net/phy/mdio_bus.c</span>
<span class="cm"> *</span>
<span class="cm"> * MDIO Bus interface</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Andy Fleming</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2004 Freescale Semiconductor, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute  it and/or modify it</span>
<span class="cm"> * under  the terms of  the GNU General  Public License as published by the</span>
<span class="cm"> * Free Software Foundation;  either version 2 of the  License, or (at your</span>
<span class="cm"> * option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/unistd.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/mii.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/phy.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cm">/**</span>
<span class="cm"> * mdiobus_alloc_size - allocate a mii_bus structure</span>
<span class="cm"> * @size: extra amount of memory to allocate for private storage.</span>
<span class="cm"> * If non-zero, then bus-&gt;priv is points to that memory.</span>
<span class="cm"> *</span>
<span class="cm"> * Description: called by a bus driver to allocate an mii_bus</span>
<span class="cm"> * structure to fill in.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="nf">mdiobus_alloc_size</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">aligned_size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bus</span><span class="p">),</span> <span class="n">NETDEV_ALIGN</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">alloc_size</span><span class="p">;</span>

	<span class="cm">/* If we alloc extra space, it should be aligned */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span>
		<span class="n">alloc_size</span> <span class="o">=</span> <span class="n">aligned_size</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">alloc_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bus</span><span class="p">);</span>

	<span class="n">bus</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bus</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">MDIOBUS_ALLOCATED</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span>
			<span class="n">bus</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">bus</span> <span class="o">+</span> <span class="n">aligned_size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">bus</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mdiobus_alloc_size</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * mdiobus_release - mii_bus device release callback</span>
<span class="cm"> * @d: the target struct device that contains the mii_bus</span>
<span class="cm"> *</span>
<span class="cm"> * Description: called when the last reference to an mii_bus is</span>
<span class="cm"> * dropped, to free the underlying memory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mdiobus_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">to_mii_bus</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">MDIOBUS_RELEASED</span> <span class="o">&amp;&amp;</span>
	       <span class="cm">/* for compatibility with error handling in drivers */</span>
	       <span class="n">bus</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">MDIOBUS_ALLOCATED</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">class</span> <span class="n">mdio_bus_class</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;mdio_bus&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_release</span>	<span class="o">=</span> <span class="n">mdiobus_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#if IS_ENABLED(CONFIG_OF_MDIO)</span>
<span class="cm">/* Helper function for of_mdio_find_bus */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">of_mdio_bus_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mdio_bus_np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">of_node</span> <span class="o">==</span> <span class="n">mdio_bus_np</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * of_mdio_find_bus - Given an mii_bus node, find the mii_bus.</span>
<span class="cm"> * @mdio_bus_np: Pointer to the mii_bus.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to the mii_bus, or NULL if none found.</span>
<span class="cm"> *</span>
<span class="cm"> * Because the association of a device_node and mii_bus is made via</span>
<span class="cm"> * of_mdiobus_register(), the mii_bus cannot be found before it is</span>
<span class="cm"> * registered with of_mdiobus_register().</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="nf">of_mdio_find_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">mdio_bus_np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mdio_bus_np</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">d</span> <span class="o">=</span> <span class="n">class_find_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdio_bus_class</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>  <span class="n">mdio_bus_np</span><span class="p">,</span>
			      <span class="n">of_mdio_bus_match</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">d</span> <span class="o">?</span> <span class="n">to_mii_bus</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">of_mdio_find_bus</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * mdiobus_register - bring up all the PHYs on a given bus and attach them to bus</span>
<span class="cm"> * @bus: target mii_bus</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Called by a bus driver to bring up all the PHYs</span>
<span class="cm"> *   on a given bus, and attach them to the bus.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success or &lt; 0 on error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">mdiobus_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">bus</span> <span class="o">||</span> <span class="nb">NULL</span> <span class="o">==</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">||</span>
			<span class="nb">NULL</span> <span class="o">==</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">||</span>
			<span class="nb">NULL</span> <span class="o">==</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">MDIOBUS_ALLOCATED</span> <span class="o">&amp;&amp;</span>
	       <span class="n">bus</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">MDIOBUS_UNREGISTERED</span><span class="p">);</span>

	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mdio_bus_class</span><span class="p">;</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">groups</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;mii_bus %s failed to register</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">mdio_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">)</span>
		<span class="n">bus</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PHY_MAX_ADDR</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">phy_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">;</span>

			<span class="n">phydev</span> <span class="o">=</span> <span class="n">mdiobus_scan</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">phydev</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">phydev</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">MDIOBUS_REGISTERED</span><span class="p">;</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: probed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">phy_map</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">phy_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">device_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mdiobus_register</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">mdiobus_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">MDIOBUS_REGISTERED</span><span class="p">);</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">MDIOBUS_UNREGISTERED</span><span class="p">;</span>

	<span class="n">device_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PHY_MAX_ADDR</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">phy_map</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">phy_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">bus</span><span class="o">-&gt;</span><span class="n">phy_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mdiobus_unregister</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * mdiobus_free - free a struct mii_bus</span>
<span class="cm"> * @bus: mii_bus to free</span>
<span class="cm"> *</span>
<span class="cm"> * This function releases the reference to the underlying device</span>
<span class="cm"> * object in the mii_bus.  If this is the last reference, the mii_bus</span>
<span class="cm"> * will be freed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">mdiobus_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * For compatibility with error handling in drivers.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">MDIOBUS_ALLOCATED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">MDIOBUS_UNREGISTERED</span><span class="p">);</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">MDIOBUS_RELEASED</span><span class="p">;</span>

	<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mdiobus_free</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="nf">mdiobus_scan</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">phydev</span> <span class="o">=</span> <span class="n">get_phy_device</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">phydev</span><span class="p">)</span> <span class="o">||</span> <span class="n">phydev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">phydev</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">phy_device_register</span><span class="p">(</span><span class="n">phydev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phy_device_free</span><span class="p">(</span><span class="n">phydev</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">phydev</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mdiobus_scan</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * mdiobus_read - Convenience function for reading a given MII mgmt register</span>
<span class="cm"> * @bus: the mii_bus struct</span>
<span class="cm"> * @addr: the phy address</span>
<span class="cm"> * @regnum: register number to read</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: MUST NOT be called from interrupt context,</span>
<span class="cm"> * because the bus read/write functions may wait for an interrupt</span>
<span class="cm"> * to conclude the operation.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">mdiobus_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">regnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">in_interrupt</span><span class="p">());</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">mdio_lock</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">regnum</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">mdio_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mdiobus_read</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * mdiobus_write - Convenience function for writing a given MII mgmt register</span>
<span class="cm"> * @bus: the mii_bus struct</span>
<span class="cm"> * @addr: the phy address</span>
<span class="cm"> * @regnum: register number to write</span>
<span class="cm"> * @val: value to write to @regnum</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: MUST NOT be called from interrupt context,</span>
<span class="cm"> * because the bus read/write functions may wait for an interrupt</span>
<span class="cm"> * to conclude the operation.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">mdiobus_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">regnum</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">in_interrupt</span><span class="p">());</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">mdio_lock</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">regnum</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">mdio_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mdiobus_write</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * mdio_bus_match - determine if given PHY driver supports the given PHY device</span>
<span class="cm"> * @dev: target PHY device</span>
<span class="cm"> * @drv: given PHY driver</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Given a PHY device, and a PHY driver, return 1 if</span>
<span class="cm"> *   the driver supports the device.  Otherwise, return 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mdio_bus_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span> <span class="o">=</span> <span class="n">to_phy_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">phy_driver</span> <span class="o">*</span><span class="n">phydrv</span> <span class="o">=</span> <span class="n">to_phy_driver</span><span class="p">(</span><span class="n">drv</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">((</span><span class="n">phydrv</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">&amp;</span> <span class="n">phydrv</span><span class="o">-&gt;</span><span class="n">phy_id_mask</span><span class="p">)</span> <span class="o">==</span>
		<span class="p">(</span><span class="n">phydev</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">&amp;</span> <span class="n">phydrv</span><span class="o">-&gt;</span><span class="n">phy_id_mask</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">mdio_bus_phy_may_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span> <span class="o">=</span> <span class="n">phydev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">phy_driver</span> <span class="o">*</span><span class="n">phydrv</span> <span class="o">=</span> <span class="n">to_phy_driver</span><span class="p">(</span><span class="n">drv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">phydev</span><span class="o">-&gt;</span><span class="n">attached_dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drv</span> <span class="o">||</span> <span class="o">!</span><span class="n">phydrv</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* PHY not attached? May suspend. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netdev</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t suspend PHY if the attched netdev parent may wakeup.</span>
<span class="cm">	 * The parent may point to a PCI device, as in tg3 driver.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">&amp;&amp;</span> <span class="n">device_may_wakeup</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Also don&#39;t suspend PHY if the netdev itself may wakeup. This</span>
<span class="cm">	 * is the case for devices w/o underlaying pwr. mgmt. aware bus,</span>
<span class="cm">	 * e.g. SoC devices.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device_may_wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mdio_bus_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">phy_driver</span> <span class="o">*</span><span class="n">phydrv</span> <span class="o">=</span> <span class="n">to_phy_driver</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span> <span class="o">=</span> <span class="n">to_phy_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We must stop the state machine manually, otherwise it stops out of</span>
<span class="cm">	 * control, possibly with the phydev-&gt;lock held. Upon resume, netdev</span>
<span class="cm">	 * may call phy routines that try to grab the same lock, and that may</span>
<span class="cm">	 * lead to a deadlock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phydev</span><span class="o">-&gt;</span><span class="n">attached_dev</span> <span class="o">&amp;&amp;</span> <span class="n">phydev</span><span class="o">-&gt;</span><span class="n">adjust_link</span><span class="p">)</span>
		<span class="n">phy_stop_machine</span><span class="p">(</span><span class="n">phydev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mdio_bus_phy_may_suspend</span><span class="p">(</span><span class="n">phydev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">phydrv</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">(</span><span class="n">phydev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mdio_bus_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">phy_driver</span> <span class="o">*</span><span class="n">phydrv</span> <span class="o">=</span> <span class="n">to_phy_driver</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span> <span class="o">=</span> <span class="n">to_phy_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mdio_bus_phy_may_suspend</span><span class="p">(</span><span class="n">phydev</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">no_resume</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">phydrv</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">(</span><span class="n">phydev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">no_resume:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phydev</span><span class="o">-&gt;</span><span class="n">attached_dev</span> <span class="o">&amp;&amp;</span> <span class="n">phydev</span><span class="o">-&gt;</span><span class="n">adjust_link</span><span class="p">)</span>
		<span class="n">phy_start_machine</span><span class="p">(</span><span class="n">phydev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mdio_bus_restore</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span> <span class="o">=</span> <span class="n">to_phy_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">phydev</span><span class="o">-&gt;</span><span class="n">attached_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netdev</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">phy_init_hw</span><span class="p">(</span><span class="n">phydev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* The PHY needs to renegotiate. */</span>
	<span class="n">phydev</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phydev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">PHY_UP</span><span class="p">;</span>

	<span class="n">phy_start_machine</span><span class="p">(</span><span class="n">phydev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">mdio_bus_pm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">mdio_bus_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">mdio_bus_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">freeze</span> <span class="o">=</span> <span class="n">mdio_bus_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">thaw</span> <span class="o">=</span> <span class="n">mdio_bus_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">restore</span> <span class="o">=</span> <span class="n">mdio_bus_restore</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define MDIO_BUS_PM_OPS (&amp;mdio_bus_pm_ops)</span>

<span class="cp">#else</span>

<span class="cp">#define MDIO_BUS_PM_OPS NULL</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">bus_type</span> <span class="n">mdio_bus_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;mdio_bus&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">match</span>		<span class="o">=</span> <span class="n">mdio_bus_match</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pm</span>		<span class="o">=</span> <span class="n">MDIO_BUS_PM_OPS</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mdio_bus_type</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">mdio_bus_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">class_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdio_bus_class</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">bus_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdio_bus_type</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">class_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdio_bus_class</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">mdio_bus_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">class_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdio_bus_class</span><span class="p">);</span>
	<span class="n">bus_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdio_bus_type</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
