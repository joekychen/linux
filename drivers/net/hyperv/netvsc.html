<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › hyperv › netvsc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>netvsc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2009, Microsoft Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms and conditions of the GNU General Public License,</span>
<span class="cm"> * version 2, as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 59 Temple</span>
<span class="cm"> * Place - Suite 330, Boston, MA 02111-1307 USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:</span>
<span class="cm"> *   Haiyang Zhang &lt;haiyangz@microsoft.com&gt;</span>
<span class="cm"> *   Hank Janssen  &lt;hjanssen@microsoft.com&gt;</span>
<span class="cm"> */</span>
<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/if_ether.h&gt;</span>

<span class="cp">#include &quot;hyperv_net.h&quot;</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">netvsc_device</span> <span class="o">*</span><span class="nf">alloc_net_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netvsc_device</span> <span class="o">*</span><span class="n">net_device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span> <span class="o">=</span> <span class="n">hv_get_drvdata</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="n">net_device</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">netvsc_device</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net_device</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">wait_drain</span><span class="p">);</span>
	<span class="n">net_device</span><span class="o">-&gt;</span><span class="n">start_remove</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">net_device</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">net_device</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">device</span><span class="p">;</span>
	<span class="n">net_device</span><span class="o">-&gt;</span><span class="n">ndev</span> <span class="o">=</span> <span class="n">ndev</span><span class="p">;</span>

	<span class="n">hv_set_drvdata</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">net_device</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">net_device</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">netvsc_device</span> <span class="o">*</span><span class="nf">get_outbound_net_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netvsc_device</span> <span class="o">*</span><span class="n">net_device</span><span class="p">;</span>

	<span class="n">net_device</span> <span class="o">=</span> <span class="n">hv_get_drvdata</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">net_device</span> <span class="o">&amp;&amp;</span> <span class="n">net_device</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">)</span>
		<span class="n">net_device</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">net_device</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">netvsc_device</span> <span class="o">*</span><span class="nf">get_inbound_net_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netvsc_device</span> <span class="o">*</span><span class="n">net_device</span><span class="p">;</span>

	<span class="n">net_device</span> <span class="o">=</span> <span class="n">hv_get_drvdata</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net_device</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">get_in_err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">&amp;&amp;</span>
		<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">num_outstanding_sends</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">net_device</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">get_in_err:</span>
	<span class="k">return</span> <span class="n">net_device</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">netvsc_destroy_recv_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">netvsc_device</span> <span class="o">*</span><span class="n">net_device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nvsp_message</span> <span class="o">*</span><span class="n">revoke_packet</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span> <span class="o">=</span> <span class="n">net_device</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we got a section count, it means we received a</span>
<span class="cm">	 * SendReceiveBufferComplete msg (ie sent</span>
<span class="cm">	 * NvspMessage1TypeSendReceiveBuffer msg) therefore, we need</span>
<span class="cm">	 * to send a revoke msg here</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_section_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Send the revoke receive buffer */</span>
		<span class="n">revoke_packet</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">revoke_packet</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">revoke_packet</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvsp_message</span><span class="p">));</span>

		<span class="n">revoke_packet</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">msg_type</span> <span class="o">=</span>
			<span class="n">NVSP_MSG1_TYPE_REVOKE_RECV_BUF</span><span class="p">;</span>
		<span class="n">revoke_packet</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span><span class="n">v1_msg</span><span class="p">.</span>
		<span class="n">revoke_recv_buf</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">NETVSC_RECEIVE_BUFFER_ID</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">vmbus_sendpacket</span><span class="p">(</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
				       <span class="n">revoke_packet</span><span class="p">,</span>
				       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvsp_message</span><span class="p">),</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">revoke_packet</span><span class="p">,</span>
				       <span class="n">VM_PKT_DATA_INBAND</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we failed here, we might as well return and</span>
<span class="cm">		 * have a leak rather than continue and a bugchk</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="s">&quot;unable to send &quot;</span>
				<span class="s">&quot;revoke receive buffer to netvsp</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Teardown the gpadl on the vsp end */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_buf_gpadl_handle</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">vmbus_teardown_gpadl</span><span class="p">(</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
			   <span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_buf_gpadl_handle</span><span class="p">);</span>

		<span class="cm">/* If we failed here, we might as well return and have a leak</span>
<span class="cm">		 * rather than continue and a bugchk</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span>
				   <span class="s">&quot;unable to teardown receive buffer&#39;s gpadl</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_buf_gpadl_handle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Free up the receive buffer */</span>
		<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_buf</span><span class="p">,</span>
			<span class="n">get_order</span><span class="p">(</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_buf_size</span><span class="p">));</span>
		<span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_section</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_section_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_section</span><span class="p">);</span>
		<span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_section</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">netvsc_init_recv_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">t</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netvsc_device</span> <span class="o">*</span><span class="n">net_device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nvsp_message</span> <span class="o">*</span><span class="n">init_packet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">;</span>

	<span class="n">net_device</span> <span class="o">=</span> <span class="n">get_outbound_net_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net_device</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">ndev</span> <span class="o">=</span> <span class="n">net_device</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">;</span>

	<span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_buf</span> <span class="o">=</span>
		<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="o">|</span><span class="n">__GFP_ZERO</span><span class="p">,</span>
				<span class="n">get_order</span><span class="p">(</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_buf_size</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="s">&quot;unable to allocate receive &quot;</span>
			<span class="s">&quot;buffer of size %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_buf_size</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Establish the gpadl handle for this buffer on this</span>
<span class="cm">	 * channel.  Note: This call uses the vmbus connection rather</span>
<span class="cm">	 * than the channel to establish the gpadl handle.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">vmbus_establish_gpadl</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_buf</span><span class="p">,</span>
				    <span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_buf_size</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_buf_gpadl_handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span>
			<span class="s">&quot;unable to establish receive buffer&#39;s gpadl</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/* Notify the NetVsp of the gpadl handle */</span>
	<span class="n">init_packet</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">channel_init_pkt</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">init_packet</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvsp_message</span><span class="p">));</span>

	<span class="n">init_packet</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">NVSP_MSG1_TYPE_SEND_RECV_BUF</span><span class="p">;</span>
	<span class="n">init_packet</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span><span class="n">v1_msg</span><span class="p">.</span><span class="n">send_recv_buf</span><span class="p">.</span>
		<span class="n">gpadl_handle</span> <span class="o">=</span> <span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_buf_gpadl_handle</span><span class="p">;</span>
	<span class="n">init_packet</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span><span class="n">v1_msg</span><span class="p">.</span>
		<span class="n">send_recv_buf</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">NETVSC_RECEIVE_BUFFER_ID</span><span class="p">;</span>

	<span class="cm">/* Send the gpadl notification request */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">vmbus_sendpacket</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">init_packet</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvsp_message</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">init_packet</span><span class="p">,</span>
			       <span class="n">VM_PKT_DATA_INBAND</span><span class="p">,</span>
			       <span class="n">VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span>
			<span class="s">&quot;unable to send receive buffer&#39;s gpadl to netvsp</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">t</span> <span class="o">=</span> <span class="n">wait_for_completion_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">channel_init_wait</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>


	<span class="cm">/* Check the response */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">init_packet</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span><span class="n">v1_msg</span><span class="p">.</span>
	    <span class="n">send_recv_buf_complete</span><span class="p">.</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NVSP_STAT_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="s">&quot;Unable to complete receive buffer &quot;</span>
			   <span class="s">&quot;initialization with NetVsp - status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">init_packet</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span><span class="n">v1_msg</span><span class="p">.</span>
			   <span class="n">send_recv_buf_complete</span><span class="p">.</span><span class="n">status</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Parse the response */</span>

	<span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_section_cnt</span> <span class="o">=</span> <span class="n">init_packet</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span>
		<span class="n">v1_msg</span><span class="p">.</span><span class="n">send_recv_buf_complete</span><span class="p">.</span><span class="n">num_sections</span><span class="p">;</span>

	<span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_section</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span>
		<span class="n">init_packet</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span><span class="n">v1_msg</span><span class="p">.</span><span class="n">send_recv_buf_complete</span><span class="p">.</span><span class="n">sections</span><span class="p">,</span>
		<span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_section_cnt</span> <span class="o">*</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvsp_1_receive_buffer_section</span><span class="p">),</span>
		<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_section</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * For 1st release, there should only be 1 section that represents the</span>
<span class="cm">	 * entire receive buffer</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_section_cnt</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span>
	    <span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_section</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

<span class="nl">cleanup:</span>
	<span class="n">netvsc_destroy_recv_buf</span><span class="p">(</span><span class="n">net_device</span><span class="p">);</span>

<span class="nl">exit:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Negotiate NVSP protocol version */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">negotiate_nvsp_ver</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">netvsc_device</span> <span class="o">*</span><span class="n">net_device</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">nvsp_message</span> <span class="o">*</span><span class="n">init_packet</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">nvsp_ver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">t</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">init_packet</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvsp_message</span><span class="p">));</span>
	<span class="n">init_packet</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">NVSP_MSG_TYPE_INIT</span><span class="p">;</span>
	<span class="n">init_packet</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span><span class="n">init_msg</span><span class="p">.</span><span class="n">init</span><span class="p">.</span><span class="n">min_protocol_ver</span> <span class="o">=</span> <span class="n">nvsp_ver</span><span class="p">;</span>
	<span class="n">init_packet</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span><span class="n">init_msg</span><span class="p">.</span><span class="n">init</span><span class="p">.</span><span class="n">max_protocol_ver</span> <span class="o">=</span> <span class="n">nvsp_ver</span><span class="p">;</span>

	<span class="cm">/* Send the init request */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">vmbus_sendpacket</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">init_packet</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvsp_message</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">init_packet</span><span class="p">,</span>
			       <span class="n">VM_PKT_DATA_INBAND</span><span class="p">,</span>
			       <span class="n">VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">=</span> <span class="n">wait_for_completion_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">channel_init_wait</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">init_packet</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span><span class="n">init_msg</span><span class="p">.</span><span class="n">init_complete</span><span class="p">.</span><span class="n">status</span> <span class="o">!=</span>
	    <span class="n">NVSP_STAT_SUCCESS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nvsp_ver</span> <span class="o">!=</span> <span class="n">NVSP_PROTOCOL_VERSION_2</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* NVSPv2 only: Send NDIS config */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">init_packet</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvsp_message</span><span class="p">));</span>
	<span class="n">init_packet</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">NVSP_MSG2_TYPE_SEND_NDIS_CONFIG</span><span class="p">;</span>
	<span class="n">init_packet</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span><span class="n">v2_msg</span><span class="p">.</span><span class="n">send_ndis_config</span><span class="p">.</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">net_device</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">;</span>
	<span class="n">init_packet</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span><span class="n">v2_msg</span><span class="p">.</span><span class="n">send_ndis_config</span><span class="p">.</span><span class="n">capability</span><span class="p">.</span><span class="n">ieee8021q</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">vmbus_sendpacket</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">init_packet</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvsp_message</span><span class="p">),</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">init_packet</span><span class="p">,</span>
				<span class="n">VM_PKT_DATA_INBAND</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">netvsc_connect_vsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netvsc_device</span> <span class="o">*</span><span class="n">net_device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nvsp_message</span> <span class="o">*</span><span class="n">init_packet</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ndis_version</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">;</span>

	<span class="n">net_device</span> <span class="o">=</span> <span class="n">get_outbound_net_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net_device</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">ndev</span> <span class="o">=</span> <span class="n">net_device</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">;</span>

	<span class="n">init_packet</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">channel_init_pkt</span><span class="p">;</span>

	<span class="cm">/* Negotiate the latest NVSP protocol supported */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">negotiate_nvsp_ver</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">net_device</span><span class="p">,</span> <span class="n">init_packet</span><span class="p">,</span>
			       <span class="n">NVSP_PROTOCOL_VERSION_2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">net_device</span><span class="o">-&gt;</span><span class="n">nvsp_version</span> <span class="o">=</span> <span class="n">NVSP_PROTOCOL_VERSION_2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">negotiate_nvsp_ver</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">net_device</span><span class="p">,</span> <span class="n">init_packet</span><span class="p">,</span>
				    <span class="n">NVSP_PROTOCOL_VERSION_1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">net_device</span><span class="o">-&gt;</span><span class="n">nvsp_version</span> <span class="o">=</span> <span class="n">NVSP_PROTOCOL_VERSION_1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Negotiated NVSP version:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">net_device</span><span class="o">-&gt;</span><span class="n">nvsp_version</span><span class="p">);</span>

	<span class="cm">/* Send the ndis version */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">init_packet</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvsp_message</span><span class="p">));</span>

	<span class="n">ndis_version</span> <span class="o">=</span> <span class="mh">0x00050001</span><span class="p">;</span>

	<span class="n">init_packet</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">NVSP_MSG1_TYPE_SEND_NDIS_VER</span><span class="p">;</span>
	<span class="n">init_packet</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span><span class="n">v1_msg</span><span class="p">.</span>
		<span class="n">send_ndis_ver</span><span class="p">.</span><span class="n">ndis_major_ver</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">ndis_version</span> <span class="o">&amp;</span> <span class="mh">0xFFFF0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">init_packet</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span><span class="n">v1_msg</span><span class="p">.</span>
		<span class="n">send_ndis_ver</span><span class="p">.</span><span class="n">ndis_minor_ver</span> <span class="o">=</span>
				<span class="n">ndis_version</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">;</span>

	<span class="cm">/* Send the init request */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">vmbus_sendpacket</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">init_packet</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvsp_message</span><span class="p">),</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">init_packet</span><span class="p">,</span>
				<span class="n">VM_PKT_DATA_INBAND</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="cm">/* Post the big receive buffer to NetVSP */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">netvsc_init_recv_buf</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

<span class="nl">cleanup:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">netvsc_disconnect_vsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">netvsc_device</span> <span class="o">*</span><span class="n">net_device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netvsc_destroy_recv_buf</span><span class="p">(</span><span class="n">net_device</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * netvsc_device_remove - Callback when the root bus device is removed</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netvsc_device_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netvsc_device</span> <span class="o">*</span><span class="n">net_device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hv_netvsc_packet</span> <span class="o">*</span><span class="n">netvsc_packet</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">net_device</span> <span class="o">=</span> <span class="n">hv_get_drvdata</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">inbound_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">net_device</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">inbound_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Wait for all send completions */</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">wait_drain</span><span class="p">,</span>
		   <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">num_outstanding_sends</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">netvsc_disconnect_vsp</span><span class="p">(</span><span class="n">net_device</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since we have already drained, we don&#39;t need to busy wait</span>
<span class="cm">	 * as was done in final_release_stor_device()</span>
<span class="cm">	 * Note that we cannot set the ext pointer to NULL until</span>
<span class="cm">	 * we have drained - to drain the outgoing packets, we need to</span>
<span class="cm">	 * allow incoming packets.</span>
<span class="cm">	 */</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">inbound_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">hv_set_drvdata</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">inbound_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * At this point, no one should be accessing net_device</span>
<span class="cm">	 * except in here</span>
<span class="cm">	 */</span>
	<span class="n">dev_notice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;net device safe to remove</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Now, we can close the channel safely */</span>
	<span class="n">vmbus_close</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>

	<span class="cm">/* Release all resources */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">netvsc_packet</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_pkt_list</span><span class="p">,</span> <span class="n">list_ent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netvsc_packet</span><span class="o">-&gt;</span><span class="n">list_ent</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">netvsc_packet</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">net_device</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#define RING_AVAIL_PERCENT_HIWATER 20</span>
<span class="cp">#define RING_AVAIL_PERCENT_LOWATER 10</span>

<span class="cm">/*</span>
<span class="cm"> * Get the percentage of available bytes to write in the ring.</span>
<span class="cm"> * The return value is in range from 0 to 100.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">hv_ringbuf_avail_percent</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">hv_ring_buffer_info</span> <span class="o">*</span><span class="n">ring_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">avail_read</span><span class="p">,</span> <span class="n">avail_write</span><span class="p">;</span>

	<span class="n">hv_get_ringbuffer_availbytes</span><span class="p">(</span><span class="n">ring_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">avail_read</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">avail_write</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">avail_write</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="n">ring_info</span><span class="o">-&gt;</span><span class="n">ring_datasize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">netvsc_send_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">vmpacket_descriptor</span> <span class="o">*</span><span class="n">packet</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netvsc_device</span> <span class="o">*</span><span class="n">net_device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nvsp_message</span> <span class="o">*</span><span class="n">nvsp_packet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hv_netvsc_packet</span> <span class="o">*</span><span class="n">nvsc_packet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">;</span>

	<span class="n">net_device</span> <span class="o">=</span> <span class="n">get_inbound_net_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net_device</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">ndev</span> <span class="o">=</span> <span class="n">net_device</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">;</span>

	<span class="n">nvsp_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nvsp_message</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">packet</span> <span class="o">+</span>
			<span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">offset8</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">nvsp_packet</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">msg_type</span> <span class="o">==</span> <span class="n">NVSP_MSG_TYPE_INIT_COMPLETE</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">nvsp_packet</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">msg_type</span> <span class="o">==</span>
	     <span class="n">NVSP_MSG1_TYPE_SEND_RECV_BUF_COMPLETE</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">nvsp_packet</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">msg_type</span> <span class="o">==</span>
	     <span class="n">NVSP_MSG1_TYPE_SEND_SEND_BUF_COMPLETE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Copy the response back */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">channel_init_pkt</span><span class="p">,</span> <span class="n">nvsp_packet</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvsp_message</span><span class="p">));</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">channel_init_wait</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nvsp_packet</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">msg_type</span> <span class="o">==</span>
		   <span class="n">NVSP_MSG1_TYPE_SEND_RNDIS_PKT_COMPLETE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">num_outstanding_sends</span><span class="p">;</span>

		<span class="cm">/* Get the send context */</span>
		<span class="n">nvsc_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hv_netvsc_packet</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span>
			<span class="n">packet</span><span class="o">-&gt;</span><span class="n">trans_id</span><span class="p">;</span>

		<span class="cm">/* Notify the layer above us */</span>
		<span class="n">nvsc_packet</span><span class="o">-&gt;</span><span class="n">completion</span><span class="p">.</span><span class="n">send</span><span class="p">.</span><span class="n">send_completion</span><span class="p">(</span>
			<span class="n">nvsc_packet</span><span class="o">-&gt;</span><span class="n">completion</span><span class="p">.</span><span class="n">send</span><span class="p">.</span><span class="n">send_completion_ctx</span><span class="p">);</span>

		<span class="n">num_outstanding_sends</span> <span class="o">=</span>
			<span class="n">atomic_dec_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">num_outstanding_sends</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">&amp;&amp;</span> <span class="n">num_outstanding_sends</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">wait_drain</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">netif_queue_stopped</span><span class="p">(</span><span class="n">ndev</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">start_remove</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">hv_ringbuf_avail_percent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">outbound</span><span class="p">)</span>
			<span class="o">&gt;</span> <span class="n">RING_AVAIL_PERCENT_HIWATER</span> <span class="o">||</span>
			<span class="n">num_outstanding_sends</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">))</span>
				<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="s">&quot;Unknown send completion packet type- &quot;</span>
			   <span class="s">&quot;%d received!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nvsp_packet</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">msg_type</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="nf">netvsc_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">hv_netvsc_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netvsc_device</span> <span class="o">*</span><span class="n">net_device</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nvsp_message</span> <span class="n">sendMessage</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">;</span>

	<span class="n">net_device</span> <span class="o">=</span> <span class="n">get_outbound_net_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net_device</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">ndev</span> <span class="o">=</span> <span class="n">net_device</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">;</span>

	<span class="n">sendMessage</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">NVSP_MSG1_TYPE_SEND_RNDIS_PKT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">is_data_pkt</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* 0 is RMC_DATA; */</span>
		<span class="n">sendMessage</span><span class="p">.</span><span class="n">msg</span><span class="p">.</span><span class="n">v1_msg</span><span class="p">.</span><span class="n">send_rndis_pkt</span><span class="p">.</span><span class="n">channel_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* 1 is RMC_CONTROL; */</span>
		<span class="n">sendMessage</span><span class="p">.</span><span class="n">msg</span><span class="p">.</span><span class="n">v1_msg</span><span class="p">.</span><span class="n">send_rndis_pkt</span><span class="p">.</span><span class="n">channel_type</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Not using send buffer section */</span>
	<span class="n">sendMessage</span><span class="p">.</span><span class="n">msg</span><span class="p">.</span><span class="n">v1_msg</span><span class="p">.</span><span class="n">send_rndis_pkt</span><span class="p">.</span><span class="n">send_buf_section_index</span> <span class="o">=</span>
		<span class="mh">0xFFFFFFFF</span><span class="p">;</span>
	<span class="n">sendMessage</span><span class="p">.</span><span class="n">msg</span><span class="p">.</span><span class="n">v1_msg</span><span class="p">.</span><span class="n">send_rndis_pkt</span><span class="p">.</span><span class="n">send_buf_section_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">page_buf_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">vmbus_sendpacket_pagebuffer</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
						  <span class="n">packet</span><span class="o">-&gt;</span><span class="n">page_buf</span><span class="p">,</span>
						  <span class="n">packet</span><span class="o">-&gt;</span><span class="n">page_buf_cnt</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">sendMessage</span><span class="p">,</span>
						  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvsp_message</span><span class="p">),</span>
						  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">packet</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">vmbus_sendpacket</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sendMessage</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvsp_message</span><span class="p">),</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">packet</span><span class="p">,</span>
				<span class="n">VM_PKT_DATA_INBAND</span><span class="p">,</span>
				<span class="n">VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">num_outstanding_sends</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hv_ringbuf_avail_percent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">outbound</span><span class="p">)</span> <span class="o">&lt;</span>
			<span class="n">RING_AVAIL_PERCENT_LOWATER</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span>
				<span class="n">num_outstanding_sends</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">num_outstanding_sends</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="s">&quot;Unable to send packet %p ret %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">packet</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">netvsc_send_recv_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
					<span class="n">u64</span> <span class="n">transaction_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nvsp_message</span> <span class="n">recvcompMessage</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netvsc_device</span> <span class="o">*</span><span class="n">net_device</span> <span class="o">=</span> <span class="n">hv_get_drvdata</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="n">ndev</span> <span class="o">=</span> <span class="n">net_device</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">;</span>

	<span class="n">recvcompMessage</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">msg_type</span> <span class="o">=</span>
				<span class="n">NVSP_MSG1_TYPE_SEND_RNDIS_PKT_COMPLETE</span><span class="p">;</span>

	<span class="cm">/* FIXME: Pass in the status */</span>
	<span class="n">recvcompMessage</span><span class="p">.</span><span class="n">msg</span><span class="p">.</span><span class="n">v1_msg</span><span class="p">.</span><span class="n">send_rndis_pkt_complete</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span>
		<span class="n">NVSP_STAT_SUCCESS</span><span class="p">;</span>

<span class="nl">retry_send_cmplt:</span>
	<span class="cm">/* Send the completion */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">vmbus_sendpacket</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">recvcompMessage</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvsp_message</span><span class="p">),</span> <span class="n">transaction_id</span><span class="p">,</span>
			       <span class="n">VM_PKT_COMP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* success */</span>
		<span class="cm">/* no-op */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* no more room...wait a bit and attempt to retry 3 times */</span>
		<span class="n">retries</span><span class="o">++</span><span class="p">;</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="s">&quot;unable to send receive completion pkt&quot;</span>
			<span class="s">&quot; (tid %llx)...retrying %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">transaction_id</span><span class="p">,</span> <span class="n">retries</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">retries</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">retry_send_cmplt</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="s">&quot;unable to send receive &quot;</span>
				<span class="s">&quot;completion pkt (tid %llx)...give up retrying</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">transaction_id</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="s">&quot;unable to send receive &quot;</span>
			<span class="s">&quot;completion pkt - %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">transaction_id</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Send a receive completion packet to RNDIS device (ie NetVsp) */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">netvsc_receive_completion</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hv_netvsc_packet</span> <span class="o">*</span><span class="n">packet</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="p">)</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netvsc_device</span> <span class="o">*</span><span class="n">net_device</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">transaction_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">fsend_receive_comp</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Even though it seems logical to do a GetOutboundNetDevice() here to</span>
<span class="cm">	 * send out receive completion, we are using GetInboundNetDevice()</span>
<span class="cm">	 * since we may have disable outbound traffic already.</span>
<span class="cm">	 */</span>
	<span class="n">net_device</span> <span class="o">=</span> <span class="n">get_inbound_net_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net_device</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">ndev</span> <span class="o">=</span> <span class="n">net_device</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">;</span>

	<span class="cm">/* Overloading use of the lock. */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_pkt_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">packet</span><span class="o">-&gt;</span><span class="n">xfer_page_pkt</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Last one in the line that represent 1 xfer page packet.</span>
<span class="cm">	 * Return the xfer page packet itself to the freelist</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">xfer_page_pkt</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fsend_receive_comp</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">transaction_id</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">completion</span><span class="p">.</span><span class="n">recv</span><span class="p">.</span><span class="n">recv_completion_tid</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">xfer_page_pkt</span><span class="o">-&gt;</span><span class="n">list_ent</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_pkt_list</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="cm">/* Put the packet back */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">list_ent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_pkt_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_pkt_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Send a receive completion for the xfer page packet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsend_receive_comp</span><span class="p">)</span>
		<span class="n">netvsc_send_recv_completion</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">transaction_id</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">netvsc_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">vmpacket_descriptor</span> <span class="o">*</span><span class="n">packet</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netvsc_device</span> <span class="o">*</span><span class="n">net_device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmtransfer_page_packet_header</span> <span class="o">*</span><span class="n">vmxferpage_packet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nvsp_message</span> <span class="o">*</span><span class="n">nvsp_packet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hv_netvsc_packet</span> <span class="o">*</span><span class="n">netvsc_packet</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* struct netvsc_driver *netvscDriver; */</span>
	<span class="k">struct</span> <span class="n">xferpage_packet</span> <span class="o">*</span><span class="n">xferpage_packet</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">;</span>

	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">listHead</span><span class="p">);</span>

	<span class="n">net_device</span> <span class="o">=</span> <span class="n">get_inbound_net_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net_device</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">ndev</span> <span class="o">=</span> <span class="n">net_device</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * All inbound packets other than send completion should be xfer page</span>
<span class="cm">	 * packet</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">VM_PKT_DATA_USING_XFER_PAGES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="s">&quot;Unknown packet type received - %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">packet</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nvsp_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nvsp_message</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">packet</span> <span class="o">+</span>
			<span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">offset8</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">));</span>

	<span class="cm">/* Make sure this is a valid nvsp packet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nvsp_packet</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">msg_type</span> <span class="o">!=</span>
	    <span class="n">NVSP_MSG1_TYPE_SEND_RNDIS_PKT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="s">&quot;Unknown nvsp packet type received-&quot;</span>
			<span class="s">&quot; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nvsp_packet</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">msg_type</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vmxferpage_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vmtransfer_page_packet_header</span> <span class="o">*</span><span class="p">)</span><span class="n">packet</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmxferpage_packet</span><span class="o">-&gt;</span><span class="n">xfer_pageset_id</span> <span class="o">!=</span> <span class="n">NETVSC_RECEIVE_BUFFER_ID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="s">&quot;Invalid xfer page set id - &quot;</span>
			   <span class="s">&quot;expecting %x got %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">NETVSC_RECEIVE_BUFFER_ID</span><span class="p">,</span>
			   <span class="n">vmxferpage_packet</span><span class="o">-&gt;</span><span class="n">xfer_pageset_id</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Grab free packets (range count + 1) to represent this xfer</span>
<span class="cm">	 * page packet. +1 to represent the xfer page packet itself.</span>
<span class="cm">	 * We grab it here so that we know exactly how many we can</span>
<span class="cm">	 * fulfil</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_pkt_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_pkt_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_pkt_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">listHead</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">count</span> <span class="o">==</span> <span class="n">vmxferpage_packet</span><span class="o">-&gt;</span><span class="n">range_cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_pkt_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need at least 2 netvsc pkts (1 to represent the xfer</span>
<span class="cm">	 * page and at least 1 for the range) i.e. we can handled</span>
<span class="cm">	 * some of the xfer page packet ranges...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="s">&quot;Got only %d netvsc pkt...needed &quot;</span>
			<span class="s">&quot;%d pkts. Dropping this xfer page packet completely!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">count</span><span class="p">,</span> <span class="n">vmxferpage_packet</span><span class="o">-&gt;</span><span class="n">range_cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* Return it to the freelist */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_pkt_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="n">listHead</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_pkt_list</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_pkt_list_lock</span><span class="p">,</span>
				       <span class="n">flags</span><span class="p">);</span>

		<span class="n">netvsc_send_recv_completion</span><span class="p">(</span><span class="n">device</span><span class="p">,</span>
					    <span class="n">vmxferpage_packet</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">.</span><span class="n">trans_id</span><span class="p">);</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Remove the 1st packet to represent the xfer page packet itself */</span>
	<span class="n">xferpage_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xferpage_packet</span> <span class="o">*</span><span class="p">)</span><span class="n">listHead</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xferpage_packet</span><span class="o">-&gt;</span><span class="n">list_ent</span><span class="p">);</span>

	<span class="cm">/* This is how much we can satisfy */</span>
	<span class="n">xferpage_packet</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xferpage_packet</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">!=</span> <span class="n">vmxferpage_packet</span><span class="o">-&gt;</span><span class="n">range_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="s">&quot;Needed %d netvsc pkts to satisfy &quot;</span>
			<span class="s">&quot;this xfer page...got %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">vmxferpage_packet</span><span class="o">-&gt;</span><span class="n">range_cnt</span><span class="p">,</span> <span class="n">xferpage_packet</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Each range represents 1 RNDIS pkt that contains 1 ethernet frame */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netvsc_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hv_netvsc_packet</span> <span class="o">*</span><span class="p">)</span><span class="n">listHead</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netvsc_packet</span><span class="o">-&gt;</span><span class="n">list_ent</span><span class="p">);</span>

		<span class="cm">/* Initialize the netvsc packet */</span>
		<span class="n">netvsc_packet</span><span class="o">-&gt;</span><span class="n">xfer_page_pkt</span> <span class="o">=</span> <span class="n">xferpage_packet</span><span class="p">;</span>
		<span class="n">netvsc_packet</span><span class="o">-&gt;</span><span class="n">completion</span><span class="p">.</span><span class="n">recv</span><span class="p">.</span><span class="n">recv_completion</span> <span class="o">=</span>
					<span class="n">netvsc_receive_completion</span><span class="p">;</span>
		<span class="n">netvsc_packet</span><span class="o">-&gt;</span><span class="n">completion</span><span class="p">.</span><span class="n">recv</span><span class="p">.</span><span class="n">recv_completion_ctx</span> <span class="o">=</span>
					<span class="n">netvsc_packet</span><span class="p">;</span>
		<span class="n">netvsc_packet</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span><span class="p">;</span>
		<span class="cm">/* Save this so that we can send it back */</span>
		<span class="n">netvsc_packet</span><span class="o">-&gt;</span><span class="n">completion</span><span class="p">.</span><span class="n">recv</span><span class="p">.</span><span class="n">recv_completion_tid</span> <span class="o">=</span>
					<span class="n">vmxferpage_packet</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">.</span><span class="n">trans_id</span><span class="p">;</span>

		<span class="n">netvsc_packet</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">net_device</span><span class="o">-&gt;</span>
			<span class="n">recv_buf</span> <span class="o">+</span> <span class="n">vmxferpage_packet</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">byte_offset</span><span class="p">);</span>
		<span class="n">netvsc_packet</span><span class="o">-&gt;</span><span class="n">total_data_buflen</span> <span class="o">=</span>
					<span class="n">vmxferpage_packet</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">byte_count</span><span class="p">;</span>

		<span class="cm">/* Pass it to the upper layer */</span>
		<span class="n">rndis_filter_receive</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">netvsc_packet</span><span class="p">);</span>

		<span class="n">netvsc_receive_completion</span><span class="p">(</span><span class="n">netvsc_packet</span><span class="o">-&gt;</span>
				<span class="n">completion</span><span class="p">.</span><span class="n">recv</span><span class="p">.</span><span class="n">recv_completion_ctx</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">netvsc_channel_cb</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netvsc_device</span> <span class="o">*</span><span class="n">net_device</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bytes_recvd</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">request_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">packet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmpacket_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bufferlen</span> <span class="o">=</span> <span class="n">NETVSC_PACKET_SIZE</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">;</span>

	<span class="n">packet</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">NETVSC_PACKET_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">),</span>
			 <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">packet</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">buffer</span> <span class="o">=</span> <span class="n">packet</span><span class="p">;</span>

	<span class="n">net_device</span> <span class="o">=</span> <span class="n">get_inbound_net_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net_device</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">ndev</span> <span class="o">=</span> <span class="n">net_device</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">vmbus_recvpacket_raw</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">bufferlen</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">bytes_recvd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">request_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bytes_recvd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">desc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vmpacket_descriptor</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">;</span>
				<span class="k">switch</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">case</span> <span class="n">VM_PKT_COMP</span>:
					<span class="n">netvsc_send_completion</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>

				<span class="k">case</span> <span class="n">VM_PKT_DATA_USING_XFER_PAGES</span>:
					<span class="n">netvsc_receive</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>

				<span class="nl">default:</span>
					<span class="n">netdev_err</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span>
						   <span class="s">&quot;unhandled packet type %d, &quot;</span>
						   <span class="s">&quot;tid %llx len %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						   <span class="n">desc</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">request_id</span><span class="p">,</span>
						   <span class="n">bytes_recvd</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/* reset */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bufferlen</span> <span class="o">&gt;</span> <span class="n">NETVSC_PACKET_SIZE</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
					<span class="n">buffer</span> <span class="o">=</span> <span class="n">packet</span><span class="p">;</span>
					<span class="n">bufferlen</span> <span class="o">=</span> <span class="n">NETVSC_PACKET_SIZE</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* reset */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bufferlen</span> <span class="o">&gt;</span> <span class="n">NETVSC_PACKET_SIZE</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
					<span class="n">buffer</span> <span class="o">=</span> <span class="n">packet</span><span class="p">;</span>
					<span class="n">bufferlen</span> <span class="o">=</span> <span class="n">NETVSC_PACKET_SIZE</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Handle large packet */</span>
			<span class="n">buffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">bytes_recvd</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Try again next time around */</span>
				<span class="n">netdev_err</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span>
					   <span class="s">&quot;unable to allocate buffer of size &quot;</span>
					   <span class="s">&quot;(%d)!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bytes_recvd</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">bufferlen</span> <span class="o">=</span> <span class="n">bytes_recvd</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * netvsc_device_add - Callback when the device belonging to this</span>
<span class="cm"> * driver is added</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netvsc_device_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">additional_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ring_size</span> <span class="o">=</span>
	<span class="p">((</span><span class="k">struct</span> <span class="n">netvsc_device_info</span> <span class="o">*</span><span class="p">)</span><span class="n">additional_info</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ring_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netvsc_device</span> <span class="o">*</span><span class="n">net_device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hv_netvsc_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">;</span>

	<span class="n">net_device</span> <span class="o">=</span> <span class="n">alloc_net_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net_device</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Coming into this function, struct net_device * is</span>
<span class="cm">	 * registered as the driver private data.</span>
<span class="cm">	 * In alloc_net_device(), we register struct netvsc_device *</span>
<span class="cm">	 * as the driver private data and stash away struct net_device *</span>
<span class="cm">	 * in struct netvsc_device *.</span>
<span class="cm">	 */</span>
	<span class="n">ndev</span> <span class="o">=</span> <span class="n">net_device</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">;</span>

	<span class="cm">/* Initialize the NetVSC channel extension */</span>
	<span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_buf_size</span> <span class="o">=</span> <span class="n">NETVSC_RECEIVE_BUFFER_SIZE</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_pkt_list_lock</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_pkt_list</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NETVSC_RECEIVE_PACKETLIST_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">packet</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_netvsc_packet</span><span class="p">)</span> <span class="o">+</span>
				 <span class="p">(</span><span class="n">NETVSC_RECEIVE_SG_COUNT</span> <span class="o">*</span>
				  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_page_buffer</span><span class="p">)),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">packet</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">list_ent</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_pkt_list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">channel_init_wait</span><span class="p">);</span>

	<span class="cm">/* Open the channel */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">vmbus_open</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">ring_size</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
			 <span class="n">ring_size</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			 <span class="n">netvsc_channel_cb</span><span class="p">,</span> <span class="n">device</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="s">&quot;unable to open channel: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Channel is opened */</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;hv_netvsc channel opened successfully</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Connect with the NetVsp */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">netvsc_connect_vsp</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span>
			<span class="s">&quot;unable to connect to NetVSP - %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">close</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">close:</span>
	<span class="cm">/* Now, we can close the channel safely */</span>
	<span class="n">vmbus_close</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>

<span class="nl">cleanup:</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">net_device</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">packet</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">net_device</span><span class="o">-&gt;</span><span class="n">recv_pkt_list</span><span class="p">,</span>
					 <span class="n">list_ent</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">list_ent</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">net_device</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
