<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › usb › usbnet.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>usbnet.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * USB Network driver infrastructure</span>
<span class="cm"> * Copyright (C) 2000-2005 by David Brownell</span>
<span class="cm"> * Copyright (C) 2003-2005 David Hollis &lt;dhollis@davehollis.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This is a generic &quot;USB networking&quot; framework that works with several</span>
<span class="cm"> * kinds of full and high speed networking devices:  host-to-host cables,</span>
<span class="cm"> * smart usb peripherals, and actual Ethernet adapters.</span>
<span class="cm"> *</span>
<span class="cm"> * These devices usually differ in terms of control protocols (if they</span>
<span class="cm"> * even have one!) and sometimes they define new framing to wrap or batch</span>
<span class="cm"> * Ethernet packets.  Otherwise, they talk to USB pretty much the same,</span>
<span class="cm"> * so interface (un)binding, endpoint I/O queues, fault handling, and other</span>
<span class="cm"> * issues can usefully be addressed by this framework.</span>
<span class="cm"> */</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><h1>define    DEBUG           // error path messages, extra info</h1>

<h1>define    VERBOSE         // more; success messages</h1></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/mii.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/usb/usbnet.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/pm_runtime.h&gt;</span>

<span class="cp">#define DRIVER_VERSION		&quot;22-Aug-2005&quot;</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * Nineteen USB 1.1 max size bulk transactions per frame (ms), max.</span>
<span class="cm"> * Several dozen bytes of IPv4 data can fit in two such transactions.</span>
<span class="cm"> * One maximum size Ethernet packet takes twenty four of them.</span>
<span class="cm"> * For high speed, each frame comfortably fits almost 36 max size</span>
<span class="cm"> * Ethernet packets (so queues should be bigger).</span>
<span class="cm"> *</span>
<span class="cm"> * REVISIT qlens should be members of &#39;struct usbnet&#39;; the goal is to</span>
<span class="cm"> * let the USB host controller be busy for 5msec or more before an irq</span>
<span class="cm"> * is required, under load.  Jumbograms change the equation.</span>
<span class="cm"> */</span>
<span class="cp">#define RX_MAX_QUEUE_MEMORY (60 * 1518)</span>
<span class="cp">#define	RX_QLEN(dev) (((dev)-&gt;udev-&gt;speed == USB_SPEED_HIGH) ? \</span>
<span class="cp">			(RX_MAX_QUEUE_MEMORY/(dev)-&gt;rx_urb_size) : 4)</span>
<span class="cp">#define	TX_QLEN(dev) (((dev)-&gt;udev-&gt;speed == USB_SPEED_HIGH) ? \</span>
<span class="cp">			(RX_MAX_QUEUE_MEMORY/(dev)-&gt;hard_mtu) : 4)</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>reawaken network queue this soon after stopping; else watchdog barks</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define TX_TIMEOUT_JIFFIES	(5*HZ)</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>throttle rx/tx briefly after some faults, so khubd might disconnect()
us (it polls at HZ/4 usually) before we report too many false errors.</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define THROTTLE_JIFFIES	(HZ/8)</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>between wakeups</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define UNLINK_TIMEOUT_MS	3</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>randomly generated ethernet address</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">u8</span>	<span class="n">node_id</span> <span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">driver_name</span> <span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;usbnet&quot;</span><span class="p">;</span>

<span class="cm">/* use ethtool to change the level for any given device */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">msg_level</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span> <span class="p">(</span><span class="n">msg_level</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span> <span class="p">(</span><span class="n">msg_level</span><span class="p">,</span> <span class="s">&quot;Override default message level&quot;</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* handles CDC Ethernet and many other network &quot;bulk data&quot; interfaces */</span>
<span class="kt">int</span> <span class="nf">usbnet_get_endpoints</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>				<span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_interface</span>	<span class="o">*</span><span class="n">alt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span>	<span class="o">*</span><span class="n">in</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span>	<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">num_altsetting</span><span class="p">;</span> <span class="n">tmp</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span>	<span class="n">ep</span><span class="p">;</span>

		<span class="n">in</span> <span class="o">=</span> <span class="n">out</span> <span class="o">=</span> <span class="n">status</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">alt</span> <span class="o">=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">altsetting</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">;</span>

		<span class="cm">/* take the first altsetting with in-bulk + out-bulk;</span>
<span class="cm">		 * remember any status endpoint, just in case;</span>
<span class="cm">		 * ignore other endpoints and altsettings.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">ep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ep</span> <span class="o">&lt;</span> <span class="n">alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumEndpoints</span><span class="p">;</span> <span class="n">ep</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">usb_host_endpoint</span>	<span class="o">*</span><span class="n">e</span><span class="p">;</span>
			<span class="kt">int</span>				<span class="n">intr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">e</span> <span class="o">=</span> <span class="n">alt</span><span class="o">-&gt;</span><span class="n">endpoint</span> <span class="o">+</span> <span class="n">ep</span><span class="p">;</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bmAttributes</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_INT</span>:
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usb_endpoint_dir_in</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">))</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="n">intr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="cm">/* FALLTHROUGH */</span>
			<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_BULK</span>:
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_dir_in</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">in</span><span class="p">)</span>
					<span class="n">in</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
				<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">intr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">status</span><span class="p">)</span>
					<span class="n">status</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">out</span><span class="p">)</span>
					<span class="n">out</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in</span> <span class="o">&amp;&amp;</span> <span class="n">out</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alt</span> <span class="o">||</span> <span class="o">!</span><span class="n">in</span> <span class="o">||</span> <span class="o">!</span><span class="n">out</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bAlternateSetting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_NO_SETINT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">usb_set_interface</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">,</span>
				<span class="n">alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bAlternateSetting</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">in</span> <span class="o">=</span> <span class="n">usb_rcvbulkpipe</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span>
			<span class="n">in</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_NUMBER_MASK</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">out</span> <span class="o">=</span> <span class="n">usb_sndbulkpipe</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span>
			<span class="n">out</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_NUMBER_MASK</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usbnet_get_endpoints</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">usbnet_get_ethernet_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iMACAddress</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> 		<span class="n">tmp</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">buf</span> <span class="p">[</span><span class="mi">13</span><span class="p">];</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">usb_string</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">iMACAddress</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="mi">12</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;bad MAC string %d fetch, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">iMACAddress</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dev_addr</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">hex_to_bin</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">tmp</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">hex_to_bin</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">tmp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usbnet_get_ethernet_addr</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">intr_complete</span> <span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_status</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">pipe</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">maxp</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">period</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pipe</span> <span class="o">=</span> <span class="n">usb_rcvintpipe</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">status</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span>
				<span class="o">&amp;</span> <span class="n">USB_ENDPOINT_NUMBER_MASK</span><span class="p">);</span>
	<span class="n">maxp</span> <span class="o">=</span> <span class="n">usb_maxpacket</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* avoid 1 msec chatter:  min 8 msec poll rate */</span>
	<span class="n">period</span> <span class="o">=</span> <span class="n">max</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">status</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterval</span><span class="p">,</span>
		<span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span> <span class="o">?</span> <span class="mi">7</span> <span class="o">:</span> <span class="mi">3</span><span class="p">);</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span> <span class="p">(</span><span class="n">maxp</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">interrupt</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">interrupt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span> <span class="p">(</span><span class="n">buf</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">usb_fill_int_urb</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">interrupt</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span>
				<span class="n">buf</span><span class="p">,</span> <span class="n">maxp</span><span class="p">,</span> <span class="n">intr_complete</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">interrupt</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">|=</span> <span class="n">URB_FREE_BUFFER</span><span class="p">;</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;status ep%din, %d bytes period %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">pipe</span><span class="p">),</span> <span class="n">maxp</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Passes this packet up the stack, updating its accounting.</span>
<span class="cm"> * Some link protocols batch packets, so their rx_fixup paths</span>
<span class="cm"> * can return clones as well as just modify the original skb.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usbnet_skb_return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">EVENT_RX_PAUSED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rxq_pause</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span> <span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rx_status</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;&lt; rx, len %zu, type 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ethhdr</span><span class="p">),</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">);</span>
	<span class="n">memset</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">skb_data</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_defer_rx_timestamp</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">netif_rx</span> <span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NET_RX_SUCCESS</span><span class="p">)</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rx_err</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span>
			  <span class="s">&quot;netif_rx status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usbnet_skb_return</span><span class="p">);</span>


<span class="cm">/*-------------------------------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> * Network Device Driver (peer link to &quot;Host Device&quot;, from USB host)</span>
<span class="cm"> *</span>
<span class="cm"> *-------------------------------------------------------------------------*/</span>

<span class="kt">int</span> <span class="nf">usbnet_change_mtu</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbnet</span>	<span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="n">ll_mtu</span> <span class="o">=</span> <span class="n">new_mtu</span> <span class="o">+</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">hard_header_len</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">old_hard_mtu</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">hard_mtu</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">old_rx_urb_size</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_urb_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_mtu</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>no second zero-length packet read wanted after mtu-sized packets</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">((</span><span class="n">ll_mtu</span> <span class="o">%</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">maxpacket</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EDOM</span><span class="p">;</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">new_mtu</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hard_mtu</span> <span class="o">=</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">+</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">hard_header_len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_urb_size</span> <span class="o">==</span> <span class="n">old_hard_mtu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_urb_size</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">hard_mtu</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_urb_size</span> <span class="o">&gt;</span> <span class="n">old_rx_urb_size</span><span class="p">)</span>
			<span class="n">usbnet_unlink_rx_urbs</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usbnet_change_mtu</span><span class="p">);</span>

<span class="cm">/* The caller must hold list-&gt;lock */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__usbnet_queue_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">newsk</span><span class="p">,</span> <span class="k">enum</span> <span class="n">skb_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">skb_data</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">skb_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">newsk</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">;</span>

	<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">newsk</span><span class="p">);</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* some LK 2.4 HCDs oopsed if we freed or resubmitted urbs from</span>
<span class="cm"> * completion callbacks.  2.5 should have fixed those bugs...</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">skb_state</span> <span class="nf">defer_bh</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="k">enum</span> <span class="n">skb_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">skb_state</span> 		<span class="n">old_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">skb_data</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">skb_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">old_state</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">.</span><span class="n">qlen</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">old_state</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* some work can&#39;t be done in tasklets, so we use keventd</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  annoying asymmetry:  if it&#39;s active, schedule_work() fails,</span>
<span class="cm"> * but tasklet_schedule() doesn&#39;t.  hope the failure is rare.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usbnet_defer_kevent</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span> <span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">schedule_work</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kevent</span><span class="p">))</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;kevent %d may have been dropped</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">netdev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;kevent %d scheduled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usbnet_defer_kevent</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">rx_complete</span> <span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rx_submit</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>		<span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">skb_data</span>		<span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">lockflags</span><span class="p">;</span>
	<span class="kt">size_t</span>			<span class="n">size</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_urb_size</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">__netdev_alloc_skb_ip_align</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rx_err</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;no rx skb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">usbnet_defer_kevent</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">EVENT_RX_MEMORY</span><span class="p">);</span>
		<span class="n">usb_free_urb</span> <span class="p">(</span><span class="n">urb</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">skb_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">usb_fill_bulk_urb</span> <span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">,</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">rx_complete</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">lockflags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">netif_device_present</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">test_bit</span> <span class="p">(</span><span class="n">EVENT_RX_HALT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">test_bit</span> <span class="p">(</span><span class="n">EVENT_DEV_ASLEEP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">retval</span> <span class="o">=</span> <span class="n">usb_submit_urb</span> <span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">EPIPE</span>:
			<span class="n">usbnet_defer_kevent</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">EVENT_RX_HALT</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">ENOMEM</span>:
			<span class="n">usbnet_defer_kevent</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">EVENT_RX_MEMORY</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">ENODEV</span>:
			<span class="n">netif_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ifdown</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;device gone</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">netif_device_detach</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">EHOSTUNREACH</span>:
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOLINK</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">netif_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rx_err</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span>
				  <span class="s">&quot;rx submit, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
			<span class="n">tasklet_schedule</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="n">__usbnet_queue_skb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rxq</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">rx_start</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ifdown</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;rx: stopped</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOLINK</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">lockflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb_any</span> <span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">usb_free_urb</span> <span class="p">(</span><span class="n">urb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rx_process</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">rx_fixup</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">rx_fixup</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* With RX_ASSEMBLE, rx_fixup() must update counters */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_RX_ASSEMBLE</span><span class="p">))</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>else network stack removes extra byte if we forced a short packet</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* all data was already cloned from skb inside the driver */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_MULTI_PACKET</span><span class="p">)</span>
			<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">usbnet_skb_return</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rx_err</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;drop</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
<span class="nl">done:</span>
	<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rx_complete</span> <span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>		<span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">skb_data</span>		<span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">skb_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbnet</span>		<span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">urb_status</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">skb_state</span>		<span class="n">state</span><span class="p">;</span>

	<span class="n">skb_put</span> <span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>
	<span class="n">state</span> <span class="o">=</span> <span class="n">rx_done</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">urb_status</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/* success */</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">hard_header_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">state</span> <span class="o">=</span> <span class="n">rx_cleanup</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_length_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="n">netif_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rx_err</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span>
				  <span class="s">&quot;rx length %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* stalls need manual reset. this is rare ... except that</span>
<span class="cm">	 * when going through USB 2.0 TTs, unplug appears this way.</span>
<span class="cm">	 * we avoid the highspeed version of the ETIMEDOUT/EILSEQ</span>
<span class="cm">	 * storm, recovering as needed.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EPIPE</span>:
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">usbnet_defer_kevent</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">EVENT_RX_HALT</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>FALLTHROUGH</p></td><td class="code"><div class="highlight"><pre>	<span class="cm">/* software-driven interface shutdown */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ECONNRESET</span>:		<span class="cm">/* async unlink */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ESHUTDOWN</span>:		<span class="cm">/* hardware gone */</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ifdown</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span>
			  <span class="s">&quot;rx shutdown, code %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb_status</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">block</span><span class="p">;</span>

	<span class="cm">/* we get controller i/o faults during khubd disconnect() delays.</span>
<span class="cm">	 * throttle down resubmits, to avoid log floods; just temporarily,</span>
<span class="cm">	 * so we still recover when the fault isn&#39;t a khubd delay.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EPROTO</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ETIME</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">EILSEQ</span>:
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timer_pending</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">delay</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mod_timer</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">delay</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">THROTTLE_JIFFIES</span><span class="p">);</span>
			<span class="n">netif_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span>
				  <span class="s">&quot;rx throttle %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb_status</span><span class="p">);</span>
		<span class="p">}</span>
<span class="nl">block:</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">rx_cleanup</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>
		<span class="n">urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* data overrun ... flush fifo? */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EOVERFLOW</span>:
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_over_errors</span><span class="o">++</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><p>FALLTHROUGH</p></td><td class="code"><div class="highlight"><pre>	<span class="nl">default:</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">rx_cleanup</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rx_err</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;rx status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb_status</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">defer_bh</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rxq</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">test_bit</span> <span class="p">(</span><span class="n">EVENT_RX_HALT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">state</span> <span class="o">!=</span> <span class="n">unlink_start</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rx_submit</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="n">usb_mark_last_busy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">usb_free_urb</span> <span class="p">(</span><span class="n">urb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rx_err</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;no read resubmitted</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">intr_complete</span> <span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbnet</span>	<span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">status</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/* success */</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* software-driven interface shutdown */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ENOENT</span>:		<span class="cm">/* urb killed */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ESHUTDOWN</span>:	<span class="cm">/* hardware gone */</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ifdown</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span>
			  <span class="s">&quot;intr shutdown, code %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* NOTE:  not throttling like RX/TX, since this endpoint</span>
<span class="cm">	 * already polls infrequently</span>
<span class="cm">	 */</span>
	<span class="nl">default:</span>
		<span class="n">netdev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;intr status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">usb_submit_urb</span> <span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">timer</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span>
			  <span class="s">&quot;intr resubmit --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>
<span class="kt">void</span> <span class="nf">usbnet_pause_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">EVENT_RX_PAUSED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rx_status</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;paused rx queue enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usbnet_pause_rx</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">usbnet_resume_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">EVENT_RX_PAUSED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rxq_pause</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usbnet_skb_return</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">num</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rx_status</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span>
		  <span class="s">&quot;paused rx queue disabled, %d skbs requeued</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usbnet_resume_rx</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">usbnet_purge_paused_rxq</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rxq_pause</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usbnet_purge_paused_rxq</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div><p>unlink pending rx/tx; completion handlers do all other cleanup</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">unlink_urbs</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>		<span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">skb_data</span>		<span class="o">*</span><span class="n">entry</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">;</span>
		<span class="kt">int</span>			<span class="n">retval</span><span class="p">;</span>

		<span class="n">skb_queue_walk</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">skb_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">unlink_start</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
<span class="nl">found:</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">unlink_start</span><span class="p">;</span>
		<span class="n">urb</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Get reference count of the URB to avoid it to be</span>
<span class="cm">		 * freed during usb_unlink_urb, which may trigger</span>
<span class="cm">		 * use-after-free problem inside usb_unlink_urb since</span>
<span class="cm">		 * usb_unlink_urb is always racing with .complete</span>
<span class="cm">		 * handler(include defer_bh).</span>
<span class="cm">		 */</span>
		<span class="n">usb_get_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-12"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-12">&#182;</a></div><p>during some PM-driven resume scenarios,
these (async) unlinks complete immediately</p></td><td class="code"><div class="highlight"><pre>		<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_unlink_urb</span> <span class="p">(</span><span class="n">urb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span> <span class="o">&amp;&amp;</span> <span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">netdev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;unlink urb err, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">usb_put_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-13"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-13">&#182;</a></div><p>Flush all pending rx urbs
minidrivers may need to do this when the MTU changes</p></td><td class="code"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">usbnet_unlink_rx_urbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">))</span> <span class="p">{</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">unlink_urbs</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rxq</span><span class="p">);</span>
		<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usbnet_unlink_rx_urbs</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span></pre></div></td></tr>


<tr id="section-14"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-14">&#182;</a></div><p>precondition: never called in_interrupt</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">usbnet_terminate_urbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DECLARE_WAIT_QUEUE_HEAD_ONSTACK</span><span class="p">(</span><span class="n">unlink_wakeup</span><span class="p">);</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">temp</span><span class="p">;</span>

	<span class="cm">/* ensure there are no more active urbs */</span>
	<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unlink_wakeup</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">wait</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">unlink_wakeup</span><span class="p">;</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">unlink_urbs</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">unlink_urbs</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rxq</span><span class="p">);</span>

	<span class="cm">/* maybe wait for deletions to finish. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rxq</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">schedule_timeout</span><span class="p">(</span><span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">UNLINK_TIMEOUT_MS</span><span class="p">));</span>
			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
			<span class="n">netif_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ifdown</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span>
				  <span class="s">&quot;waited for %d urb completions</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">wait</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unlink_wakeup</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">usbnet_stop</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbnet</span>		<span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">driver_info</span>	<span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">retval</span><span class="p">;</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">EVENT_DEV_OPEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">netif_stop_queue</span> <span class="p">(</span><span class="n">net</span><span class="p">);</span>

	<span class="n">netif_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ifdown</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span>
		   <span class="s">&quot;stop stats: rx/tx %lu/%lu, errs %lu/%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="p">,</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="p">,</span>
		   <span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="p">,</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="p">);</span>

	<span class="cm">/* allow minidriver to stop correctly (wireless devices to turn off</span>
<span class="cm">	 * radio etc) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">netif_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ifdown</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span>
				   <span class="s">&quot;stop fail (%d) usbnet usb-%s-%s, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">retval</span><span class="p">,</span>
				   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bus_name</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span>
				   <span class="n">info</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_AVOID_UNLINK_URBS</span><span class="p">))</span>
		<span class="n">usbnet_terminate_urbs</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">interrupt</span><span class="p">);</span>

	<span class="n">usbnet_purge_paused_rxq</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* deferred work (task, timer, softirq) must also stop.</span>
<span class="cm">	 * can&#39;t flush_scheduled_work() until we drop rtnl (later),</span>
<span class="cm">	 * else workers could deadlock; so make workers a NOP.</span>
<span class="cm">	 */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">del_timer_sync</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">delay</span><span class="p">);</span>
	<span class="n">tasklet_kill</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">manage_power</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">manage_power</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">usb_autopm_put_interface</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usbnet_stop</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span></pre></div></td></tr>


<tr id="section-15"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-15">&#182;</a></div><p>posts reads, and enables write queuing</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-16"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-16">&#182;</a></div><p>precondition: never called in_interrupt</p></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">usbnet_open</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbnet</span>		<span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">driver_info</span>	<span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">usb_autopm_get_interface</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ifup</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span>
			   <span class="s">&quot;resumption fail (%d) usbnet usb-%s-%s, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">retval</span><span class="p">,</span>
			   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bus_name</span><span class="p">,</span>
			   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span>
			   <span class="n">info</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done_nopm</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-17"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-17">&#182;</a></div><p>put into "known safe" state</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">reset</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">retval</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">reset</span> <span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ifup</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span>
			   <span class="s">&quot;open reset fail (%d) usbnet usb-%s-%s, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">retval</span><span class="p">,</span>
			   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bus_name</span><span class="p">,</span>
			   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span>
			   <span class="n">info</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-18"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-18">&#182;</a></div><p>insist peer be connected</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">check_connect</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">retval</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">check_connect</span> <span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ifup</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;can&#39;t open; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* start any status interrupt transfer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">interrupt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_submit_urb</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">interrupt</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ifup</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span>
				  <span class="s">&quot;intr submit %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">EVENT_DEV_OPEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">netif_start_queue</span> <span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="n">netif_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ifup</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span>
		   <span class="s">&quot;open: enable queueing (rx %d, tx %d) mtu %d %s framing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">RX_QLEN</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">TX_QLEN</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span>
		   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">,</span>
		   <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_FRAMING_NC</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;NetChip&quot;</span> <span class="o">:</span>
		   <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_FRAMING_GL</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;GeneSys&quot;</span> <span class="o">:</span>
		   <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_FRAMING_Z</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Zaurus&quot;</span> <span class="o">:</span>
		   <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_FRAMING_RN</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;RNDIS&quot;</span> <span class="o">:</span>
		   <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_FRAMING_AX</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;ASIX&quot;</span> <span class="o">:</span>
		   <span class="s">&quot;simple&quot;</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-19"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-19">&#182;</a></div><p>delay posting reads until we're fully open</p></td><td class="code"><div class="highlight"><pre>	<span class="n">tasklet_schedule</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">manage_power</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">manage_power</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done_manage_power_error</span><span class="p">;</span>
		<span class="n">usb_autopm_put_interface</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

<span class="nl">done_manage_power_error:</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">EVENT_DEV_OPEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="nl">done:</span>
	<span class="n">usb_autopm_put_interface</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>
<span class="nl">done_nopm:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usbnet_open</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* ethtool methods; minidrivers may need to add some more, but</span>
<span class="cm"> * they&#39;ll probably want to use this base set.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">usbnet_get_settings</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">.</span><span class="n">mdio_read</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">mii_ethtool_gset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usbnet_get_settings</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">usbnet_set_settings</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">.</span><span class="n">mdio_write</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">mii_ethtool_sset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="cm">/* link speed/duplex might have changed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">link_reset</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">link_reset</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usbnet_set_settings</span><span class="p">);</span>

<span class="n">u32</span> <span class="nf">usbnet_get_link</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

	<span class="cm">/* If a check_connect is defined, return its result */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">check_connect</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">check_connect</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* if the device has mii operations, use those */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">.</span><span class="n">mdio_read</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">mii_link_ok</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">);</span>

	<span class="cm">/* Otherwise, dtrt for drivers calling netif_carrier_{on,off} */</span>
	<span class="k">return</span> <span class="n">ethtool_op_get_link</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usbnet_get_link</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">usbnet_nway_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">.</span><span class="n">mdio_write</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">mii_nway_restart</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usbnet_nway_reset</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">usbnet_get_drvinfo</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_drvinfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

	<span class="n">strlcpy</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_name</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="n">strlcpy</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">DRIVER_VERSION</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">);</span>
	<span class="n">strlcpy</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">,</span>
		<span class="k">sizeof</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">);</span>
	<span class="n">usb_make_path</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usbnet_get_drvinfo</span><span class="p">);</span>

<span class="n">u32</span> <span class="nf">usbnet_get_msglevel</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">msg_enable</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usbnet_get_msglevel</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">usbnet_set_msglevel</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">u32</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usbnet_set_msglevel</span><span class="p">);</span>

<span class="cm">/* drivers may override default ethtool_ops in their bind() routine */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ethtool_ops</span> <span class="n">usbnet_ethtool_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_settings</span>		<span class="o">=</span> <span class="n">usbnet_get_settings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_settings</span>		<span class="o">=</span> <span class="n">usbnet_set_settings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_link</span>		<span class="o">=</span> <span class="n">usbnet_get_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nway_reset</span>		<span class="o">=</span> <span class="n">usbnet_nway_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_drvinfo</span>		<span class="o">=</span> <span class="n">usbnet_get_drvinfo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_msglevel</span>		<span class="o">=</span> <span class="n">usbnet_get_msglevel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_msglevel</span>		<span class="o">=</span> <span class="n">usbnet_set_msglevel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_ts_info</span>		<span class="o">=</span> <span class="n">ethtool_op_get_ts_info</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* work that cannot be done in interrupt context uses keventd.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  with 2.5 we could do more of this using completion callbacks,</span>
<span class="cm"> * especially now that control transfers can be queued.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">kevent</span> <span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbnet</span>		<span class="o">*</span><span class="n">dev</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usbnet</span><span class="p">,</span> <span class="n">kevent</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>

	<span class="cm">/* usb_clear_halt() needs a thread context */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span> <span class="p">(</span><span class="n">EVENT_TX_HALT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">unlink_urbs</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">usb_autopm_get_interface</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail_pipe</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">usb_clear_halt</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">out</span><span class="p">);</span>
		<span class="n">usb_autopm_put_interface</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EPIPE</span> <span class="o">&amp;&amp;</span>
		    <span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_tx_err</span> <span class="p">(</span><span class="n">dev</span><span class="p">))</span>
<span class="nl">fail_pipe:</span>
				<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;can&#39;t clear tx halt, status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">status</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">clear_bit</span> <span class="p">(</span><span class="n">EVENT_TX_HALT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">)</span>
				<span class="n">netif_wake_queue</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span> <span class="p">(</span><span class="n">EVENT_RX_HALT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">unlink_urbs</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rxq</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">usb_autopm_get_interface</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail_halt</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">usb_clear_halt</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">);</span>
		<span class="n">usb_autopm_put_interface</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EPIPE</span> <span class="o">&amp;&amp;</span>
		    <span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_rx_err</span> <span class="p">(</span><span class="n">dev</span><span class="p">))</span>
<span class="nl">fail_halt:</span>
				<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;can&#39;t clear rx halt, status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">status</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">clear_bit</span> <span class="p">(</span><span class="n">EVENT_RX_HALT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">tasklet_schedule</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* tasklet could resubmit itself forever if memory is tight */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span> <span class="p">(</span><span class="n">EVENT_RX_MEMORY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">urb</span>	<span class="o">*</span><span class="n">urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">resched</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">))</span>
			<span class="n">urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">clear_bit</span> <span class="p">(</span><span class="n">EVENT_RX_MEMORY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clear_bit</span> <span class="p">(</span><span class="n">EVENT_RX_MEMORY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">usb_autopm_get_interface</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">fail_lowmem</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rx_submit</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOLINK</span><span class="p">)</span>
				<span class="n">resched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">usb_autopm_put_interface</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>
<span class="nl">fail_lowmem:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">resched</span><span class="p">)</span>
				<span class="n">tasklet_schedule</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span> <span class="p">(</span><span class="n">EVENT_LINK_RESET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">driver_info</span>	<span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="p">;</span>
		<span class="kt">int</span>			<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">clear_bit</span> <span class="p">(</span><span class="n">EVENT_LINK_RESET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">usb_autopm_get_interface</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">skip_reset</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">link_reset</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">retval</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">link_reset</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">usb_autopm_put_interface</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>
<span class="nl">skip_reset:</span>
			<span class="n">netdev_info</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;link reset failed (%d) usbnet usb-%s-%s, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">retval</span><span class="p">,</span>
				    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bus_name</span><span class="p">,</span>
				    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span>
				    <span class="n">info</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">usb_autopm_put_interface</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span>
		<span class="n">netdev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;kevent done, flags = 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tx_complete</span> <span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>		<span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">skb_data</span>		<span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">skb_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbnet</span>		<span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_MULTI_PACKET</span><span class="p">))</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">EPIPE</span>:
			<span class="n">usbnet_defer_kevent</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">EVENT_TX_HALT</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* software-driven interface shutdown */</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">ECONNRESET</span>:		<span class="c1">// async unlink</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">ESHUTDOWN</span>:		<span class="c1">// hardware gone</span>
			<span class="k">break</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-20"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-20">&#182;</a></div><p>like rx, tx gets controller i/o faults during khubd delays
and so it uses the same throttling mechanism.</p></td><td class="code"><div class="highlight"><pre>		<span class="k">case</span> <span class="o">-</span><span class="n">EPROTO</span>:
		<span class="k">case</span> <span class="o">-</span><span class="n">ETIME</span>:
		<span class="k">case</span> <span class="o">-</span><span class="n">EILSEQ</span>:
			<span class="n">usb_mark_last_busy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timer_pending</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">delay</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">mod_timer</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">delay</span><span class="p">,</span>
					<span class="n">jiffies</span> <span class="o">+</span> <span class="n">THROTTLE_JIFFIES</span><span class="p">);</span>
				<span class="n">netif_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span>
					  <span class="s">&quot;tx throttle %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">netif_stop_queue</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">netif_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">tx_err</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span>
				  <span class="s">&quot;tx err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">usb_autopm_put_interface_async</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">defer_bh</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">,</span> <span class="n">tx_done</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="kt">void</span> <span class="nf">usbnet_tx_timeout</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbnet</span>		<span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

	<span class="n">unlink_urbs</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">);</span>
	<span class="n">tasklet_schedule</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-21"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-21">&#182;</a></div><p>FIXME: device recovery -- reset?</p></td><td class="code"><div class="highlight"><pre><span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usbnet_tx_timeout</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="n">netdev_tx_t</span> <span class="nf">usbnet_start_xmit</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbnet</span>		<span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">length</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">skb_data</span>		<span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">driver_info</span>	<span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
		<span class="n">skb_tx_timestamp</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-22"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-22">&#182;</a></div><p>some devices want funky USB-level framing, for
win32 driver (usually) and/or hardware quirks</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_fixup</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_fixup</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_tx_err</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">netif_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">tx_err</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;can&#39;t tx_fixup skb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* cdc_ncm collected packet; waits for more */</span>
				<span class="k">goto</span> <span class="n">not_drop</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">tx_err</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;no urb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">skb_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>

	<span class="n">usb_fill_bulk_urb</span> <span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">out</span><span class="p">,</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">tx_complete</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* don&#39;t assume the hardware handles USB_ZERO_PACKET</span>
<span class="cm">	 * NOTE:  strictly conforming cdc-ether devices should expect</span>
<span class="cm">	 * the ZLP here, but ignore the one-byte packet.</span>
<span class="cm">	 * NOTE2: CDC NCM specification is different from CDC ECM when</span>
<span class="cm">	 * handling ZLP/short packets, so cdc_ncm driver will make short</span>
<span class="cm">	 * packet itself if needed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">%</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">maxpacket</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_SEND_ZLP</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_MULTI_PACKET</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="o">++</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">skb_tailroom</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">__skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">|=</span> <span class="n">URB_ZERO_PACKET</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_autopm_get_interface_async</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
	<span class="cm">/* if this triggers the device is still a sleep */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">EVENT_DEV_ASLEEP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* transmission will be done in resume */</span>
		<span class="n">usb_anchor_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">deferred</span><span class="p">);</span>
		<span class="cm">/* no use to process more packets */</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">netdev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;Delaying transmission for resumption</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">deferred</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">switch</span> <span class="p">((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">usb_submit_urb</span> <span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">)))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EPIPE</span>:
		<span class="n">netif_stop_queue</span> <span class="p">(</span><span class="n">net</span><span class="p">);</span>
		<span class="n">usbnet_defer_kevent</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">EVENT_TX_HALT</span><span class="p">);</span>
		<span class="n">usb_autopm_put_interface_async</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">usb_autopm_put_interface_async</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">tx_err</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span>
			  <span class="s">&quot;tx: submit urb err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">net</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">__usbnet_queue_skb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">tx_start</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">.</span><span class="n">qlen</span> <span class="o">&gt;=</span> <span class="n">TX_QLEN</span> <span class="p">(</span><span class="n">dev</span><span class="p">))</span>
			<span class="n">netif_stop_queue</span> <span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">tx_err</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;drop, code %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
<span class="nl">drop:</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_dropped</span><span class="o">++</span><span class="p">;</span>
<span class="nl">not_drop:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
			<span class="n">dev_kfree_skb_any</span> <span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">usb_free_urb</span> <span class="p">(</span><span class="n">urb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">tx_queued</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span>
			  <span class="s">&quot;&gt; tx, len %d, type 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PM</span>
<span class="nl">deferred:</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usbnet_start_xmit</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rx_alloc_submit</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span>	<span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>

	<span class="cm">/* don&#39;t refill the queue all at once */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rxq</span><span class="p">.</span><span class="n">qlen</span> <span class="o">&lt;</span> <span class="n">RX_QLEN</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rx_submit</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOLINK</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span></pre></div></td></tr>


<tr id="section-23"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-23">&#182;</a></div><p>tasklet (work deferred from completions, in_irq) or timer</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">usbnet_bh</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbnet</span>		<span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="p">)</span> <span class="n">param</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>		<span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">skb_data</span>		<span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">skb_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">rx_done</span>:
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">rx_cleanup</span><span class="p">;</span>
			<span class="n">rx_process</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">tx_done</span>:
		<span class="k">case</span> <span class="n">rx_cleanup</span>:
			<span class="n">usb_free_urb</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">);</span>
			<span class="n">dev_kfree_skb</span> <span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">netdev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;bogus skb state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-24"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-24">&#182;</a></div><p>waiting for all pending urbs to complete?</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">.</span><span class="n">qlen</span> <span class="o">+</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rxq</span><span class="p">.</span><span class="n">qlen</span> <span class="o">+</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">.</span><span class="n">qlen</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wake_up</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-25"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-25">&#182;</a></div><p>or are we maybe short a few urbs?</p></td><td class="code"><div class="highlight"><pre>	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="n">netif_device_present</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="o">!</span><span class="n">timer_pending</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">delay</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="o">!</span><span class="n">test_bit</span> <span class="p">(</span><span class="n">EVENT_RX_HALT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">temp</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rxq</span><span class="p">.</span><span class="n">qlen</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&lt;</span> <span class="n">RX_QLEN</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rx_alloc_submit</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">!=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rxq</span><span class="p">.</span><span class="n">qlen</span><span class="p">)</span>
				<span class="n">netif_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span>
					  <span class="s">&quot;rxqlen %d --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">temp</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rxq</span><span class="p">.</span><span class="n">qlen</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rxq</span><span class="p">.</span><span class="n">qlen</span> <span class="o">&lt;</span> <span class="n">RX_QLEN</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
				<span class="n">tasklet_schedule</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">.</span><span class="n">qlen</span> <span class="o">&lt;</span> <span class="n">TX_QLEN</span> <span class="p">(</span><span class="n">dev</span><span class="p">))</span>
			<span class="n">netif_wake_queue</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> * USB Device Driver support</span>
<span class="cm"> *</span>
<span class="cm"> *-------------------------------------------------------------------------*/</span></pre></div></td></tr>


<tr id="section-26"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-26">&#182;</a></div><p>precondition: never called in_interrupt</p></td><td class="code"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">usbnet_disconnect</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbnet</span>		<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">xdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span>	<span class="o">*</span><span class="n">net</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">xdev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span> <span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="n">netif_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;unregister &#39;%s&#39; usb-%s-%s, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		   <span class="n">xdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bus_name</span><span class="p">,</span> <span class="n">xdev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span>
		   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">);</span>

	<span class="n">net</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">;</span>
	<span class="n">unregister_netdev</span> <span class="p">(</span><span class="n">net</span><span class="p">);</span>

	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kevent</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">unbind</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">unbind</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">intf</span><span class="p">);</span>

	<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">interrupt</span><span class="p">);</span>
	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">interrupt</span><span class="p">);</span>

	<span class="n">free_netdev</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="n">usb_put_dev</span> <span class="p">(</span><span class="n">xdev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usbnet_disconnect</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">usbnet_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>		<span class="o">=</span> <span class="n">usbnet_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">usbnet_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">usbnet_start_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span>		<span class="o">=</span> <span class="n">usbnet_tx_timeout</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>		<span class="o">=</span> <span class="n">usbnet_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span> 	<span class="o">=</span> <span class="n">eth_mac_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_validate_addr</span>	<span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span></pre></div></td></tr>


<tr id="section-27"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-27">&#182;</a></div><p>precondition: never called in_interrupt</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="k">struct</span> <span class="n">device_type</span> <span class="n">wlan_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;wlan&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_type</span> <span class="n">wwan_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;wwan&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span>
<span class="nf">usbnet_probe</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">prod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbnet</span>			<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span>		<span class="o">*</span><span class="n">net</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_interface</span>	<span class="o">*</span><span class="n">interface</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">driver_info</span>		<span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span>		<span class="o">*</span><span class="n">xdev</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">status</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>			<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_driver</span> 	<span class="o">*</span><span class="n">driver</span> <span class="o">=</span> <span class="n">to_usb_driver</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="p">);</span>

	<span class="cm">/* usbnet already took usb runtime pm, so have to enable the feature</span>
<span class="cm">	 * for usb interface, otherwise usb_autopm_get_interface may return</span>
<span class="cm">	 * failure if USB_SUSPEND(RUNTIME_PM) is enabled.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">supports_autosuspend</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">driver</span><span class="o">-&gt;</span><span class="n">supports_autosuspend</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pm_runtime_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">name</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">driver_info</span> <span class="o">*</span><span class="p">)</span> <span class="n">prod</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;blacklisted by %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xdev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span> <span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="n">interface</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="p">;</span>

	<span class="n">usb_get_dev</span> <span class="p">(</span><span class="n">xdev</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-28"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-28">&#182;</a></div><p>set up our own records</p></td><td class="code"><div class="highlight"><pre>	<span class="n">net</span> <span class="o">=</span> <span class="n">alloc_etherdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dev</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* netdev_printk() needs this so do it as early as possible */</span>
	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span> <span class="o">=</span> <span class="n">xdev</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span> <span class="o">=</span> <span class="n">udev</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">netif_msg_init</span> <span class="p">(</span><span class="n">msg_level</span><span class="p">,</span> <span class="n">NETIF_MSG_DRV</span>
				<span class="o">|</span> <span class="n">NETIF_MSG_PROBE</span> <span class="o">|</span> <span class="n">NETIF_MSG_LINK</span><span class="p">);</span>
	<span class="n">skb_queue_head_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rxq</span><span class="p">);</span>
	<span class="n">skb_queue_head_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">);</span>
	<span class="n">skb_queue_head_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>
	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rxq_pause</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">usbnet_bh</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">INIT_WORK</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kevent</span><span class="p">,</span> <span class="n">kevent</span><span class="p">);</span>
	<span class="n">init_usb_anchor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">deferred</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">delay</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">usbnet_bh</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">delay</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">init_timer</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">delay</span><span class="p">);</span>
	<span class="n">mutex_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">phy_mutex</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span> <span class="o">=</span> <span class="n">net</span><span class="p">;</span>
	<span class="n">strcpy</span> <span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;usb%d&quot;</span><span class="p">);</span>
	<span class="n">memcpy</span> <span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">node_id</span><span class="p">);</span>

	<span class="cm">/* rx and tx sides can use different message sizes;</span>
<span class="cm">	 * bind() should set rx_urb_size in that case.</span>
<span class="cm">	 */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hard_mtu</span> <span class="o">=</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">+</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">hard_header_len</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c"></span></pre></div></td></tr>


<tr id="section-29"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-29">&#182;</a></div><p>dma_supported() is deeply broken on almost all architectures
possible with some EHCI controllers</p></td><td class="code"><div class="highlight"><pre><span class="c">	if (dma_supported (&amp;udev-&gt;dev, DMA_BIT_MASK(64)))</span>
<span class="c">		net-&gt;features |= NETIF_F_HIGHDMA;</span>
<span class="cp">#endif</span>

	<span class="n">net</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usbnet_netdev_ops</span><span class="p">;</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="n">TX_TIMEOUT_JIFFIES</span><span class="p">;</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">ethtool_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usbnet_ethtool_ops</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-30"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-30">&#182;</a></div><p>allow device-specific bind/init procedures
NOTE net->name still not usable ...</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bind</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bind</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">udev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out1</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-31"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-31">&#182;</a></div><p>heuristic:  "usb%d" for links we know are two-host,
else "eth%d" when there's reasonable doubt.  userspace
can rename the link if it knows better.</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_ETHER</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_POINTTOPOINT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
		     <span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dev_addr</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">strcpy</span> <span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;eth%d&quot;</span><span class="p">);</span>
		<span class="cm">/* WLAN devices should always be named &quot;wlan%d&quot; */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_WLAN</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">strcpy</span><span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;wlan%d&quot;</span><span class="p">);</span>
		<span class="cm">/* WWAN devices should always be named &quot;wwan%d&quot; */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_WWAN</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">strcpy</span><span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;wwan%d&quot;</span><span class="p">);</span>

		<span class="cm">/* maybe the remote can&#39;t receive an Ethernet MTU */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hard_mtu</span> <span class="o">-</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">hard_header_len</span><span class="p">))</span>
			<span class="n">net</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">hard_mtu</span> <span class="o">-</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">hard_header_len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">in</span> <span class="o">||</span> <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">out</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">usbnet_get_endpoints</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">udev</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">in</span> <span class="o">=</span> <span class="n">usb_rcvbulkpipe</span> <span class="p">(</span><span class="n">xdev</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">out</span> <span class="o">=</span> <span class="n">usb_sndbulkpipe</span> <span class="p">(</span><span class="n">xdev</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">out</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_NO_SETINT</span><span class="p">))</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">usb_set_interface</span> <span class="p">(</span><span class="n">xdev</span><span class="p">,</span>
				<span class="n">interface</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">,</span>
				<span class="n">interface</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bAlternateSetting</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">init_status</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">udev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out3</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_urb_size</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_urb_size</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">hard_mtu</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">maxpacket</span> <span class="o">=</span> <span class="n">usb_maxpacket</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">out</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_WLAN</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">SET_NETDEV_DEVTYPE</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wlan_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_WWAN</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">SET_NETDEV_DEVTYPE</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wwan_type</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">register_netdev</span> <span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out4</span><span class="p">;</span>
	<span class="n">netif_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span>
		   <span class="s">&quot;register &#39;%s&#39; at usb-%s-%s, %s, %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		   <span class="n">xdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bus_name</span><span class="p">,</span> <span class="n">xdev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span>
		   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">,</span>
		   <span class="n">net</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-32"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-32">&#182;</a></div><p>ok, it's ready to go.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">usb_set_intfdata</span> <span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">netif_device_attach</span> <span class="p">(</span><span class="n">net</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_LINK_INTR</span><span class="p">)</span>
		<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out4:</span>
	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">interrupt</span><span class="p">);</span>
<span class="nl">out3:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">unbind</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">unbind</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">udev</span><span class="p">);</span>
<span class="nl">out1:</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">usb_put_dev</span><span class="p">(</span><span class="n">xdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usbnet_probe</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * suspend the whole driver as soon as the first interface is suspended</span>
<span class="cm"> * resume only when the last interface is resumed</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">usbnet_suspend</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbnet</span>		<span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">suspend_count</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="cm">/* don&#39;t autosuspend while transmitting */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">.</span><span class="n">qlen</span> <span class="o">&amp;&amp;</span> <span class="n">PMSG_IS_AUTO</span><span class="p">(</span><span class="n">message</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">suspend_count</span><span class="o">--</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">EVENT_DEV_ASLEEP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * accelerate emptying of the rx and queues, to avoid</span>
<span class="cm">		 * having everything error out.</span>
<span class="cm">		 */</span>
		<span class="n">netif_device_detach</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">);</span>
		<span class="n">usbnet_terminate_urbs</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">interrupt</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * reattach so runtime management can use and</span>
<span class="cm">		 * wake the device</span>
<span class="cm">		 */</span>
		<span class="n">netif_device_attach</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usbnet_suspend</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">usbnet_resume</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbnet</span>		<span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>          <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span>              <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="kt">int</span>                     <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">suspend_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* resume interrupt URBs */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">interrupt</span> <span class="o">&amp;&amp;</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">EVENT_DEV_OPEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">interrupt</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">res</span> <span class="o">=</span> <span class="n">usb_get_from_anchor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">deferred</span><span class="p">)))</span> <span class="p">{</span>

			<span class="n">skb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
				<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
				<span class="n">usb_autopm_put_interface_async</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
				<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">smp_mb</span><span class="p">();</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">EVENT_DEV_ASLEEP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">EVENT_DEV_OPEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* handle remote wakeup ASAP */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">wait</span> <span class="o">&amp;&amp;</span>
				<span class="n">netif_device_present</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="o">!</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">delay</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">EVENT_RX_HALT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
					<span class="n">rx_alloc_submit</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">.</span><span class="n">qlen</span> <span class="o">&gt;=</span> <span class="n">TX_QLEN</span><span class="p">(</span><span class="n">dev</span><span class="p">)))</span>
				<span class="n">netif_tx_wake_all_queues</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">);</span>
			<span class="n">tasklet_schedule</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usbnet_resume</span><span class="p">);</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">usbnet_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Compiler should optimize this out. */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span>
		<span class="n">FIELD_SIZEOF</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">cb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">skb_data</span><span class="p">));</span>

	<span class="n">random_ether_addr</span><span class="p">(</span><span class="n">node_id</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">usbnet_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">usbnet_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">usbnet_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;David Brownell&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;USB network driver framework&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
