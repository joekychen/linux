<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › usb › qmi_wwan.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>qmi_wwan.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2012  Bjørn Mork &lt;bjorn@mork.no&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * version 2 as published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/mii.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/usb/cdc.h&gt;</span>
<span class="cp">#include &lt;linux/usb/usbnet.h&gt;</span>
<span class="cp">#include &lt;linux/usb/cdc-wdm.h&gt;</span>

<span class="cm">/* The name of the CDC Device Management driver */</span>
<span class="cp">#define DM_DRIVER &quot;cdc_wdm&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * This driver supports wwan (3G/LTE/?) devices using a vendor</span>
<span class="cm"> * specific management protocol called Qualcomm MSM Interface (QMI) -</span>
<span class="cm"> * in addition to the more common AT commands over serial interface</span>
<span class="cm"> * management</span>
<span class="cm"> *</span>
<span class="cm"> * QMI is wrapped in CDC, using CDC encapsulated commands on the</span>
<span class="cm"> * control (&quot;master&quot;) interface of a two-interface CDC Union</span>
<span class="cm"> * resembling standard CDC ECM.  The devices do not use the control</span>
<span class="cm"> * interface for any other CDC messages.  Most likely because the</span>
<span class="cm"> * management protocol is used in place of the standard CDC</span>
<span class="cm"> * notifications NOTIFY_NETWORK_CONNECTION and NOTIFY_SPEED_CHANGE</span>
<span class="cm"> *</span>
<span class="cm"> * Handling a protocol like QMI is out of the scope for any driver.</span>
<span class="cm"> * It can be exported as a character device using the cdc-wdm driver,</span>
<span class="cm"> * which will enable userspace applications (&quot;modem managers&quot;) to</span>
<span class="cm"> * handle it.  This may be required to use the network interface</span>
<span class="cm"> * provided by the driver.</span>
<span class="cm"> *</span>
<span class="cm"> * These devices may alternatively/additionally be configured using AT</span>
<span class="cm"> * commands on any of the serial interfaces driven by the option driver</span>
<span class="cm"> *</span>
<span class="cm"> * This driver binds only to the data (&quot;slave&quot;) interface to enable</span>
<span class="cm"> * the cdc-wdm driver to bind to the control interface.  It still</span>
<span class="cm"> * parses the CDC functional descriptors on the control interface to</span>
<span class="cm"> *  a) verify that this is indeed a handled interface (CDC Union</span>
<span class="cm"> *     header lists it as slave)</span>
<span class="cm"> *  b) get MAC address and other ethernet config from the CDC Ethernet</span>
<span class="cm"> *     header</span>
<span class="cm"> *  c) enable user bind requests against the control interface, which</span>
<span class="cm"> *     is the common way to bind to CDC Ethernet Control Model type</span>
<span class="cm"> *     interfaces</span>
<span class="cm"> *  d) provide a hint to the user about which interface is the</span>
<span class="cm"> *     corresponding management interface</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qmi_wwan_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">control</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">extralen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface_descriptor</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_cdc_union_desc</span> <span class="o">*</span><span class="n">cdc_union</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_cdc_ether_desc</span> <span class="o">*</span><span class="n">cdc_ether</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">required</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USB_CDC_HEADER_TYPE</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USB_CDC_UNION_TYPE</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="o">*</span><span class="n">pmcount</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="n">pmcount</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * assume a data interface has no additional descriptors and</span>
<span class="cm">	 * that the control and data interface are numbered</span>
<span class="cm">	 * consecutively - this holds for the Huawei device at least</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">bInterfaceNumber</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">control</span> <span class="o">=</span> <span class="n">usb_ifnum_to_if</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">bInterfaceNumber</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">control</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">buf</span> <span class="o">=</span> <span class="n">control</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">control</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">extralen</span><span class="p">;</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;guessing </span><span class="se">\&quot;</span><span class="s">control</span><span class="se">\&quot;</span><span class="s"> =&gt; %s, </span><span class="se">\&quot;</span><span class="s">data</span><span class="se">\&quot;</span><span class="s"> =&gt; this</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">control</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_descriptor_header</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>

		<span class="cm">/* ignore any misplaced descriptors */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span> <span class="o">!=</span> <span class="n">USB_DT_CS_INTERFACE</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">next_desc</span><span class="p">;</span>

		<span class="cm">/* buf[2] is CDC descriptor subtype */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">USB_CDC_HEADER_TYPE</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USB_CDC_HEADER_TYPE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;extra CDC header</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">bLength</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_cdc_header_desc</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;CDC header len %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">bLength</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_CDC_UNION_TYPE</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USB_CDC_UNION_TYPE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;extra CDC union</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">bLength</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_cdc_union_desc</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;CDC union len %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">bLength</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">cdc_union</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_cdc_union_desc</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_CDC_ETHERNET_TYPE</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USB_CDC_ETHERNET_TYPE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;extra CDC ether</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">bLength</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_cdc_ether_desc</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;CDC ether len %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>  <span class="n">h</span><span class="o">-&gt;</span><span class="n">bLength</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">cdc_ether</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_cdc_ether_desc</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Remember which CDC functional descriptors we&#39;ve seen.  Works</span>
<span class="cm">		 * for all types we care about, of which USB_CDC_ETHERNET_TYPE</span>
<span class="cm">		 * (0x0f) is the highest numbered</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">)</span>
			<span class="n">found</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="nl">next_desc:</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">bLength</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">bLength</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* did we find all the required ones? */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">found</span> <span class="o">&amp;</span> <span class="n">required</span><span class="p">)</span> <span class="o">!=</span> <span class="n">required</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;CDC functional descriptors missing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* give the user a helpful hint if trying to bind to the wrong interface */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cdc_union</span> <span class="o">&amp;&amp;</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">bInterfaceNumber</span> <span class="o">==</span> <span class="n">cdc_union</span><span class="o">-&gt;</span><span class="n">bMasterInterface0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;leaving </span><span class="se">\&quot;</span><span class="s">control</span><span class="se">\&quot;</span><span class="s"> interface for &quot;</span> <span class="n">DM_DRIVER</span> <span class="s">&quot; - try binding to %s instead!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_ifnum_to_if</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">cdc_union</span><span class="o">-&gt;</span><span class="n">bSlaveInterface0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* errors aren&#39;t fatal - we can live with the dynamic address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cdc_ether</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hard_mtu</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">cdc_ether</span><span class="o">-&gt;</span><span class="n">wMaxSegmentSize</span><span class="p">);</span>
		<span class="n">usbnet_get_ethernet_addr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cdc_ether</span><span class="o">-&gt;</span><span class="n">iMACAddress</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* success! point the user to the management interface */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">control</span><span class="p">)</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Use </span><span class="se">\&quot;</span><span class="s">&quot;</span> <span class="n">DM_DRIVER</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s"> for QMI interface %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">control</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>

	<span class="cm">/* XXX: add a sysfs symlink somewhere to help management applications find it? */</span>

	<span class="cm">/* collect bulk endpoints now that we know intf == &quot;data&quot; interface */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">usbnet_get_endpoints</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">intf</span><span class="p">);</span>

<span class="nl">err:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* using a counter to merge subdriver requests with our own into a combined state */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">qmi_wwan_manage_power</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_t</span> <span class="o">*</span><span class="n">pmcount</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s() pmcount=%d, on=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="n">pmcount</span><span class="p">),</span> <span class="n">on</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">on</span> <span class="o">&amp;&amp;</span> <span class="n">atomic_add_return</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">pmcount</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">on</span> <span class="o">&amp;&amp;</span> <span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="n">pmcount</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* need autopm_get/put here to ensure the usbcore sees the new value */</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="n">usb_autopm_get_interface</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">needs_remote_wakeup</span> <span class="o">=</span> <span class="n">on</span><span class="p">;</span>
		<span class="n">usb_autopm_put_interface</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">err:</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qmi_wwan_cdc_wdm_manage_power</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="cm">/* can be called while disconnecting */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">qmi_wwan_manage_power</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">on</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Some devices combine the &quot;control&quot; and &quot;data&quot; functions into a</span>
<span class="cm"> * single interface with all three endpoints: interrupt + bulk in and</span>
<span class="cm"> * out</span>
<span class="cm"> *</span>
<span class="cm"> * Setting up cdc-wdm as a subdriver owning the interrupt endpoint</span>
<span class="cm"> * will let it provide userspace access to the encapsulated QMI</span>
<span class="cm"> * protocol without interfering with the usbnet operations.</span>
<span class="cm">  */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">qmi_wwan_bind_shared</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">subdriver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="o">*</span><span class="n">pmcount</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="cm">/* ZTE makes devices where the interface descriptors and endpoint</span>
<span class="cm">	 * configurations of two or more interfaces are identical, even</span>
<span class="cm">	 * though the functions are completely different.  If set, then</span>
<span class="cm">	 * driver_info-&gt;data is a bitmap of acceptable interface numbers</span>
<span class="cm">	 * allowing us to bind to one such interface without binding to</span>
<span class="cm">	 * all of them</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;not on our whitelist - ignored&quot;</span><span class="p">);</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="n">pmcount</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* collect all three endpoints */</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">usbnet_get_endpoints</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">intf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* require interrupt endpoint for subdriver */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">subdriver</span> <span class="o">=</span> <span class="n">usb_cdc_wdm_register</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">status</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qmi_wwan_cdc_wdm_manage_power</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">subdriver</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">subdriver</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* can&#39;t let usbnet use the interrupt endpoint */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* save subdriver struct for suspend/resume wrappers */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">subdriver</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">qmi_wwan_unbind_shared</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">subdriver</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">subdriver</span> <span class="o">&amp;&amp;</span> <span class="n">subdriver</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">)</span>
		<span class="n">subdriver</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* suspend/resume wrappers calling both usbnet and the cdc-wdm</span>
<span class="cm"> * subdriver if present.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: cdc-wdm also supports pre/post_reset, but we cannot provide</span>
<span class="cm"> * wrappers for those without adding usbnet reset support first.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">qmi_wwan_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">subdriver</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">usbnet_suspend</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">subdriver</span> <span class="o">&amp;&amp;</span> <span class="n">subdriver</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">subdriver</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">usbnet_resume</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
<span class="nl">err:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qmi_wwan_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbnet</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">subdriver</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">subdriver</span> <span class="o">&amp;&amp;</span> <span class="n">subdriver</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">subdriver</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">usbnet_resume</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">subdriver</span> <span class="o">&amp;&amp;</span> <span class="n">subdriver</span><span class="o">-&gt;</span><span class="n">resume</span> <span class="o">&amp;&amp;</span> <span class="n">subdriver</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">)</span>
		<span class="n">subdriver</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">PMSG_SUSPEND</span><span class="p">);</span>
<span class="nl">err:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">driver_info</span>	<span class="n">qmi_wwan_info</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">description</span>	<span class="o">=</span> <span class="s">&quot;QMI speaking wwan device&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">FLAG_WWAN</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bind</span>		<span class="o">=</span> <span class="n">qmi_wwan_bind</span><span class="p">,</span>
	<span class="p">.</span><span class="n">manage_power</span>	<span class="o">=</span> <span class="n">qmi_wwan_manage_power</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">driver_info</span>	<span class="n">qmi_wwan_shared</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">description</span>	<span class="o">=</span> <span class="s">&quot;QMI speaking wwan device with combined interface&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">FLAG_WWAN</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bind</span>		<span class="o">=</span> <span class="n">qmi_wwan_bind_shared</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unbind</span>		<span class="o">=</span> <span class="n">qmi_wwan_unbind_shared</span><span class="p">,</span>
	<span class="p">.</span><span class="n">manage_power</span>	<span class="o">=</span> <span class="n">qmi_wwan_manage_power</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">driver_info</span>	<span class="n">qmi_wwan_force_int0</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">description</span>	<span class="o">=</span> <span class="s">&quot;Qualcomm WWAN/QMI device&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">FLAG_WWAN</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bind</span>		<span class="o">=</span> <span class="n">qmi_wwan_bind_shared</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unbind</span>		<span class="o">=</span> <span class="n">qmi_wwan_unbind_shared</span><span class="p">,</span>
	<span class="p">.</span><span class="n">manage_power</span>	<span class="o">=</span> <span class="n">qmi_wwan_manage_power</span><span class="p">,</span>
	<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="cm">/* interface whitelist bitmap */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">driver_info</span>	<span class="n">qmi_wwan_force_int1</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">description</span>	<span class="o">=</span> <span class="s">&quot;Qualcomm WWAN/QMI device&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">FLAG_WWAN</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bind</span>		<span class="o">=</span> <span class="n">qmi_wwan_bind_shared</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unbind</span>		<span class="o">=</span> <span class="n">qmi_wwan_unbind_shared</span><span class="p">,</span>
	<span class="p">.</span><span class="n">manage_power</span>	<span class="o">=</span> <span class="n">qmi_wwan_manage_power</span><span class="p">,</span>
	<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="cm">/* interface whitelist bitmap */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">driver_info</span>	<span class="n">qmi_wwan_force_int3</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">description</span>	<span class="o">=</span> <span class="s">&quot;Qualcomm WWAN/QMI device&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">FLAG_WWAN</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bind</span>		<span class="o">=</span> <span class="n">qmi_wwan_bind_shared</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unbind</span>		<span class="o">=</span> <span class="n">qmi_wwan_unbind_shared</span><span class="p">,</span>
	<span class="p">.</span><span class="n">manage_power</span>	<span class="o">=</span> <span class="n">qmi_wwan_manage_power</span><span class="p">,</span>
	<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="cm">/* interface whitelist bitmap */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">driver_info</span>	<span class="n">qmi_wwan_force_int4</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">description</span>	<span class="o">=</span> <span class="s">&quot;Qualcomm WWAN/QMI device&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">FLAG_WWAN</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bind</span>		<span class="o">=</span> <span class="n">qmi_wwan_bind_shared</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unbind</span>		<span class="o">=</span> <span class="n">qmi_wwan_unbind_shared</span><span class="p">,</span>
	<span class="p">.</span><span class="n">manage_power</span>	<span class="o">=</span> <span class="n">qmi_wwan_manage_power</span><span class="p">,</span>
	<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="cm">/* interface whitelist bitmap */</span>
<span class="p">};</span>

<span class="cm">/* Sierra Wireless provide equally useless interface descriptors</span>
<span class="cm"> * Devices in QMI mode can be switched between two different</span>
<span class="cm"> * configurations:</span>
<span class="cm"> *   a) USB interface #8 is QMI/wwan</span>
<span class="cm"> *   b) USB interfaces #8, #19 and #20 are QMI/wwan</span>
<span class="cm"> *</span>
<span class="cm"> * Both configurations provide a number of other interfaces (serial++),</span>
<span class="cm"> * some of which have the same endpoint configuration as we expect, so</span>
<span class="cm"> * a whitelist or blacklist is necessary.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: The below whitelist should include BIT(20).  It does not</span>
<span class="cm"> * because I cannot get it to work...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">driver_info</span>	<span class="n">qmi_wwan_sierra</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">description</span>	<span class="o">=</span> <span class="s">&quot;Sierra Wireless wwan/QMI device&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">FLAG_WWAN</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bind</span>		<span class="o">=</span> <span class="n">qmi_wwan_bind_shared</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unbind</span>		<span class="o">=</span> <span class="n">qmi_wwan_unbind_shared</span><span class="p">,</span>
	<span class="p">.</span><span class="n">manage_power</span>	<span class="o">=</span> <span class="n">qmi_wwan_manage_power</span><span class="p">,</span>
	<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">19</span><span class="p">),</span> <span class="cm">/* interface whitelist bitmap */</span>
<span class="p">};</span>

<span class="cp">#define HUAWEI_VENDOR_ID	0x12D1</span>

<span class="cm">/* Gobi 1000 QMI/wwan interface number is 3 according to qcserial */</span>
<span class="cp">#define QMI_GOBI1K_DEVICE(vend, prod) \</span>
<span class="cp">	USB_DEVICE(vend, prod), \</span>
<span class="cp">	.driver_info = (unsigned long)&amp;qmi_wwan_force_int3</span>

<span class="cm">/* Gobi 2000 and Gobi 3000 QMI/wwan interface number is 0 according to qcserial */</span>
<span class="cp">#define QMI_GOBI_DEVICE(vend, prod) \</span>
<span class="cp">	USB_DEVICE(vend, prod), \</span>
<span class="cp">	.driver_info = (unsigned long)&amp;qmi_wwan_force_int0</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="n">products</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>	<span class="cm">/* Huawei E392, E398 and possibly others sharing both device id and more... */</span>
		<span class="p">.</span><span class="n">match_flags</span>        <span class="o">=</span> <span class="n">USB_DEVICE_ID_MATCH_VENDOR</span> <span class="o">|</span> <span class="n">USB_DEVICE_ID_MATCH_INT_INFO</span><span class="p">,</span>
		<span class="p">.</span><span class="n">idVendor</span>           <span class="o">=</span> <span class="n">HUAWEI_VENDOR_ID</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceClass</span>    <span class="o">=</span> <span class="n">USB_CLASS_VENDOR_SPEC</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceSubClass</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceProtocol</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="cm">/* NOTE: This is the *slave* interface of the CDC Union! */</span>
		<span class="p">.</span><span class="n">driver_info</span>        <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">qmi_wwan_info</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* Vodafone/Huawei K5005 (12d1:14c8) and similar modems */</span>
		<span class="p">.</span><span class="n">match_flags</span>        <span class="o">=</span> <span class="n">USB_DEVICE_ID_MATCH_VENDOR</span> <span class="o">|</span> <span class="n">USB_DEVICE_ID_MATCH_INT_INFO</span><span class="p">,</span>
		<span class="p">.</span><span class="n">idVendor</span>           <span class="o">=</span> <span class="n">HUAWEI_VENDOR_ID</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceClass</span>    <span class="o">=</span> <span class="n">USB_CLASS_VENDOR_SPEC</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceSubClass</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceProtocol</span> <span class="o">=</span> <span class="mi">56</span><span class="p">,</span> <span class="cm">/* NOTE: This is the *slave* interface of the CDC Union! */</span>
		<span class="p">.</span><span class="n">driver_info</span>        <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">qmi_wwan_info</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* Huawei E392, E398 and possibly others in &quot;Windows mode&quot;</span>
<span class="cm">		 * using a combined control and data interface without any CDC</span>
<span class="cm">		 * functional descriptors</span>
<span class="cm">		 */</span>
		<span class="p">.</span><span class="n">match_flags</span>        <span class="o">=</span> <span class="n">USB_DEVICE_ID_MATCH_VENDOR</span> <span class="o">|</span> <span class="n">USB_DEVICE_ID_MATCH_INT_INFO</span><span class="p">,</span>
		<span class="p">.</span><span class="n">idVendor</span>           <span class="o">=</span> <span class="n">HUAWEI_VENDOR_ID</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceClass</span>    <span class="o">=</span> <span class="n">USB_CLASS_VENDOR_SPEC</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceSubClass</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceProtocol</span> <span class="o">=</span> <span class="mi">17</span><span class="p">,</span>
		<span class="p">.</span><span class="n">driver_info</span>        <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">qmi_wwan_shared</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* Pantech UML290 */</span>
		<span class="p">.</span><span class="n">match_flags</span>	    <span class="o">=</span> <span class="n">USB_DEVICE_ID_MATCH_DEVICE</span> <span class="o">|</span> <span class="n">USB_DEVICE_ID_MATCH_INT_INFO</span><span class="p">,</span>
		<span class="p">.</span><span class="n">idVendor</span>           <span class="o">=</span> <span class="mh">0x106c</span><span class="p">,</span>
		<span class="p">.</span><span class="n">idProduct</span>          <span class="o">=</span> <span class="mh">0x3718</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceClass</span>    <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceSubClass</span> <span class="o">=</span> <span class="mh">0xf0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceProtocol</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
		<span class="p">.</span><span class="n">driver_info</span>        <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">qmi_wwan_shared</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* ZTE MF820D */</span>
		<span class="p">.</span><span class="n">match_flags</span>	    <span class="o">=</span> <span class="n">USB_DEVICE_ID_MATCH_DEVICE</span> <span class="o">|</span> <span class="n">USB_DEVICE_ID_MATCH_INT_INFO</span><span class="p">,</span>
		<span class="p">.</span><span class="n">idVendor</span>           <span class="o">=</span> <span class="mh">0x19d2</span><span class="p">,</span>
		<span class="p">.</span><span class="n">idProduct</span>          <span class="o">=</span> <span class="mh">0x0167</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceClass</span>    <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceSubClass</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceProtocol</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
		<span class="p">.</span><span class="n">driver_info</span>        <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">qmi_wwan_force_int4</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* ZTE (Vodafone) K3520-Z */</span>
		<span class="p">.</span><span class="n">match_flags</span>	    <span class="o">=</span> <span class="n">USB_DEVICE_ID_MATCH_DEVICE</span> <span class="o">|</span> <span class="n">USB_DEVICE_ID_MATCH_INT_INFO</span><span class="p">,</span>
		<span class="p">.</span><span class="n">idVendor</span>           <span class="o">=</span> <span class="mh">0x19d2</span><span class="p">,</span>
		<span class="p">.</span><span class="n">idProduct</span>          <span class="o">=</span> <span class="mh">0x0055</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceClass</span>    <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceSubClass</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceProtocol</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
		<span class="p">.</span><span class="n">driver_info</span>        <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">qmi_wwan_force_int1</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* ZTE (Vodafone) K3565-Z */</span>
		<span class="p">.</span><span class="n">match_flags</span>	    <span class="o">=</span> <span class="n">USB_DEVICE_ID_MATCH_DEVICE</span> <span class="o">|</span> <span class="n">USB_DEVICE_ID_MATCH_INT_INFO</span><span class="p">,</span>
		<span class="p">.</span><span class="n">idVendor</span>           <span class="o">=</span> <span class="mh">0x19d2</span><span class="p">,</span>
		<span class="p">.</span><span class="n">idProduct</span>          <span class="o">=</span> <span class="mh">0x0063</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceClass</span>    <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceSubClass</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceProtocol</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
		<span class="p">.</span><span class="n">driver_info</span>        <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">qmi_wwan_force_int4</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* ZTE (Vodafone) K3570-Z */</span>
		<span class="p">.</span><span class="n">match_flags</span>	    <span class="o">=</span> <span class="n">USB_DEVICE_ID_MATCH_DEVICE</span> <span class="o">|</span> <span class="n">USB_DEVICE_ID_MATCH_INT_INFO</span><span class="p">,</span>
		<span class="p">.</span><span class="n">idVendor</span>           <span class="o">=</span> <span class="mh">0x19d2</span><span class="p">,</span>
		<span class="p">.</span><span class="n">idProduct</span>          <span class="o">=</span> <span class="mh">0x1008</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceClass</span>    <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceSubClass</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceProtocol</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
		<span class="p">.</span><span class="n">driver_info</span>        <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">qmi_wwan_force_int4</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* ZTE (Vodafone) K3571-Z */</span>
		<span class="p">.</span><span class="n">match_flags</span>	    <span class="o">=</span> <span class="n">USB_DEVICE_ID_MATCH_DEVICE</span> <span class="o">|</span> <span class="n">USB_DEVICE_ID_MATCH_INT_INFO</span><span class="p">,</span>
		<span class="p">.</span><span class="n">idVendor</span>           <span class="o">=</span> <span class="mh">0x19d2</span><span class="p">,</span>
		<span class="p">.</span><span class="n">idProduct</span>          <span class="o">=</span> <span class="mh">0x1010</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceClass</span>    <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceSubClass</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceProtocol</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
		<span class="p">.</span><span class="n">driver_info</span>        <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">qmi_wwan_force_int4</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* ZTE (Vodafone) K3765-Z */</span>
		<span class="p">.</span><span class="n">match_flags</span>	    <span class="o">=</span> <span class="n">USB_DEVICE_ID_MATCH_DEVICE</span> <span class="o">|</span> <span class="n">USB_DEVICE_ID_MATCH_INT_INFO</span><span class="p">,</span>
		<span class="p">.</span><span class="n">idVendor</span>           <span class="o">=</span> <span class="mh">0x19d2</span><span class="p">,</span>
		<span class="p">.</span><span class="n">idProduct</span>          <span class="o">=</span> <span class="mh">0x2002</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceClass</span>    <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceSubClass</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceProtocol</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
		<span class="p">.</span><span class="n">driver_info</span>        <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">qmi_wwan_force_int4</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* ZTE (Vodafone) K4505-Z */</span>
		<span class="p">.</span><span class="n">match_flags</span>	    <span class="o">=</span> <span class="n">USB_DEVICE_ID_MATCH_DEVICE</span> <span class="o">|</span> <span class="n">USB_DEVICE_ID_MATCH_INT_INFO</span><span class="p">,</span>
		<span class="p">.</span><span class="n">idVendor</span>           <span class="o">=</span> <span class="mh">0x19d2</span><span class="p">,</span>
		<span class="p">.</span><span class="n">idProduct</span>          <span class="o">=</span> <span class="mh">0x0104</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceClass</span>    <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceSubClass</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceProtocol</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
		<span class="p">.</span><span class="n">driver_info</span>        <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">qmi_wwan_force_int4</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* Sierra Wireless MC77xx in QMI mode */</span>
		<span class="p">.</span><span class="n">match_flags</span>	    <span class="o">=</span> <span class="n">USB_DEVICE_ID_MATCH_DEVICE</span> <span class="o">|</span> <span class="n">USB_DEVICE_ID_MATCH_INT_INFO</span><span class="p">,</span>
		<span class="p">.</span><span class="n">idVendor</span>           <span class="o">=</span> <span class="mh">0x1199</span><span class="p">,</span>
		<span class="p">.</span><span class="n">idProduct</span>          <span class="o">=</span> <span class="mh">0x68a2</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceClass</span>    <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceSubClass</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bInterfaceProtocol</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
		<span class="p">.</span><span class="n">driver_info</span>        <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">qmi_wwan_sierra</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="cm">/* Gobi 1000 devices */</span>
	<span class="p">{</span><span class="n">QMI_GOBI1K_DEVICE</span><span class="p">(</span><span class="mh">0x05c6</span><span class="p">,</span> <span class="mh">0x9212</span><span class="p">)},</span>	<span class="cm">/* Acer Gobi Modem Device */</span>
	<span class="p">{</span><span class="n">QMI_GOBI1K_DEVICE</span><span class="p">(</span><span class="mh">0x03f0</span><span class="p">,</span> <span class="mh">0x1f1d</span><span class="p">)},</span>	<span class="cm">/* HP un2400 Gobi Modem Device */</span>
	<span class="p">{</span><span class="n">QMI_GOBI1K_DEVICE</span><span class="p">(</span><span class="mh">0x03f0</span><span class="p">,</span> <span class="mh">0x371d</span><span class="p">)},</span>	<span class="cm">/* HP un2430 Mobile Broadband Module */</span>
	<span class="p">{</span><span class="n">QMI_GOBI1K_DEVICE</span><span class="p">(</span><span class="mh">0x04da</span><span class="p">,</span> <span class="mh">0x250d</span><span class="p">)},</span>	<span class="cm">/* Panasonic Gobi Modem device */</span>
	<span class="p">{</span><span class="n">QMI_GOBI1K_DEVICE</span><span class="p">(</span><span class="mh">0x413c</span><span class="p">,</span> <span class="mh">0x8172</span><span class="p">)},</span>	<span class="cm">/* Dell Gobi Modem device */</span>
	<span class="p">{</span><span class="n">QMI_GOBI1K_DEVICE</span><span class="p">(</span><span class="mh">0x1410</span><span class="p">,</span> <span class="mh">0xa001</span><span class="p">)},</span>	<span class="cm">/* Novatel Gobi Modem device */</span>
	<span class="p">{</span><span class="n">QMI_GOBI1K_DEVICE</span><span class="p">(</span><span class="mh">0x0b05</span><span class="p">,</span> <span class="mh">0x1776</span><span class="p">)},</span>	<span class="cm">/* Asus Gobi Modem device */</span>
	<span class="p">{</span><span class="n">QMI_GOBI1K_DEVICE</span><span class="p">(</span><span class="mh">0x19d2</span><span class="p">,</span> <span class="mh">0xfff3</span><span class="p">)},</span>	<span class="cm">/* ONDA Gobi Modem device */</span>
	<span class="p">{</span><span class="n">QMI_GOBI1K_DEVICE</span><span class="p">(</span><span class="mh">0x05c6</span><span class="p">,</span> <span class="mh">0x9001</span><span class="p">)},</span>	<span class="cm">/* Generic Gobi Modem device */</span>
	<span class="p">{</span><span class="n">QMI_GOBI1K_DEVICE</span><span class="p">(</span><span class="mh">0x05c6</span><span class="p">,</span> <span class="mh">0x9002</span><span class="p">)},</span>	<span class="cm">/* Generic Gobi Modem device */</span>
	<span class="p">{</span><span class="n">QMI_GOBI1K_DEVICE</span><span class="p">(</span><span class="mh">0x05c6</span><span class="p">,</span> <span class="mh">0x9202</span><span class="p">)},</span>	<span class="cm">/* Generic Gobi Modem device */</span>
	<span class="p">{</span><span class="n">QMI_GOBI1K_DEVICE</span><span class="p">(</span><span class="mh">0x05c6</span><span class="p">,</span> <span class="mh">0x9203</span><span class="p">)},</span>	<span class="cm">/* Generic Gobi Modem device */</span>
	<span class="p">{</span><span class="n">QMI_GOBI1K_DEVICE</span><span class="p">(</span><span class="mh">0x05c6</span><span class="p">,</span> <span class="mh">0x9222</span><span class="p">)},</span>	<span class="cm">/* Generic Gobi Modem device */</span>
	<span class="p">{</span><span class="n">QMI_GOBI1K_DEVICE</span><span class="p">(</span><span class="mh">0x05c6</span><span class="p">,</span> <span class="mh">0x9009</span><span class="p">)},</span>	<span class="cm">/* Generic Gobi Modem device */</span>

	<span class="cm">/* Gobi 2000 and 3000 devices */</span>
	<span class="p">{</span><span class="n">QMI_GOBI_DEVICE</span><span class="p">(</span><span class="mh">0x413c</span><span class="p">,</span> <span class="mh">0x8186</span><span class="p">)},</span>	<span class="cm">/* Dell Gobi 2000 Modem device (N0218, VU936) */</span>
	<span class="p">{</span><span class="n">QMI_GOBI_DEVICE</span><span class="p">(</span><span class="mh">0x05c6</span><span class="p">,</span> <span class="mh">0x920b</span><span class="p">)},</span>	<span class="cm">/* Generic Gobi 2000 Modem device */</span>
	<span class="p">{</span><span class="n">QMI_GOBI_DEVICE</span><span class="p">(</span><span class="mh">0x05c6</span><span class="p">,</span> <span class="mh">0x9225</span><span class="p">)},</span>	<span class="cm">/* Sony Gobi 2000 Modem device (N0279, VU730) */</span>
	<span class="p">{</span><span class="n">QMI_GOBI_DEVICE</span><span class="p">(</span><span class="mh">0x05c6</span><span class="p">,</span> <span class="mh">0x9245</span><span class="p">)},</span>	<span class="cm">/* Samsung Gobi 2000 Modem device (VL176) */</span>
	<span class="p">{</span><span class="n">QMI_GOBI_DEVICE</span><span class="p">(</span><span class="mh">0x03f0</span><span class="p">,</span> <span class="mh">0x251d</span><span class="p">)},</span>	<span class="cm">/* HP Gobi 2000 Modem device (VP412) */</span>
	<span class="p">{</span><span class="n">QMI_GOBI_DEVICE</span><span class="p">(</span><span class="mh">0x05c6</span><span class="p">,</span> <span class="mh">0x9215</span><span class="p">)},</span>	<span class="cm">/* Acer Gobi 2000 Modem device (VP413) */</span>
	<span class="p">{</span><span class="n">QMI_GOBI_DEVICE</span><span class="p">(</span><span class="mh">0x05c6</span><span class="p">,</span> <span class="mh">0x9265</span><span class="p">)},</span>	<span class="cm">/* Asus Gobi 2000 Modem device (VR305) */</span>
	<span class="p">{</span><span class="n">QMI_GOBI_DEVICE</span><span class="p">(</span><span class="mh">0x05c6</span><span class="p">,</span> <span class="mh">0x9235</span><span class="p">)},</span>	<span class="cm">/* Top Global Gobi 2000 Modem device (VR306) */</span>
	<span class="p">{</span><span class="n">QMI_GOBI_DEVICE</span><span class="p">(</span><span class="mh">0x05c6</span><span class="p">,</span> <span class="mh">0x9275</span><span class="p">)},</span>	<span class="cm">/* iRex Technologies Gobi 2000 Modem device (VR307) */</span>
	<span class="p">{</span><span class="n">QMI_GOBI_DEVICE</span><span class="p">(</span><span class="mh">0x1199</span><span class="p">,</span> <span class="mh">0x9001</span><span class="p">)},</span>	<span class="cm">/* Sierra Wireless Gobi 2000 Modem device (VT773) */</span>
	<span class="p">{</span><span class="n">QMI_GOBI_DEVICE</span><span class="p">(</span><span class="mh">0x1199</span><span class="p">,</span> <span class="mh">0x9002</span><span class="p">)},</span>	<span class="cm">/* Sierra Wireless Gobi 2000 Modem device (VT773) */</span>
	<span class="p">{</span><span class="n">QMI_GOBI_DEVICE</span><span class="p">(</span><span class="mh">0x1199</span><span class="p">,</span> <span class="mh">0x9003</span><span class="p">)},</span>	<span class="cm">/* Sierra Wireless Gobi 2000 Modem device (VT773) */</span>
	<span class="p">{</span><span class="n">QMI_GOBI_DEVICE</span><span class="p">(</span><span class="mh">0x1199</span><span class="p">,</span> <span class="mh">0x9004</span><span class="p">)},</span>	<span class="cm">/* Sierra Wireless Gobi 2000 Modem device (VT773) */</span>
	<span class="p">{</span><span class="n">QMI_GOBI_DEVICE</span><span class="p">(</span><span class="mh">0x1199</span><span class="p">,</span> <span class="mh">0x9005</span><span class="p">)},</span>	<span class="cm">/* Sierra Wireless Gobi 2000 Modem device (VT773) */</span>
	<span class="p">{</span><span class="n">QMI_GOBI_DEVICE</span><span class="p">(</span><span class="mh">0x1199</span><span class="p">,</span> <span class="mh">0x9006</span><span class="p">)},</span>	<span class="cm">/* Sierra Wireless Gobi 2000 Modem device (VT773) */</span>
	<span class="p">{</span><span class="n">QMI_GOBI_DEVICE</span><span class="p">(</span><span class="mh">0x1199</span><span class="p">,</span> <span class="mh">0x9007</span><span class="p">)},</span>	<span class="cm">/* Sierra Wireless Gobi 2000 Modem device (VT773) */</span>
	<span class="p">{</span><span class="n">QMI_GOBI_DEVICE</span><span class="p">(</span><span class="mh">0x1199</span><span class="p">,</span> <span class="mh">0x9008</span><span class="p">)},</span>	<span class="cm">/* Sierra Wireless Gobi 2000 Modem device (VT773) */</span>
	<span class="p">{</span><span class="n">QMI_GOBI_DEVICE</span><span class="p">(</span><span class="mh">0x1199</span><span class="p">,</span> <span class="mh">0x9009</span><span class="p">)},</span>	<span class="cm">/* Sierra Wireless Gobi 2000 Modem device (VT773) */</span>
	<span class="p">{</span><span class="n">QMI_GOBI_DEVICE</span><span class="p">(</span><span class="mh">0x1199</span><span class="p">,</span> <span class="mh">0x900a</span><span class="p">)},</span>	<span class="cm">/* Sierra Wireless Gobi 2000 Modem device (VT773) */</span>
	<span class="p">{</span><span class="n">QMI_GOBI_DEVICE</span><span class="p">(</span><span class="mh">0x1199</span><span class="p">,</span> <span class="mh">0x9011</span><span class="p">)},</span>	<span class="cm">/* Sierra Wireless Gobi 2000 Modem device (MC8305) */</span>
	<span class="p">{</span><span class="n">QMI_GOBI_DEVICE</span><span class="p">(</span><span class="mh">0x16d8</span><span class="p">,</span> <span class="mh">0x8002</span><span class="p">)},</span>	<span class="cm">/* CMDTech Gobi 2000 Modem device (VU922) */</span>
	<span class="p">{</span><span class="n">QMI_GOBI_DEVICE</span><span class="p">(</span><span class="mh">0x05c6</span><span class="p">,</span> <span class="mh">0x9205</span><span class="p">)},</span>	<span class="cm">/* Gobi 2000 Modem device */</span>
	<span class="p">{</span><span class="n">QMI_GOBI_DEVICE</span><span class="p">(</span><span class="mh">0x1199</span><span class="p">,</span> <span class="mh">0x9013</span><span class="p">)},</span>	<span class="cm">/* Sierra Wireless Gobi 3000 Modem device (MC8355) */</span>
	<span class="p">{</span><span class="n">QMI_GOBI_DEVICE</span><span class="p">(</span><span class="mh">0x1199</span><span class="p">,</span> <span class="mh">0x9015</span><span class="p">)},</span>	<span class="cm">/* Sierra Wireless Gobi 3000 Modem device */</span>
	<span class="p">{</span><span class="n">QMI_GOBI_DEVICE</span><span class="p">(</span><span class="mh">0x1199</span><span class="p">,</span> <span class="mh">0x9019</span><span class="p">)},</span>	<span class="cm">/* Sierra Wireless Gobi 3000 Modem device */</span>
	<span class="p">{</span> <span class="p">}</span>					<span class="cm">/* END */</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">usb</span><span class="p">,</span> <span class="n">products</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_driver</span> <span class="n">qmi_wwan_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		      <span class="o">=</span> <span class="s">&quot;qmi_wwan&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	      <span class="o">=</span> <span class="n">products</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		      <span class="o">=</span>	<span class="n">usbnet_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disconnect</span>	      <span class="o">=</span> <span class="n">usbnet_disconnect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span>	      <span class="o">=</span> <span class="n">qmi_wwan_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		      <span class="o">=</span>	<span class="n">qmi_wwan_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_resume</span>         <span class="o">=</span> <span class="n">qmi_wwan_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">supports_autosuspend</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disable_hub_initiated_lpm</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">qmi_wwan_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">usb_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qmi_wwan_driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">qmi_wwan_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">qmi_wwan_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">usb_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qmi_wwan_driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">qmi_wwan_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Bjørn Mork &lt;bjorn@mork.no&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Qualcomm MSM Interface (QMI) WWAN driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
