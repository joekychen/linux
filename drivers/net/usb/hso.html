<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › usb › hso.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>hso.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Driver for Option High Speed Mobile Devices.</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2008 Option International</span>
<span class="cm"> *                     Filip Aben &lt;f.aben@option.com&gt;</span>
<span class="cm"> *                     Denis Joseph Barrow &lt;d.barow@option.com&gt;</span>
<span class="cm"> *                     Jan Dumon &lt;j.dumon@option.com&gt;</span>
<span class="cm"> *  Copyright (C) 2007 Andrew Bird (Sphere Systems Ltd)</span>
<span class="cm"> *  			&lt;ajb@spheresystems.co.uk&gt;</span>
<span class="cm"> *  Copyright (C) 2008 Greg Kroah-Hartman &lt;gregkh@suse.de&gt;</span>
<span class="cm"> *  Copyright (C) 2008 Novell, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> *  published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; if not, write to the Free Software</span>
<span class="cm"> *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,</span>
<span class="cm"> *  USA</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Description of the device:</span>
<span class="cm"> *</span>
<span class="cm"> * Interface 0:	Contains the IP network interface on the bulk end points.</span>
<span class="cm"> *		The multiplexed serial ports are using the interrupt and</span>
<span class="cm"> *		control endpoints.</span>
<span class="cm"> *		Interrupt contains a bitmap telling which multiplexed</span>
<span class="cm"> *		serialport needs servicing.</span>
<span class="cm"> *</span>
<span class="cm"> * Interface 1:	Diagnostics port, uses bulk only, do not submit urbs until the</span>
<span class="cm"> *		port is opened, as this have a huge impact on the network port</span>
<span class="cm"> *		throughput.</span>
<span class="cm"> *</span>
<span class="cm"> * Interface 2:	Standard modem interface - circuit switched interface, this</span>
<span class="cm"> *		can be used to make a standard ppp connection however it</span>
<span class="cm"> *              should not be used in conjunction with the IP network interface</span>
<span class="cm"> *              enabled for USB performance reasons i.e. if using this set</span>
<span class="cm"> *              ideally disable_net=1.</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/tty_driver.h&gt;</span>
<span class="cp">#include &lt;linux/tty_flip.h&gt;</span>
<span class="cp">#include &lt;linux/kmod.h&gt;</span>
<span class="cp">#include &lt;linux/rfkill.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/usb/cdc.h&gt;</span>
<span class="cp">#include &lt;net/arp.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;linux/serial_core.h&gt;</span>
<span class="cp">#include &lt;linux/serial.h&gt;</span>


<span class="cp">#define MOD_AUTHOR			&quot;Option Wireless&quot;</span>
<span class="cp">#define MOD_DESCRIPTION			&quot;USB High Speed Option driver&quot;</span>
<span class="cp">#define MOD_LICENSE			&quot;GPL&quot;</span>

<span class="cp">#define HSO_MAX_NET_DEVICES		10</span>
<span class="cp">#define HSO__MAX_MTU			2048</span>
<span class="cp">#define DEFAULT_MTU			1500</span>
<span class="cp">#define DEFAULT_MRU			1500</span>

<span class="cp">#define CTRL_URB_RX_SIZE		1024</span>
<span class="cp">#define CTRL_URB_TX_SIZE		64</span>

<span class="cp">#define BULK_URB_RX_SIZE		4096</span>
<span class="cp">#define BULK_URB_TX_SIZE		8192</span>

<span class="cp">#define MUX_BULK_RX_BUF_SIZE		HSO__MAX_MTU</span>
<span class="cp">#define MUX_BULK_TX_BUF_SIZE		HSO__MAX_MTU</span>
<span class="cp">#define MUX_BULK_RX_BUF_COUNT		4</span>
<span class="cp">#define USB_TYPE_OPTION_VENDOR		0x20</span>

<span class="cm">/* These definitions are used with the struct hso_net flags element */</span>
<span class="cm">/* - use *_bit operations on it. (bit indices not values.) */</span>
<span class="cp">#define HSO_NET_RUNNING			0</span>

<span class="cp">#define	HSO_NET_TX_TIMEOUT		(HZ*10)</span>

<span class="cp">#define HSO_SERIAL_MAGIC		0x48534f31</span>

<span class="cm">/* Number of ttys to handle */</span>
<span class="cp">#define HSO_SERIAL_TTY_MINORS		256</span>

<span class="cp">#define MAX_RX_URBS			2</span>

<span class="cm">/*****************************************************************************/</span>
<span class="cm">/* Debugging functions                                                       */</span>
<span class="cm">/*****************************************************************************/</span>
<span class="cp">#define D__(lvl_, fmt, arg...)				\</span>
<span class="cp">	do {						\</span>
<span class="cp">		printk(lvl_ &quot;[%d:%s]: &quot; fmt &quot;\n&quot;,	\</span>
<span class="cp">		       __LINE__, __func__, ## arg);	\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define D_(lvl, args...)				\</span>
<span class="cp">	do {						\</span>
<span class="cp">		if (lvl &amp; debug)			\</span>
<span class="cp">			D__(KERN_INFO, args);		\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define D1(args...)	D_(0x01, ##args)</span>
<span class="cp">#define D2(args...)	D_(0x02, ##args)</span>
<span class="cp">#define D3(args...)	D_(0x04, ##args)</span>
<span class="cp">#define D4(args...)	D_(0x08, ##args)</span>
<span class="cp">#define D5(args...)	D_(0x10, ##args)</span>

<span class="cm">/*****************************************************************************/</span>
<span class="cm">/* Enumerators                                                               */</span>
<span class="cm">/*****************************************************************************/</span>
<span class="k">enum</span> <span class="n">pkt_parse_state</span> <span class="p">{</span>
	<span class="n">WAIT_IP</span><span class="p">,</span>
	<span class="n">WAIT_DATA</span><span class="p">,</span>
	<span class="n">WAIT_SYNC</span>
<span class="p">};</span>

<span class="cm">/*****************************************************************************/</span>
<span class="cm">/* Structs                                                                   */</span>
<span class="cm">/*****************************************************************************/</span>

<span class="k">struct</span> <span class="n">hso_shared_int</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">intr_endp</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">shared_intr_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">shared_intr_urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">use_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ref_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">shared_int_lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hso_net</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">in_endp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">out_endp</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">mux_bulk_rx_urb_pool</span><span class="p">[</span><span class="n">MUX_BULK_RX_BUF_COUNT</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">mux_bulk_tx_urb</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">mux_bulk_rx_buf_pool</span><span class="p">[</span><span class="n">MUX_BULK_RX_BUF_COUNT</span><span class="p">];</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">mux_bulk_tx_buf</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb_rx_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb_tx_buf</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">pkt_parse_state</span> <span class="n">rx_parse_state</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">net_lock</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">rx_buf_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">rx_buf_missing</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iphdr</span> <span class="n">rx_ip_hdr</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">rx_ctrl_state</span><span class="p">{</span>
	<span class="n">RX_IDLE</span><span class="p">,</span>
	<span class="n">RX_SENT</span><span class="p">,</span>
	<span class="n">RX_PENDING</span>
<span class="p">};</span>

<span class="cp">#define BM_REQUEST_TYPE (0xa1)</span>
<span class="cp">#define B_NOTIFICATION  (0x20)</span>
<span class="cp">#define W_VALUE         (0x0)</span>
<span class="cp">#define W_INDEX         (0x2)</span>
<span class="cp">#define W_LENGTH        (0x2)</span>

<span class="cp">#define B_OVERRUN       (0x1&lt;&lt;6)</span>
<span class="cp">#define B_PARITY        (0x1&lt;&lt;5)</span>
<span class="cp">#define B_FRAMING       (0x1&lt;&lt;4)</span>
<span class="cp">#define B_RING_SIGNAL   (0x1&lt;&lt;3)</span>
<span class="cp">#define B_BREAK         (0x1&lt;&lt;2)</span>
<span class="cp">#define B_TX_CARRIER    (0x1&lt;&lt;1)</span>
<span class="cp">#define B_RX_CARRIER    (0x1&lt;&lt;0)</span>

<span class="k">struct</span> <span class="n">hso_serial_state_notification</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">bmRequestType</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bNotification</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">wValue</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">wIndex</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">wLength</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">UART_state_bitmap</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">hso_tiocmget</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">waitq</span><span class="p">;</span>
	<span class="kt">int</span>    <span class="n">intr_completed</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">endp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hso_serial_state_notification</span> <span class="n">serial_state_notification</span><span class="p">;</span>
	<span class="n">u16</span>    <span class="n">prev_UART_state_bitmap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_icount</span> <span class="n">icount</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">hso_serial</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">magic</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">minor</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">hso_shared_int</span> <span class="o">*</span><span class="n">shared_int</span><span class="p">;</span>

	<span class="cm">/* rx/tx urb could be either a bulk urb or a control urb depending</span>
<span class="cm">	   on which serial port it is used on. */</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">rx_urb</span><span class="p">[</span><span class="n">MAX_RX_URBS</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">num_rx_urbs</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">rx_data</span><span class="p">[</span><span class="n">MAX_RX_URBS</span><span class="p">];</span>
	<span class="n">u16</span> <span class="n">rx_data_length</span><span class="p">;</span>	<span class="cm">/* should contain allocated length */</span>

	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">tx_urb</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">tx_data</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">tx_buffer</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tx_data_length</span><span class="p">;</span>	<span class="cm">/* should contain allocated length */</span>
	<span class="n">u16</span> <span class="n">tx_data_count</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tx_buffer_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="n">ctrl_req_tx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="n">ctrl_req_rx</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">in_endp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">out_endp</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">rx_ctrl_state</span> <span class="n">rx_state</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">rts_state</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">dtr_state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">tx_urb_used</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">tty_port</span> <span class="n">port</span><span class="p">;</span>
	<span class="cm">/* from usb_serial_port */</span>
	<span class="n">spinlock_t</span> <span class="n">serial_lock</span><span class="p">;</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_data</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hso_tiocmget</span>  <span class="o">*</span><span class="n">tiocmget</span><span class="p">;</span>
	<span class="cm">/* Hacks required to get flow control</span>
<span class="cm">	 * working on the serial receive buffers</span>
<span class="cm">	 * so as not to drop characters on the floor.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>  <span class="n">curr_rx_urb_idx</span><span class="p">;</span>
	<span class="n">u16</span>  <span class="n">curr_rx_urb_offset</span><span class="p">;</span>
	<span class="n">u8</span>   <span class="n">rx_urb_filled</span><span class="p">[</span><span class="n">MAX_RX_URBS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">unthrottle_tasklet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span>    <span class="n">retry_unthrottle_workqueue</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hso_device</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">dev_serial</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">hso_net</span> <span class="o">*</span><span class="n">dev_net</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">port_data</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">port_spec</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">is_active</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">usb_gone</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">async_get_intf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">async_put_intf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">reset_device</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Type of interface */</span>
<span class="cp">#define HSO_INTF_MASK		0xFF00</span>
<span class="cp">#define	HSO_INTF_MUX		0x0100</span>
<span class="cp">#define	HSO_INTF_BULK   	0x0200</span>

<span class="cm">/* Type of port */</span>
<span class="cp">#define HSO_PORT_MASK		0xFF</span>
<span class="cp">#define HSO_PORT_NO_PORT	0x0</span>
<span class="cp">#define	HSO_PORT_CONTROL	0x1</span>
<span class="cp">#define	HSO_PORT_APP		0x2</span>
<span class="cp">#define	HSO_PORT_GPS		0x3</span>
<span class="cp">#define	HSO_PORT_PCSC		0x4</span>
<span class="cp">#define	HSO_PORT_APP2		0x5</span>
<span class="cp">#define HSO_PORT_GPS_CONTROL	0x6</span>
<span class="cp">#define HSO_PORT_MSD		0x7</span>
<span class="cp">#define HSO_PORT_VOICE		0x8</span>
<span class="cp">#define HSO_PORT_DIAG2		0x9</span>
<span class="cp">#define	HSO_PORT_DIAG		0x10</span>
<span class="cp">#define	HSO_PORT_MODEM		0x11</span>
<span class="cp">#define	HSO_PORT_NETWORK	0x12</span>

<span class="cm">/* Additional device info */</span>
<span class="cp">#define HSO_INFO_MASK		0xFF000000</span>
<span class="cp">#define HSO_INFO_CRC_BUG	0x01000000</span>

<span class="cm">/*****************************************************************************/</span>
<span class="cm">/* Prototypes                                                                */</span>
<span class="cm">/*****************************************************************************/</span>
<span class="cm">/* Serial driver functions */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hso_serial_tiocmset</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">set</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clear</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ctrl_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">put_rxbuf_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hso_kick_transmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">);</span>
<span class="cm">/* Helper functions */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hso_mux_submit_intr_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_shared_int</span> <span class="o">*</span><span class="n">mux_int</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">handle_usb_error</span><span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">function</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">hso_get_ep</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span>
						  <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hso_get_mux_ports</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ports</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hso_free_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hso_start_serial_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hso_stop_serial_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hso_start_net_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hso_free_shared_int</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_shared_int</span> <span class="o">*</span><span class="n">shared_int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hso_stop_net_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hso_serial_ref_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">ref</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hso_std_serial_read_bulk_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hso_mux_serial_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">async_get_intf</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">async_put_intf</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hso_put_activity</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hso_get_activity</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">tiocmget_intr_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">reset_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="cm">/*****************************************************************************/</span>
<span class="cm">/* Helping functions                                                         */</span>
<span class="cm">/*****************************************************************************/</span>

<span class="cm">/* #define DEBUG */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">hso_net</span> <span class="o">*</span><span class="nf">dev2net</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">port_data</span><span class="p">.</span><span class="n">dev_net</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="nf">dev2ser</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">port_data</span><span class="p">.</span><span class="n">dev_serial</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Debugging functions */</span>
<span class="cp">#ifdef DEBUG</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dbg_dump</span><span class="p">(</span><span class="kt">int</span> <span class="n">line_count</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">func_name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">255</span><span class="p">];</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;hso[%d:%s]&quot;</span><span class="p">,</span> <span class="n">line_count</span><span class="p">,</span> <span class="n">func_name</span><span class="p">);</span>
	<span class="n">print_hex_dump_bytes</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">DUMP_PREFIX_NONE</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define DUMP(buf_, len_)	\</span>
<span class="cp">	dbg_dump(__LINE__, __func__, (unsigned char *)buf_, len_)</span>

<span class="cp">#define DUMP1(buf_, len_)			\</span>
<span class="cp">	do {					\</span>
<span class="cp">		if (0x01 &amp; debug)		\</span>
<span class="cp">			DUMP(buf_, len_);	\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#else</span>
<span class="cp">#define DUMP(buf_, len_)</span>
<span class="cp">#define DUMP1(buf_, len_)</span>
<span class="cp">#endif</span>

<span class="cm">/* module parameters */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">debug</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">tty_major</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">disable_net</span><span class="p">;</span>

<span class="cm">/* driver info */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">driver_name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;hso&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">tty_filename</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;ttyHS&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">version</span> <span class="o">=</span> <span class="n">__FILE__</span> <span class="s">&quot;: &quot;</span> <span class="n">MOD_AUTHOR</span><span class="p">;</span>
<span class="cm">/* the usb driver itself (registered in hso_init) */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_driver</span> <span class="n">hso_driver</span><span class="p">;</span>
<span class="cm">/* serial structures */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">tty_drv</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">serial_table</span><span class="p">[</span><span class="n">HSO_SERIAL_TTY_MINORS</span><span class="p">];</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">network_table</span><span class="p">[</span><span class="n">HSO_MAX_NET_DEVICES</span><span class="p">];</span>
<span class="k">static</span> <span class="n">spinlock_t</span> <span class="n">serial_table_lock</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">s32</span> <span class="n">default_port_spec</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">HSO_INTF_MUX</span> <span class="o">|</span> <span class="n">HSO_PORT_NETWORK</span><span class="p">,</span>
	<span class="n">HSO_INTF_BULK</span> <span class="o">|</span> <span class="n">HSO_PORT_DIAG</span><span class="p">,</span>
	<span class="n">HSO_INTF_BULK</span> <span class="o">|</span> <span class="n">HSO_PORT_MODEM</span><span class="p">,</span>
	<span class="mi">0</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">s32</span> <span class="n">icon321_port_spec</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">HSO_INTF_MUX</span> <span class="o">|</span> <span class="n">HSO_PORT_NETWORK</span><span class="p">,</span>
	<span class="n">HSO_INTF_BULK</span> <span class="o">|</span> <span class="n">HSO_PORT_DIAG2</span><span class="p">,</span>
	<span class="n">HSO_INTF_BULK</span> <span class="o">|</span> <span class="n">HSO_PORT_MODEM</span><span class="p">,</span>
	<span class="n">HSO_INTF_BULK</span> <span class="o">|</span> <span class="n">HSO_PORT_DIAG</span><span class="p">,</span>
	<span class="mi">0</span>
<span class="p">};</span>

<span class="cp">#define default_port_device(vendor, product)	\</span>
<span class="cp">	USB_DEVICE(vendor, product),	\</span>
<span class="cp">		.driver_info = (kernel_ulong_t)default_port_spec</span>

<span class="cp">#define icon321_port_device(vendor, product)	\</span>
<span class="cp">	USB_DEVICE(vendor, product),	\</span>
<span class="cp">		.driver_info = (kernel_ulong_t)icon321_port_spec</span>

<span class="cm">/* list of devices we support */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="n">hso_ids</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">default_port_device</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x6711</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">default_port_device</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x6731</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">default_port_device</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x6751</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">default_port_device</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x6771</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">default_port_device</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x6791</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">default_port_device</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x6811</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">default_port_device</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x6911</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">default_port_device</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x6951</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">default_port_device</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x6971</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">default_port_device</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x7011</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">default_port_device</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x7031</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">default_port_device</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x7051</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">default_port_device</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x7071</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">default_port_device</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x7111</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">default_port_device</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x7211</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">default_port_device</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x7251</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">default_port_device</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x7271</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">default_port_device</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x7311</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">default_port_device</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0xc031</span><span class="p">)},</span>	<span class="cm">/* Icon-Edge */</span>
	<span class="p">{</span><span class="n">icon321_port_device</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0xd013</span><span class="p">)},</span>	<span class="cm">/* Module HSxPA */</span>
	<span class="p">{</span><span class="n">icon321_port_device</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0xd031</span><span class="p">)},</span>	<span class="cm">/* Icon-321 */</span>
	<span class="p">{</span><span class="n">icon321_port_device</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0xd033</span><span class="p">)},</span>	<span class="cm">/* Icon-322 */</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x7301</span><span class="p">)},</span>		<span class="cm">/* GE40x */</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x7361</span><span class="p">)},</span>		<span class="cm">/* GE40x */</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x7381</span><span class="p">)},</span>		<span class="cm">/* GE40x */</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x7401</span><span class="p">)},</span>		<span class="cm">/* GI 0401 */</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x7501</span><span class="p">)},</span>		<span class="cm">/* GTM 382 */</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x7601</span><span class="p">)},</span>		<span class="cm">/* GE40x */</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x7701</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x7706</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x7801</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x7901</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x7A01</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x7A05</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x8200</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x8201</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x8300</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x8302</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x8304</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x8400</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x8600</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x8800</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x8900</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0x9000</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0xd035</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0xd055</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0xd155</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0xd255</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0xd057</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0xd157</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0xd257</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0xd357</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0xd058</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0af0</span><span class="p">,</span> <span class="mh">0xc100</span><span class="p">)},</span>
	<span class="p">{}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">usb</span><span class="p">,</span> <span class="n">hso_ids</span><span class="p">);</span>

<span class="cm">/* Sysfs attribute */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">hso_sysfs_show_porttype</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				       <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">port_name</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hso_dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">port_spec</span> <span class="o">&amp;</span> <span class="n">HSO_PORT_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HSO_PORT_CONTROL</span>:
		<span class="n">port_name</span> <span class="o">=</span> <span class="s">&quot;Control&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HSO_PORT_APP</span>:
		<span class="n">port_name</span> <span class="o">=</span> <span class="s">&quot;Application&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HSO_PORT_APP2</span>:
		<span class="n">port_name</span> <span class="o">=</span> <span class="s">&quot;Application2&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HSO_PORT_GPS</span>:
		<span class="n">port_name</span> <span class="o">=</span> <span class="s">&quot;GPS&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HSO_PORT_GPS_CONTROL</span>:
		<span class="n">port_name</span> <span class="o">=</span> <span class="s">&quot;GPS Control&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HSO_PORT_PCSC</span>:
		<span class="n">port_name</span> <span class="o">=</span> <span class="s">&quot;PCSC&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HSO_PORT_DIAG</span>:
		<span class="n">port_name</span> <span class="o">=</span> <span class="s">&quot;Diagnostic&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HSO_PORT_DIAG2</span>:
		<span class="n">port_name</span> <span class="o">=</span> <span class="s">&quot;Diagnostic2&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HSO_PORT_MODEM</span>:
		<span class="n">port_name</span> <span class="o">=</span> <span class="s">&quot;Modem&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HSO_PORT_NETWORK</span>:
		<span class="n">port_name</span> <span class="o">=</span> <span class="s">&quot;Network&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">port_name</span> <span class="o">=</span> <span class="s">&quot;Unknown&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port_name</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">hsotype</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">hso_sysfs_show_porttype</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_urb_to_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">num_rx_urbs</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">urb</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">idx</span><span class="p">;</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;hso_urb_to_index failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* converts mux value to a port spec value */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">hso_mux_to_port</span><span class="p">(</span><span class="kt">int</span> <span class="n">mux</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mux</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x1</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">HSO_PORT_CONTROL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x2</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">HSO_PORT_APP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x4</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">HSO_PORT_PCSC</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x8</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">HSO_PORT_GPS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x10</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">HSO_PORT_APP2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">HSO_PORT_NO_PORT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* converts port spec value to a mux value */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">hso_port_to_mux</span><span class="p">(</span><span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">port</span> <span class="o">&amp;</span> <span class="n">HSO_PORT_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HSO_PORT_CONTROL</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HSO_PORT_APP</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HSO_PORT_PCSC</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HSO_PORT_GPS</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="mh">0x3</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HSO_PORT_APP2</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="mh">0x4</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">result</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="nf">get_serial_by_shared_int_and_type</span><span class="p">(</span>
					<span class="k">struct</span> <span class="n">hso_shared_int</span> <span class="o">*</span><span class="n">shared_int</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">mux</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">port</span><span class="p">;</span>

	<span class="n">port</span> <span class="o">=</span> <span class="n">hso_mux_to_port</span><span class="p">(</span><span class="n">mux</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HSO_SERIAL_TTY_MINORS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">serial_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">dev2ser</span><span class="p">(</span><span class="n">serial_table</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">shared_int</span> <span class="o">==</span> <span class="n">shared_int</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">((</span><span class="n">serial_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">port_spec</span> <span class="o">&amp;</span> <span class="n">HSO_PORT_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">port</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">dev2ser</span><span class="p">(</span><span class="n">serial_table</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="nf">get_serial_by_index</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial_table_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">serial_table</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
		<span class="n">serial</span> <span class="o">=</span> <span class="n">dev2ser</span><span class="p">(</span><span class="n">serial_table</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial_table_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">serial</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_free_serial_index</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial_table_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">HSO_SERIAL_TTY_MINORS</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">serial_table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial_table_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">index</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial_table_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: no free serial devices in table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_serial_by_index</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">index</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial_table_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">serial</span><span class="p">)</span>
		<span class="n">serial_table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">serial_table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial_table_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_usb_error</span><span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">function</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">explanation</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ENODEV</span>:
		<span class="n">explanation</span> <span class="o">=</span> <span class="s">&quot;no device&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ENOENT</span>:
		<span class="n">explanation</span> <span class="o">=</span> <span class="s">&quot;endpoint not enabled&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EPIPE</span>:
		<span class="n">explanation</span> <span class="o">=</span> <span class="s">&quot;endpoint stalled&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ENOSPC</span>:
		<span class="n">explanation</span> <span class="o">=</span> <span class="s">&quot;not enough bandwidth&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ESHUTDOWN</span>:
		<span class="n">explanation</span> <span class="o">=</span> <span class="s">&quot;device disabled&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EHOSTUNREACH</span>:
		<span class="n">explanation</span> <span class="o">=</span> <span class="s">&quot;device suspended&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EINVAL</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">EAGAIN</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">EFBIG</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">EMSGSIZE</span>:
		<span class="n">explanation</span> <span class="o">=</span> <span class="s">&quot;internal error&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EILSEQ</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">EPROTO</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ETIME</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ETIMEDOUT</span>:
		<span class="n">explanation</span> <span class="o">=</span> <span class="s">&quot;protocol error&quot;</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hso_dev</span><span class="p">)</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">reset_device</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">explanation</span> <span class="o">=</span> <span class="s">&quot;unknown status&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* log a meaningful explanation of an USB status */</span>
	<span class="n">D1</span><span class="p">(</span><span class="s">&quot;%s: received USB status - %s (%d)&quot;</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">explanation</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Network interface functions */</span>

<span class="cm">/* called when net interface is brought up by ifconfig */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_net_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_net</span> <span class="o">*</span><span class="n">odev</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">odev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No net device !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">odev</span><span class="o">-&gt;</span><span class="n">skb_tx_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* setup environment */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">net_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_parse_state</span> <span class="o">=</span> <span class="n">WAIT_IP</span><span class="p">;</span>
	<span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_buf_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_buf_missing</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">net_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* We are up and running. */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">HSO_NET_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">hso_start_net_device</span><span class="p">(</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>

	<span class="cm">/* Tell the kernel we are ready to start receiving from it */</span>
	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* called when interface is brought down by ifconfig */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_net_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_net</span> <span class="o">*</span><span class="n">odev</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

	<span class="cm">/* we don&#39;t need the queue anymore */</span>
	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="cm">/* no longer running */</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">HSO_NET_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">hso_stop_net_device</span><span class="p">(</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>

	<span class="cm">/* done */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* USB tells is xmit done, we should start the netqueue again */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">write_bulk_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_net</span> <span class="o">*</span><span class="n">odev</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>

	<span class="cm">/* Sanity check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">odev</span> <span class="o">||</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">HSO_NET_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: device not running</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Do we still have a valid kernel network device? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_device_present</span><span class="p">(</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: net device not present</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* log status, but don&#39;t act on it, we don&#39;t need to resubmit anything</span>
<span class="cm">	 * anyhow */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">handle_usb_error</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">odev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>

	<span class="n">hso_put_activity</span><span class="p">(</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>

	<span class="cm">/* Tell the network interface we are ready for another frame */</span>
	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* called by kernel when we need to transmit a packet */</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">hso_net_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_net</span> <span class="o">*</span><span class="n">odev</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* Tell the kernel, &quot;No more frames &#39;til we are done with this one.&quot; */</span>
	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hso_get_activity</span><span class="p">(</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">odev</span><span class="o">-&gt;</span><span class="n">skb_tx_buf</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* log if asked */</span>
	<span class="n">DUMP1</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="cm">/* Copy it from kernel memory to OUR memory */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">mux_bulk_tx_buf</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">D1</span><span class="p">(</span><span class="s">&quot;len: %d/%d&quot;</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">MUX_BULK_TX_BUF_SIZE</span><span class="p">);</span>

	<span class="cm">/* Fill in the URB for shipping it out. */</span>
	<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">mux_bulk_tx_urb</span><span class="p">,</span>
			  <span class="n">odev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span>
			  <span class="n">usb_sndbulkpipe</span><span class="p">(</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span>
					  <span class="n">odev</span><span class="o">-&gt;</span><span class="n">out_endp</span><span class="o">-&gt;</span>
					  <span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">),</span>
			  <span class="n">odev</span><span class="o">-&gt;</span><span class="n">mux_bulk_tx_buf</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">write_bulk_callback</span><span class="p">,</span>
			  <span class="n">odev</span><span class="p">);</span>

	<span class="cm">/* Deal with the Zero Length packet problem, I hope */</span>
	<span class="n">odev</span><span class="o">-&gt;</span><span class="n">mux_bulk_tx_urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">|=</span> <span class="n">URB_ZERO_PACKET</span><span class="p">;</span>

	<span class="cm">/* Send the URB on its merry way. */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">mux_bulk_tx_urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;failed mux_bulk_tx_urb %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
		<span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="cm">/* we&#39;re done */</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ethtool_ops</span> <span class="n">ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_link</span> <span class="o">=</span> <span class="n">ethtool_op_get_link</span>
<span class="p">};</span>

<span class="cm">/* called when a packet did not ack after watchdogtimeout */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hso_net_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_net</span> <span class="o">*</span><span class="n">odev</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">odev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Tell syslog we are hosed. */</span>
	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Tx timed out.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Tear the waiting frame off the list */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">mux_bulk_tx_urb</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">mux_bulk_tx_urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">usb_unlink_urb</span><span class="p">(</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">mux_bulk_tx_urb</span><span class="p">);</span>

	<span class="cm">/* Update statistics */</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* make a real packet from the received USB buffer */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">packetizeRx</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_net</span> <span class="o">*</span><span class="n">odev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ip_pkt</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">is_eop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">temp_bytes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">buffer_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">frame_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tmp_rx_buf</span><span class="p">;</span>

	<span class="cm">/* log if needed */</span>
	<span class="n">D1</span><span class="p">(</span><span class="s">&quot;Rx %d bytes&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">DUMP</span><span class="p">(</span><span class="n">ip_pkt</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">count</span><span class="p">));</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_parse_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">WAIT_IP</span>:
			<span class="cm">/* waiting for IP header. */</span>
			<span class="cm">/* wanted bytes - size of ip header */</span>
			<span class="n">temp_bytes</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span>
			     <span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_buf_missing</span><span class="p">)</span> <span class="o">?</span> <span class="n">count</span> <span class="o">:</span> <span class="n">odev</span><span class="o">-&gt;</span>
			    <span class="n">rx_buf_missing</span><span class="p">;</span>

			<span class="n">memcpy</span><span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_ip_hdr</span><span class="p">))</span> <span class="o">+</span>
			       <span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_buf_size</span><span class="p">,</span> <span class="n">ip_pkt</span> <span class="o">+</span> <span class="n">buffer_offset</span><span class="p">,</span>
			       <span class="n">temp_bytes</span><span class="p">);</span>

			<span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_buf_size</span> <span class="o">+=</span> <span class="n">temp_bytes</span><span class="p">;</span>
			<span class="n">buffer_offset</span> <span class="o">+=</span> <span class="n">temp_bytes</span><span class="p">;</span>
			<span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_buf_missing</span> <span class="o">-=</span> <span class="n">temp_bytes</span><span class="p">;</span>
			<span class="n">count</span> <span class="o">-=</span> <span class="n">temp_bytes</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_buf_missing</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* header is complete allocate an sk_buffer and</span>
<span class="cm">				 * continue to WAIT_DATA */</span>
				<span class="n">frame_len</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_ip_hdr</span><span class="p">.</span><span class="n">tot_len</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">((</span><span class="n">frame_len</span> <span class="o">&gt;</span> <span class="n">DEFAULT_MRU</span><span class="p">)</span> <span class="o">||</span>
				    <span class="p">(</span><span class="n">frame_len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span><span class="p">)))</span> <span class="p">{</span>
					<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						<span class="s">&quot;Invalid frame (%d) length</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">frame_len</span><span class="p">);</span>
					<span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_parse_state</span> <span class="o">=</span> <span class="n">WAIT_SYNC</span><span class="p">;</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="cm">/* Allocate an sk_buff */</span>
				<span class="n">odev</span><span class="o">-&gt;</span><span class="n">skb_rx_buf</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span>
								    <span class="n">frame_len</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">skb_rx_buf</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* We got no receive buffer. */</span>
					<span class="n">D1</span><span class="p">(</span><span class="s">&quot;could not allocate memory&quot;</span><span class="p">);</span>
					<span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_parse_state</span> <span class="o">=</span> <span class="n">WAIT_SYNC</span><span class="p">;</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/* Copy what we got so far. make room for iphdr</span>
<span class="cm">				 * after tail. */</span>
				<span class="n">tmp_rx_buf</span> <span class="o">=</span>
				    <span class="n">skb_put</span><span class="p">(</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">skb_rx_buf</span><span class="p">,</span>
					    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span><span class="p">));</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">tmp_rx_buf</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_ip_hdr</span><span class="p">),</span>
				       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span><span class="p">));</span>

				<span class="cm">/* ETH_HLEN */</span>
				<span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_buf_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span><span class="p">);</span>

				<span class="cm">/* Filip actually use .tot_len */</span>
				<span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_buf_missing</span> <span class="o">=</span>
				    <span class="n">frame_len</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span><span class="p">);</span>
				<span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_parse_state</span> <span class="o">=</span> <span class="n">WAIT_DATA</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">WAIT_DATA</span>:
			<span class="n">temp_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_buf_missing</span><span class="p">)</span>
					<span class="o">?</span> <span class="n">count</span> <span class="o">:</span> <span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_buf_missing</span><span class="p">;</span>

			<span class="cm">/* Copy the rest of the bytes that are left in the</span>
<span class="cm">			 * buffer into the waiting sk_buf. */</span>
			<span class="cm">/* Make room for temp_bytes after tail. */</span>
			<span class="n">tmp_rx_buf</span> <span class="o">=</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">skb_rx_buf</span><span class="p">,</span> <span class="n">temp_bytes</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">tmp_rx_buf</span><span class="p">,</span> <span class="n">ip_pkt</span> <span class="o">+</span> <span class="n">buffer_offset</span><span class="p">,</span> <span class="n">temp_bytes</span><span class="p">);</span>

			<span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_buf_missing</span> <span class="o">-=</span> <span class="n">temp_bytes</span><span class="p">;</span>
			<span class="n">count</span> <span class="o">-=</span> <span class="n">temp_bytes</span><span class="p">;</span>
			<span class="n">buffer_offset</span> <span class="o">+=</span> <span class="n">temp_bytes</span><span class="p">;</span>
			<span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_buf_size</span> <span class="o">+=</span> <span class="n">temp_bytes</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_buf_missing</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Packet is complete. Inject into stack. */</span>
				<span class="cm">/* We have IP packet here */</span>
				<span class="n">odev</span><span class="o">-&gt;</span><span class="n">skb_rx_buf</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">);</span>
				<span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">skb_rx_buf</span><span class="p">);</span>

				<span class="cm">/* Ship it off to the kernel */</span>
				<span class="n">netif_rx</span><span class="p">(</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">skb_rx_buf</span><span class="p">);</span>
				<span class="cm">/* No longer our buffer. */</span>
				<span class="n">odev</span><span class="o">-&gt;</span><span class="n">skb_rx_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

				<span class="cm">/* update out statistics */</span>
				<span class="n">odev</span><span class="o">-&gt;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>

				<span class="n">odev</span><span class="o">-&gt;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_buf_size</span><span class="p">;</span>

				<span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_buf_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_buf_missing</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span><span class="p">);</span>
				<span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_parse_state</span> <span class="o">=</span> <span class="n">WAIT_IP</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">WAIT_SYNC</span>:
			<span class="n">D1</span><span class="p">(</span><span class="s">&quot; W_S&quot;</span><span class="p">);</span>
			<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">D1</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">);</span>
			<span class="n">count</span><span class="o">--</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Recovery mechanism for WAIT_SYNC state. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_eop</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_parse_state</span> <span class="o">==</span> <span class="n">WAIT_SYNC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_parse_state</span> <span class="o">=</span> <span class="n">WAIT_IP</span><span class="p">;</span>
			<span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_buf_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">odev</span><span class="o">-&gt;</span><span class="n">rx_buf_missing</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fix_crc_bug</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="n">__le16</span> <span class="n">max_packet_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">crc_check</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xDE</span><span class="p">,</span> <span class="mh">0xAD</span><span class="p">,</span> <span class="mh">0xBE</span><span class="p">,</span> <span class="mh">0xEF</span> <span class="p">};</span>
	<span class="n">u32</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">%</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">max_packet_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">rest</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">rest</span> <span class="o">==</span> <span class="mi">6</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">memcmp</span><span class="p">(((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">)</span> <span class="o">+</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span>
		    <span class="n">crc_check</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Moving data from usb to kernel (in interrupt state) */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">read_bulk_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_net</span> <span class="o">*</span><span class="n">odev</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>

	<span class="cm">/* is al ok?  (Filip: Who&#39;s Al ?) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">handle_usb_error</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">odev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Sanity check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">odev</span> <span class="o">||</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">HSO_NET_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">D1</span><span class="p">(</span><span class="s">&quot;BULK IN callback but driver is not active!&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">usb_mark_last_busy</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">net</span> <span class="o">=</span> <span class="n">odev</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_device_present</span><span class="p">(</span><span class="n">net</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Somebody killed our network interface... */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">port_spec</span> <span class="o">&amp;</span> <span class="n">HSO_INFO_CRC_BUG</span><span class="p">)</span>
		<span class="n">fix_crc_bug</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">odev</span><span class="o">-&gt;</span><span class="n">in_endp</span><span class="o">-&gt;</span><span class="n">wMaxPacketSize</span><span class="p">);</span>

	<span class="cm">/* do we even have a packet? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Handle the IP stream, add header and push it onto network</span>
<span class="cm">		 * stack if the packet is complete. */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">net_lock</span><span class="p">);</span>
		<span class="n">packetizeRx</span><span class="p">(</span><span class="n">odev</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">,</span>
			    <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">&gt;</span>
			     <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">net_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* We are done with this URB, resubmit it. Prep the USB to wait for</span>
<span class="cm">	 * another frame. Reuse same as received. */</span>
	<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span>
			  <span class="n">odev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span>
			  <span class="n">usb_rcvbulkpipe</span><span class="p">(</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span>
					  <span class="n">odev</span><span class="o">-&gt;</span><span class="n">in_endp</span><span class="o">-&gt;</span>
					  <span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">),</span>
			  <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span> <span class="n">MUX_BULK_RX_BUF_SIZE</span><span class="p">,</span>
			  <span class="n">read_bulk_callback</span><span class="p">,</span> <span class="n">odev</span><span class="p">);</span>

	<span class="cm">/* Give this to the USB subsystem so it can tell us when more data</span>
<span class="cm">	 * arrives. */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">odev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;%s failed submit mux_bulk_rx_urb %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			 <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Serial driver functions */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hso_init_termios</span><span class="p">(</span><span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">termios</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The default requirements for this device are:</span>
<span class="cm">	 */</span>
	<span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_iflag</span> <span class="o">&amp;=</span>
		<span class="o">~</span><span class="p">(</span><span class="n">IGNBRK</span>	<span class="cm">/* disable ignore break */</span>
		<span class="o">|</span> <span class="n">BRKINT</span>	<span class="cm">/* disable break causes interrupt */</span>
		<span class="o">|</span> <span class="n">PARMRK</span>	<span class="cm">/* disable mark parity errors */</span>
		<span class="o">|</span> <span class="n">ISTRIP</span>	<span class="cm">/* disable clear high bit of input characters */</span>
		<span class="o">|</span> <span class="n">INLCR</span>		<span class="cm">/* disable translate NL to CR */</span>
		<span class="o">|</span> <span class="n">IGNCR</span>		<span class="cm">/* disable ignore CR */</span>
		<span class="o">|</span> <span class="n">ICRNL</span>		<span class="cm">/* disable translate CR to NL */</span>
		<span class="o">|</span> <span class="n">IXON</span><span class="p">);</span>	<span class="cm">/* disable enable XON/XOFF flow control */</span>

	<span class="cm">/* disable postprocess output characters */</span>
	<span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_oflag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">OPOST</span><span class="p">;</span>

	<span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_lflag</span> <span class="o">&amp;=</span>
		<span class="o">~</span><span class="p">(</span><span class="n">ECHO</span>		<span class="cm">/* disable echo input characters */</span>
		<span class="o">|</span> <span class="n">ECHONL</span>	<span class="cm">/* disable echo new line */</span>
		<span class="o">|</span> <span class="n">ICANON</span>	<span class="cm">/* disable erase, kill, werase, and rprnt</span>
<span class="cm">				   special characters */</span>
		<span class="o">|</span> <span class="n">ISIG</span>		<span class="cm">/* disable interrupt, quit, and suspend special</span>
<span class="cm">				   characters */</span>
		<span class="o">|</span> <span class="n">IEXTEN</span><span class="p">);</span>	<span class="cm">/* disable non-POSIX special characters */</span>

	<span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;=</span>
		<span class="o">~</span><span class="p">(</span><span class="n">CSIZE</span>		<span class="cm">/* no size */</span>
		<span class="o">|</span> <span class="n">PARENB</span>	<span class="cm">/* disable parity bit */</span>
		<span class="o">|</span> <span class="n">CBAUD</span>		<span class="cm">/* clear current baud rate */</span>
		<span class="o">|</span> <span class="n">CBAUDEX</span><span class="p">);</span>	<span class="cm">/* clear current buad rate */</span>

	<span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">|=</span> <span class="n">CS8</span><span class="p">;</span>	<span class="cm">/* character size 8 bits */</span>

	<span class="cm">/* baud rate 115200 */</span>
	<span class="n">tty_termios_encode_baud_rate</span><span class="p">(</span><span class="n">termios</span><span class="p">,</span> <span class="mi">115200</span><span class="p">,</span> <span class="mi">115200</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_hso_serial_set_termios</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">old</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">termios</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serial</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: no tty structures&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">D4</span><span class="p">(</span><span class="s">&quot;port %d&quot;</span><span class="p">,</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Fix up unsupported bits</span>
<span class="cm">	 */</span>
	<span class="n">termios</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="p">;</span>
	<span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_iflag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXON</span><span class="p">;</span> <span class="cm">/* disable enable XON/XOFF flow control */</span>

	<span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;=</span>
		<span class="o">~</span><span class="p">(</span><span class="n">CSIZE</span>		<span class="cm">/* no size */</span>
		<span class="o">|</span> <span class="n">PARENB</span>	<span class="cm">/* disable parity bit */</span>
		<span class="o">|</span> <span class="n">CBAUD</span>		<span class="cm">/* clear current baud rate */</span>
		<span class="o">|</span> <span class="n">CBAUDEX</span><span class="p">);</span>	<span class="cm">/* clear current buad rate */</span>

	<span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">|=</span> <span class="n">CS8</span><span class="p">;</span>	<span class="cm">/* character size 8 bits */</span>

	<span class="cm">/* baud rate 115200 */</span>
	<span class="n">tty_encode_baud_rate</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="mi">115200</span><span class="p">,</span> <span class="mi">115200</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hso_resubmit_rx_bulk_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="cm">/* We are done with this URB, resubmit it. Prep the USB to wait for</span>
<span class="cm">	 * another frame */</span>
	<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span>
			  <span class="n">usb_rcvbulkpipe</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span>
					  <span class="n">serial</span><span class="o">-&gt;</span><span class="n">in_endp</span><span class="o">-&gt;</span>
					  <span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">),</span>
			  <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_data_length</span><span class="p">,</span>
			  <span class="n">hso_std_serial_read_bulk_callback</span><span class="p">,</span> <span class="n">serial</span><span class="p">);</span>
	<span class="cm">/* Give this to the USB subsystem so it can tell us when more data</span>
<span class="cm">	 * arrives. */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s failed submit serial rx_urb %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>




<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_rxbuf_data_and_resubmit_bulk_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">curr_urb</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_urb_filled</span><span class="p">[</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">curr_rx_urb_idx</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">curr_urb</span> <span class="o">=</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">[</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">curr_rx_urb_idx</span><span class="p">];</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">put_rxbuf_data</span><span class="p">(</span><span class="n">curr_urb</span><span class="p">,</span> <span class="n">serial</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">serial</span><span class="o">-&gt;</span><span class="n">curr_rx_urb_idx</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">curr_rx_urb_idx</span> <span class="o">&gt;=</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">num_rx_urbs</span><span class="p">)</span>
				<span class="n">serial</span><span class="o">-&gt;</span><span class="n">curr_rx_urb_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">hso_resubmit_rx_bulk_urb</span><span class="p">(</span><span class="n">serial</span><span class="p">,</span> <span class="n">curr_urb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_rxbuf_data_and_resubmit_ctrl_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>

	<span class="n">urb</span> <span class="o">=</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">put_rxbuf_data</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">serial</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Re issue a read as long as we receive data. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
			   <span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_state</span> <span class="o">==</span> <span class="n">RX_PENDING</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_state</span> <span class="o">=</span> <span class="n">RX_SENT</span><span class="p">;</span>
		<span class="n">hso_mux_serial_read</span><span class="p">(</span><span class="n">serial</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_state</span> <span class="o">=</span> <span class="n">RX_IDLE</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* read callback for Diag and CS port */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hso_std_serial_read_bulk_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>

	<span class="cm">/* sanity check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serial</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">D1</span><span class="p">(</span><span class="s">&quot;serial == NULL&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">handle_usb_error</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">D4</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">--- Got serial_read_bulk callback %02x ---&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">D1</span><span class="p">(</span><span class="s">&quot;Actual length = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>
	<span class="n">DUMP1</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>

	<span class="cm">/* Anyone listening? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">port_spec</span> <span class="o">&amp;</span> <span class="n">HSO_INFO_CRC_BUG</span><span class="p">)</span>
			<span class="n">fix_crc_bug</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">in_endp</span><span class="o">-&gt;</span><span class="n">wMaxPacketSize</span><span class="p">);</span>
		<span class="cm">/* Valid data, handle RX data */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">);</span>
		<span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_urb_filled</span><span class="p">[</span><span class="n">hso_urb_to_index</span><span class="p">(</span><span class="n">serial</span><span class="p">,</span> <span class="n">urb</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">put_rxbuf_data_and_resubmit_bulk_urb</span><span class="p">(</span><span class="n">serial</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span> <span class="o">||</span> <span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Unlinked - check for throttled port. */</span>
		<span class="n">D2</span><span class="p">(</span><span class="s">&quot;Port %d, successfully unlinked urb&quot;</span><span class="p">,</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">);</span>
		<span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_urb_filled</span><span class="p">[</span><span class="n">hso_urb_to_index</span><span class="p">(</span><span class="n">serial</span><span class="p">,</span> <span class="n">urb</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">hso_resubmit_rx_bulk_urb</span><span class="p">(</span><span class="n">serial</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">D2</span><span class="p">(</span><span class="s">&quot;Port %d, status = %d for read urb&quot;</span><span class="p">,</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This needs to be a tasklet otherwise we will</span>
<span class="cm"> * end up recursively calling this function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hso_unthrottle_tasklet</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">port_spec</span> <span class="o">&amp;</span> <span class="n">HSO_INTF_MUX</span><span class="p">))</span>
		<span class="n">put_rxbuf_data_and_resubmit_ctrl_urb</span><span class="p">(</span><span class="n">serial</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">put_rxbuf_data_and_resubmit_bulk_urb</span><span class="p">(</span><span class="n">serial</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span>	<span class="kt">void</span> <span class="nf">hso_unthrottle</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>

	<span class="n">tasklet_hi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">unthrottle_tasklet</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hso_unthrottle_workfunc</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span> <span class="o">=</span>
	    <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hso_serial</span><span class="p">,</span>
			 <span class="n">retry_unthrottle_workqueue</span><span class="p">);</span>
	<span class="n">hso_unthrottle_tasklet</span><span class="p">(</span><span class="n">serial</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* open the requested serial port */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_serial_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span> <span class="o">=</span> <span class="n">get_serial_by_index</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* sanity check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">serial</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">HSO_SERIAL_MAGIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">D1</span><span class="p">(</span><span class="s">&quot;Failed to open port&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_autopm_get_interface</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

	<span class="n">D1</span><span class="p">(</span><span class="s">&quot;Opening %d&quot;</span><span class="p">,</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>
	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>

	<span class="cm">/* setup */</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">serial</span><span class="p">;</span>
	<span class="n">tty_port_tty_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">,</span> <span class="n">tty</span><span class="p">);</span>

	<span class="cm">/* check for port already opened, if not set the termios */</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_state</span> <span class="o">=</span> <span class="n">RX_IDLE</span><span class="p">;</span>
		<span class="cm">/* Force default termio settings */</span>
		<span class="n">_hso_serial_set_termios</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">unthrottle_tasklet</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))</span><span class="n">hso_unthrottle_tasklet</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">serial</span><span class="p">);</span>
		<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">retry_unthrottle_workqueue</span><span class="p">,</span>
			  <span class="n">hso_unthrottle_workfunc</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">hso_start_serial_device</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hso_stop_serial_device</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
			<span class="n">serial</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
			<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="n">hso_serial_ref_free</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">D1</span><span class="p">(</span><span class="s">&quot;Port was already open&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">usb_autopm_put_interface</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">);</span>

	<span class="cm">/* done */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="n">hso_serial_tiocmset</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">TIOCM_RTS</span> <span class="o">|</span> <span class="n">TIOCM_DTR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">err_out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* close the requested serial port */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hso_serial_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">usb_gone</span><span class="p">;</span>

	<span class="n">D1</span><span class="p">(</span><span class="s">&quot;Closing serial port&quot;</span><span class="p">);</span>

	<span class="cm">/* Open failed, no close cleanup required */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">serial</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">usb_gone</span> <span class="o">=</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">usb_gone</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usb_gone</span><span class="p">)</span>
		<span class="n">usb_autopm_get_interface</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">);</span>

	<span class="cm">/* reset the rts and dtr */</span>
	<span class="cm">/* do the actual close */</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">serial</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tty_port_tty_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usb_gone</span><span class="p">)</span>
			<span class="n">hso_stop_serial_device</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
		<span class="n">tasklet_kill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">unthrottle_tasklet</span><span class="p">);</span>
		<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">retry_unthrottle_workqueue</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usb_gone</span><span class="p">)</span>
		<span class="n">usb_autopm_put_interface</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="n">hso_serial_ref_free</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* close the requested serial port */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_serial_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">space</span><span class="p">,</span> <span class="n">tx_bytes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* sanity check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">serial</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: serial is NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">space</span> <span class="o">=</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_data_length</span> <span class="o">-</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_buffer_count</span><span class="p">;</span>
	<span class="n">tx_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">space</span><span class="p">)</span> <span class="o">?</span> <span class="n">count</span> <span class="o">:</span> <span class="n">space</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx_bytes</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_buffer</span> <span class="o">+</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_buffer_count</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">tx_bytes</span><span class="p">);</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_buffer_count</span> <span class="o">+=</span> <span class="n">tx_bytes</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">hso_kick_transmit</span><span class="p">(</span><span class="n">serial</span><span class="p">);</span>
	<span class="cm">/* done */</span>
	<span class="k">return</span> <span class="n">tx_bytes</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* how much room is there for writing */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_serial_write_room</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">room</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">room</span> <span class="o">=</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_data_length</span> <span class="o">-</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_buffer_count</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* return free room */</span>
	<span class="k">return</span> <span class="n">room</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* setup the term */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hso_serial_set_termios</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">old</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old</span><span class="p">)</span>
		<span class="n">D5</span><span class="p">(</span><span class="s">&quot;Termios called with: cflags new[%d] - old[%d]&quot;</span><span class="p">,</span>
		   <span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span><span class="p">,</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">c_cflag</span><span class="p">);</span>

	<span class="cm">/* the actual setup */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span><span class="p">)</span>
		<span class="n">_hso_serial_set_termios</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">old</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span> <span class="o">=</span> <span class="n">old</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* done */</span>
<span class="p">}</span>

<span class="cm">/* how many characters in the buffer */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_serial_chars_in_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chars</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* sanity check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">serial</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">chars</span> <span class="o">=</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_buffer_count</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">chars</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tiocmget_submit_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">hso_tiocmget</span> <span class="o">*</span><span class="n">tiocmget</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">usb_gone</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">usb_fill_int_urb</span><span class="p">(</span><span class="n">tiocmget</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">,</span> <span class="n">usb</span><span class="p">,</span>
			 <span class="n">usb_rcvintpipe</span><span class="p">(</span><span class="n">usb</span><span class="p">,</span>
					<span class="n">tiocmget</span><span class="o">-&gt;</span><span class="n">endp</span><span class="o">-&gt;</span>
					<span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">),</span>
			 <span class="o">&amp;</span><span class="n">tiocmget</span><span class="o">-&gt;</span><span class="n">serial_state_notification</span><span class="p">,</span>
			 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_serial_state_notification</span><span class="p">),</span>
			 <span class="n">tiocmget_intr_callback</span><span class="p">,</span> <span class="n">serial</span><span class="p">,</span>
			 <span class="n">tiocmget</span><span class="o">-&gt;</span><span class="n">endp</span><span class="o">-&gt;</span><span class="n">bInterval</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">tiocmget</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s usb_submit_urb failed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			 <span class="n">result</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tiocmget_intr_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hso_tiocmget</span> <span class="o">*</span><span class="n">tiocmget</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">UART_state_bitmap</span><span class="p">,</span> <span class="n">prev_UART_state_bitmap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_icount</span> <span class="o">*</span><span class="n">icount</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hso_serial_state_notification</span> <span class="o">*</span><span class="n">serial_state_notification</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb</span><span class="p">;</span>

	<span class="cm">/* Sanity checks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serial</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">handle_usb_error</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tiocmget</span> <span class="o">=</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">tiocmget</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tiocmget</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">usb</span> <span class="o">=</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">;</span>
	<span class="n">serial_state_notification</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tiocmget</span><span class="o">-&gt;</span><span class="n">serial_state_notification</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">serial_state_notification</span><span class="o">-&gt;</span><span class="n">bmRequestType</span> <span class="o">!=</span> <span class="n">BM_REQUEST_TYPE</span> <span class="o">||</span>
	    <span class="n">serial_state_notification</span><span class="o">-&gt;</span><span class="n">bNotification</span> <span class="o">!=</span> <span class="n">B_NOTIFICATION</span> <span class="o">||</span>
	    <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">serial_state_notification</span><span class="o">-&gt;</span><span class="n">wValue</span><span class="p">)</span> <span class="o">!=</span> <span class="n">W_VALUE</span> <span class="o">||</span>
	    <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">serial_state_notification</span><span class="o">-&gt;</span><span class="n">wIndex</span><span class="p">)</span> <span class="o">!=</span> <span class="n">W_INDEX</span> <span class="o">||</span>
	    <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">serial_state_notification</span><span class="o">-&gt;</span><span class="n">wLength</span><span class="p">)</span> <span class="o">!=</span> <span class="n">W_LENGTH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;hso received invalid serial state notification</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">DUMP</span><span class="p">(</span><span class="n">serial_state_notification</span><span class="p">,</span>
		     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_serial_state_notification</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

		<span class="n">UART_state_bitmap</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">serial_state_notification</span><span class="o">-&gt;</span>
						<span class="n">UART_state_bitmap</span><span class="p">);</span>
		<span class="n">prev_UART_state_bitmap</span> <span class="o">=</span> <span class="n">tiocmget</span><span class="o">-&gt;</span><span class="n">prev_UART_state_bitmap</span><span class="p">;</span>
		<span class="n">icount</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tiocmget</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">UART_state_bitmap</span> <span class="o">&amp;</span> <span class="n">B_OVERRUN</span><span class="p">)</span> <span class="o">!=</span>
		   <span class="p">(</span><span class="n">prev_UART_state_bitmap</span> <span class="o">&amp;</span> <span class="n">B_OVERRUN</span><span class="p">))</span>
			<span class="n">icount</span><span class="o">-&gt;</span><span class="n">parity</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">UART_state_bitmap</span> <span class="o">&amp;</span> <span class="n">B_PARITY</span><span class="p">)</span> <span class="o">!=</span>
		   <span class="p">(</span><span class="n">prev_UART_state_bitmap</span> <span class="o">&amp;</span> <span class="n">B_PARITY</span><span class="p">))</span>
			<span class="n">icount</span><span class="o">-&gt;</span><span class="n">parity</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">UART_state_bitmap</span> <span class="o">&amp;</span> <span class="n">B_FRAMING</span><span class="p">)</span> <span class="o">!=</span>
		   <span class="p">(</span><span class="n">prev_UART_state_bitmap</span> <span class="o">&amp;</span> <span class="n">B_FRAMING</span><span class="p">))</span>
			<span class="n">icount</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">UART_state_bitmap</span> <span class="o">&amp;</span> <span class="n">B_RING_SIGNAL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="o">!</span><span class="p">(</span><span class="n">prev_UART_state_bitmap</span> <span class="o">&amp;</span> <span class="n">B_RING_SIGNAL</span><span class="p">))</span>
			<span class="n">icount</span><span class="o">-&gt;</span><span class="n">rng</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">UART_state_bitmap</span> <span class="o">&amp;</span> <span class="n">B_BREAK</span><span class="p">)</span> <span class="o">!=</span>
		   <span class="p">(</span><span class="n">prev_UART_state_bitmap</span> <span class="o">&amp;</span> <span class="n">B_BREAK</span><span class="p">))</span>
			<span class="n">icount</span><span class="o">-&gt;</span><span class="n">brk</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">UART_state_bitmap</span> <span class="o">&amp;</span> <span class="n">B_TX_CARRIER</span><span class="p">)</span> <span class="o">!=</span>
		   <span class="p">(</span><span class="n">prev_UART_state_bitmap</span> <span class="o">&amp;</span> <span class="n">B_TX_CARRIER</span><span class="p">))</span>
			<span class="n">icount</span><span class="o">-&gt;</span><span class="n">dsr</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">UART_state_bitmap</span> <span class="o">&amp;</span> <span class="n">B_RX_CARRIER</span><span class="p">)</span> <span class="o">!=</span>
		   <span class="p">(</span><span class="n">prev_UART_state_bitmap</span> <span class="o">&amp;</span> <span class="n">B_RX_CARRIER</span><span class="p">))</span>
			<span class="n">icount</span><span class="o">-&gt;</span><span class="n">dcd</span><span class="o">++</span><span class="p">;</span>
		<span class="n">tiocmget</span><span class="o">-&gt;</span><span class="n">prev_UART_state_bitmap</span> <span class="o">=</span> <span class="n">UART_state_bitmap</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">);</span>
		<span class="n">tiocmget</span><span class="o">-&gt;</span><span class="n">intr_completed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tiocmget</span><span class="o">-&gt;</span><span class="n">waitq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">serial_state_notification</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_serial_state_notification</span><span class="p">));</span>
	<span class="n">tiocmget_submit_urb</span><span class="p">(</span><span class="n">serial</span><span class="p">,</span>
			    <span class="n">tiocmget</span><span class="p">,</span>
			    <span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * next few functions largely stolen from drivers/serial/serial_core.c</span>
<span class="cm"> */</span>
<span class="cm">/* Wait for any of the 4 modem inputs (DCD,RI,DSR,CTS) to change</span>
<span class="cm"> * - mask passed in arg for lines of interest</span>
<span class="cm"> *   (use |&#39;ed TIOCM_RNG/DSR/CD/CTS for masking)</span>
<span class="cm"> * Caller should use TIOCGICOUNT to see which one it was</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">hso_wait_modem_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">uart_icount</span> <span class="n">cprev</span><span class="p">,</span> <span class="n">cnow</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hso_tiocmget</span>  <span class="o">*</span><span class="n">tiocmget</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">tiocmget</span> <span class="o">=</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">tiocmget</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tiocmget</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * note the counters on entry</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cprev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tiocmget</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_icount</span><span class="p">));</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">);</span>
	<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tiocmget</span><span class="o">-&gt;</span><span class="n">waitq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cnow</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tiocmget</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_icount</span><span class="p">));</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">);</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">arg</span> <span class="o">&amp;</span> <span class="n">TIOCM_RNG</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cnow</span><span class="p">.</span><span class="n">rng</span> <span class="o">!=</span> <span class="n">cprev</span><span class="p">.</span><span class="n">rng</span><span class="p">))</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">arg</span> <span class="o">&amp;</span> <span class="n">TIOCM_DSR</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cnow</span><span class="p">.</span><span class="n">dsr</span> <span class="o">!=</span> <span class="n">cprev</span><span class="p">.</span><span class="n">dsr</span><span class="p">))</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">arg</span> <span class="o">&amp;</span> <span class="n">TIOCM_CD</span><span class="p">)</span>  <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cnow</span><span class="p">.</span><span class="n">dcd</span> <span class="o">!=</span> <span class="n">cprev</span><span class="p">.</span><span class="n">dcd</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="cm">/* see if a signal did it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cprev</span> <span class="o">=</span> <span class="n">cnow</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tiocmget</span><span class="o">-&gt;</span><span class="n">waitq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get counter of input serial line interrupts (DCD,RI,DSR,CTS)</span>
<span class="cm"> * Return: write counters to the user passed counter struct</span>
<span class="cm"> * NB: both 1-&gt;0 and 0-&gt;1 transitions are counted except for</span>
<span class="cm"> *     RI where only 0-&gt;1 is counted.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_get_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">serial_icounter_struct</span> <span class="o">*</span><span class="n">icount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_icount</span> <span class="n">cnow</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hso_tiocmget</span>  <span class="o">*</span><span class="n">tiocmget</span> <span class="o">=</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">tiocmget</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">icount</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">serial_icounter_struct</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tiocmget</span><span class="p">)</span>
		 <span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cnow</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tiocmget</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_icount</span><span class="p">));</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">);</span>

	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">cts</span>         <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">cts</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">dsr</span>         <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">dsr</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">rng</span>         <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">rng</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">dcd</span>         <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">dcd</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">rx</span>          <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">rx</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">tx</span>          <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">tx</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">frame</span>       <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">frame</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">overrun</span>     <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">overrun</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">parity</span>      <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">parity</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">brk</span>         <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">brk</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">buf_overrun</span> <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">buf_overrun</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_serial_tiocmget</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hso_tiocmget</span>  <span class="o">*</span><span class="n">tiocmget</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">UART_state_bitmap</span><span class="p">;</span>

	<span class="cm">/* sanity check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serial</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">D1</span><span class="p">(</span><span class="s">&quot;no tty structures&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="p">((</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">rts_state</span><span class="p">)</span> <span class="o">?</span> <span class="n">TIOCM_RTS</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
	    <span class="p">((</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">dtr_state</span><span class="p">)</span> <span class="o">?</span> <span class="n">TIOCM_DTR</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">tiocmget</span> <span class="o">=</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">tiocmget</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tiocmget</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">UART_state_bitmap</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span>
			<span class="n">tiocmget</span><span class="o">-&gt;</span><span class="n">prev_UART_state_bitmap</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">UART_state_bitmap</span> <span class="o">&amp;</span> <span class="n">B_RING_SIGNAL</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">|=</span>  <span class="n">TIOCM_RNG</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">UART_state_bitmap</span> <span class="o">&amp;</span> <span class="n">B_RX_CARRIER</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">|=</span>  <span class="n">TIOCM_CD</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">UART_state_bitmap</span> <span class="o">&amp;</span> <span class="n">B_TX_CARRIER</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">|=</span>  <span class="n">TIOCM_DSR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_serial_tiocmset</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">set</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clear</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">if_num</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>

	<span class="cm">/* sanity check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serial</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">D1</span><span class="p">(</span><span class="s">&quot;no tty structures&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">port_spec</span> <span class="o">&amp;</span> <span class="n">HSO_PORT_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">HSO_PORT_MODEM</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">if_num</span> <span class="o">=</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">set</span> <span class="o">&amp;</span> <span class="n">TIOCM_RTS</span><span class="p">)</span>
		<span class="n">serial</span><span class="o">-&gt;</span><span class="n">rts_state</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">set</span> <span class="o">&amp;</span> <span class="n">TIOCM_DTR</span><span class="p">)</span>
		<span class="n">serial</span><span class="o">-&gt;</span><span class="n">dtr_state</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clear</span> <span class="o">&amp;</span> <span class="n">TIOCM_RTS</span><span class="p">)</span>
		<span class="n">serial</span><span class="o">-&gt;</span><span class="n">rts_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clear</span> <span class="o">&amp;</span> <span class="n">TIOCM_DTR</span><span class="p">)</span>
		<span class="n">serial</span><span class="o">-&gt;</span><span class="n">dtr_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">dtr_state</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="mh">0x01</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">rts_state</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="mh">0x02</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span>
			       <span class="n">usb_rcvctrlpipe</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mh">0x22</span><span class="p">,</span>
			       <span class="mh">0x21</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">if_num</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			       <span class="n">USB_CTRL_SET_TIMEOUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_serial_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">D4</span><span class="p">(</span><span class="s">&quot;IOCTL cmd: %d, arg: %ld&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serial</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TIOCMIWAIT</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">hso_wait_modem_status</span><span class="p">(</span><span class="n">serial</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* starts a transmit */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hso_kick_transmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_buffer_count</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_urb_used</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Wakeup USB interface if necessary */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hso_get_activity</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Switch pointers around to avoid memcpy */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_buffer</span><span class="p">;</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_buffer</span> <span class="o">=</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_data</span><span class="p">;</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_data</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_data_count</span> <span class="o">=</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_buffer_count</span><span class="p">;</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_buffer_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If temp is set, it means we switched buffers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;&amp;</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">write_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">write_data</span><span class="p">(</span><span class="n">serial</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_urb_used</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* make a request (for reading and writing data to muxed serial port) */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mux_device_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">,</span> <span class="n">u8</span> <span class="n">type</span><span class="p">,</span> <span class="n">u16</span> <span class="n">port</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">ctrl_urb</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">ctrl_req</span><span class="p">,</span>
			      <span class="n">u8</span> <span class="o">*</span><span class="n">ctrl_urb_data</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pipe</span><span class="p">;</span>

	<span class="cm">/* Sanity check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serial</span> <span class="o">||</span> <span class="o">!</span><span class="n">ctrl_urb</span> <span class="o">||</span> <span class="o">!</span><span class="n">ctrl_req</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Wrong arguments</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* initialize */</span>
	<span class="n">ctrl_req</span><span class="o">-&gt;</span><span class="n">wValue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ctrl_req</span><span class="o">-&gt;</span><span class="n">wIndex</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">hso_port_to_mux</span><span class="p">(</span><span class="n">port</span><span class="p">));</span>
	<span class="n">ctrl_req</span><span class="o">-&gt;</span><span class="n">wLength</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">USB_CDC_GET_ENCAPSULATED_RESPONSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Reading command */</span>
		<span class="n">ctrl_req</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">=</span> <span class="n">USB_DIR_IN</span> <span class="o">|</span>
					 <span class="n">USB_TYPE_OPTION_VENDOR</span> <span class="o">|</span>
					 <span class="n">USB_RECIP_INTERFACE</span><span class="p">;</span>
		<span class="n">ctrl_req</span><span class="o">-&gt;</span><span class="n">bRequest</span> <span class="o">=</span> <span class="n">USB_CDC_GET_ENCAPSULATED_RESPONSE</span><span class="p">;</span>
		<span class="n">pipe</span> <span class="o">=</span> <span class="n">usb_rcvctrlpipe</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Writing command */</span>
		<span class="n">ctrl_req</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">=</span> <span class="n">USB_DIR_OUT</span> <span class="o">|</span>
					 <span class="n">USB_TYPE_OPTION_VENDOR</span> <span class="o">|</span>
					 <span class="n">USB_RECIP_INTERFACE</span><span class="p">;</span>
		<span class="n">ctrl_req</span><span class="o">-&gt;</span><span class="n">bRequest</span> <span class="o">=</span> <span class="n">USB_CDC_SEND_ENCAPSULATED_COMMAND</span><span class="p">;</span>
		<span class="n">pipe</span> <span class="o">=</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* syslog */</span>
	<span class="n">D2</span><span class="p">(</span><span class="s">&quot;%s command (%02x) len: %d, port: %d&quot;</span><span class="p">,</span>
	   <span class="n">type</span> <span class="o">==</span> <span class="n">USB_CDC_GET_ENCAPSULATED_RESPONSE</span> <span class="o">?</span> <span class="s">&quot;Read&quot;</span> <span class="o">:</span> <span class="s">&quot;Write&quot;</span><span class="p">,</span>
	   <span class="n">ctrl_req</span><span class="o">-&gt;</span><span class="n">bRequestType</span><span class="p">,</span> <span class="n">ctrl_req</span><span class="o">-&gt;</span><span class="n">wLength</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

	<span class="cm">/* Load ctrl urb */</span>
	<span class="n">ctrl_urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">usb_fill_control_urb</span><span class="p">(</span><span class="n">ctrl_urb</span><span class="p">,</span>
			     <span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span>
			     <span class="n">pipe</span><span class="p">,</span>
			     <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">ctrl_req</span><span class="p">,</span>
			     <span class="n">ctrl_urb_data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">ctrl_callback</span><span class="p">,</span> <span class="n">serial</span><span class="p">);</span>
	<span class="cm">/* Send it on merry way */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">ctrl_urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctrl_urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s failed submit ctrl_urb %d type %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">result</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* done */</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* called by intr_callback when read occurs */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_mux_serial_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serial</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* clean data */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CTRL_URB_RX_SIZE</span><span class="p">);</span>
	<span class="cm">/* make the request */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">num_rx_urbs</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;ERROR: mux&#39;d reads with multiple buffers &quot;</span>
			<span class="s">&quot;not possible</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">mux_device_request</span><span class="p">(</span><span class="n">serial</span><span class="p">,</span>
				  <span class="n">USB_CDC_GET_ENCAPSULATED_RESPONSE</span><span class="p">,</span>
				  <span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">port_spec</span> <span class="o">&amp;</span> <span class="n">HSO_PORT_MASK</span><span class="p">,</span>
				  <span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				  <span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">ctrl_req_rx</span><span class="p">,</span>
				  <span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_data_length</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* used for muxed serial port callback (muxed serial read) */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">intr_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_shared_int</span> <span class="o">*</span><span class="n">shared_int</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">port_req</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">usb_mark_last_busy</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* sanity check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shared_int</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* status check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">handle_usb_error</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">D4</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">--- Got intr callback 0x%02X ---&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="cm">/* what request? */</span>
	<span class="n">port_req</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">;</span>
	<span class="n">D4</span><span class="p">(</span><span class="s">&quot; port_req = 0x%.2X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">port_req</span><span class="p">);</span>
	<span class="cm">/* loop over all muxed ports to find the one sending this */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* max 8 channels on MUX */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">port_req</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">serial</span> <span class="o">=</span> <span class="n">get_serial_by_shared_int_and_type</span><span class="p">(</span><span class="n">shared_int</span><span class="p">,</span>
								   <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">serial</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">D1</span><span class="p">(</span><span class="s">&quot;Pending read interrupt on port %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_state</span> <span class="o">==</span> <span class="n">RX_IDLE</span> <span class="o">&amp;&amp;</span>
					<span class="n">serial</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Setup and send a ctrl req read on</span>
<span class="cm">					 * port i */</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_urb_filled</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
						<span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_state</span> <span class="o">=</span> <span class="n">RX_SENT</span><span class="p">;</span>
						<span class="n">hso_mux_serial_read</span><span class="p">(</span><span class="n">serial</span><span class="p">);</span>
					<span class="p">}</span> <span class="k">else</span>
						<span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_state</span> <span class="o">=</span> <span class="n">RX_PENDING</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">D1</span><span class="p">(</span><span class="s">&quot;Already a read pending on &quot;</span>
					   <span class="s">&quot;port %d or port not open</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Resubmit interrupt urb */</span>
	<span class="n">hso_mux_submit_intr_urb</span><span class="p">(</span><span class="n">shared_int</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* called for writing to muxed serial port */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_mux_serial_write_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">serial</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">mux_device_request</span><span class="p">(</span><span class="n">serial</span><span class="p">,</span>
				  <span class="n">USB_CDC_SEND_ENCAPSULATED_COMMAND</span><span class="p">,</span>
				  <span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">port_spec</span> <span class="o">&amp;</span> <span class="n">HSO_PORT_MASK</span><span class="p">,</span>
				  <span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">ctrl_req_tx</span><span class="p">,</span>
				  <span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_data</span><span class="p">,</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_data_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* write callback for Diag and CS port */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hso_std_serial_write_bulk_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>

	<span class="cm">/* sanity check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serial</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">D1</span><span class="p">(</span><span class="s">&quot;serial == NULL&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">);</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_urb_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">handle_usb_error</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hso_put_activity</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">tty</span> <span class="o">=</span> <span class="n">tty_port_tty_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tty_wakeup</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="n">tty_kref_put</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">hso_kick_transmit</span><span class="p">(</span><span class="n">serial</span><span class="p">);</span>

	<span class="n">D1</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* called for writing diag or CS serial port */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_std_serial_write_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_data_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="p">,</span>
			  <span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span>
			  <span class="n">usb_sndbulkpipe</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span>
					  <span class="n">serial</span><span class="o">-&gt;</span><span class="n">out_endp</span><span class="o">-&gt;</span>
					  <span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">),</span>
			  <span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_data</span><span class="p">,</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_data_count</span><span class="p">,</span>
			  <span class="n">hso_std_serial_write_bulk_callback</span><span class="p">,</span> <span class="n">serial</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;Failed to submit urb - res %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* callback after read or write on muxed serial port */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ctrl_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>

	<span class="cm">/* sanity check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serial</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">);</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_urb_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">handle_usb_error</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* what request? */</span>
	<span class="n">req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="p">)(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">setup_packet</span><span class="p">);</span>
	<span class="n">D4</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">--- Got muxed ctrl callback 0x%02X ---&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">D4</span><span class="p">(</span><span class="s">&quot;Actual length of urb = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>
	<span class="n">DUMP1</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">==</span>
	    <span class="p">(</span><span class="n">USB_DIR_IN</span> <span class="o">|</span> <span class="n">USB_TYPE_OPTION_VENDOR</span> <span class="o">|</span> <span class="n">USB_RECIP_INTERFACE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* response to a read command */</span>
		<span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_urb_filled</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">);</span>
		<span class="n">put_rxbuf_data_and_resubmit_ctrl_urb</span><span class="p">(</span><span class="n">serial</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span> <span class="n">tty_port_tty_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
		<span class="n">hso_put_activity</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tty_wakeup</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
			<span class="n">tty_kref_put</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* response to a write command */</span>
		<span class="n">hso_kick_transmit</span><span class="p">(</span><span class="n">serial</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* handle RX data for serial port */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">put_rxbuf_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">write_length_remaining</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">curr_write_len</span><span class="p">;</span>

	<span class="cm">/* Sanity check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">serial</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">D1</span><span class="p">(</span><span class="s">&quot;serial = NULL&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tty</span> <span class="o">=</span> <span class="n">tty_port_tty_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>

	<span class="cm">/* Push data to tty */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">write_length_remaining</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">-</span>
			<span class="n">serial</span><span class="o">-&gt;</span><span class="n">curr_rx_urb_offset</span><span class="p">;</span>
		<span class="n">D1</span><span class="p">(</span><span class="s">&quot;data to push to tty&quot;</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">write_length_remaining</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">TTY_THROTTLED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">tty_kref_put</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">curr_write_len</span> <span class="o">=</span>  <span class="n">tty_insert_flip_string</span>
				<span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">+</span>
				 <span class="n">serial</span><span class="o">-&gt;</span><span class="n">curr_rx_urb_offset</span><span class="p">,</span>
				 <span class="n">write_length_remaining</span><span class="p">);</span>
			<span class="n">serial</span><span class="o">-&gt;</span><span class="n">curr_rx_urb_offset</span> <span class="o">+=</span> <span class="n">curr_write_len</span><span class="p">;</span>
			<span class="n">write_length_remaining</span> <span class="o">-=</span> <span class="n">curr_write_len</span><span class="p">;</span>
			<span class="n">tty_flip_buffer_push</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">tty_kref_put</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">write_length_remaining</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">serial</span><span class="o">-&gt;</span><span class="n">curr_rx_urb_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_urb_filled</span><span class="p">[</span><span class="n">hso_urb_to_index</span><span class="p">(</span><span class="n">serial</span><span class="p">,</span> <span class="n">urb</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">write_length_remaining</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Base driver functions */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hso_log_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">port_type</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">port_dev</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">port_spec</span> <span class="o">&amp;</span> <span class="n">HSO_PORT_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HSO_PORT_CONTROL</span>:
		<span class="n">port_type</span> <span class="o">=</span> <span class="s">&quot;Control&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HSO_PORT_APP</span>:
		<span class="n">port_type</span> <span class="o">=</span> <span class="s">&quot;Application&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HSO_PORT_GPS</span>:
		<span class="n">port_type</span> <span class="o">=</span> <span class="s">&quot;GPS&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HSO_PORT_GPS_CONTROL</span>:
		<span class="n">port_type</span> <span class="o">=</span> <span class="s">&quot;GPS control&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HSO_PORT_APP2</span>:
		<span class="n">port_type</span> <span class="o">=</span> <span class="s">&quot;Application2&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HSO_PORT_PCSC</span>:
		<span class="n">port_type</span> <span class="o">=</span> <span class="s">&quot;PCSC&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HSO_PORT_DIAG</span>:
		<span class="n">port_type</span> <span class="o">=</span> <span class="s">&quot;Diagnostic&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HSO_PORT_DIAG2</span>:
		<span class="n">port_type</span> <span class="o">=</span> <span class="s">&quot;Diagnostic2&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HSO_PORT_MODEM</span>:
		<span class="n">port_type</span> <span class="o">=</span> <span class="s">&quot;Modem&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HSO_PORT_NETWORK</span>:
		<span class="n">port_type</span> <span class="o">=</span> <span class="s">&quot;Network&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">port_type</span> <span class="o">=</span> <span class="s">&quot;Unknown&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">port_spec</span> <span class="o">&amp;</span> <span class="n">HSO_PORT_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">HSO_PORT_NETWORK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">port_dev</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">dev2net</span><span class="p">(</span><span class="n">hso_dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">port_dev</span><span class="p">,</span> <span class="s">&quot;/dev/%s%d&quot;</span><span class="p">,</span> <span class="n">tty_filename</span><span class="p">,</span>
			<span class="n">dev2ser</span><span class="p">(</span><span class="n">hso_dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;HSO: Found %s port %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">port_type</span><span class="p">,</span> <span class="n">port_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_start_net_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hso_net</span> <span class="o">*</span><span class="n">hso_net</span> <span class="o">=</span> <span class="n">dev2net</span><span class="p">(</span><span class="n">hso_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hso_net</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* send URBs for all read buffers */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MUX_BULK_RX_BUF_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Prep a receive URB */</span>
		<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">mux_bulk_rx_urb_pool</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				  <span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span>
				  <span class="n">usb_rcvbulkpipe</span><span class="p">(</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span>
						  <span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">in_endp</span><span class="o">-&gt;</span>
						  <span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">),</span>
				  <span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">mux_bulk_rx_buf_pool</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				  <span class="n">MUX_BULK_RX_BUF_SIZE</span><span class="p">,</span> <span class="n">read_bulk_callback</span><span class="p">,</span>
				  <span class="n">hso_net</span><span class="p">);</span>

		<span class="cm">/* Put it out there so the device can send us stuff */</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">mux_bulk_rx_urb_pool</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					<span class="n">GFP_NOIO</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;%s failed mux_bulk_rx_urb[%d] %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">i</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_stop_net_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hso_net</span> <span class="o">*</span><span class="n">hso_net</span> <span class="o">=</span> <span class="n">dev2net</span><span class="p">(</span><span class="n">hso_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hso_net</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MUX_BULK_RX_BUF_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">mux_bulk_rx_urb_pool</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">mux_bulk_rx_urb_pool</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">mux_bulk_tx_urb</span><span class="p">)</span>
		<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">mux_bulk_tx_urb</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_start_serial_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span> <span class="o">=</span> <span class="n">dev2ser</span><span class="p">(</span><span class="n">hso_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serial</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* If it is not the MUX port fill in and submit a bulk urb (already</span>
<span class="cm">	 * allocated in hso_serial_start) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">port_spec</span> <span class="o">&amp;</span> <span class="n">HSO_INTF_MUX</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">num_rx_urbs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					  <span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span>
					  <span class="n">usb_rcvbulkpipe</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span>
							  <span class="n">serial</span><span class="o">-&gt;</span><span class="n">in_endp</span><span class="o">-&gt;</span>
							  <span class="n">bEndpointAddress</span> <span class="o">&amp;</span>
							  <span class="mh">0x7F</span><span class="p">),</span>
					  <span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					  <span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_data_length</span><span class="p">,</span>
					  <span class="n">hso_std_serial_read_bulk_callback</span><span class="p">,</span>
					  <span class="n">serial</span><span class="p">);</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					 <span class="s">&quot;Failed to submit urb - res %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">result</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">shared_int</span><span class="o">-&gt;</span><span class="n">shared_int_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">shared_int</span><span class="o">-&gt;</span><span class="n">use_count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">=</span>
			    <span class="n">hso_mux_submit_intr_urb</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">shared_int</span><span class="p">,</span>
						    <span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">serial</span><span class="o">-&gt;</span><span class="n">shared_int</span><span class="o">-&gt;</span><span class="n">use_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">shared_int</span><span class="o">-&gt;</span><span class="n">shared_int_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">tiocmget</span><span class="p">)</span>
		<span class="n">tiocmget_submit_urb</span><span class="p">(</span><span class="n">serial</span><span class="p">,</span>
				    <span class="n">serial</span><span class="o">-&gt;</span><span class="n">tiocmget</span><span class="p">,</span>
				    <span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_stop_serial_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span> <span class="o">=</span> <span class="n">dev2ser</span><span class="p">(</span><span class="n">hso_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hso_tiocmget</span>  <span class="o">*</span><span class="n">tiocmget</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serial</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">num_rx_urbs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_urb_filled</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">curr_rx_urb_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">curr_rx_urb_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="p">)</span>
		<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">shared_int</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">shared_int</span><span class="o">-&gt;</span><span class="n">shared_int_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">shared_int</span><span class="o">-&gt;</span><span class="n">use_count</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">--</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">shared_int</span><span class="o">-&gt;</span><span class="n">use_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>

			<span class="n">urb</span> <span class="o">=</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">shared_int</span><span class="o">-&gt;</span><span class="n">shared_intr_urb</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="p">)</span>
				<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">shared_int</span><span class="o">-&gt;</span><span class="n">shared_int_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">tiocmget</span> <span class="o">=</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">tiocmget</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tiocmget</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tiocmget</span><span class="o">-&gt;</span><span class="n">waitq</span><span class="p">);</span>
		<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">tiocmget</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hso_serial_common_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span>
		<span class="n">device_remove_file</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_hsotype</span><span class="p">);</span>

	<span class="n">tty_unregister_device</span><span class="p">(</span><span class="n">tty_drv</span><span class="p">,</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">num_rx_urbs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* unlink and free RX URB */</span>
		<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="cm">/* free the RX buffer */</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/* unlink and free TX URB */</span>
	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_serial_common_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_urbs</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">rx_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tx_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">minor</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">minor</span> <span class="o">=</span> <span class="n">get_free_serial_index</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">minor</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="cm">/* register our minor number */</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">tty_register_device</span><span class="p">(</span><span class="n">tty_drv</span><span class="p">,</span> <span class="n">minor</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_hsotype</span><span class="p">);</span>

	<span class="cm">/* fill in specific data for later use */</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">minor</span> <span class="o">=</span> <span class="n">minor</span><span class="p">;</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">HSO_SERIAL_MAGIC</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">serial_lock</span><span class="p">);</span>
	<span class="n">tty_port_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">num_rx_urbs</span> <span class="o">=</span> <span class="n">num_urbs</span><span class="p">;</span>

	<span class="cm">/* RX, allocate urb and initialize */</span>

	<span class="cm">/* prepare our RX buffer */</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_data_length</span> <span class="o">=</span> <span class="n">rx_size</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">num_rx_urbs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not allocate urb?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_data_length</span><span class="p">,</span>
					     <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">rx_data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s - Out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* TX, allocate urb and initialize */</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not allocate urb?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* prepare our TX buffer */</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_data_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_buffer_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_data_length</span> <span class="o">=</span> <span class="n">tx_size</span><span class="p">;</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_data</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_data_length</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s - Out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_buffer</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_data_length</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s - Out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">exit:</span>
	<span class="n">hso_serial_common_free</span><span class="p">(</span><span class="n">serial</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Creates a general hso device */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="nf">hso_create_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span>
					    <span class="kt">int</span> <span class="n">port_spec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span><span class="p">;</span>

	<span class="n">hso_dev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hso_dev</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hso_dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">port_spec</span> <span class="o">=</span> <span class="n">port_spec</span><span class="p">;</span>
	<span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">usb</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">interface</span> <span class="o">=</span> <span class="n">intf</span><span class="p">;</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">async_get_intf</span><span class="p">,</span> <span class="n">async_get_intf</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">async_put_intf</span><span class="p">,</span> <span class="n">async_put_intf</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">reset_device</span><span class="p">,</span> <span class="n">reset_device</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">hso_dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Removes a network device in the network device table */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">remove_net_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HSO_MAX_NET_DEVICES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">network_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">hso_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">network_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">HSO_MAX_NET_DEVICES</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Frees our network device */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hso_free_net_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hso_net</span> <span class="o">*</span><span class="n">hso_net</span> <span class="o">=</span> <span class="n">dev2net</span><span class="p">(</span><span class="n">hso_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hso_net</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">remove_net_device</span><span class="p">(</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">)</span>
		<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">);</span>

	<span class="cm">/* start freeing */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MUX_BULK_RX_BUF_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">mux_bulk_rx_urb_pool</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">mux_bulk_rx_buf_pool</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">mux_bulk_rx_buf_pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">mux_bulk_tx_urb</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">mux_bulk_tx_buf</span><span class="p">);</span>
	<span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">mux_bulk_tx_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">)</span>
		<span class="n">free_netdev</span><span class="p">(</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">hso_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">hso_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>	<span class="o">=</span> <span class="n">hso_net_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>	<span class="o">=</span> <span class="n">hso_net_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span> <span class="o">=</span> <span class="n">hso_net_start_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span> <span class="o">=</span> <span class="n">hso_net_tx_timeout</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* initialize the network interface */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hso_net_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_net</span> <span class="o">*</span><span class="n">hso_net</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

	<span class="n">D1</span><span class="p">(</span><span class="s">&quot;sizeof hso_net is %d&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hso_net</span><span class="p">));</span>

	<span class="cm">/* fill in the other fields */</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hso_netdev_ops</span><span class="p">;</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="n">HSO_NET_TX_TIMEOUT</span><span class="p">;</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IFF_POINTOPOINT</span> <span class="o">|</span> <span class="n">IFF_NOARP</span> <span class="o">|</span> <span class="n">IFF_MULTICAST</span><span class="p">;</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">ARPHRD_NONE</span><span class="p">;</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">DEFAULT_MTU</span> <span class="o">-</span> <span class="mi">14</span><span class="p">;</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">tx_queue_len</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">SET_ETHTOOL_OPS</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ops</span><span class="p">);</span>

	<span class="cm">/* and initialize the semaphore */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">net_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Adds a network device in the network device table */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_net_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HSO_MAX_NET_DEVICES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">network_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">network_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hso_dev</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">HSO_MAX_NET_DEVICES</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_rfkill_set_block</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">bool</span> <span class="n">blocked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">enabled</span> <span class="o">=</span> <span class="o">!</span><span class="n">blocked</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">usb_gone</span><span class="p">)</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span> <span class="n">usb_rcvctrlpipe</span><span class="p">(</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
				       <span class="n">enabled</span> <span class="o">?</span> <span class="mh">0x82</span> <span class="o">:</span> <span class="mh">0x81</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				       <span class="n">USB_CTRL_SET_TIMEOUT</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rfkill_ops</span> <span class="n">hso_rfkill_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">set_block</span> <span class="o">=</span> <span class="n">hso_rfkill_set_block</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Creates and sets up everything for rfkill */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hso_create_rfkill</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_net</span> <span class="o">*</span><span class="n">hso_net</span> <span class="o">=</span> <span class="n">dev2net</span><span class="p">(</span><span class="n">hso_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">rfkn</span><span class="p">;</span>

	<span class="n">rfkn</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rfkn</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s - Out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">rfkn</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&quot;hso-%d&quot;</span><span class="p">,</span>
		 <span class="n">interface</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">);</span>

	<span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">rfkill</span> <span class="o">=</span> <span class="n">rfkill_alloc</span><span class="p">(</span><span class="n">rfkn</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">interface</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				       <span class="n">RFKILL_TYPE_WWAN</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">hso_rfkill_ops</span><span class="p">,</span> <span class="n">hso_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">rfkill</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s - Out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rfkn</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rfkill_register</span><span class="p">(</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">rfkill</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rfkill_destroy</span><span class="p">(</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">rfkill</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rfkn</span><span class="p">);</span>
		<span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">rfkill</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s - Failed to register rfkill</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_type</span> <span class="n">hso_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;wwan&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Creates our network device */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="nf">hso_create_net_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">port_spec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hso_net</span> <span class="o">*</span><span class="n">hso_net</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span><span class="p">;</span>

	<span class="n">hso_dev</span> <span class="o">=</span> <span class="n">hso_create_device</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="n">port_spec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hso_dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* allocate our network device, then we can put in our private data */</span>
	<span class="cm">/* call hso_net_init to do the basic initialization */</span>
	<span class="n">net</span> <span class="o">=</span> <span class="n">alloc_netdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_net</span><span class="p">),</span> <span class="s">&quot;hso%d&quot;</span><span class="p">,</span> <span class="n">hso_net_init</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to create ethernet device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hso_net</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

	<span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">port_data</span><span class="p">.</span><span class="n">dev_net</span> <span class="o">=</span> <span class="n">hso_net</span><span class="p">;</span>
	<span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">net</span> <span class="o">=</span> <span class="n">net</span><span class="p">;</span>
	<span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">hso_dev</span><span class="p">;</span>

	<span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">in_endp</span> <span class="o">=</span> <span class="n">hso_get_ep</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="n">USB_ENDPOINT_XFER_BULK</span><span class="p">,</span>
				      <span class="n">USB_DIR_IN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">in_endp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t find BULK IN endpoint</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">out_endp</span> <span class="o">=</span> <span class="n">hso_get_ep</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="n">USB_ENDPOINT_XFER_BULK</span><span class="p">,</span>
				       <span class="n">USB_DIR_OUT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">out_endp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t find BULK OUT endpoint</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">SET_NETDEV_DEVTYPE</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hso_type</span><span class="p">);</span>

	<span class="cm">/* registering our net device */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to register device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* start allocating */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MUX_BULK_RX_BUF_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">mux_bulk_rx_urb_pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">mux_bulk_rx_urb_pool</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not allocate rx urb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">mux_bulk_rx_buf_pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">MUX_BULK_RX_BUF_SIZE</span><span class="p">,</span>
							   <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">mux_bulk_rx_buf_pool</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not allocate rx buf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">mux_bulk_tx_urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">mux_bulk_tx_urb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not allocate tx urb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">mux_bulk_tx_buf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">MUX_BULK_TX_BUF_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">mux_bulk_tx_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not allocate tx buf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">add_net_device</span><span class="p">(</span><span class="n">hso_dev</span><span class="p">);</span>

	<span class="n">hso_log_port</span><span class="p">(</span><span class="n">hso_dev</span><span class="p">);</span>

	<span class="n">hso_create_rfkill</span><span class="p">(</span><span class="n">hso_dev</span><span class="p">,</span> <span class="n">interface</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">hso_dev</span><span class="p">;</span>
<span class="nl">exit:</span>
	<span class="n">hso_free_net_device</span><span class="p">(</span><span class="n">hso_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hso_free_tiomget</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_tiocmget</span> <span class="o">*</span><span class="n">tiocmget</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serial</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">tiocmget</span> <span class="o">=</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">tiocmget</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tiocmget</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">tiocmget</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">);</span>
		<span class="n">tiocmget</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">serial</span><span class="o">-&gt;</span><span class="n">tiocmget</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">tiocmget</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Frees an AT channel ( goes for both mux and non-mux ) */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hso_free_serial_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span> <span class="o">=</span> <span class="n">dev2ser</span><span class="p">(</span><span class="n">hso_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serial</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">set_serial_by_index</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">hso_serial_common_free</span><span class="p">(</span><span class="n">serial</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">shared_int</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">shared_int</span><span class="o">-&gt;</span><span class="n">shared_int_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">shared_int</span><span class="o">-&gt;</span><span class="n">ref_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">hso_free_shared_int</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">shared_int</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">shared_int</span><span class="o">-&gt;</span><span class="n">shared_int_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">hso_free_tiomget</span><span class="p">(</span><span class="n">serial</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">serial</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hso_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Creates a bulk AT channel */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="nf">hso_create_bulk_serial_device</span><span class="p">(</span>
			<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_urbs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hso_tiocmget</span> <span class="o">*</span><span class="n">tiocmget</span><span class="p">;</span>

	<span class="n">hso_dev</span> <span class="o">=</span> <span class="n">hso_create_device</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hso_dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">serial</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">serial</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serial</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">hso_dev</span><span class="p">;</span>
	<span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">port_data</span><span class="p">.</span><span class="n">dev_serial</span> <span class="o">=</span> <span class="n">serial</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">port</span> <span class="o">&amp;</span> <span class="n">HSO_PORT_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">HSO_PORT_MODEM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">num_urbs</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">serial</span><span class="o">-&gt;</span><span class="n">tiocmget</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_tiocmget</span><span class="p">),</span>
					   <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="cm">/* it isn&#39;t going to break our heart if serial-&gt;tiocmget</span>
<span class="cm">		 *  allocation fails don&#39;t bother checking this.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">tiocmget</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tiocmget</span> <span class="o">=</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">tiocmget</span><span class="p">;</span>
			<span class="n">tiocmget</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tiocmget</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tiocmget</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
				<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tiocmget</span><span class="o">-&gt;</span><span class="n">waitq</span><span class="p">);</span>
				<span class="n">tiocmget</span><span class="o">-&gt;</span><span class="n">endp</span> <span class="o">=</span> <span class="n">hso_get_ep</span><span class="p">(</span>
					<span class="n">interface</span><span class="p">,</span>
					<span class="n">USB_ENDPOINT_XFER_INT</span><span class="p">,</span>
					<span class="n">USB_DIR_IN</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">hso_free_tiomget</span><span class="p">(</span><span class="n">serial</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">else</span>
		<span class="n">num_urbs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hso_serial_common_create</span><span class="p">(</span><span class="n">serial</span><span class="p">,</span> <span class="n">num_urbs</span><span class="p">,</span> <span class="n">BULK_URB_RX_SIZE</span><span class="p">,</span>
				     <span class="n">BULK_URB_TX_SIZE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">in_endp</span> <span class="o">=</span> <span class="n">hso_get_ep</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="n">USB_ENDPOINT_XFER_BULK</span><span class="p">,</span>
				     <span class="n">USB_DIR_IN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">in_endp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to find BULK IN ep</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span>
	    <span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">out_endp</span> <span class="o">=</span>
	     <span class="n">hso_get_ep</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="n">USB_ENDPOINT_XFER_BULK</span><span class="p">,</span> <span class="n">USB_DIR_OUT</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to find BULK IN ep</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">write_data</span> <span class="o">=</span> <span class="n">hso_std_serial_write_data</span><span class="p">;</span>

	<span class="cm">/* and record this serial */</span>
	<span class="n">set_serial_by_index</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span> <span class="n">serial</span><span class="p">);</span>

	<span class="cm">/* setup the proc dirs and files if needed */</span>
	<span class="n">hso_log_port</span><span class="p">(</span><span class="n">hso_dev</span><span class="p">);</span>

	<span class="cm">/* done, return it */</span>
	<span class="k">return</span> <span class="n">hso_dev</span><span class="p">;</span>

<span class="nl">exit2:</span>
	<span class="n">hso_serial_common_free</span><span class="p">(</span><span class="n">serial</span><span class="p">);</span>
<span class="nl">exit:</span>
	<span class="n">hso_free_tiomget</span><span class="p">(</span><span class="n">serial</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">serial</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hso_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Creates a multiplexed AT channel */</span>
<span class="k">static</span>
<span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="nf">hso_create_mux_serial_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">port</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">hso_shared_int</span> <span class="o">*</span><span class="n">mux</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">port_spec</span><span class="p">;</span>

	<span class="n">port_spec</span> <span class="o">=</span> <span class="n">HSO_INTF_MUX</span><span class="p">;</span>
	<span class="n">port_spec</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HSO_PORT_MASK</span><span class="p">;</span>

	<span class="n">port_spec</span> <span class="o">|=</span> <span class="n">hso_mux_to_port</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">port_spec</span> <span class="o">&amp;</span> <span class="n">HSO_PORT_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">HSO_PORT_NO_PORT</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">hso_dev</span> <span class="o">=</span> <span class="n">hso_create_device</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="n">port_spec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hso_dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">serial</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">serial</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serial</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">port_data</span><span class="p">.</span><span class="n">dev_serial</span> <span class="o">=</span> <span class="n">serial</span><span class="p">;</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">hso_dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hso_serial_common_create</span>
	    <span class="p">(</span><span class="n">serial</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">CTRL_URB_RX_SIZE</span><span class="p">,</span> <span class="n">CTRL_URB_TX_SIZE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">tx_data_length</span><span class="o">--</span><span class="p">;</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">write_data</span> <span class="o">=</span> <span class="n">hso_mux_serial_write_data</span><span class="p">;</span>

	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">shared_int</span> <span class="o">=</span> <span class="n">mux</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">shared_int</span><span class="o">-&gt;</span><span class="n">shared_int_lock</span><span class="p">);</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">shared_int</span><span class="o">-&gt;</span><span class="n">ref_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">shared_int</span><span class="o">-&gt;</span><span class="n">shared_int_lock</span><span class="p">);</span>

	<span class="cm">/* and record this serial */</span>
	<span class="n">set_serial_by_index</span><span class="p">(</span><span class="n">serial</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span> <span class="n">serial</span><span class="p">);</span>

	<span class="cm">/* setup the proc dirs and files if needed */</span>
	<span class="n">hso_log_port</span><span class="p">(</span><span class="n">hso_dev</span><span class="p">);</span>

	<span class="cm">/* done, return it */</span>
	<span class="k">return</span> <span class="n">hso_dev</span><span class="p">;</span>

<span class="nl">exit:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">serial</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tty_unregister_device</span><span class="p">(</span><span class="n">tty_drv</span><span class="p">,</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">serial</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hso_dev</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">hso_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hso_free_shared_int</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_shared_int</span> <span class="o">*</span><span class="n">mux</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">shared_intr_urb</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">shared_intr_buf</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">shared_int_lock</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mux</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span>
<span class="k">struct</span> <span class="n">hso_shared_int</span> <span class="o">*</span><span class="nf">hso_create_shared_int</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_shared_int</span> <span class="o">*</span><span class="n">mux</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mux</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mux</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">mux</span><span class="o">-&gt;</span><span class="n">intr_endp</span> <span class="o">=</span> <span class="n">hso_get_ep</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="n">USB_ENDPOINT_XFER_INT</span><span class="p">,</span>
				    <span class="n">USB_DIR_IN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">intr_endp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t find INT IN endpoint</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mux</span><span class="o">-&gt;</span><span class="n">shared_intr_urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">shared_intr_urb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not allocate intr urb?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mux</span><span class="o">-&gt;</span><span class="n">shared_intr_buf</span> <span class="o">=</span>
		<span class="n">kzalloc</span><span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">intr_endp</span><span class="o">-&gt;</span><span class="n">wMaxPacketSize</span><span class="p">),</span>
			<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">shared_intr_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not allocate intr buf?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">shared_int_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mux</span><span class="p">;</span>

<span class="nl">exit:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">shared_intr_buf</span><span class="p">);</span>
	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">shared_intr_urb</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mux</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Gets the port spec for a certain interface */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_get_config_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usbdev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">config_data</span><span class="p">[</span><span class="mi">17</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">if_num</span> <span class="o">=</span> <span class="n">interface</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_control_msg</span><span class="p">(</span><span class="n">usbdev</span><span class="p">,</span> <span class="n">usb_rcvctrlpipe</span><span class="p">(</span><span class="n">usbdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
			    <span class="mh">0x86</span><span class="p">,</span> <span class="mh">0xC0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">config_data</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span>
			    <span class="n">USB_CTRL_SET_TIMEOUT</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x11</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">config_data</span><span class="p">[</span><span class="n">if_num</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x0</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x1</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">HSO_PORT_DIAG</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x2</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">HSO_PORT_GPS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x3</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">HSO_PORT_GPS_CONTROL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x4</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">HSO_PORT_APP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x5</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">HSO_PORT_APP2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x6</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">HSO_PORT_CONTROL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x7</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">HSO_PORT_NETWORK</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x8</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">HSO_PORT_MODEM</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x9</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">HSO_PORT_MSD</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0xa</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">HSO_PORT_PCSC</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0xb</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">HSO_PORT_VOICE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">|=</span> <span class="n">HSO_INTF_BULK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">config_data</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">|=</span> <span class="n">HSO_INFO_CRC_BUG</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* called once for each interface upon device insertion */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">,</span>
		     <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">mux</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">if_num</span><span class="p">,</span> <span class="n">port_spec</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">port_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hso_shared_int</span> <span class="o">*</span><span class="n">shared_int</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">tmp_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">if_num</span> <span class="o">=</span> <span class="n">interface</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">;</span>

	<span class="cm">/* Get the interface/port specification from either driver_info or from</span>
<span class="cm">	 * the device itself */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="p">)</span>
		<span class="n">port_spec</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="p">))[</span><span class="n">if_num</span><span class="p">];</span>
	<span class="k">else</span>
		<span class="n">port_spec</span> <span class="o">=</span> <span class="n">hso_get_config_data</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceClass</span> <span class="o">!=</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Not our interface</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Check if we need to switch to alt interfaces prior to port</span>
<span class="cm">	 * configuration */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">num_altsetting</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">usb_set_interface</span><span class="p">(</span><span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">interface</span><span class="p">),</span> <span class="n">if_num</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">interface</span><span class="o">-&gt;</span><span class="n">needs_remote_wakeup</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Allocate new hso device(s) */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">port_spec</span> <span class="o">&amp;</span> <span class="n">HSO_INTF_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HSO_INTF_MUX</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">port_spec</span> <span class="o">&amp;</span> <span class="n">HSO_PORT_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">HSO_PORT_NETWORK</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Create the network device */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">disable_net</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">hso_dev</span> <span class="o">=</span> <span class="n">hso_create_net_device</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span>
								<span class="n">port_spec</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hso_dev</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
				<span class="n">tmp_dev</span> <span class="o">=</span> <span class="n">hso_dev</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hso_get_mux_ports</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port_mask</span><span class="p">))</span>
			<span class="cm">/* TODO: de-allocate everything */</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

		<span class="n">shared_int</span> <span class="o">=</span> <span class="n">hso_create_shared_int</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shared_int</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mux</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mh">0x100</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mux</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">port_mask</span> <span class="o">&amp;</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">hso_dev</span> <span class="o">=</span> <span class="n">hso_create_mux_serial_device</span><span class="p">(</span>
						<span class="n">interface</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">shared_int</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hso_dev</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tmp_dev</span><span class="p">)</span>
			<span class="n">hso_dev</span> <span class="o">=</span> <span class="n">tmp_dev</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">HSO_INTF_BULK</span>:
		<span class="cm">/* It&#39;s a regular bulk interface */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">port_spec</span> <span class="o">&amp;</span> <span class="n">HSO_PORT_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">HSO_PORT_NETWORK</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">disable_net</span><span class="p">)</span>
				<span class="n">hso_dev</span> <span class="o">=</span>
				    <span class="n">hso_create_net_device</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="n">port_spec</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">hso_dev</span> <span class="o">=</span>
			    <span class="n">hso_create_bulk_serial_device</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="n">port_spec</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hso_dev</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* save our data pointer in this device */</span>
	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="n">hso_dev</span><span class="p">);</span>

	<span class="cm">/* done */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">exit:</span>
	<span class="n">hso_free_interface</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* device removed, cleaning up */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hso_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hso_free_interface</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>

	<span class="cm">/* remove reference of our private data */</span>
	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">async_get_intf</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span> <span class="o">=</span>
	    <span class="n">container_of</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hso_device</span><span class="p">,</span> <span class="n">async_get_intf</span><span class="p">);</span>
	<span class="n">usb_autopm_get_interface</span><span class="p">(</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">async_put_intf</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span> <span class="o">=</span>
	    <span class="n">container_of</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hso_device</span><span class="p">,</span> <span class="n">async_put_intf</span><span class="p">);</span>
	<span class="n">usb_autopm_put_interface</span><span class="p">(</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_get_activity</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_SUSPENDED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">is_active</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">is_active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">async_get_intf</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">USB_STATE_CONFIGURED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="n">usb_mark_last_busy</span><span class="p">(</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_put_activity</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">USB_STATE_SUSPENDED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">is_active</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">is_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">async_put_intf</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">is_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* called by kernel when we need to suspend device */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* Stop all serial ports */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HSO_SERIAL_TTY_MINORS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">serial_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">serial_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">interface</span> <span class="o">==</span> <span class="n">iface</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">hso_stop_serial_device</span><span class="p">(</span><span class="n">serial_table</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Stop all network ports */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HSO_MAX_NET_DEVICES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">network_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">network_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">interface</span> <span class="o">==</span> <span class="n">iface</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">hso_stop_net_device</span><span class="p">(</span><span class="n">network_table</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* called by kernel when we need to resume device */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hso_net</span> <span class="o">*</span><span class="n">hso_net</span><span class="p">;</span>

	<span class="cm">/* Start all serial ports */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HSO_SERIAL_TTY_MINORS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">serial_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">serial_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">interface</span> <span class="o">==</span> <span class="n">iface</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dev2ser</span><span class="p">(</span><span class="n">serial_table</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">result</span> <span class="o">=</span>
				    <span class="n">hso_start_serial_device</span><span class="p">(</span><span class="n">serial_table</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
				<span class="n">hso_kick_transmit</span><span class="p">(</span><span class="n">dev2ser</span><span class="p">(</span><span class="n">serial_table</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Start all network ports */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HSO_MAX_NET_DEVICES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">network_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">network_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">interface</span> <span class="o">==</span> <span class="n">iface</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">hso_net</span> <span class="o">=</span> <span class="n">dev2net</span><span class="p">(</span><span class="n">network_table</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* First transmit any lingering data,</span>
<span class="cm">				   then restart the device. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">skb_tx_buf</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						<span class="s">&quot;Transmitting&quot;</span>
						<span class="s">&quot; lingering data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="n">hso_net_start_xmit</span><span class="p">(</span><span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">skb_tx_buf</span><span class="p">,</span>
							   <span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">);</span>
					<span class="n">hso_net</span><span class="o">-&gt;</span><span class="n">skb_tx_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">result</span> <span class="o">=</span> <span class="n">hso_start_net_device</span><span class="p">(</span><span class="n">network_table</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reset_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span> <span class="o">=</span>
	    <span class="n">container_of</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hso_device</span><span class="p">,</span> <span class="n">reset_device</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb</span> <span class="o">=</span> <span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">usb_gone</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">D1</span><span class="p">(</span><span class="s">&quot;No reset during disconnect</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">usb_lock_device_for_reset</span><span class="p">(</span><span class="n">usb</span><span class="p">,</span> <span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">D1</span><span class="p">(</span><span class="s">&quot;unable to lock device for reset: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">usb_reset_device</span><span class="p">(</span><span class="n">usb</span><span class="p">);</span>
			<span class="n">usb_unlock_device</span><span class="p">(</span><span class="n">usb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hso_serial_ref_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_device</span> <span class="o">*</span><span class="n">hso_dev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hso_device</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>

	<span class="n">hso_free_serial_device</span><span class="p">(</span><span class="n">hso_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hso_free_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hso_serial</span> <span class="o">*</span><span class="n">hso_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HSO_SERIAL_TTY_MINORS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">serial_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">serial_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">interface</span> <span class="o">==</span> <span class="n">interface</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">hso_dev</span> <span class="o">=</span> <span class="n">dev2ser</span><span class="p">(</span><span class="n">serial_table</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">tty</span> <span class="o">=</span> <span class="n">tty_port_tty_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tty_hangup</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
				<span class="n">tty_kref_put</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">usb_gone</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hso_dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="n">hso_serial_ref_free</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HSO_MAX_NET_DEVICES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">network_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">network_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">interface</span> <span class="o">==</span> <span class="n">interface</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfk</span> <span class="o">=</span> <span class="n">dev2net</span><span class="p">(</span><span class="n">network_table</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">rfkill</span><span class="p">;</span>
			<span class="cm">/* hso_stop_net_device doesn&#39;t stop the net queue since</span>
<span class="cm">			 * traffic needs to start it again when suspended */</span>
			<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev2net</span><span class="p">(</span><span class="n">network_table</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">);</span>
			<span class="n">hso_stop_net_device</span><span class="p">(</span><span class="n">network_table</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">network_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">async_put_intf</span><span class="p">);</span>
			<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">network_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">async_get_intf</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rfk</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rfkill_unregister</span><span class="p">(</span><span class="n">rfk</span><span class="p">);</span>
				<span class="n">rfkill_destroy</span><span class="p">(</span><span class="n">rfk</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">hso_free_net_device</span><span class="p">(</span><span class="n">network_table</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Helper functions */</span>

<span class="cm">/* Get the endpoint ! */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="nf">hso_get_ep</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span>
						  <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">iface</span> <span class="o">=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">endp</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iface</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumEndpoints</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">endp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">endp</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_DIR_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">dir</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">usb_endpoint_type</span><span class="p">(</span><span class="n">endp</span><span class="p">)</span> <span class="o">==</span> <span class="n">type</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">endp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get the byte that describes which ports are enabled */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_get_mux_ports</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ports</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">iface</span> <span class="o">=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">extralen</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ports</span> <span class="o">=</span> <span class="n">iface</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iface</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumEndpoints</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">extralen</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">ports</span> <span class="o">=</span> <span class="n">iface</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">extra</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* interrupt urb needs to be submitted, used for serial read of muxed port */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hso_mux_submit_intr_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">hso_shared_int</span> <span class="o">*</span><span class="n">shared_int</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">usb_fill_int_urb</span><span class="p">(</span><span class="n">shared_int</span><span class="o">-&gt;</span><span class="n">shared_intr_urb</span><span class="p">,</span> <span class="n">usb</span><span class="p">,</span>
			 <span class="n">usb_rcvintpipe</span><span class="p">(</span><span class="n">usb</span><span class="p">,</span>
				<span class="n">shared_int</span><span class="o">-&gt;</span><span class="n">intr_endp</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">),</span>
			 <span class="n">shared_int</span><span class="o">-&gt;</span><span class="n">shared_intr_buf</span><span class="p">,</span>
			 <span class="mi">1</span><span class="p">,</span>
			 <span class="n">intr_callback</span><span class="p">,</span> <span class="n">shared_int</span><span class="p">,</span>
			 <span class="n">shared_int</span><span class="o">-&gt;</span><span class="n">intr_endp</span><span class="o">-&gt;</span><span class="n">bInterval</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">shared_int</span><span class="o">-&gt;</span><span class="n">shared_intr_urb</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s failed mux_intr_urb %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">result</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* operations setup of the serial interface */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tty_operations</span> <span class="n">hso_serial_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">hso_serial_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span> <span class="o">=</span> <span class="n">hso_serial_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">hso_serial_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_room</span> <span class="o">=</span> <span class="n">hso_serial_write_room</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span> <span class="o">=</span> <span class="n">hso_serial_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_termios</span> <span class="o">=</span> <span class="n">hso_serial_set_termios</span><span class="p">,</span>
	<span class="p">.</span><span class="n">chars_in_buffer</span> <span class="o">=</span> <span class="n">hso_serial_chars_in_buffer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tiocmget</span> <span class="o">=</span> <span class="n">hso_serial_tiocmget</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tiocmset</span> <span class="o">=</span> <span class="n">hso_serial_tiocmset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_icount</span> <span class="o">=</span> <span class="n">hso_get_count</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unthrottle</span> <span class="o">=</span> <span class="n">hso_unthrottle</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_driver</span> <span class="n">hso_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">driver_name</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">hso_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disconnect</span> <span class="o">=</span> <span class="n">hso_disconnect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">hso_ids</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">hso_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">hso_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_resume</span> <span class="o">=</span> <span class="n">hso_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">supports_autosuspend</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disable_hub_initiated_lpm</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">hso_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* put it in the log */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;hso: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>

	<span class="cm">/* Initialise the serial table semaphore and table */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial_table_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HSO_SERIAL_TTY_MINORS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">serial_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* allocate our driver using the proper amount of supported minors */</span>
	<span class="n">tty_drv</span> <span class="o">=</span> <span class="n">alloc_tty_driver</span><span class="p">(</span><span class="n">HSO_SERIAL_TTY_MINORS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty_drv</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* fill in all needed values */</span>
	<span class="n">tty_drv</span><span class="o">-&gt;</span><span class="n">driver_name</span> <span class="o">=</span> <span class="n">driver_name</span><span class="p">;</span>
	<span class="n">tty_drv</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">tty_filename</span><span class="p">;</span>

	<span class="cm">/* if major number is provided as parameter, use that one */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty_major</span><span class="p">)</span>
		<span class="n">tty_drv</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">=</span> <span class="n">tty_major</span><span class="p">;</span>

	<span class="n">tty_drv</span><span class="o">-&gt;</span><span class="n">minor_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tty_drv</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">TTY_DRIVER_TYPE_SERIAL</span><span class="p">;</span>
	<span class="n">tty_drv</span><span class="o">-&gt;</span><span class="n">subtype</span> <span class="o">=</span> <span class="n">SERIAL_TYPE_NORMAL</span><span class="p">;</span>
	<span class="n">tty_drv</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">TTY_DRIVER_REAL_RAW</span> <span class="o">|</span> <span class="n">TTY_DRIVER_DYNAMIC_DEV</span><span class="p">;</span>
	<span class="n">tty_drv</span><span class="o">-&gt;</span><span class="n">init_termios</span> <span class="o">=</span> <span class="n">tty_std_termios</span><span class="p">;</span>
	<span class="n">hso_init_termios</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_drv</span><span class="o">-&gt;</span><span class="n">init_termios</span><span class="p">);</span>
	<span class="n">tty_set_operations</span><span class="p">(</span><span class="n">tty_drv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hso_serial_ops</span><span class="p">);</span>

	<span class="cm">/* register the tty driver */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">tty_register_driver</span><span class="p">(</span><span class="n">tty_drv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s - tty_register_driver failed(%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_free_tty</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* register this module as an usb driver */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hso_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Could not register hso driver? error: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_unreg_tty</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* done */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err_unreg_tty:</span>
	<span class="n">tty_unregister_driver</span><span class="p">(</span><span class="n">tty_drv</span><span class="p">);</span>
<span class="nl">err_free_tty:</span>
	<span class="n">put_tty_driver</span><span class="p">(</span><span class="n">tty_drv</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">hso_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;hso: unloaded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">tty_unregister_driver</span><span class="p">(</span><span class="n">tty_drv</span><span class="p">);</span>
	<span class="n">put_tty_driver</span><span class="p">(</span><span class="n">tty_drv</span><span class="p">);</span>
	<span class="cm">/* deregister the usb driver */</span>
	<span class="n">usb_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hso_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Module definitions */</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">hso_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">hso_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="n">MOD_AUTHOR</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">MOD_DESCRIPTION</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="n">MOD_LICENSE</span><span class="p">);</span>

<span class="cm">/* change the debug level (eg: insmod hso.ko debug=0x04) */</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="s">&quot;Level of debug [0x01 | 0x02 | 0x04 | 0x08 | 0x10]&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>

<span class="cm">/* set the major tty number (eg: insmod hso.ko tty_major=245) */</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">tty_major</span><span class="p">,</span> <span class="s">&quot;Set the major tty number&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">tty_major</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>

<span class="cm">/* disable network interface (eg: insmod hso.ko disable_net=1) */</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">disable_net</span><span class="p">,</span> <span class="s">&quot;Disable the network interface&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">disable_net</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
