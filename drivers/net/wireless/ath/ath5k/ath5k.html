<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › ath › ath5k › ath5k.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>ath5k.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2004-2007 Reyk Floeter &lt;reyk@openbsd.org&gt;</span>
<span class="cm"> * Copyright (c) 2006-2007 Nick Kossifidis &lt;mickflemm@gmail.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Permission to use, copy, modify, and distribute this software for any</span>
<span class="cm"> * purpose with or without fee is hereby granted, provided that the above</span>
<span class="cm"> * copyright notice and this permission notice appear in all copies.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES</span>
<span class="cm"> * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR</span>
<span class="cm"> * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="cm"> * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="cm"> * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</span>
<span class="cm"> * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _ATH5K_H</span>
<span class="cp">#define _ATH5K_H</span>

<span class="cm">/* TODO: Clean up channel debugging (doesn&#39;t work anyway) and start</span>
<span class="cm"> * working on reg. control code using all available eeprom information</span>
<span class="cm"> * (rev. engineering needed) */</span>
<span class="cp">#define CHAN_DEBUG	0</span>

<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/average.h&gt;</span>
<span class="cp">#include &lt;linux/leds.h&gt;</span>
<span class="cp">#include &lt;net/mac80211.h&gt;</span>

<span class="cm">/* RX/TX descriptor hw structs</span>
<span class="cm"> * TODO: Driver part should only see sw structs */</span>
<span class="cp">#include &quot;desc.h&quot;</span>

<span class="cm">/* EEPROM structs/offsets</span>
<span class="cm"> * TODO: Make a more generic struct (eg. add more stuff to ath5k_capabilities)</span>
<span class="cm"> * and clean up common bits, then introduce set/get functions in eeprom.c */</span>
<span class="cp">#include &quot;eeprom.h&quot;</span>
<span class="cp">#include &quot;debug.h&quot;</span>
<span class="cp">#include &quot;../ath.h&quot;</span>
<span class="cp">#include &quot;ani.h&quot;</span>

<span class="cm">/* PCI IDs */</span>
<span class="cp">#define PCI_DEVICE_ID_ATHEROS_AR5210		0x0007 </span><span class="cm">/* AR5210 */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_ATHEROS_AR5311		0x0011 </span><span class="cm">/* AR5311 */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_ATHEROS_AR5211		0x0012 </span><span class="cm">/* AR5211 */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_ATHEROS_AR5212		0x0013 </span><span class="cm">/* AR5212 */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_3COM_3CRDAG675		0x0013 </span><span class="cm">/* 3CRDAG675 (Atheros AR5212) */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_3COM_2_3CRPAG175		0x0013 </span><span class="cm">/* 3CRPAG175 (Atheros AR5212) */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_ATHEROS_AR5210_AP		0x0207 </span><span class="cm">/* AR5210 (Early) */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_ATHEROS_AR5212_IBM	0x1014 </span><span class="cm">/* AR5212 (IBM MiniPCI) */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_ATHEROS_AR5210_DEFAULT	0x1107 </span><span class="cm">/* AR5210 (no eeprom) */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_ATHEROS_AR5212_DEFAULT	0x1113 </span><span class="cm">/* AR5212 (no eeprom) */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_ATHEROS_AR5211_DEFAULT	0x1112 </span><span class="cm">/* AR5211 (no eeprom) */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_ATHEROS_AR5212_FPGA	0xf013 </span><span class="cm">/* AR5212 (emulation board) */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_ATHEROS_AR5211_LEGACY	0xff12 </span><span class="cm">/* AR5211 (emulation board) */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_ATHEROS_AR5211_FPGA11B	0xf11b </span><span class="cm">/* AR5211 (emulation board) */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_ATHEROS_AR5312_REV2	0x0052 </span><span class="cm">/* AR5312 WMAC (AP31) */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_ATHEROS_AR5312_REV7	0x0057 </span><span class="cm">/* AR5312 WMAC (AP30-040) */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_ATHEROS_AR5312_REV8	0x0058 </span><span class="cm">/* AR5312 WMAC (AP43-030) */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_ATHEROS_AR5212_0014	0x0014 </span><span class="cm">/* AR5212 compatible */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_ATHEROS_AR5212_0015	0x0015 </span><span class="cm">/* AR5212 compatible */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_ATHEROS_AR5212_0016	0x0016 </span><span class="cm">/* AR5212 compatible */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_ATHEROS_AR5212_0017	0x0017 </span><span class="cm">/* AR5212 compatible */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_ATHEROS_AR5212_0018	0x0018 </span><span class="cm">/* AR5212 compatible */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_ATHEROS_AR5212_0019	0x0019 </span><span class="cm">/* AR5212 compatible */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_ATHEROS_AR2413		0x001a </span><span class="cm">/* AR2413 (Griffin-lite) */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_ATHEROS_AR5413		0x001b </span><span class="cm">/* AR5413 (Eagle) */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_ATHEROS_AR5424		0x001c </span><span class="cm">/* AR5424 (Condor PCI-E) */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_ATHEROS_AR5416		0x0023 </span><span class="cm">/* AR5416 */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_ATHEROS_AR5418		0x0024 </span><span class="cm">/* AR5418 */</span><span class="cp"></span>

<span class="cm">/****************************\</span>
<span class="cm">  GENERIC DRIVER DEFINITIONS</span>
<span class="cm">\****************************/</span>

<span class="cp">#define ATH5K_PRINTF(fmt, ...)						\</span>
<span class="cp">	pr_warn(&quot;%s: &quot; fmt, __func__, ##__VA_ARGS__)</span>

<span class="kt">void</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">_ath5k_printk</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">level</span><span class="p">,</span>
	      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>

<span class="cp">#define ATH5K_PRINTK(_sc, _level, _fmt, ...)				\</span>
<span class="cp">	_ath5k_printk(_sc, _level, _fmt, ##__VA_ARGS__)</span>

<span class="cp">#define ATH5K_PRINTK_LIMIT(_sc, _level, _fmt, ...)			\</span>
<span class="cp">do {									\</span>
<span class="cp">	if (net_ratelimit())						\</span>
<span class="cp">		ATH5K_PRINTK(_sc, _level, _fmt, ##__VA_ARGS__); 	\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define ATH5K_INFO(_sc, _fmt, ...)					\</span>
<span class="cp">	ATH5K_PRINTK(_sc, KERN_INFO, _fmt, ##__VA_ARGS__)</span>

<span class="cp">#define ATH5K_WARN(_sc, _fmt, ...)					\</span>
<span class="cp">	ATH5K_PRINTK_LIMIT(_sc, KERN_WARNING, _fmt, ##__VA_ARGS__)</span>

<span class="cp">#define ATH5K_ERR(_sc, _fmt, ...)					\</span>
<span class="cp">	ATH5K_PRINTK_LIMIT(_sc, KERN_ERR, _fmt, ##__VA_ARGS__)</span>

<span class="cm">/*</span>
<span class="cm"> * AR5K REGISTER ACCESS</span>
<span class="cm"> */</span>

<span class="cm">/* Some macros to read/write fields */</span>

<span class="cm">/* First shift, then mask */</span>
<span class="cp">#define AR5K_REG_SM(_val, _flags)					\</span>
<span class="cp">	(((_val) &lt;&lt; _flags##_S) &amp; (_flags))</span>

<span class="cm">/* First mask, then shift */</span>
<span class="cp">#define AR5K_REG_MS(_val, _flags)					\</span>
<span class="cp">	(((_val) &amp; (_flags)) &gt;&gt; _flags##_S)</span>

<span class="cm">/* Some registers can hold multiple values of interest. For this</span>
<span class="cm"> * reason when we want to write to these registers we must first</span>
<span class="cm"> * retrieve the values which we do not want to clear (lets call this</span>
<span class="cm"> * old_data) and then set the register with this and our new_value:</span>
<span class="cm"> * ( old_data | new_value) */</span>
<span class="cp">#define AR5K_REG_WRITE_BITS(ah, _reg, _flags, _val)			\</span>
<span class="cp">	ath5k_hw_reg_write(ah, (ath5k_hw_reg_read(ah, _reg) &amp; ~(_flags)) | \</span>
<span class="cp">	    (((_val) &lt;&lt; _flags##_S) &amp; (_flags)), _reg)</span>

<span class="cp">#define AR5K_REG_MASKED_BITS(ah, _reg, _flags, _mask)			\</span>
<span class="cp">	ath5k_hw_reg_write(ah, (ath5k_hw_reg_read(ah, _reg) &amp;		\</span>
<span class="cp">			(_mask)) | (_flags), _reg)</span>

<span class="cp">#define AR5K_REG_ENABLE_BITS(ah, _reg, _flags)				\</span>
<span class="cp">	ath5k_hw_reg_write(ah, ath5k_hw_reg_read(ah, _reg) | (_flags), _reg)</span>

<span class="cp">#define AR5K_REG_DISABLE_BITS(ah, _reg, _flags)			\</span>
<span class="cp">	ath5k_hw_reg_write(ah, ath5k_hw_reg_read(ah, _reg) &amp; ~(_flags), _reg)</span>

<span class="cm">/* Access QCU registers per queue */</span>
<span class="cp">#define AR5K_REG_READ_Q(ah, _reg, _queue)				\</span>
<span class="cp">	(ath5k_hw_reg_read(ah, _reg) &amp; (1 &lt;&lt; _queue))			\</span>

<span class="cp">#define AR5K_REG_WRITE_Q(ah, _reg, _queue)				\</span>
<span class="cp">	ath5k_hw_reg_write(ah, (1 &lt;&lt; _queue), _reg)</span>

<span class="cp">#define AR5K_Q_ENABLE_BITS(_reg, _queue) do {				\</span>
<span class="cp">	_reg |= 1 &lt;&lt; _queue;						\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define AR5K_Q_DISABLE_BITS(_reg, _queue) do {				\</span>
<span class="cp">	_reg &amp;= ~(1 &lt;&lt; _queue);						\</span>
<span class="cp">} while (0)</span>

<span class="cm">/* Used while writing initvals */</span>
<span class="cp">#define AR5K_REG_WAIT(_i) do {						\</span>
<span class="cp">	if (_i % 64)							\</span>
<span class="cp">		udelay(1);						\</span>
<span class="cp">} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Some tunable values (these should be changeable by the user)</span>
<span class="cm"> * TODO: Make use of them and add more options OR use debug/configfs</span>
<span class="cm"> */</span>
<span class="cp">#define AR5K_TUNE_DMA_BEACON_RESP		2</span>
<span class="cp">#define AR5K_TUNE_SW_BEACON_RESP		10</span>
<span class="cp">#define AR5K_TUNE_ADDITIONAL_SWBA_BACKOFF	0</span>
<span class="cp">#define AR5K_TUNE_MIN_TX_FIFO_THRES		1</span>
<span class="cp">#define AR5K_TUNE_MAX_TX_FIFO_THRES	((IEEE80211_MAX_FRAME_LEN / 64) + 1)</span>
<span class="cp">#define AR5K_TUNE_REGISTER_TIMEOUT		20000</span>
<span class="cm">/* Register for RSSI threshold has a mask of 0xff, so 255 seems to</span>
<span class="cm"> * be the max value. */</span>
<span class="cp">#define AR5K_TUNE_RSSI_THRES			129</span>
<span class="cm">/* This must be set when setting the RSSI threshold otherwise it can</span>
<span class="cm"> * prevent a reset. If AR5K_RSSI_THR is read after writing to it</span>
<span class="cm"> * the BMISS_THRES will be seen as 0, seems hardware doesn&#39;t keep</span>
<span class="cm"> * track of it. Max value depends on hardware. For AR5210 this is just 7.</span>
<span class="cm"> * For AR5211+ this seems to be up to 255. */</span>
<span class="cp">#define AR5K_TUNE_BMISS_THRES			7</span>
<span class="cp">#define AR5K_TUNE_REGISTER_DWELL_TIME		20000</span>
<span class="cp">#define AR5K_TUNE_BEACON_INTERVAL		100</span>
<span class="cp">#define AR5K_TUNE_AIFS				2</span>
<span class="cp">#define AR5K_TUNE_AIFS_11B			2</span>
<span class="cp">#define AR5K_TUNE_AIFS_XR			0</span>
<span class="cp">#define AR5K_TUNE_CWMIN				15</span>
<span class="cp">#define AR5K_TUNE_CWMIN_11B			31</span>
<span class="cp">#define AR5K_TUNE_CWMIN_XR			3</span>
<span class="cp">#define AR5K_TUNE_CWMAX				1023</span>
<span class="cp">#define AR5K_TUNE_CWMAX_11B			1023</span>
<span class="cp">#define AR5K_TUNE_CWMAX_XR			7</span>
<span class="cp">#define AR5K_TUNE_NOISE_FLOOR			-72</span>
<span class="cp">#define AR5K_TUNE_CCA_MAX_GOOD_VALUE		-95</span>
<span class="cp">#define AR5K_TUNE_MAX_TXPOWER			63</span>
<span class="cp">#define AR5K_TUNE_DEFAULT_TXPOWER		25</span>
<span class="cp">#define AR5K_TUNE_TPC_TXPOWER			false</span>
<span class="cp">#define ATH5K_TUNE_CALIBRATION_INTERVAL_FULL    60000   </span><span class="cm">/* 60 sec */</span><span class="cp"></span>
<span class="cp">#define	ATH5K_TUNE_CALIBRATION_INTERVAL_SHORT	10000	</span><span class="cm">/* 10 sec */</span><span class="cp"></span>
<span class="cp">#define ATH5K_TUNE_CALIBRATION_INTERVAL_ANI	1000	</span><span class="cm">/* 1 sec */</span><span class="cp"></span>
<span class="cp">#define ATH5K_TX_COMPLETE_POLL_INT		3000	</span><span class="cm">/* 3 sec */</span><span class="cp"></span>

<span class="cp">#define AR5K_INIT_CARR_SENSE_EN			1</span>

<span class="cm">/*Swap RX/TX Descriptor for big endian archs*/</span>
<span class="cp">#if defined(__BIG_ENDIAN)</span>
<span class="cp">#define AR5K_INIT_CFG	(		\</span>
<span class="cp">	AR5K_CFG_SWTD | AR5K_CFG_SWRD	\</span>
<span class="cp">)</span>
<span class="cp">#else</span>
<span class="cp">#define AR5K_INIT_CFG	0x00000000</span>
<span class="cp">#endif</span>

<span class="cm">/* Initial values */</span>
<span class="cp">#define	AR5K_INIT_CYCRSSI_THR1			2</span>

<span class="cm">/* Tx retry limit defaults from standard */</span>
<span class="cp">#define AR5K_INIT_RETRY_SHORT			7</span>
<span class="cp">#define AR5K_INIT_RETRY_LONG			4</span>

<span class="cm">/* Slot time */</span>
<span class="cp">#define AR5K_INIT_SLOT_TIME_TURBO		6</span>
<span class="cp">#define AR5K_INIT_SLOT_TIME_DEFAULT		9</span>
<span class="cp">#define	AR5K_INIT_SLOT_TIME_HALF_RATE		13</span>
<span class="cp">#define	AR5K_INIT_SLOT_TIME_QUARTER_RATE	21</span>
<span class="cp">#define	AR5K_INIT_SLOT_TIME_B			20</span>
<span class="cp">#define AR5K_SLOT_TIME_MAX			0xffff</span>

<span class="cm">/* SIFS */</span>
<span class="cp">#define	AR5K_INIT_SIFS_TURBO			6</span>
<span class="cp">#define	AR5K_INIT_SIFS_DEFAULT_BG		10</span>
<span class="cp">#define	AR5K_INIT_SIFS_DEFAULT_A		16</span>
<span class="cp">#define	AR5K_INIT_SIFS_HALF_RATE		32</span>
<span class="cp">#define AR5K_INIT_SIFS_QUARTER_RATE		64</span>

<span class="cm">/* Used to calculate tx time for non 5/10/40MHz</span>
<span class="cm"> * operation */</span>
<span class="cm">/* It&#39;s preamble time + signal time (16 + 4) */</span>
<span class="cp">#define	AR5K_INIT_OFDM_PREAMPLE_TIME		20</span>
<span class="cm">/* Preamble time for 40MHz (turbo) operation (min ?) */</span>
<span class="cp">#define	AR5K_INIT_OFDM_PREAMBLE_TIME_MIN	14</span>
<span class="cp">#define	AR5K_INIT_OFDM_SYMBOL_TIME		4</span>
<span class="cp">#define	AR5K_INIT_OFDM_PLCP_BITS		22</span>

<span class="cm">/* Rx latency for 5 and 10MHz operation (max ?) */</span>
<span class="cp">#define AR5K_INIT_RX_LAT_MAX			63</span>
<span class="cm">/* Tx latencies from initvals (5212 only but no problem</span>
<span class="cm"> * because we only tweak them on 5212) */</span>
<span class="cp">#define	AR5K_INIT_TX_LAT_A			54</span>
<span class="cp">#define	AR5K_INIT_TX_LAT_BG			384</span>
<span class="cm">/* Tx latency for 40MHz (turbo) operation (min ?) */</span>
<span class="cp">#define	AR5K_INIT_TX_LAT_MIN			32</span>
<span class="cm">/* Default Tx/Rx latencies (same for 5211)*/</span>
<span class="cp">#define AR5K_INIT_TX_LATENCY_5210		54</span>
<span class="cp">#define	AR5K_INIT_RX_LATENCY_5210		29</span>

<span class="cm">/* Tx frame to Tx data start delay */</span>
<span class="cp">#define AR5K_INIT_TXF2TXD_START_DEFAULT		14</span>
<span class="cp">#define AR5K_INIT_TXF2TXD_START_DELAY_10MHZ	12</span>
<span class="cp">#define AR5K_INIT_TXF2TXD_START_DELAY_5MHZ	13</span>

<span class="cm">/* We need to increase PHY switch and agc settling time</span>
<span class="cm"> * on turbo mode */</span>
<span class="cp">#define	AR5K_SWITCH_SETTLING			5760</span>
<span class="cp">#define	AR5K_SWITCH_SETTLING_TURBO		7168</span>

<span class="cp">#define	AR5K_AGC_SETTLING			28</span>
<span class="cm">/* 38 on 5210 but shouldn&#39;t matter */</span>
<span class="cp">#define	AR5K_AGC_SETTLING_TURBO			37</span>



<span class="cm">/*****************************\</span>
<span class="cm">* GENERIC CHIPSET DEFINITIONS *</span>
<span class="cm">\*****************************/</span>

<span class="cm">/**</span>
<span class="cm"> * enum ath5k_version - MAC Chips</span>
<span class="cm"> * @AR5K_AR5210: AR5210 (Crete)</span>
<span class="cm"> * @AR5K_AR5211: AR5211 (Oahu/Maui)</span>
<span class="cm"> * @AR5K_AR5212: AR5212 (Venice) and newer</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ath5k_version</span> <span class="p">{</span>
	<span class="n">AR5K_AR5210</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">AR5K_AR5211</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">AR5K_AR5212</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum ath5k_radio - PHY Chips</span>
<span class="cm"> * @AR5K_RF5110: RF5110 (Fez)</span>
<span class="cm"> * @AR5K_RF5111: RF5111 (Sombrero)</span>
<span class="cm"> * @AR5K_RF5112: RF2112/5112(A) (Derby/Derby2)</span>
<span class="cm"> * @AR5K_RF2413: RF2413/2414 (Griffin/Griffin-Lite)</span>
<span class="cm"> * @AR5K_RF5413: RF5413/5414/5424 (Eagle/Condor)</span>
<span class="cm"> * @AR5K_RF2316: RF2315/2316 (Cobra SoC)</span>
<span class="cm"> * @AR5K_RF2317: RF2317 (Spider SoC)</span>
<span class="cm"> * @AR5K_RF2425: RF2425/2417 (Swan/Nalla)</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ath5k_radio</span> <span class="p">{</span>
	<span class="n">AR5K_RF5110</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">AR5K_RF5111</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">AR5K_RF5112</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">AR5K_RF2413</span>	<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">AR5K_RF5413</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">AR5K_RF2316</span>	<span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">AR5K_RF2317</span>	<span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">AR5K_RF2425</span>	<span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Common silicon revision/version values</span>
<span class="cm"> */</span>

<span class="cp">#define AR5K_SREV_UNKNOWN	0xffff</span>

<span class="cp">#define AR5K_SREV_AR5210	0x00 </span><span class="cm">/* Crete */</span><span class="cp"></span>
<span class="cp">#define AR5K_SREV_AR5311	0x10 </span><span class="cm">/* Maui 1 */</span><span class="cp"></span>
<span class="cp">#define AR5K_SREV_AR5311A	0x20 </span><span class="cm">/* Maui 2 */</span><span class="cp"></span>
<span class="cp">#define AR5K_SREV_AR5311B	0x30 </span><span class="cm">/* Spirit */</span><span class="cp"></span>
<span class="cp">#define AR5K_SREV_AR5211	0x40 </span><span class="cm">/* Oahu */</span><span class="cp"></span>
<span class="cp">#define AR5K_SREV_AR5212	0x50 </span><span class="cm">/* Venice */</span><span class="cp"></span>
<span class="cp">#define AR5K_SREV_AR5312_R2	0x52 </span><span class="cm">/* AP31 */</span><span class="cp"></span>
<span class="cp">#define AR5K_SREV_AR5212_V4	0x54 </span><span class="cm">/* ??? */</span><span class="cp"></span>
<span class="cp">#define AR5K_SREV_AR5213	0x55 </span><span class="cm">/* ??? */</span><span class="cp"></span>
<span class="cp">#define AR5K_SREV_AR5312_R7	0x57 </span><span class="cm">/* AP30 */</span><span class="cp"></span>
<span class="cp">#define AR5K_SREV_AR2313_R8	0x58 </span><span class="cm">/* AP43 */</span><span class="cp"></span>
<span class="cp">#define AR5K_SREV_AR5213A	0x59 </span><span class="cm">/* Hainan */</span><span class="cp"></span>
<span class="cp">#define AR5K_SREV_AR2413	0x78 </span><span class="cm">/* Griffin lite */</span><span class="cp"></span>
<span class="cp">#define AR5K_SREV_AR2414	0x70 </span><span class="cm">/* Griffin */</span><span class="cp"></span>
<span class="cp">#define AR5K_SREV_AR2315_R6	0x86 </span><span class="cm">/* AP51-Light */</span><span class="cp"></span>
<span class="cp">#define AR5K_SREV_AR2315_R7	0x87 </span><span class="cm">/* AP51-Full */</span><span class="cp"></span>
<span class="cp">#define AR5K_SREV_AR5424	0x90 </span><span class="cm">/* Condor */</span><span class="cp"></span>
<span class="cp">#define AR5K_SREV_AR2317_R1	0x90 </span><span class="cm">/* AP61-Light */</span><span class="cp"></span>
<span class="cp">#define AR5K_SREV_AR2317_R2	0x91 </span><span class="cm">/* AP61-Full */</span><span class="cp"></span>
<span class="cp">#define AR5K_SREV_AR5413	0xa4 </span><span class="cm">/* Eagle lite */</span><span class="cp"></span>
<span class="cp">#define AR5K_SREV_AR5414	0xa0 </span><span class="cm">/* Eagle */</span><span class="cp"></span>
<span class="cp">#define AR5K_SREV_AR2415	0xb0 </span><span class="cm">/* Talon */</span><span class="cp"></span>
<span class="cp">#define AR5K_SREV_AR5416	0xc0 </span><span class="cm">/* PCI-E */</span><span class="cp"></span>
<span class="cp">#define AR5K_SREV_AR5418	0xca </span><span class="cm">/* PCI-E */</span><span class="cp"></span>
<span class="cp">#define AR5K_SREV_AR2425	0xe0 </span><span class="cm">/* Swan */</span><span class="cp"></span>
<span class="cp">#define AR5K_SREV_AR2417	0xf0 </span><span class="cm">/* Nala */</span><span class="cp"></span>

<span class="cp">#define AR5K_SREV_RAD_5110	0x00</span>
<span class="cp">#define AR5K_SREV_RAD_5111	0x10</span>
<span class="cp">#define AR5K_SREV_RAD_5111A	0x15</span>
<span class="cp">#define AR5K_SREV_RAD_2111	0x20</span>
<span class="cp">#define AR5K_SREV_RAD_5112	0x30</span>
<span class="cp">#define AR5K_SREV_RAD_5112A	0x35</span>
<span class="cp">#define	AR5K_SREV_RAD_5112B	0x36</span>
<span class="cp">#define AR5K_SREV_RAD_2112	0x40</span>
<span class="cp">#define AR5K_SREV_RAD_2112A	0x45</span>
<span class="cp">#define	AR5K_SREV_RAD_2112B	0x46</span>
<span class="cp">#define AR5K_SREV_RAD_2413	0x50</span>
<span class="cp">#define AR5K_SREV_RAD_5413	0x60</span>
<span class="cp">#define AR5K_SREV_RAD_2316	0x70 </span><span class="cm">/* Cobra SoC */</span><span class="cp"></span>
<span class="cp">#define AR5K_SREV_RAD_2317	0x80</span>
<span class="cp">#define AR5K_SREV_RAD_5424	0xa0 </span><span class="cm">/* Mostly same as 5413 */</span><span class="cp"></span>
<span class="cp">#define AR5K_SREV_RAD_2425	0xa2</span>
<span class="cp">#define AR5K_SREV_RAD_5133	0xc0</span>

<span class="cp">#define AR5K_SREV_PHY_5211	0x30</span>
<span class="cp">#define AR5K_SREV_PHY_5212	0x41</span>
<span class="cp">#define	AR5K_SREV_PHY_5212A	0x42</span>
<span class="cp">#define AR5K_SREV_PHY_5212B	0x43</span>
<span class="cp">#define AR5K_SREV_PHY_2413	0x45</span>
<span class="cp">#define AR5K_SREV_PHY_5413	0x61</span>
<span class="cp">#define AR5K_SREV_PHY_2425	0x70</span>

<span class="cm">/* TODO add support to mac80211 for vendor-specific rates and modes */</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: Atheros XR</span>
<span class="cm"> *</span>
<span class="cm"> * Some of this information is based on Documentation from:</span>
<span class="cm"> *</span>
<span class="cm"> * http://madwifi-project.org/wiki/ChipsetFeatures/SuperAG</span>
<span class="cm"> *</span>
<span class="cm"> * Atheros&#39; eXtended Range - range enhancing extension is a modulation scheme</span>
<span class="cm"> * that is supposed to double the link distance between an Atheros XR-enabled</span>
<span class="cm"> * client device with an Atheros XR-enabled access point. This is achieved</span>
<span class="cm"> * by increasing the receiver sensitivity up to, -105dBm, which is about 20dB</span>
<span class="cm"> * above what the 802.11 specifications demand. In addition, new (proprietary)</span>
<span class="cm"> * data rates are introduced: 3, 2, 1, 0.5 and 0.25 MBit/s.</span>
<span class="cm"> *</span>
<span class="cm"> * Please note that can you either use XR or TURBO but you cannot use both,</span>
<span class="cm"> * they are exclusive.</span>
<span class="cm"> *</span>
<span class="cm"> * Also note that we do not plan to support XR mode at least for now. You can</span>
<span class="cm"> * get a mode similar to XR by using 5MHz bwmode.</span>
<span class="cm"> */</span>


<span class="cm">/**</span>
<span class="cm"> * DOC: Atheros SuperAG</span>
<span class="cm"> *</span>
<span class="cm"> * In addition to XR we have another modulation scheme called TURBO mode</span>
<span class="cm"> * that is supposed to provide a throughput transmission speed up to 40Mbit/s</span>
<span class="cm"> * -60Mbit/s at a 108Mbit/s signaling rate achieved through the bonding of two</span>
<span class="cm"> * 54Mbit/s 802.11g channels. To use this feature both ends must support it.</span>
<span class="cm"> * There is also a distinction between &quot;static&quot; and &quot;dynamic&quot; turbo modes:</span>
<span class="cm"> *</span>
<span class="cm"> * - Static: is the dumb version: devices set to this mode stick to it until</span>
<span class="cm"> *     the mode is turned off.</span>
<span class="cm"> *</span>
<span class="cm"> * - Dynamic: is the intelligent version, the network decides itself if it</span>
<span class="cm"> *     is ok to use turbo. As soon as traffic is detected on adjacent channels</span>
<span class="cm"> *     (which would get used in turbo mode), or when a non-turbo station joins</span>
<span class="cm"> *     the network, turbo mode won&#39;t be used until the situation changes again.</span>
<span class="cm"> *     Dynamic mode is achieved by Atheros&#39; Adaptive Radio (AR) feature which</span>
<span class="cm"> *     monitors the used radio band in order to decide whether turbo mode may</span>
<span class="cm"> *     be used or not.</span>
<span class="cm"> *</span>
<span class="cm"> * This article claims Super G sticks to bonding of channels 5 and 6 for</span>
<span class="cm"> * USA:</span>
<span class="cm"> *</span>
<span class="cm"> * http://www.pcworld.com/article/id,113428-page,1/article.html</span>
<span class="cm"> *</span>
<span class="cm"> * The channel bonding seems to be driver specific though.</span>
<span class="cm"> *</span>
<span class="cm"> * In addition to TURBO modes we also have the following features for even</span>
<span class="cm"> * greater speed-up:</span>
<span class="cm"> *</span>
<span class="cm"> * - Bursting: allows multiple frames to be sent at once, rather than pausing</span>
<span class="cm"> *     after each frame. Bursting is a standards-compliant feature that can be</span>
<span class="cm"> *     used with any Access Point.</span>
<span class="cm"> *</span>
<span class="cm"> * - Fast frames: increases the amount of information that can be sent per</span>
<span class="cm"> *     frame, also resulting in a reduction of transmission overhead. It is a</span>
<span class="cm"> *     proprietary feature that needs to be supported by the Access Point.</span>
<span class="cm"> *</span>
<span class="cm"> * - Compression: data frames are compressed in real time using a Lempel Ziv</span>
<span class="cm"> *     algorithm. This is done transparently. Once this feature is enabled,</span>
<span class="cm"> *     compression and decompression takes place inside the chipset, without</span>
<span class="cm"> *     putting additional load on the host CPU.</span>
<span class="cm"> *</span>
<span class="cm"> * As with XR we also don&#39;t plan to support SuperAG features for now. You can</span>
<span class="cm"> * get a mode similar to TURBO by using 40MHz bwmode.</span>
<span class="cm"> */</span>


<span class="cm">/**</span>
<span class="cm"> * enum ath5k_driver_mode - PHY operation mode</span>
<span class="cm"> * @AR5K_MODE_11A: 802.11a</span>
<span class="cm"> * @AR5K_MODE_11B: 802.11b</span>
<span class="cm"> * @AR5K_MODE_11G: 801.11g</span>
<span class="cm"> * @AR5K_MODE_MAX: Used for boundary checks</span>
<span class="cm"> *</span>
<span class="cm"> * Do not change the order here, we use these as</span>
<span class="cm"> * array indices and it also maps EEPROM structures.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ath5k_driver_mode</span> <span class="p">{</span>
	<span class="n">AR5K_MODE_11A</span>		<span class="o">=</span>	<span class="mi">0</span><span class="p">,</span>
	<span class="n">AR5K_MODE_11B</span>		<span class="o">=</span>	<span class="mi">1</span><span class="p">,</span>
	<span class="n">AR5K_MODE_11G</span>		<span class="o">=</span>	<span class="mi">2</span><span class="p">,</span>
	<span class="n">AR5K_MODE_MAX</span>		<span class="o">=</span>	<span class="mi">3</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum ath5k_ant_mode - Antenna operation mode</span>
<span class="cm"> * @AR5K_ANTMODE_DEFAULT: Default antenna setup</span>
<span class="cm"> * @AR5K_ANTMODE_FIXED_A: Only antenna A is present</span>
<span class="cm"> * @AR5K_ANTMODE_FIXED_B: Only antenna B is present</span>
<span class="cm"> * @AR5K_ANTMODE_SINGLE_AP: STA locked on a single ap</span>
<span class="cm"> * @AR5K_ANTMODE_SECTOR_AP: AP with tx antenna set on tx desc</span>
<span class="cm"> * @AR5K_ANTMODE_SECTOR_STA: STA with tx antenna set on tx desc</span>
<span class="cm"> * @AR5K_ANTMODE_DEBUG: Debug mode -A -&gt; Rx, B-&gt; Tx-</span>
<span class="cm"> * @AR5K_ANTMODE_MAX: Used for boundary checks</span>
<span class="cm"> *</span>
<span class="cm"> * For more infos on antenna control check out phy.c</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ath5k_ant_mode</span> <span class="p">{</span>
	<span class="n">AR5K_ANTMODE_DEFAULT</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">AR5K_ANTMODE_FIXED_A</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">AR5K_ANTMODE_FIXED_B</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">AR5K_ANTMODE_SINGLE_AP</span>	<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">AR5K_ANTMODE_SECTOR_AP</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">AR5K_ANTMODE_SECTOR_STA</span>	<span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">AR5K_ANTMODE_DEBUG</span>	<span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">AR5K_ANTMODE_MAX</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum ath5k_bw_mode - Bandwidth operation mode</span>
<span class="cm"> * @AR5K_BWMODE_DEFAULT: 20MHz, default operation</span>
<span class="cm"> * @AR5K_BWMODE_5MHZ: Quarter rate</span>
<span class="cm"> * @AR5K_BWMODE_10MHZ: Half rate</span>
<span class="cm"> * @AR5K_BWMODE_40MHZ: Turbo</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ath5k_bw_mode</span> <span class="p">{</span>
	<span class="n">AR5K_BWMODE_DEFAULT</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">AR5K_BWMODE_5MHZ</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">AR5K_BWMODE_10MHZ</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">AR5K_BWMODE_40MHZ</span>	<span class="o">=</span> <span class="mi">3</span>
<span class="p">};</span>



<span class="cm">/****************\</span>
<span class="cm">  TX DEFINITIONS</span>
<span class="cm">\****************/</span>

<span class="cm">/**</span>
<span class="cm"> * struct ath5k_tx_status - TX Status descriptor</span>
<span class="cm"> * @ts_seqnum: Sequence number</span>
<span class="cm"> * @ts_tstamp: Timestamp</span>
<span class="cm"> * @ts_status: Status code</span>
<span class="cm"> * @ts_final_idx: Final transmission series index</span>
<span class="cm"> * @ts_final_retry: Final retry count</span>
<span class="cm"> * @ts_rssi: RSSI for received ACK</span>
<span class="cm"> * @ts_shortretry: Short retry count</span>
<span class="cm"> * @ts_virtcol: Virtual collision count</span>
<span class="cm"> * @ts_antenna: Antenna used</span>
<span class="cm"> *</span>
<span class="cm"> * TX status descriptor gets filled by the hw</span>
<span class="cm"> * on each transmission attempt.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ath5k_tx_status</span> <span class="p">{</span>
	<span class="n">u16</span>	<span class="n">ts_seqnum</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">ts_tstamp</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">ts_status</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">ts_final_idx</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">ts_final_retry</span><span class="p">;</span>
	<span class="n">s8</span>	<span class="n">ts_rssi</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">ts_shortretry</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">ts_virtcol</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">ts_antenna</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define AR5K_TXSTAT_ALTRATE	0x80</span>
<span class="cp">#define AR5K_TXERR_XRETRY	0x01</span>
<span class="cp">#define AR5K_TXERR_FILT		0x02</span>
<span class="cp">#define AR5K_TXERR_FIFO		0x04</span>

<span class="cm">/**</span>
<span class="cm"> * enum ath5k_tx_queue - Queue types used to classify tx queues.</span>
<span class="cm"> * @AR5K_TX_QUEUE_INACTIVE: q is unused -- see ath5k_hw_release_tx_queue</span>
<span class="cm"> * @AR5K_TX_QUEUE_DATA: A normal data queue</span>
<span class="cm"> * @AR5K_TX_QUEUE_BEACON: The beacon queue</span>
<span class="cm"> * @AR5K_TX_QUEUE_CAB: The after-beacon queue</span>
<span class="cm"> * @AR5K_TX_QUEUE_UAPSD: Unscheduled Automatic Power Save Delivery queue</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ath5k_tx_queue</span> <span class="p">{</span>
	<span class="n">AR5K_TX_QUEUE_INACTIVE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">AR5K_TX_QUEUE_DATA</span><span class="p">,</span>
	<span class="n">AR5K_TX_QUEUE_BEACON</span><span class="p">,</span>
	<span class="n">AR5K_TX_QUEUE_CAB</span><span class="p">,</span>
	<span class="n">AR5K_TX_QUEUE_UAPSD</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define	AR5K_NUM_TX_QUEUES		10</span>
<span class="cp">#define	AR5K_NUM_TX_QUEUES_NOQCU	2</span>

<span class="cm">/**</span>
<span class="cm"> * enum ath5k_tx_queue_subtype - Queue sub-types to classify normal data queues</span>
<span class="cm"> * @AR5K_WME_AC_BK: Background traffic</span>
<span class="cm"> * @AR5K_WME_AC_BE: Best-effort (normal) traffic</span>
<span class="cm"> * @AR5K_WME_AC_VI: Video traffic</span>
<span class="cm"> * @AR5K_WME_AC_VO: Voice traffic</span>
<span class="cm"> *</span>
<span class="cm"> * These are the 4 Access Categories as defined in</span>
<span class="cm"> * WME spec. 0 is the lowest priority and 4 is the</span>
<span class="cm"> * highest. Normal data that hasn&#39;t been classified</span>
<span class="cm"> * goes to the Best Effort AC.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ath5k_tx_queue_subtype</span> <span class="p">{</span>
	<span class="n">AR5K_WME_AC_BK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">AR5K_WME_AC_BE</span><span class="p">,</span>
	<span class="n">AR5K_WME_AC_VI</span><span class="p">,</span>
	<span class="n">AR5K_WME_AC_VO</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum ath5k_tx_queue_id - Queue ID numbers as returned by the hw functions</span>
<span class="cm"> * @AR5K_TX_QUEUE_ID_NOQCU_DATA: Data queue on AR5210 (no QCU available)</span>
<span class="cm"> * @AR5K_TX_QUEUE_ID_NOQCU_BEACON: Beacon queue on AR5210 (no QCU available)</span>
<span class="cm"> * @AR5K_TX_QUEUE_ID_DATA_MIN: Data queue min index</span>
<span class="cm"> * @AR5K_TX_QUEUE_ID_DATA_MAX: Data queue max index</span>
<span class="cm"> * @AR5K_TX_QUEUE_ID_CAB: Content after beacon queue</span>
<span class="cm"> * @AR5K_TX_QUEUE_ID_BEACON: Beacon queue</span>
<span class="cm"> * @AR5K_TX_QUEUE_ID_UAPSD: Urgent Automatic Power Save Delivery,</span>
<span class="cm"> *</span>
<span class="cm"> * Each number represents a hw queue. If hw does not support hw queues</span>
<span class="cm"> * (eg 5210) all data goes in one queue.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ath5k_tx_queue_id</span> <span class="p">{</span>
	<span class="n">AR5K_TX_QUEUE_ID_NOQCU_DATA</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">AR5K_TX_QUEUE_ID_NOQCU_BEACON</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">AR5K_TX_QUEUE_ID_DATA_MIN</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">AR5K_TX_QUEUE_ID_DATA_MAX</span>	<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">AR5K_TX_QUEUE_ID_UAPSD</span>		<span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
	<span class="n">AR5K_TX_QUEUE_ID_CAB</span>		<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">AR5K_TX_QUEUE_ID_BEACON</span>		<span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Flags to set hw queue&#39;s parameters...</span>
<span class="cm"> */</span>
<span class="cp">#define AR5K_TXQ_FLAG_TXOKINT_ENABLE		0x0001	</span><span class="cm">/* Enable TXOK interrupt */</span><span class="cp"></span>
<span class="cp">#define AR5K_TXQ_FLAG_TXERRINT_ENABLE		0x0002	</span><span class="cm">/* Enable TXERR interrupt */</span><span class="cp"></span>
<span class="cp">#define AR5K_TXQ_FLAG_TXEOLINT_ENABLE		0x0004	</span><span class="cm">/* Enable TXEOL interrupt -not used- */</span><span class="cp"></span>
<span class="cp">#define AR5K_TXQ_FLAG_TXDESCINT_ENABLE		0x0008	</span><span class="cm">/* Enable TXDESC interrupt -not used- */</span><span class="cp"></span>
<span class="cp">#define AR5K_TXQ_FLAG_TXURNINT_ENABLE		0x0010	</span><span class="cm">/* Enable TXURN interrupt */</span><span class="cp"></span>
<span class="cp">#define AR5K_TXQ_FLAG_CBRORNINT_ENABLE		0x0020	</span><span class="cm">/* Enable CBRORN interrupt */</span><span class="cp"></span>
<span class="cp">#define AR5K_TXQ_FLAG_CBRURNINT_ENABLE		0x0040	</span><span class="cm">/* Enable CBRURN interrupt */</span><span class="cp"></span>
<span class="cp">#define AR5K_TXQ_FLAG_QTRIGINT_ENABLE		0x0080	</span><span class="cm">/* Enable QTRIG interrupt */</span><span class="cp"></span>
<span class="cp">#define AR5K_TXQ_FLAG_TXNOFRMINT_ENABLE		0x0100	</span><span class="cm">/* Enable TXNOFRM interrupt */</span><span class="cp"></span>
<span class="cp">#define AR5K_TXQ_FLAG_BACKOFF_DISABLE		0x0200	</span><span class="cm">/* Disable random post-backoff */</span><span class="cp"></span>
<span class="cp">#define AR5K_TXQ_FLAG_RDYTIME_EXP_POLICY_ENABLE	0x0300	</span><span class="cm">/* Enable ready time expiry policy (?)*/</span><span class="cp"></span>
<span class="cp">#define AR5K_TXQ_FLAG_FRAG_BURST_BACKOFF_ENABLE	0x0800	</span><span class="cm">/* Enable backoff while bursting */</span><span class="cp"></span>
<span class="cp">#define AR5K_TXQ_FLAG_POST_FR_BKOFF_DIS		0x1000	</span><span class="cm">/* Disable backoff while bursting */</span><span class="cp"></span>
<span class="cp">#define AR5K_TXQ_FLAG_COMPRESSION_ENABLE	0x2000	</span><span class="cm">/* Enable hw compression -not implemented-*/</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * struct ath5k_txq - Transmit queue state</span>
<span class="cm"> * @qnum: Hardware q number</span>
<span class="cm"> * @link: Link ptr in last TX desc</span>
<span class="cm"> * @q: Transmit queue (&amp;struct list_head)</span>
<span class="cm"> * @lock: Lock on q and link</span>
<span class="cm"> * @setup: Is the queue configured</span>
<span class="cm"> * @txq_len:Number of queued buffers</span>
<span class="cm"> * @txq_max: Max allowed num of queued buffers</span>
<span class="cm"> * @txq_poll_mark: Used to check if queue got stuck</span>
<span class="cm"> * @txq_stuck: Queue stuck counter</span>
<span class="cm"> *</span>
<span class="cm"> * One of these exists for each hardware transmit queue.</span>
<span class="cm"> * Packets sent to us from above are assigned to queues based</span>
<span class="cm"> * on their priority.  Not all devices support a complete set</span>
<span class="cm"> * of hardware transmit queues. For those devices the array</span>
<span class="cm"> * sc_ac2q will map multiple priorities to fewer hardware queues</span>
<span class="cm"> * (typically all to one hardware queue).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ath5k_txq</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">qnum</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="o">*</span><span class="n">link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">q</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">setup</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">txq_len</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">txq_max</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">txq_poll_mark</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">txq_stuck</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ath5k_txq_info - A struct to hold TX queue&#39;s parameters</span>
<span class="cm"> * @tqi_type: One of enum ath5k_tx_queue</span>
<span class="cm"> * @tqi_subtype: One of enum ath5k_tx_queue_subtype</span>
<span class="cm"> * @tqi_flags: TX queue flags (see above)</span>
<span class="cm"> * @tqi_aifs: Arbitrated Inter-frame Space</span>
<span class="cm"> * @tqi_cw_min: Minimum Contention Window</span>
<span class="cm"> * @tqi_cw_max: Maximum Contention Window</span>
<span class="cm"> * @tqi_cbr_period: Constant bit rate period</span>
<span class="cm"> * @tqi_ready_time: Time queue waits after an event when RDYTIME is enabled</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ath5k_txq_info</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">ath5k_tx_queue</span> <span class="n">tqi_type</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ath5k_tx_queue_subtype</span> <span class="n">tqi_subtype</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">tqi_flags</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">tqi_aifs</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">tqi_cw_min</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">tqi_cw_max</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">tqi_cbr_period</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">tqi_cbr_overflow_limit</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">tqi_burst_time</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">tqi_ready_time</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum ath5k_pkt_type - Transmit packet types</span>
<span class="cm"> * @AR5K_PKT_TYPE_NORMAL: Normal data</span>
<span class="cm"> * @AR5K_PKT_TYPE_ATIM: ATIM</span>
<span class="cm"> * @AR5K_PKT_TYPE_PSPOLL: PS-Poll</span>
<span class="cm"> * @AR5K_PKT_TYPE_BEACON: Beacon</span>
<span class="cm"> * @AR5K_PKT_TYPE_PROBE_RESP: Probe response</span>
<span class="cm"> * @AR5K_PKT_TYPE_PIFS: PIFS</span>
<span class="cm"> * Used on tx control descriptor</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ath5k_pkt_type</span> <span class="p">{</span>
	<span class="n">AR5K_PKT_TYPE_NORMAL</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">AR5K_PKT_TYPE_ATIM</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">AR5K_PKT_TYPE_PSPOLL</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">AR5K_PKT_TYPE_BEACON</span>		<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">AR5K_PKT_TYPE_PROBE_RESP</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">AR5K_PKT_TYPE_PIFS</span>		<span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * TX power and TPC settings</span>
<span class="cm"> */</span>
<span class="cp">#define AR5K_TXPOWER_OFDM(_r, _v)	(			\</span>
<span class="cp">	((0 &amp; 1) &lt;&lt; ((_v) + 6)) |				\</span>
<span class="cp">	(((ah-&gt;ah_txpower.txp_rates_power_table[(_r)]) &amp; 0x3f) &lt;&lt; (_v))	\</span>
<span class="cp">)</span>

<span class="cp">#define AR5K_TXPOWER_CCK(_r, _v)	(			\</span>
<span class="cp">	(ah-&gt;ah_txpower.txp_rates_power_table[(_r)] &amp; 0x3f) &lt;&lt; (_v)	\</span>
<span class="cp">)</span>



<span class="cm">/****************\</span>
<span class="cm">  RX DEFINITIONS</span>
<span class="cm">\****************/</span>

<span class="cm">/**</span>
<span class="cm"> * struct ath5k_rx_status - RX Status descriptor</span>
<span class="cm"> * @rs_datalen: Data length</span>
<span class="cm"> * @rs_tstamp: Timestamp</span>
<span class="cm"> * @rs_status: Status code</span>
<span class="cm"> * @rs_phyerr: PHY error mask</span>
<span class="cm"> * @rs_rssi: RSSI in 0.5dbm units</span>
<span class="cm"> * @rs_keyix: Index to the key used for decrypting</span>
<span class="cm"> * @rs_rate: Rate used to decode the frame</span>
<span class="cm"> * @rs_antenna: Antenna used to receive the frame</span>
<span class="cm"> * @rs_more: Indicates this is a frame fragment (Fast frames)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ath5k_rx_status</span> <span class="p">{</span>
	<span class="n">u16</span>	<span class="n">rs_datalen</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">rs_tstamp</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">rs_status</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">rs_phyerr</span><span class="p">;</span>
	<span class="n">s8</span>	<span class="n">rs_rssi</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">rs_keyix</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">rs_rate</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">rs_antenna</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">rs_more</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define AR5K_RXERR_CRC		0x01</span>
<span class="cp">#define AR5K_RXERR_PHY		0x02</span>
<span class="cp">#define AR5K_RXERR_FIFO		0x04</span>
<span class="cp">#define AR5K_RXERR_DECRYPT	0x08</span>
<span class="cp">#define AR5K_RXERR_MIC		0x10</span>
<span class="cp">#define AR5K_RXKEYIX_INVALID	((u8) -1)</span>
<span class="cp">#define AR5K_TXKEYIX_INVALID	((u32) -1)</span>


<span class="cm">/**************************\</span>
<span class="cm"> BEACON TIMERS DEFINITIONS</span>
<span class="cm">\**************************/</span>

<span class="cp">#define AR5K_BEACON_PERIOD	0x0000ffff</span>
<span class="cp">#define AR5K_BEACON_ENA		0x00800000 </span><span class="cm">/*enable beacon xmit*/</span><span class="cp"></span>
<span class="cp">#define AR5K_BEACON_RESET_TSF	0x01000000 </span><span class="cm">/*force a TSF reset*/</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * TSF to TU conversion:</span>
<span class="cm"> *</span>
<span class="cm"> * TSF is a 64bit value in usec (microseconds).</span>
<span class="cm"> * TU is a 32bit value and defined by IEEE802.11 (page 6) as &quot;A measurement of</span>
<span class="cm"> * time equal to 1024 usec&quot;, so it&#39;s roughly milliseconds (usec / 1024).</span>
<span class="cm"> */</span>
<span class="cp">#define TSF_TO_TU(_tsf) (u32)((_tsf) &gt;&gt; 10)</span>



<span class="cm">/*******************************\</span>
<span class="cm">  GAIN OPTIMIZATION DEFINITIONS</span>
<span class="cm">\*******************************/</span>

<span class="cm">/**</span>
<span class="cm"> * enum ath5k_rfgain - RF Gain optimization engine state</span>
<span class="cm"> * @AR5K_RFGAIN_INACTIVE: Engine disabled</span>
<span class="cm"> * @AR5K_RFGAIN_ACTIVE: Probe active</span>
<span class="cm"> * @AR5K_RFGAIN_READ_REQUESTED: Probe requested</span>
<span class="cm"> * @AR5K_RFGAIN_NEED_CHANGE: Gain_F needs change</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ath5k_rfgain</span> <span class="p">{</span>
	<span class="n">AR5K_RFGAIN_INACTIVE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">AR5K_RFGAIN_ACTIVE</span><span class="p">,</span>
	<span class="n">AR5K_RFGAIN_READ_REQUESTED</span><span class="p">,</span>
	<span class="n">AR5K_RFGAIN_NEED_CHANGE</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ath5k_gain - RF Gain optimization engine state data</span>
<span class="cm"> * @g_step_idx: Current step index</span>
<span class="cm"> * @g_current: Current gain</span>
<span class="cm"> * @g_target: Target gain</span>
<span class="cm"> * @g_low: Low gain boundary</span>
<span class="cm"> * @g_high: High gain boundary</span>
<span class="cm"> * @g_f_corr: Gain_F correction</span>
<span class="cm"> * @g_state: One of enum ath5k_rfgain</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ath5k_gain</span> <span class="p">{</span>
	<span class="n">u8</span>			<span class="n">g_step_idx</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">g_current</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">g_target</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">g_low</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">g_high</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">g_f_corr</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">g_state</span><span class="p">;</span>
<span class="p">};</span>



<span class="cm">/********************\</span>
<span class="cm">  COMMON DEFINITIONS</span>
<span class="cm">\********************/</span>

<span class="cp">#define AR5K_SLOT_TIME_9	396</span>
<span class="cp">#define AR5K_SLOT_TIME_20	880</span>
<span class="cp">#define AR5K_SLOT_TIME_MAX	0xffff</span>

<span class="cm">/**</span>
<span class="cm"> * struct ath5k_athchan_2ghz - 2GHz to 5GHZ map for RF5111</span>
<span class="cm"> * @a2_flags: Channel flags (internal)</span>
<span class="cm"> * @a2_athchan: HW channel number (internal)</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is used to map 2GHz channels to</span>
<span class="cm"> * 5GHz Atheros channels on 2111 frequency converter</span>
<span class="cm"> * that comes together with RF5111</span>
<span class="cm"> * TODO: Clean up</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ath5k_athchan_2ghz</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">a2_flags</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">a2_athchan</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum ath5k_dmasize -  DMA size definitions (2^(n+2))</span>
<span class="cm"> * @AR5K_DMASIZE_4B: 4Bytes</span>
<span class="cm"> * @AR5K_DMASIZE_8B: 8Bytes</span>
<span class="cm"> * @AR5K_DMASIZE_16B: 16Bytes</span>
<span class="cm"> * @AR5K_DMASIZE_32B: 32Bytes</span>
<span class="cm"> * @AR5K_DMASIZE_64B: 64Bytes (Default)</span>
<span class="cm"> * @AR5K_DMASIZE_128B: 128Bytes</span>
<span class="cm"> * @AR5K_DMASIZE_256B: 256Bytes</span>
<span class="cm"> * @AR5K_DMASIZE_512B: 512Bytes</span>
<span class="cm"> *</span>
<span class="cm"> * These are used to set DMA burst size on hw</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Some platforms can&#39;t handle more than 4Bytes</span>
<span class="cm"> * be careful on embedded boards.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ath5k_dmasize</span> <span class="p">{</span>
	<span class="n">AR5K_DMASIZE_4B</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">AR5K_DMASIZE_8B</span><span class="p">,</span>
	<span class="n">AR5K_DMASIZE_16B</span><span class="p">,</span>
	<span class="n">AR5K_DMASIZE_32B</span><span class="p">,</span>
	<span class="n">AR5K_DMASIZE_64B</span><span class="p">,</span>
	<span class="n">AR5K_DMASIZE_128B</span><span class="p">,</span>
	<span class="n">AR5K_DMASIZE_256B</span><span class="p">,</span>
	<span class="n">AR5K_DMASIZE_512B</span>
<span class="p">};</span>



<span class="cm">/******************\</span>
<span class="cm">  RATE DEFINITIONS</span>
<span class="cm">\******************/</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: Rate codes</span>
<span class="cm"> *</span>
<span class="cm"> * Seems the ar5xxx hardware supports up to 32 rates, indexed by 1-32.</span>
<span class="cm"> *</span>
<span class="cm"> * The rate code is used to get the RX rate or set the TX rate on the</span>
<span class="cm"> * hardware descriptors. It is also used for internal modulation control</span>
<span class="cm"> * and settings.</span>
<span class="cm"> *</span>
<span class="cm"> * This is the hardware rate map we are aware of (html unfriendly):</span>
<span class="cm"> *</span>
<span class="cm"> * Rate code	Rate (Kbps)</span>
<span class="cm"> * ---------	-----------</span>
<span class="cm"> * 0x01		 3000 (XR)</span>
<span class="cm"> * 0x02		 1000 (XR)</span>
<span class="cm"> * 0x03		  250 (XR)</span>
<span class="cm"> * 0x04 - 05	-Reserved-</span>
<span class="cm"> * 0x06		 2000 (XR)</span>
<span class="cm"> * 0x07		  500 (XR)</span>
<span class="cm"> * 0x08		48000 (OFDM)</span>
<span class="cm"> * 0x09		24000 (OFDM)</span>
<span class="cm"> * 0x0A		12000 (OFDM)</span>
<span class="cm"> * 0x0B		 6000 (OFDM)</span>
<span class="cm"> * 0x0C		54000 (OFDM)</span>
<span class="cm"> * 0x0D		36000 (OFDM)</span>
<span class="cm"> * 0x0E		18000 (OFDM)</span>
<span class="cm"> * 0x0F		 9000 (OFDM)</span>
<span class="cm"> * 0x10 - 17	-Reserved-</span>
<span class="cm"> * 0x18		11000L (CCK)</span>
<span class="cm"> * 0x19		 5500L (CCK)</span>
<span class="cm"> * 0x1A		 2000L (CCK)</span>
<span class="cm"> * 0x1B		 1000L (CCK)</span>
<span class="cm"> * 0x1C		11000S (CCK)</span>
<span class="cm"> * 0x1D		 5500S (CCK)</span>
<span class="cm"> * 0x1E		 2000S (CCK)</span>
<span class="cm"> * 0x1F		-Reserved-</span>
<span class="cm"> *</span>
<span class="cm"> * &quot;S&quot; indicates CCK rates with short preamble and &quot;L&quot; with long preamble.</span>
<span class="cm"> *</span>
<span class="cm"> * AR5211 has different rate codes for CCK (802.11B) rates. It only uses the</span>
<span class="cm"> * lowest 4 bits, so they are the same as above with a 0xF mask.</span>
<span class="cm"> * (0xB, 0xA, 0x9 and 0x8 for 1M, 2M, 5.5M and 11M).</span>
<span class="cm"> * We handle this in ath5k_setup_bands().</span>
<span class="cm"> */</span>
<span class="cp">#define AR5K_MAX_RATES 32</span>

<span class="cm">/* B */</span>
<span class="cp">#define ATH5K_RATE_CODE_1M	0x1B</span>
<span class="cp">#define ATH5K_RATE_CODE_2M	0x1A</span>
<span class="cp">#define ATH5K_RATE_CODE_5_5M	0x19</span>
<span class="cp">#define ATH5K_RATE_CODE_11M	0x18</span>
<span class="cm">/* A and G */</span>
<span class="cp">#define ATH5K_RATE_CODE_6M	0x0B</span>
<span class="cp">#define ATH5K_RATE_CODE_9M	0x0F</span>
<span class="cp">#define ATH5K_RATE_CODE_12M	0x0A</span>
<span class="cp">#define ATH5K_RATE_CODE_18M	0x0E</span>
<span class="cp">#define ATH5K_RATE_CODE_24M	0x09</span>
<span class="cp">#define ATH5K_RATE_CODE_36M	0x0D</span>
<span class="cp">#define ATH5K_RATE_CODE_48M	0x08</span>
<span class="cp">#define ATH5K_RATE_CODE_54M	0x0C</span>

<span class="cm">/* Adding this flag to rate_code on B rates</span>
<span class="cm"> * enables short preamble */</span>
<span class="cp">#define AR5K_SET_SHORT_PREAMBLE 0x04</span>

<span class="cm">/*</span>
<span class="cm"> * Crypto definitions</span>
<span class="cm"> */</span>

<span class="cp">#define AR5K_KEYCACHE_SIZE	8</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">ath5k_modparam_nohwcrypt</span><span class="p">;</span>

<span class="cm">/***********************\</span>
<span class="cm"> HW RELATED DEFINITIONS</span>
<span class="cm">\***********************/</span>

<span class="cm">/*</span>
<span class="cm"> * Misc definitions</span>
<span class="cm"> */</span>
<span class="cp">#define	AR5K_RSSI_EP_MULTIPLIER	(1 &lt;&lt; 7)</span>

<span class="cp">#define AR5K_ASSERT_ENTRY(_e, _s) do {		\</span>
<span class="cp">	if (_e &gt;= _s)				\</span>
<span class="cp">		return false;			\</span>
<span class="cp">} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Hardware interrupt abstraction</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * enum ath5k_int - Hardware interrupt masks helpers</span>
<span class="cm"> * @AR5K_INT_RXOK: Frame successfully received</span>
<span class="cm"> * @AR5K_INT_RXDESC: Request RX descriptor/Read RX descriptor</span>
<span class="cm"> * @AR5K_INT_RXERR: Frame reception failed</span>
<span class="cm"> * @AR5K_INT_RXNOFRM: No frame received within a specified time period</span>
<span class="cm"> * @AR5K_INT_RXEOL: Reached &quot;End Of List&quot;, means we need more RX descriptors</span>
<span class="cm"> * @AR5K_INT_RXORN: Indicates we got RX FIFO overrun. Note that Rx overrun is</span>
<span class="cm"> *		not always fatal, on some chips we can continue operation</span>
<span class="cm"> *		without resetting the card, that&#39;s why %AR5K_INT_FATAL is not</span>
<span class="cm"> *		common for all chips.</span>
<span class="cm"> * @AR5K_INT_RX_ALL: Mask to identify all RX related interrupts</span>
<span class="cm"> *</span>
<span class="cm"> * @AR5K_INT_TXOK: Frame transmission success</span>
<span class="cm"> * @AR5K_INT_TXDESC: Request TX descriptor/Read TX status descriptor</span>
<span class="cm"> * @AR5K_INT_TXERR: Frame transmission failure</span>
<span class="cm"> * @AR5K_INT_TXEOL: Received End Of List for VEOL (Virtual End Of List). The</span>
<span class="cm"> *		Queue Control Unit (QCU) signals an EOL interrupt only if a</span>
<span class="cm"> *		descriptor&#39;s LinkPtr is NULL. For more details, refer to:</span>
<span class="cm"> *		&quot;http://www.freepatentsonline.com/20030225739.html&quot;</span>
<span class="cm"> * @AR5K_INT_TXNOFRM: No frame was transmitted within a specified time period</span>
<span class="cm"> * @AR5K_INT_TXURN: Indicates we got TX FIFO underrun. In such case we should</span>
<span class="cm"> *		increase the TX trigger threshold.</span>
<span class="cm"> * @AR5K_INT_TX_ALL: Mask to identify all TX related interrupts</span>
<span class="cm"> *</span>
<span class="cm"> * @AR5K_INT_MIB: Indicates the either Management Information Base counters or</span>
<span class="cm"> *		one of the PHY error counters reached the maximum value and</span>
<span class="cm"> *		should be read and cleared.</span>
<span class="cm"> * @AR5K_INT_SWI: Software triggered interrupt.</span>
<span class="cm"> * @AR5K_INT_RXPHY: RX PHY Error</span>
<span class="cm"> * @AR5K_INT_RXKCM: RX Key cache miss</span>
<span class="cm"> * @AR5K_INT_SWBA: SoftWare Beacon Alert - indicates its time to send a</span>
<span class="cm"> *		beacon that must be handled in software. The alternative is if</span>
<span class="cm"> *		you have VEOL support, in that case you let the hardware deal</span>
<span class="cm"> *		with things.</span>
<span class="cm"> * @AR5K_INT_BRSSI: Beacon received with an RSSI value below our threshold</span>
<span class="cm"> * @AR5K_INT_BMISS: If in STA mode this indicates we have stopped seeing</span>
<span class="cm"> *		beacons from the AP have associated with, we should probably</span>
<span class="cm"> *		try to reassociate. When in IBSS mode this might mean we have</span>
<span class="cm"> *		not received any beacons from any local stations. Note that</span>
<span class="cm"> *		every station in an IBSS schedules to send beacons at the</span>
<span class="cm"> *		Target Beacon Transmission Time (TBTT) with a random backoff.</span>
<span class="cm"> * @AR5K_INT_BNR: Beacon queue got triggered (DMA beacon alert) while empty.</span>
<span class="cm"> * @AR5K_INT_TIM: Beacon with local station&#39;s TIM bit set</span>
<span class="cm"> * @AR5K_INT_DTIM: Beacon with DTIM bit and zero DTIM count received</span>
<span class="cm"> * @AR5K_INT_DTIM_SYNC: DTIM sync lost</span>
<span class="cm"> * @AR5K_INT_GPIO: GPIO interrupt is used for RF Kill switches connected to</span>
<span class="cm"> *		our GPIO pins.</span>
<span class="cm"> * @AR5K_INT_BCN_TIMEOUT: Beacon timeout, we waited after TBTT but got noting</span>
<span class="cm"> * @AR5K_INT_CAB_TIMEOUT: We waited for CAB traffic after the beacon but got</span>
<span class="cm"> *		nothing or an incomplete CAB frame sequence.</span>
<span class="cm"> * @AR5K_INT_QCBRORN: A queue got it&#39;s CBR counter expired</span>
<span class="cm"> * @AR5K_INT_QCBRURN: A queue got triggered wile empty</span>
<span class="cm"> * @AR5K_INT_QTRIG: A queue got triggered</span>
<span class="cm"> *</span>
<span class="cm"> * @AR5K_INT_FATAL: Fatal errors were encountered, typically caused by bus/DMA</span>
<span class="cm"> *		errors. Indicates we need to reset the card.</span>
<span class="cm"> * @AR5K_INT_GLOBAL: Used to clear and set the IER</span>
<span class="cm"> * @AR5K_INT_NOCARD: Signals the card has been removed</span>
<span class="cm"> * @AR5K_INT_COMMON: Common interrupts shared among MACs with the same</span>
<span class="cm"> *		bit value</span>
<span class="cm"> *</span>
<span class="cm"> * These are mapped to take advantage of some common bits</span>
<span class="cm"> * between the MACs, to be able to set intr properties</span>
<span class="cm"> * easier. Some of them are not used yet inside hw.c. Most map</span>
<span class="cm"> * to the respective hw interrupt value as they are common among different</span>
<span class="cm"> * MACs.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ath5k_int</span> <span class="p">{</span>
	<span class="n">AR5K_INT_RXOK</span>	<span class="o">=</span> <span class="mh">0x00000001</span><span class="p">,</span>
	<span class="n">AR5K_INT_RXDESC</span>	<span class="o">=</span> <span class="mh">0x00000002</span><span class="p">,</span>
	<span class="n">AR5K_INT_RXERR</span>	<span class="o">=</span> <span class="mh">0x00000004</span><span class="p">,</span>
	<span class="n">AR5K_INT_RXNOFRM</span> <span class="o">=</span> <span class="mh">0x00000008</span><span class="p">,</span>
	<span class="n">AR5K_INT_RXEOL</span>	<span class="o">=</span> <span class="mh">0x00000010</span><span class="p">,</span>
	<span class="n">AR5K_INT_RXORN</span>	<span class="o">=</span> <span class="mh">0x00000020</span><span class="p">,</span>
	<span class="n">AR5K_INT_TXOK</span>	<span class="o">=</span> <span class="mh">0x00000040</span><span class="p">,</span>
	<span class="n">AR5K_INT_TXDESC</span>	<span class="o">=</span> <span class="mh">0x00000080</span><span class="p">,</span>
	<span class="n">AR5K_INT_TXERR</span>	<span class="o">=</span> <span class="mh">0x00000100</span><span class="p">,</span>
	<span class="n">AR5K_INT_TXNOFRM</span> <span class="o">=</span> <span class="mh">0x00000200</span><span class="p">,</span>
	<span class="n">AR5K_INT_TXEOL</span>	<span class="o">=</span> <span class="mh">0x00000400</span><span class="p">,</span>
	<span class="n">AR5K_INT_TXURN</span>	<span class="o">=</span> <span class="mh">0x00000800</span><span class="p">,</span>
	<span class="n">AR5K_INT_MIB</span>	<span class="o">=</span> <span class="mh">0x00001000</span><span class="p">,</span>
	<span class="n">AR5K_INT_SWI</span>	<span class="o">=</span> <span class="mh">0x00002000</span><span class="p">,</span>
	<span class="n">AR5K_INT_RXPHY</span>	<span class="o">=</span> <span class="mh">0x00004000</span><span class="p">,</span>
	<span class="n">AR5K_INT_RXKCM</span>	<span class="o">=</span> <span class="mh">0x00008000</span><span class="p">,</span>
	<span class="n">AR5K_INT_SWBA</span>	<span class="o">=</span> <span class="mh">0x00010000</span><span class="p">,</span>
	<span class="n">AR5K_INT_BRSSI</span>	<span class="o">=</span> <span class="mh">0x00020000</span><span class="p">,</span>
	<span class="n">AR5K_INT_BMISS</span>	<span class="o">=</span> <span class="mh">0x00040000</span><span class="p">,</span>
	<span class="n">AR5K_INT_FATAL</span>	<span class="o">=</span> <span class="mh">0x00080000</span><span class="p">,</span> <span class="cm">/* Non common */</span>
	<span class="n">AR5K_INT_BNR</span>	<span class="o">=</span> <span class="mh">0x00100000</span><span class="p">,</span> <span class="cm">/* Non common */</span>
	<span class="n">AR5K_INT_TIM</span>	<span class="o">=</span> <span class="mh">0x00200000</span><span class="p">,</span> <span class="cm">/* Non common */</span>
	<span class="n">AR5K_INT_DTIM</span>	<span class="o">=</span> <span class="mh">0x00400000</span><span class="p">,</span> <span class="cm">/* Non common */</span>
	<span class="n">AR5K_INT_DTIM_SYNC</span> <span class="o">=</span>	<span class="mh">0x00800000</span><span class="p">,</span> <span class="cm">/* Non common */</span>
	<span class="n">AR5K_INT_GPIO</span>	<span class="o">=</span>	<span class="mh">0x01000000</span><span class="p">,</span>
	<span class="n">AR5K_INT_BCN_TIMEOUT</span> <span class="o">=</span>	<span class="mh">0x02000000</span><span class="p">,</span> <span class="cm">/* Non common */</span>
	<span class="n">AR5K_INT_CAB_TIMEOUT</span> <span class="o">=</span>	<span class="mh">0x04000000</span><span class="p">,</span> <span class="cm">/* Non common */</span>
	<span class="n">AR5K_INT_QCBRORN</span> <span class="o">=</span>	<span class="mh">0x08000000</span><span class="p">,</span> <span class="cm">/* Non common */</span>
	<span class="n">AR5K_INT_QCBRURN</span> <span class="o">=</span>	<span class="mh">0x10000000</span><span class="p">,</span> <span class="cm">/* Non common */</span>
	<span class="n">AR5K_INT_QTRIG</span>	<span class="o">=</span>	<span class="mh">0x20000000</span><span class="p">,</span> <span class="cm">/* Non common */</span>
	<span class="n">AR5K_INT_GLOBAL</span> <span class="o">=</span>	<span class="mh">0x80000000</span><span class="p">,</span>

	<span class="n">AR5K_INT_TX_ALL</span> <span class="o">=</span> <span class="n">AR5K_INT_TXOK</span>
		<span class="o">|</span> <span class="n">AR5K_INT_TXDESC</span>
		<span class="o">|</span> <span class="n">AR5K_INT_TXERR</span>
		<span class="o">|</span> <span class="n">AR5K_INT_TXNOFRM</span>
		<span class="o">|</span> <span class="n">AR5K_INT_TXEOL</span>
		<span class="o">|</span> <span class="n">AR5K_INT_TXURN</span><span class="p">,</span>

	<span class="n">AR5K_INT_RX_ALL</span> <span class="o">=</span> <span class="n">AR5K_INT_RXOK</span>
		<span class="o">|</span> <span class="n">AR5K_INT_RXDESC</span>
		<span class="o">|</span> <span class="n">AR5K_INT_RXERR</span>
		<span class="o">|</span> <span class="n">AR5K_INT_RXNOFRM</span>
		<span class="o">|</span> <span class="n">AR5K_INT_RXEOL</span>
		<span class="o">|</span> <span class="n">AR5K_INT_RXORN</span><span class="p">,</span>

	<span class="n">AR5K_INT_COMMON</span>  <span class="o">=</span> <span class="n">AR5K_INT_RXOK</span>
		<span class="o">|</span> <span class="n">AR5K_INT_RXDESC</span>
		<span class="o">|</span> <span class="n">AR5K_INT_RXERR</span>
		<span class="o">|</span> <span class="n">AR5K_INT_RXNOFRM</span>
		<span class="o">|</span> <span class="n">AR5K_INT_RXEOL</span>
		<span class="o">|</span> <span class="n">AR5K_INT_RXORN</span>
		<span class="o">|</span> <span class="n">AR5K_INT_TXOK</span>
		<span class="o">|</span> <span class="n">AR5K_INT_TXDESC</span>
		<span class="o">|</span> <span class="n">AR5K_INT_TXERR</span>
		<span class="o">|</span> <span class="n">AR5K_INT_TXNOFRM</span>
		<span class="o">|</span> <span class="n">AR5K_INT_TXEOL</span>
		<span class="o">|</span> <span class="n">AR5K_INT_TXURN</span>
		<span class="o">|</span> <span class="n">AR5K_INT_MIB</span>
		<span class="o">|</span> <span class="n">AR5K_INT_SWI</span>
		<span class="o">|</span> <span class="n">AR5K_INT_RXPHY</span>
		<span class="o">|</span> <span class="n">AR5K_INT_RXKCM</span>
		<span class="o">|</span> <span class="n">AR5K_INT_SWBA</span>
		<span class="o">|</span> <span class="n">AR5K_INT_BRSSI</span>
		<span class="o">|</span> <span class="n">AR5K_INT_BMISS</span>
		<span class="o">|</span> <span class="n">AR5K_INT_GPIO</span>
		<span class="o">|</span> <span class="n">AR5K_INT_GLOBAL</span><span class="p">,</span>

	<span class="n">AR5K_INT_NOCARD</span>	<span class="o">=</span> <span class="mh">0xffffffff</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum ath5k_calibration_mask - Mask which calibration is active at the moment</span>
<span class="cm"> * @AR5K_CALIBRATION_FULL: Full calibration (AGC + SHORT)</span>
<span class="cm"> * @AR5K_CALIBRATION_SHORT: Short calibration (NF + I/Q)</span>
<span class="cm"> * @AR5K_CALIBRATION_NF: Noise Floor calibration</span>
<span class="cm"> * @AR5K_CALIBRATION_ANI: Adaptive Noise Immunity</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ath5k_calibration_mask</span> <span class="p">{</span>
	<span class="n">AR5K_CALIBRATION_FULL</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
	<span class="n">AR5K_CALIBRATION_SHORT</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
	<span class="n">AR5K_CALIBRATION_NF</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
	<span class="n">AR5K_CALIBRATION_ANI</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum ath5k_power_mode - Power management modes</span>
<span class="cm"> * @AR5K_PM_UNDEFINED: Undefined</span>
<span class="cm"> * @AR5K_PM_AUTO: Allow card to sleep if possible</span>
<span class="cm"> * @AR5K_PM_AWAKE: Force card to wake up</span>
<span class="cm"> * @AR5K_PM_FULL_SLEEP: Force card to full sleep (DANGEROUS)</span>
<span class="cm"> * @AR5K_PM_NETWORK_SLEEP: Allow to sleep for a specified duration</span>
<span class="cm"> *</span>
<span class="cm"> * Currently only PM_AWAKE is used, FULL_SLEEP and NETWORK_SLEEP/AUTO</span>
<span class="cm"> * are also known to have problems on some cards. This is not a big</span>
<span class="cm"> * problem though because we can have almost the same effect as</span>
<span class="cm"> * FULL_SLEEP by putting card on warm reset (it&#39;s almost powered down).</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ath5k_power_mode</span> <span class="p">{</span>
	<span class="n">AR5K_PM_UNDEFINED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">AR5K_PM_AUTO</span><span class="p">,</span>
	<span class="n">AR5K_PM_AWAKE</span><span class="p">,</span>
	<span class="n">AR5K_PM_FULL_SLEEP</span><span class="p">,</span>
	<span class="n">AR5K_PM_NETWORK_SLEEP</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * These match net80211 definitions (not used in</span>
<span class="cm"> * mac80211).</span>
<span class="cm"> * TODO: Clean this up</span>
<span class="cm"> */</span>
<span class="cp">#define AR5K_LED_INIT	0 </span><span class="cm">/*IEEE80211_S_INIT*/</span><span class="cp"></span>
<span class="cp">#define AR5K_LED_SCAN	1 </span><span class="cm">/*IEEE80211_S_SCAN*/</span><span class="cp"></span>
<span class="cp">#define AR5K_LED_AUTH	2 </span><span class="cm">/*IEEE80211_S_AUTH*/</span><span class="cp"></span>
<span class="cp">#define AR5K_LED_ASSOC	3 </span><span class="cm">/*IEEE80211_S_ASSOC*/</span><span class="cp"></span>
<span class="cp">#define AR5K_LED_RUN	4 </span><span class="cm">/*IEEE80211_S_RUN*/</span><span class="cp"></span>

<span class="cm">/* GPIO-controlled software LED */</span>
<span class="cp">#define AR5K_SOFTLED_PIN	0</span>
<span class="cp">#define AR5K_SOFTLED_ON		0</span>
<span class="cp">#define AR5K_SOFTLED_OFF	1</span>


<span class="cm">/* XXX: we *may* move cap_range stuff to struct wiphy */</span>
<span class="k">struct</span> <span class="n">ath5k_capabilities</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Supported PHY modes</span>
<span class="cm">	 * (ie. AR5K_MODE_11A, AR5K_MODE_11B, ...)</span>
<span class="cm">	 */</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">cap_mode</span><span class="p">,</span> <span class="n">AR5K_MODE_MAX</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Frequency range (without regulation restrictions)</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u16</span>	<span class="n">range_2ghz_min</span><span class="p">;</span>
		<span class="n">u16</span>	<span class="n">range_2ghz_max</span><span class="p">;</span>
		<span class="n">u16</span>	<span class="n">range_5ghz_min</span><span class="p">;</span>
		<span class="n">u16</span>	<span class="n">range_5ghz_max</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">cap_range</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Values stored in the EEPROM (some of them...)</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">ath5k_eeprom_info</span>	<span class="n">cap_eeprom</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Queue information</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u8</span>	<span class="n">q_tx_num</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">cap_queues</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">cap_has_phyerr_counters</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">cap_has_mrr_support</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">cap_needs_2GHz_ovr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* size of noise floor history (keep it a power of two) */</span>
<span class="cp">#define ATH5K_NF_CAL_HIST_MAX	8</span>
<span class="k">struct</span> <span class="n">ath5k_nfcal_hist</span> <span class="p">{</span>
	<span class="n">s16</span> <span class="n">index</span><span class="p">;</span>				<span class="cm">/* current index into nfval */</span>
	<span class="n">s16</span> <span class="n">nfval</span><span class="p">[</span><span class="n">ATH5K_NF_CAL_HIST_MAX</span><span class="p">];</span>	<span class="cm">/* last few noise floors */</span>
<span class="p">};</span>

<span class="cp">#define ATH5K_LED_MAX_NAME_LEN 31</span>

<span class="cm">/*</span>
<span class="cm"> * State for LED triggers</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ath5k_led</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">ATH5K_LED_MAX_NAME_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>	<span class="cm">/* name of the LED in sysfs */</span>
	<span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">;</span>			<span class="cm">/* driver state */</span>
	<span class="k">struct</span> <span class="n">led_classdev</span> <span class="n">led_dev</span><span class="p">;</span>		<span class="cm">/* led classdev */</span>
<span class="p">};</span>

<span class="cm">/* Rfkill */</span>
<span class="k">struct</span> <span class="n">ath5k_rfkill</span> <span class="p">{</span>
	<span class="cm">/* GPIO PIN for rfkill */</span>
	<span class="n">u16</span> <span class="n">gpio</span><span class="p">;</span>
	<span class="cm">/* polarity of rfkill GPIO PIN */</span>
	<span class="n">bool</span> <span class="n">polarity</span><span class="p">;</span>
	<span class="cm">/* RFKILL toggle tasklet */</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">toggleq</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* statistics */</span>
<span class="k">struct</span> <span class="n">ath5k_statistics</span> <span class="p">{</span>
	<span class="cm">/* antenna use */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">antenna_rx</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>	<span class="cm">/* frames count per antenna RX */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">antenna_tx</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>	<span class="cm">/* frames count per antenna TX */</span>

	<span class="cm">/* frame errors */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_all_count</span><span class="p">;</span>	<span class="cm">/* all RX frames, including errors */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_all_count</span><span class="p">;</span>	<span class="cm">/* all TX frames, including errors */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_bytes_count</span><span class="p">;</span>	<span class="cm">/* all RX bytes, including errored pkts</span>
<span class="cm">					 * and the MAC headers for each packet</span>
<span class="cm">					 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_bytes_count</span><span class="p">;</span>	<span class="cm">/* all TX bytes, including errored pkts</span>
<span class="cm">					 * and the MAC headers and padding for</span>
<span class="cm">					 * each packet.</span>
<span class="cm">					 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rxerr_crc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rxerr_phy</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rxerr_phy_code</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rxerr_fifo</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rxerr_decrypt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rxerr_mic</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rxerr_proc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rxerr_jumbo</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">txerr_retry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">txerr_fifo</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">txerr_filt</span><span class="p">;</span>

	<span class="cm">/* MIB counters */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ack_fail</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rts_fail</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rts_ok</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fcs_error</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">beacons</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mib_intr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rxorn_intr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rxeol_intr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Misc defines</span>
<span class="cm"> */</span>

<span class="cp">#define AR5K_MAX_GPIO		10</span>
<span class="cp">#define AR5K_MAX_RF_BANKS	8</span>

<span class="cp">#if CHAN_DEBUG</span>
<span class="cp">#define ATH_CHAN_MAX	(26 + 26 + 26 + 200 + 200)</span>
<span class="cp">#else</span>
<span class="cp">#define ATH_CHAN_MAX	(14 + 14 + 14 + 252 + 20)</span>
<span class="cp">#endif</span>

<span class="cp">#define	ATH_RXBUF	40		</span><span class="cm">/* number of RX buffers */</span><span class="cp"></span>
<span class="cp">#define	ATH_TXBUF	200		</span><span class="cm">/* number of TX buffers */</span><span class="cp"></span>
<span class="cp">#define ATH_BCBUF	4		</span><span class="cm">/* number of beacon buffers */</span><span class="cp"></span>
<span class="cp">#define ATH5K_TXQ_LEN_MAX	(ATH_TXBUF / 4)		</span><span class="cm">/* bufs per queue */</span><span class="cp"></span>
<span class="cp">#define ATH5K_TXQ_LEN_LOW	(ATH5K_TXQ_LEN_MAX / 2)	</span><span class="cm">/* low mark */</span><span class="cp"></span>

<span class="cm">/* Driver state associated with an instance of a device */</span>
<span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ath_common</span>       <span class="n">common</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">pci_dev</span>		<span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">dev</span><span class="p">;</span>		<span class="cm">/* for dma mapping */</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">devid</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">iobase</span><span class="p">;</span>	<span class="cm">/* address of the device */</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">lock</span><span class="p">;</span>		<span class="cm">/* dev-level lock */</span>
	<span class="k">struct</span> <span class="n">ieee80211_hw</span>	<span class="o">*</span><span class="n">hw</span><span class="p">;</span>		<span class="cm">/* IEEE 802.11 common */</span>
	<span class="k">struct</span> <span class="n">ieee80211_supported_band</span> <span class="n">sbands</span><span class="p">[</span><span class="n">IEEE80211_NUM_BANDS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="n">channels</span><span class="p">[</span><span class="n">ATH_CHAN_MAX</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ieee80211_rate</span>	<span class="n">rates</span><span class="p">[</span><span class="n">IEEE80211_NUM_BANDS</span><span class="p">][</span><span class="n">AR5K_MAX_RATES</span><span class="p">];</span>
	<span class="n">s8</span>			<span class="n">rate_idx</span><span class="p">[</span><span class="n">IEEE80211_NUM_BANDS</span><span class="p">][</span><span class="n">AR5K_MAX_RATES</span><span class="p">];</span>
	<span class="k">enum</span> <span class="n">nl80211_iftype</span>	<span class="n">opmode</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_ATH5K_DEBUG</span>
	<span class="k">struct</span> <span class="n">ath5k_dbg_info</span>	<span class="n">debug</span><span class="p">;</span>		<span class="cm">/* debug info */</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ATH5K_DEBUG */</span><span class="cp"></span>

	<span class="k">struct</span> <span class="n">ath5k_buf</span>	<span class="o">*</span><span class="n">bufptr</span><span class="p">;</span>	<span class="cm">/* allocated buffer ptr */</span>
	<span class="k">struct</span> <span class="n">ath5k_desc</span>	<span class="o">*</span><span class="n">desc</span><span class="p">;</span>		<span class="cm">/* TX/RX descriptors */</span>
	<span class="n">dma_addr_t</span>		<span class="n">desc_daddr</span><span class="p">;</span>	<span class="cm">/* DMA (physical) address */</span>
	<span class="kt">size_t</span>			<span class="n">desc_len</span><span class="p">;</span>	<span class="cm">/* size of TX/RX descriptors */</span>

	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="cp">#define ATH_STAT_INVALID	0		</span><span class="cm">/* disable hardware accesses */</span><span class="cp"></span>
<span class="cp">#define ATH_STAT_PROMISC	1</span>
<span class="cp">#define ATH_STAT_LEDSOFT	2		</span><span class="cm">/* enable LED gpio status */</span><span class="cp"></span>
<span class="cp">#define ATH_STAT_STARTED	3		</span><span class="cm">/* opened &amp; irqs enabled */</span><span class="cp"></span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">filter_flags</span><span class="p">;</span>	<span class="cm">/* HW flags, AR5K_RX_FILTER_* */</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">curchan</span><span class="p">;</span>	<span class="cm">/* current h/w channel */</span>

	<span class="n">u16</span>			<span class="n">nvifs</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">ath5k_int</span>		<span class="n">imask</span><span class="p">;</span>		<span class="cm">/* interrupt mask copy */</span>

	<span class="n">spinlock_t</span>		<span class="n">irqlock</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">rx_pending</span><span class="p">;</span>	<span class="cm">/* rx tasklet pending */</span>
	<span class="n">bool</span>			<span class="n">tx_pending</span><span class="p">;</span>	<span class="cm">/* tx tasklet pending */</span>

	<span class="n">u8</span>			<span class="n">bssidmask</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">led_pin</span><span class="p">,</span>	<span class="cm">/* GPIO pin for driving LED */</span>
				<span class="n">led_on</span><span class="p">;</span>		<span class="cm">/* pin setting for LED on */</span>

	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">reset_work</span><span class="p">;</span>	<span class="cm">/* deferred chip reset */</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">calib_work</span><span class="p">;</span>	<span class="cm">/* deferred phy calibration */</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">rxbuf</span><span class="p">;</span>		<span class="cm">/* receive buffer */</span>
	<span class="n">spinlock_t</span>		<span class="n">rxbuflock</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="o">*</span><span class="n">rxlink</span><span class="p">;</span>	<span class="cm">/* link ptr in last RX desc */</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span>	<span class="n">rxtq</span><span class="p">;</span>		<span class="cm">/* rx intr tasklet */</span>
	<span class="k">struct</span> <span class="n">ath5k_led</span>	<span class="n">rx_led</span><span class="p">;</span>		<span class="cm">/* rx led */</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">txbuf</span><span class="p">;</span>		<span class="cm">/* transmit buffer */</span>
	<span class="n">spinlock_t</span>		<span class="n">txbuflock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">txbuf_len</span><span class="p">;</span>	<span class="cm">/* buf count in txbuf list */</span>
	<span class="k">struct</span> <span class="n">ath5k_txq</span>	<span class="n">txqs</span><span class="p">[</span><span class="n">AR5K_NUM_TX_QUEUES</span><span class="p">];</span>	<span class="cm">/* tx queues */</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span>	<span class="n">txtq</span><span class="p">;</span>		<span class="cm">/* tx intr tasklet */</span>
	<span class="k">struct</span> <span class="n">ath5k_led</span>	<span class="n">tx_led</span><span class="p">;</span>		<span class="cm">/* tx led */</span>

	<span class="k">struct</span> <span class="n">ath5k_rfkill</span>	<span class="n">rf_kill</span><span class="p">;</span>

	<span class="n">spinlock_t</span>		<span class="n">block</span><span class="p">;</span>		<span class="cm">/* protects beacon */</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span>	<span class="n">beacontq</span><span class="p">;</span>	<span class="cm">/* beacon intr tasklet */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">bcbuf</span><span class="p">;</span>		<span class="cm">/* beacon buffer */</span>
	<span class="k">struct</span> <span class="n">ieee80211_vif</span>	<span class="o">*</span><span class="n">bslot</span><span class="p">[</span><span class="n">ATH_BCBUF</span><span class="p">];</span>
	<span class="n">u16</span>			<span class="n">num_ap_vifs</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">num_adhoc_vifs</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">num_mesh_vifs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">bhalq</span><span class="p">,</span>		<span class="cm">/* SW q for outgoing beacons */</span>
				<span class="n">bmisscount</span><span class="p">,</span>	<span class="cm">/* missed beacon transmits */</span>
				<span class="n">bintval</span><span class="p">,</span>	<span class="cm">/* beacon interval in TU */</span>
				<span class="n">bsent</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">nexttbtt</span><span class="p">;</span>	<span class="cm">/* next beacon time in TU */</span>
	<span class="k">struct</span> <span class="n">ath5k_txq</span>	<span class="o">*</span><span class="n">cabq</span><span class="p">;</span>		<span class="cm">/* content after beacon */</span>

	<span class="kt">int</span>			<span class="n">power_level</span><span class="p">;</span>	<span class="cm">/* Requested tx power in dBm */</span>
	<span class="n">bool</span>			<span class="n">assoc</span><span class="p">;</span>		<span class="cm">/* associate state */</span>
	<span class="n">bool</span>			<span class="n">enable_beacon</span><span class="p">;</span>	<span class="cm">/* true if beacons are on */</span>

	<span class="k">struct</span> <span class="n">ath5k_statistics</span>	<span class="n">stats</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ath5k_ani_state</span>	<span class="n">ani_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span>	<span class="n">ani_tasklet</span><span class="p">;</span>	<span class="cm">/* ANI calibration */</span>

	<span class="k">struct</span> <span class="n">delayed_work</span>	<span class="n">tx_complete_work</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">survey_info</span>	<span class="n">survey</span><span class="p">;</span>		<span class="cm">/* collected survey info */</span>

	<span class="k">enum</span> <span class="n">ath5k_int</span>		<span class="n">ah_imr</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">ah_current_channel</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">ah_iq_cal_needed</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">ah_single_chip</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">ath5k_version</span>	<span class="n">ah_version</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ath5k_radio</span>	<span class="n">ah_radio</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">ah_mac_srev</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">ah_mac_version</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">ah_phy_revision</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">ah_radio_5ghz_revision</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">ah_radio_2ghz_revision</span><span class="p">;</span>

<span class="cp">#define ah_modes		ah_capabilities.cap_mode</span>
<span class="cp">#define ah_ee_version		ah_capabilities.cap_eeprom.ee_version</span>

	<span class="n">u8</span>			<span class="n">ah_retry_long</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">ah_retry_short</span><span class="p">;</span>

	<span class="n">u32</span>			<span class="n">ah_use_32khz_clock</span><span class="p">;</span>

	<span class="n">u8</span>			<span class="n">ah_coverage_class</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">ah_ack_bitrate_high</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">ah_bwmode</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">ah_short_slot</span><span class="p">;</span>

	<span class="cm">/* Antenna Control */</span>
	<span class="n">u32</span>			<span class="n">ah_ant_ctl</span><span class="p">[</span><span class="n">AR5K_EEPROM_N_MODES</span><span class="p">][</span><span class="n">AR5K_ANT_MAX</span><span class="p">];</span>
	<span class="n">u8</span>			<span class="n">ah_ant_mode</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">ah_tx_ant</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">ah_def_ant</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ath5k_capabilities</span> <span class="n">ah_capabilities</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ath5k_txq_info</span>	<span class="n">ah_txq</span><span class="p">[</span><span class="n">AR5K_NUM_TX_QUEUES</span><span class="p">];</span>
	<span class="n">u32</span>			<span class="n">ah_txq_status</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">ah_txq_imr_txok</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">ah_txq_imr_txerr</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">ah_txq_imr_txurn</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">ah_txq_imr_txdesc</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">ah_txq_imr_txeol</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">ah_txq_imr_cbrorn</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">ah_txq_imr_cbrurn</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">ah_txq_imr_qtrig</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">ah_txq_imr_nofrm</span><span class="p">;</span>

	<span class="n">u32</span>			<span class="n">ah_txq_isr_txok_all</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">ah_txq_isr_txurn</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">ah_txq_isr_qcborn</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">ah_txq_isr_qcburn</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">ah_txq_isr_qtrig</span><span class="p">;</span>

	<span class="n">u32</span>			<span class="o">*</span><span class="n">ah_rf_banks</span><span class="p">;</span>
	<span class="kt">size_t</span>			<span class="n">ah_rf_banks_size</span><span class="p">;</span>
	<span class="kt">size_t</span>			<span class="n">ah_rf_regs_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ath5k_gain</span>	<span class="n">ah_gain</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">ah_offset</span><span class="p">[</span><span class="n">AR5K_MAX_RF_BANKS</span><span class="p">];</span>


	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/* Temporary tables used for interpolation */</span>
		<span class="n">u8</span>		<span class="n">tmpL</span><span class="p">[</span><span class="n">AR5K_EEPROM_N_PD_GAINS</span><span class="p">]</span>
					<span class="p">[</span><span class="n">AR5K_EEPROM_POWER_TABLE_SIZE</span><span class="p">];</span>
		<span class="n">u8</span>		<span class="n">tmpR</span><span class="p">[</span><span class="n">AR5K_EEPROM_N_PD_GAINS</span><span class="p">]</span>
					<span class="p">[</span><span class="n">AR5K_EEPROM_POWER_TABLE_SIZE</span><span class="p">];</span>
		<span class="n">u8</span>		<span class="n">txp_pd_table</span><span class="p">[</span><span class="n">AR5K_EEPROM_POWER_TABLE_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">];</span>
		<span class="n">u16</span>		<span class="n">txp_rates_power_table</span><span class="p">[</span><span class="n">AR5K_MAX_RATES</span><span class="p">];</span>
		<span class="n">u8</span>		<span class="n">txp_min_idx</span><span class="p">;</span>
		<span class="n">bool</span>		<span class="n">txp_tpc</span><span class="p">;</span>
		<span class="cm">/* Values in 0.25dB units */</span>
		<span class="n">s16</span>		<span class="n">txp_min_pwr</span><span class="p">;</span>
		<span class="n">s16</span>		<span class="n">txp_max_pwr</span><span class="p">;</span>
		<span class="n">s16</span>		<span class="n">txp_cur_pwr</span><span class="p">;</span>
		<span class="cm">/* Values in 0.5dB units */</span>
		<span class="n">s16</span>		<span class="n">txp_offset</span><span class="p">;</span>
		<span class="n">s16</span>		<span class="n">txp_ofdm</span><span class="p">;</span>
		<span class="n">s16</span>		<span class="n">txp_cck_ofdm_gainf_delta</span><span class="p">;</span>
		<span class="cm">/* Value in dB units */</span>
		<span class="n">s16</span>		<span class="n">txp_cck_ofdm_pwr_delta</span><span class="p">;</span>
		<span class="n">bool</span>		<span class="n">txp_setup</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ah_txpower</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ath5k_nfcal_hist</span> <span class="n">ah_nfcal_hist</span><span class="p">;</span>

	<span class="cm">/* average beacon RSSI in our BSS (used by ANI) */</span>
	<span class="k">struct</span> <span class="n">ewma</span>		<span class="n">ah_beacon_rssi_avg</span><span class="p">;</span>

	<span class="cm">/* noise floor from last periodic calibration */</span>
	<span class="n">s32</span>			<span class="n">ah_noise_floor</span><span class="p">;</span>

	<span class="cm">/* Calibration timestamp */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ah_cal_next_full</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ah_cal_next_short</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ah_cal_next_ani</span><span class="p">;</span>

	<span class="cm">/* Calibration mask */</span>
	<span class="n">u8</span>			<span class="n">ah_cal_mask</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Function pointers</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ah_setup_tx_desc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ath5k_desc</span> <span class="o">*</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ath5k_pkt_type</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ah_proc_tx_desc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ath5k_desc</span> <span class="o">*</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ath5k_tx_status</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ah_proc_rx_desc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ath5k_desc</span> <span class="o">*</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ath5k_rx_status</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ath_bus_ops</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">ath_bus_type</span> <span class="n">ath_bus_type</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">read_cachesize</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ath_common</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">csz</span><span class="p">);</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">eeprom_read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ath_common</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span> <span class="n">u32</span> <span class="n">off</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">eeprom_read_mac</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Prototypes</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_ops</span> <span class="n">ath5k_hw_ops</span><span class="p">;</span>

<span class="cm">/* Initialization and detach functions */</span>
<span class="kt">int</span> <span class="n">ath5k_hw_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ath5k_hw_deinit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ath5k_sysfs_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ath5k_sysfs_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>

<span class="cm">/*Chip id helper functions */</span>
<span class="kt">int</span> <span class="n">ath5k_hw_read_srev</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>

<span class="cm">/* LED functions */</span>
<span class="kt">int</span> <span class="n">ath5k_init_leds</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ath5k_led_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ath5k_led_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ath5k_unregister_leds</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>


<span class="cm">/* Reset Functions */</span>
<span class="kt">int</span> <span class="n">ath5k_hw_nic_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ath5k_hw_on_hold</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ath5k_hw_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">enum</span> <span class="n">nl80211_iftype</span> <span class="n">op_mode</span><span class="p">,</span>
	   <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span> <span class="n">bool</span> <span class="n">fast</span><span class="p">,</span> <span class="n">bool</span> <span class="n">skip_pcu</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ath5k_hw_register_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flag</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">,</span>
			      <span class="n">bool</span> <span class="n">is_set</span><span class="p">);</span>
<span class="cm">/* Power management functions */</span>


<span class="cm">/* Clock rate related functions */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ath5k_hw_htoclock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">usec</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ath5k_hw_clocktoh</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clock</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ath5k_hw_set_clockrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>


<span class="cm">/* DMA Related Functions */</span>
<span class="kt">void</span> <span class="n">ath5k_hw_start_rx_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">ath5k_hw_get_rxdp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ath5k_hw_set_rxdp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u32</span> <span class="n">phys_addr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ath5k_hw_start_tx_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ath5k_hw_stop_beacon_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">ath5k_hw_get_txdp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ath5k_hw_set_txdp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">phys_addr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ath5k_hw_update_tx_triglevel</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">bool</span> <span class="n">increase</span><span class="p">);</span>
<span class="cm">/* Interrupt handling */</span>
<span class="n">bool</span> <span class="n">ath5k_hw_is_intr_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ath5k_hw_get_isr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ath5k_int</span> <span class="o">*</span><span class="n">interrupt_mask</span><span class="p">);</span>
<span class="k">enum</span> <span class="n">ath5k_int</span> <span class="n">ath5k_hw_set_imr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ath5k_int</span> <span class="n">new_mask</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ath5k_hw_update_mib_counters</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="cm">/* Init/Stop functions */</span>
<span class="kt">void</span> <span class="n">ath5k_hw_dma_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ath5k_hw_dma_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>

<span class="cm">/* EEPROM access functions */</span>
<span class="kt">int</span> <span class="n">ath5k_eeprom_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ath5k_eeprom_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>


<span class="cm">/* Protocol Control Unit Functions */</span>
<span class="cm">/* Helpers */</span>
<span class="kt">int</span> <span class="n">ath5k_hw_get_frame_duration</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_rate</span> <span class="o">*</span><span class="n">rate</span><span class="p">,</span> <span class="n">bool</span> <span class="n">shortpre</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ath5k_hw_get_default_slottime</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ath5k_hw_get_default_sifs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ath5k_hw_set_opmode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">enum</span> <span class="n">nl80211_iftype</span> <span class="n">opmode</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ath5k_hw_set_coverage_class</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u8</span> <span class="n">coverage_class</span><span class="p">);</span>
<span class="cm">/* RX filter control*/</span>
<span class="kt">int</span> <span class="n">ath5k_hw_set_lladdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ath5k_hw_set_bssid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ath5k_hw_set_bssid_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mask</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ath5k_hw_set_mcast_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u32</span> <span class="n">filter0</span><span class="p">,</span> <span class="n">u32</span> <span class="n">filter1</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">ath5k_hw_get_rx_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ath5k_hw_set_rx_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u32</span> <span class="n">filter</span><span class="p">);</span>
<span class="cm">/* Receive (DRU) start/stop functions */</span>
<span class="kt">void</span> <span class="n">ath5k_hw_start_rx_pcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ath5k_hw_stop_rx_pcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="cm">/* Beacon control functions */</span>
<span class="n">u64</span> <span class="n">ath5k_hw_get_tsf64</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ath5k_hw_set_tsf64</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u64</span> <span class="n">tsf64</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ath5k_hw_reset_tsf</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ath5k_hw_init_beacon_timers</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u32</span> <span class="n">next_beacon</span><span class="p">,</span>
							<span class="n">u32</span> <span class="n">interval</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">ath5k_hw_check_beacon_timers</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="kt">int</span> <span class="n">intval</span><span class="p">);</span>
<span class="cm">/* Init function */</span>
<span class="kt">void</span> <span class="n">ath5k_hw_pcu_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">enum</span> <span class="n">nl80211_iftype</span> <span class="n">op_mode</span><span class="p">);</span>

<span class="cm">/* Queue Control Unit, DFS Control Unit Functions */</span>
<span class="kt">int</span> <span class="n">ath5k_hw_get_tx_queueprops</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ath5k_txq_info</span> <span class="o">*</span><span class="n">queue_info</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ath5k_hw_set_tx_queueprops</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">ath5k_txq_info</span> <span class="o">*</span><span class="n">queue_info</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ath5k_hw_setup_tx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span>
			    <span class="k">enum</span> <span class="n">ath5k_tx_queue</span> <span class="n">queue_type</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ath5k_txq_info</span> <span class="o">*</span><span class="n">queue_info</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ath5k_hw_set_tx_retry_limits</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">ath5k_hw_num_tx_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ath5k_hw_release_tx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ath5k_hw_reset_tx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ath5k_hw_set_ifs_intervals</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slot_time</span><span class="p">);</span>
<span class="cm">/* Init function */</span>
<span class="kt">int</span> <span class="n">ath5k_hw_init_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>

<span class="cm">/* Hardware Descriptor Functions */</span>
<span class="kt">int</span> <span class="n">ath5k_hw_init_desc_functions</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ath5k_hw_setup_rx_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ath5k_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
			   <span class="n">u32</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ath5k_hw_setup_mrr_tx_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ath5k_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_rate1</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">tx_tries1</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">tx_rate2</span><span class="p">,</span>
	<span class="n">u_int</span> <span class="n">tx_tries2</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_rate3</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">tx_tries3</span><span class="p">);</span>


<span class="cm">/* GPIO Functions */</span>
<span class="kt">void</span> <span class="n">ath5k_hw_set_ledstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">state</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ath5k_hw_set_gpio_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u32</span> <span class="n">gpio</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ath5k_hw_set_gpio_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u32</span> <span class="n">gpio</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">ath5k_hw_get_gpio</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u32</span> <span class="n">gpio</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ath5k_hw_set_gpio</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u32</span> <span class="n">gpio</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ath5k_hw_set_gpio_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gpio</span><span class="p">,</span>
			    <span class="n">u32</span> <span class="n">interrupt_level</span><span class="p">);</span>


<span class="cm">/* RFkill Functions */</span>
<span class="kt">void</span> <span class="n">ath5k_rfkill_hw_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ath5k_rfkill_hw_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>


<span class="cm">/* Misc functions TODO: Cleanup */</span>
<span class="kt">int</span> <span class="n">ath5k_hw_set_capabilities</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ath5k_hw_enable_pspoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">bssid</span><span class="p">,</span> <span class="n">u16</span> <span class="n">assoc_id</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ath5k_hw_disable_pspoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>


<span class="cm">/* Initial register settings functions */</span>
<span class="kt">int</span> <span class="n">ath5k_hw_write_initvals</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u8</span> <span class="n">mode</span><span class="p">,</span> <span class="n">bool</span> <span class="n">change_channel</span><span class="p">);</span>


<span class="cm">/* PHY functions */</span>
<span class="cm">/* Misc PHY functions */</span>
<span class="n">u16</span> <span class="n">ath5k_hw_radio_revision</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ath5k_hw_phy_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="cm">/* Gain_F optimization */</span>
<span class="k">enum</span> <span class="n">ath5k_rfgain</span> <span class="n">ath5k_hw_gainf_calibrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ath5k_hw_rfgain_opt_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="cm">/* PHY/RF channel functions */</span>
<span class="n">bool</span> <span class="n">ath5k_channel_ok</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">);</span>
<span class="cm">/* PHY calibration */</span>
<span class="kt">void</span> <span class="n">ath5k_hw_init_nfcal_hist</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ath5k_hw_phy_calibrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ath5k_hw_update_noise_floor</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
<span class="cm">/* Spur mitigation */</span>
<span class="n">bool</span> <span class="n">ath5k_hw_chan_has_spur_noise</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">);</span>
<span class="cm">/* Antenna control */</span>
<span class="kt">void</span> <span class="n">ath5k_hw_set_antenna_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ant_mode</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ath5k_hw_set_antenna_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ee_mode</span><span class="p">);</span>
<span class="cm">/* TX power setup */</span>
<span class="kt">int</span> <span class="n">ath5k_hw_set_txpower_limit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u8</span> <span class="n">txpower</span><span class="p">);</span>
<span class="cm">/* Init function */</span>
<span class="kt">int</span> <span class="n">ath5k_hw_phy_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
				<span class="n">u8</span> <span class="n">mode</span><span class="p">,</span> <span class="n">bool</span> <span class="n">fast</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Functions used internally</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ath_common</span> <span class="o">*</span><span class="nf">ath5k_hw_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ath_regulatory</span> <span class="o">*</span><span class="nf">ath5k_hw_regulatory</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ath5k_hw_common</span><span class="p">(</span><span class="n">ah</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">regulatory</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_ATHEROS_AR231X</span>
<span class="cp">#define AR5K_AR2315_PCI_BASE	((void __iomem *)0xb0100000)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="nf">ath5k_ahb_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* On AR2315 and AR2317 the PCI clock domain registers</span>
<span class="cm">	 * are outside of the WMAC register space */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">reg</span> <span class="o">&gt;=</span> <span class="mh">0x4000</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&lt;</span> <span class="mh">0x5000</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_mac_srev</span> <span class="o">&gt;=</span> <span class="n">AR5K_SREV_AR2315_R6</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">AR5K_AR2315_PCI_BASE</span> <span class="o">+</span> <span class="n">reg</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">reg</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">ath5k_hw_reg_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">ath5k_ahb_reg</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">reg</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ath5k_hw_reg_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">ath5k_ahb_reg</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">reg</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">ath5k_hw_reg_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ath5k_hw_reg_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">ath_bus_type</span> <span class="nf">ath5k_get_bus_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ath5k_hw_common</span><span class="p">(</span><span class="n">ah</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bus_ops</span><span class="o">-&gt;</span><span class="n">ath_bus_type</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ath5k_read_cachesize</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath_common</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">csz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">bus_ops</span><span class="o">-&gt;</span><span class="n">read_cachesize</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">csz</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">ath5k_hw_nvram_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u32</span> <span class="n">off</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ath_common</span> <span class="o">*</span><span class="n">common</span> <span class="o">=</span> <span class="n">ath5k_hw_common</span><span class="p">(</span><span class="n">ah</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">bus_ops</span><span class="o">-&gt;</span><span class="n">eeprom_read</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">ath5k_hw_bitswap</span><span class="p">(</span><span class="n">u32</span> <span class="n">val</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bit</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bits</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bit</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">bit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
