<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › ath › ath5k › phy.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>phy.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2004-2007 Reyk Floeter &lt;reyk@openbsd.org&gt;</span>
<span class="cm"> * Copyright (c) 2006-2009 Nick Kossifidis &lt;mickflemm@gmail.com&gt;</span>
<span class="cm"> * Copyright (c) 2007-2008 Jiri Slaby &lt;jirislaby@gmail.com&gt;</span>
<span class="cm"> * Copyright (c) 2008-2009 Felix Fietkau &lt;nbd@openwrt.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Permission to use, copy, modify, and distribute this software for any</span>
<span class="cm"> * purpose with or without fee is hereby granted, provided that the above</span>
<span class="cm"> * copyright notice and this permission notice appear in all copies.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES</span>
<span class="cm"> * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR</span>
<span class="cm"> * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="cm"> * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="cm"> * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</span>
<span class="cm"> * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/***********************\</span>
<span class="cm">* PHY related functions *</span>
<span class="cm">\***********************/</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>

<span class="cp">#include &quot;ath5k.h&quot;</span>
<span class="cp">#include &quot;reg.h&quot;</span>
<span class="cp">#include &quot;rfbuffer.h&quot;</span>
<span class="cp">#include &quot;rfgain.h&quot;</span>
<span class="cp">#include &quot;../regd.h&quot;</span>


<span class="cm">/**</span>
<span class="cm"> * DOC: PHY related functions</span>
<span class="cm"> *</span>
<span class="cm"> * Here we handle the low-level functions related to baseband</span>
<span class="cm"> * and analog frontend (RF) parts. This is by far the most complex</span>
<span class="cm"> * part of the hw code so make sure you know what you are doing.</span>
<span class="cm"> *</span>
<span class="cm"> * Here is a list of what this is all about:</span>
<span class="cm"> *</span>
<span class="cm"> * - Channel setting/switching</span>
<span class="cm"> *</span>
<span class="cm"> * - Automatic Gain Control (AGC) calibration</span>
<span class="cm"> *</span>
<span class="cm"> * - Noise Floor calibration</span>
<span class="cm"> *</span>
<span class="cm"> * - I/Q imbalance calibration (QAM correction)</span>
<span class="cm"> *</span>
<span class="cm"> * - Calibration due to thermal changes (gain_F)</span>
<span class="cm"> *</span>
<span class="cm"> * - Spur noise mitigation</span>
<span class="cm"> *</span>
<span class="cm"> * - RF/PHY initialization for the various operating modes and bwmodes</span>
<span class="cm"> *</span>
<span class="cm"> * - Antenna control</span>
<span class="cm"> *</span>
<span class="cm"> * - TX power control per channel/rate/packet type</span>
<span class="cm"> *</span>
<span class="cm"> * Also have in mind we never got documentation for most of these</span>
<span class="cm"> * functions, what we have comes mostly from Atheros&#39;s code, reverse</span>
<span class="cm"> * engineering and patent docs/presentations etc.</span>
<span class="cm"> */</span>


<span class="cm">/******************\</span>
<span class="cm">* Helper functions *</span>
<span class="cm">\******************/</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_radio_revision() - Get the PHY Chip revision</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @band: One of enum ieee80211_band</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the revision number of a 2GHz, 5GHz or single chip</span>
<span class="cm"> * radio.</span>
<span class="cm"> */</span>
<span class="n">u16</span>
<span class="nf">ath5k_hw_radio_revision</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">srev</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the radio chip access register</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">band</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IEEE80211_BAND_2GHZ</span>:
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_SHIFT_2GHZ</span><span class="p">,</span> <span class="n">AR5K_PHY</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IEEE80211_BAND_5GHZ</span>:
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_SHIFT_5GHZ</span><span class="p">,</span> <span class="n">AR5K_PHY</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">usleep_range</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">2500</span><span class="p">);</span>

	<span class="cm">/* ...wait until PHY is ready and read the selected radio revision */</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="mh">0x00001c16</span><span class="p">,</span> <span class="n">AR5K_PHY</span><span class="p">(</span><span class="mh">0x34</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="mh">0x00010000</span><span class="p">,</span> <span class="n">AR5K_PHY</span><span class="p">(</span><span class="mh">0x20</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5210</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">srev</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">28</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">ath5k_hw_bitswap</span><span class="p">(</span><span class="n">srev</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">srev</span> <span class="o">=</span> <span class="p">(</span><span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY</span><span class="p">(</span><span class="mh">0x100</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">ath5k_hw_bitswap</span><span class="p">(((</span><span class="n">srev</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">((</span><span class="n">srev</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span> <span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Reset to the 5GHz mode */</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_SHIFT_5GHZ</span><span class="p">,</span> <span class="n">AR5K_PHY</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_channel_ok() - Check if a channel is supported by the hw</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @channel: The &amp;struct ieee80211_channel</span>
<span class="cm"> *</span>
<span class="cm"> * Note: We don&#39;t do any regulatory domain checks here, it&#39;s just</span>
<span class="cm"> * a sanity check.</span>
<span class="cm"> */</span>
<span class="n">bool</span>
<span class="nf">ath5k_channel_ok</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span><span class="p">;</span>

	<span class="cm">/* Check if the channel is in our supported range */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">band</span> <span class="o">==</span> <span class="n">IEEE80211_BAND_2GHZ</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">freq</span> <span class="o">&gt;=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_capabilities</span><span class="p">.</span><span class="n">cap_range</span><span class="p">.</span><span class="n">range_2ghz_min</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">freq</span> <span class="o">&lt;=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_capabilities</span><span class="p">.</span><span class="n">cap_range</span><span class="p">.</span><span class="n">range_2ghz_max</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">band</span> <span class="o">==</span> <span class="n">IEEE80211_BAND_5GHZ</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">freq</span> <span class="o">&gt;=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_capabilities</span><span class="p">.</span><span class="n">cap_range</span><span class="p">.</span><span class="n">range_5ghz_min</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">freq</span> <span class="o">&lt;=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_capabilities</span><span class="p">.</span><span class="n">cap_range</span><span class="p">.</span><span class="n">range_5ghz_max</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_chan_has_spur_noise() - Check if channel is sensitive to spur noise</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @channel: The &amp;struct ieee80211_channel</span>
<span class="cm"> */</span>
<span class="n">bool</span>
<span class="nf">ath5k_hw_chan_has_spur_noise</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">refclk_freq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio</span> <span class="o">==</span> <span class="n">AR5K_RF5112</span><span class="p">)</span> <span class="o">||</span>
	<span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio</span> <span class="o">==</span> <span class="n">AR5K_RF5413</span><span class="p">)</span> <span class="o">||</span>
	<span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio</span> <span class="o">==</span> <span class="n">AR5K_RF2413</span><span class="p">)</span> <span class="o">||</span>
	<span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_mac_version</span> <span class="o">==</span> <span class="p">(</span><span class="n">AR5K_SREV_AR2417</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)))</span>
		<span class="n">refclk_freq</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">refclk_freq</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span> <span class="o">%</span> <span class="n">refclk_freq</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	<span class="p">((</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span> <span class="o">%</span> <span class="n">refclk_freq</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">||</span>
	<span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span> <span class="o">%</span> <span class="n">refclk_freq</span> <span class="o">&gt;</span> <span class="mi">22</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_rfb_op() - Perform an operation on the given RF Buffer</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @rf_regs: The struct ath5k_rf_reg</span>
<span class="cm"> * @val: New value</span>
<span class="cm"> * @reg_id: RF register ID</span>
<span class="cm"> * @set: Indicate we need to swap data</span>
<span class="cm"> *</span>
<span class="cm"> * This is an internal function used to modify RF Banks before</span>
<span class="cm"> * writing them to AR5K_RF_BUFFER. Check out rfbuffer.h for more</span>
<span class="cm"> * infos.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">ath5k_hw_rfb_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ath5k_rf_reg</span> <span class="o">*</span><span class="n">rf_regs</span><span class="p">,</span>
					<span class="n">u32</span> <span class="n">val</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg_id</span><span class="p">,</span> <span class="n">bool</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ath5k_rf_reg</span> <span class="o">*</span><span class="n">rfreg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">offset</span><span class="p">,</span> <span class="n">bank</span><span class="p">,</span> <span class="n">num_bits</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">position</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">entry</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">last_bit</span><span class="p">,</span> <span class="n">bits_shifted</span><span class="p">,</span> <span class="n">first_bit</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">rfb</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">bits_left</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rfb</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_banks</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_regs_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rf_regs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">index</span> <span class="o">==</span> <span class="n">reg_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rfreg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rf_regs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rfb</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">rfreg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ATH5K_PRINTF</span><span class="p">(</span><span class="s">&quot;Rf register not found!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* should not happen */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bank</span> <span class="o">=</span> <span class="n">rfreg</span><span class="o">-&gt;</span><span class="n">bank</span><span class="p">;</span>
	<span class="n">num_bits</span> <span class="o">=</span> <span class="n">rfreg</span><span class="o">-&gt;</span><span class="n">field</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
	<span class="n">first_bit</span> <span class="o">=</span> <span class="n">rfreg</span><span class="o">-&gt;</span><span class="n">field</span><span class="p">.</span><span class="n">pos</span><span class="p">;</span>
	<span class="n">col</span> <span class="o">=</span> <span class="n">rfreg</span><span class="o">-&gt;</span><span class="n">field</span><span class="p">.</span><span class="n">col</span><span class="p">;</span>

	<span class="cm">/* first_bit is an offset from bank&#39;s</span>
<span class="cm">	 * start. Since we have all banks on</span>
<span class="cm">	 * the same array, we use this offset</span>
<span class="cm">	 * to mark each bank&#39;s start */</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_offset</span><span class="p">[</span><span class="n">bank</span><span class="p">];</span>

	<span class="cm">/* Boundary check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">col</span> <span class="o">&lt;=</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">num_bits</span> <span class="o">&lt;=</span> <span class="mi">32</span> <span class="o">&amp;&amp;</span> <span class="n">first_bit</span> <span class="o">+</span> <span class="n">num_bits</span> <span class="o">&lt;=</span> <span class="mi">319</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ATH5K_PRINTF</span><span class="p">(</span><span class="s">&quot;invalid values at offset %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="p">((</span><span class="n">first_bit</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">position</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_bit</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">8</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">set</span><span class="p">)</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">ath5k_hw_bitswap</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">num_bits</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">bits_shifted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bits_left</span> <span class="o">=</span> <span class="n">num_bits</span><span class="p">;</span> <span class="n">bits_left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
	     <span class="n">position</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">entry</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">last_bit</span> <span class="o">=</span> <span class="p">(</span><span class="n">position</span> <span class="o">+</span> <span class="n">bits_left</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">?</span> <span class="mi">8</span> <span class="o">:</span>
					<span class="n">position</span> <span class="o">+</span> <span class="n">bits_left</span><span class="p">;</span>

		<span class="n">mask</span> <span class="o">=</span> <span class="p">(((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">last_bit</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">position</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&lt;&lt;</span>
								<span class="p">(</span><span class="n">col</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">set</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rfb</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
			<span class="n">rfb</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">|=</span> <span class="p">((</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="n">position</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">col</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
			<span class="n">data</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="mi">8</span> <span class="o">-</span> <span class="n">position</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">data</span> <span class="o">|=</span> <span class="p">(((</span><span class="n">rfb</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">col</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">position</span><span class="p">)</span>
				<span class="o">&lt;&lt;</span> <span class="n">bits_shifted</span><span class="p">;</span>
			<span class="n">bits_shifted</span> <span class="o">+=</span> <span class="n">last_bit</span> <span class="o">-</span> <span class="n">position</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">bits_left</span> <span class="o">-=</span> <span class="mi">8</span> <span class="o">-</span> <span class="n">position</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">set</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">ath5k_hw_bitswap</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">num_bits</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_write_ofdm_timings() - set OFDM timings on AR5212</span>
<span class="cm"> * @ah: the &amp;struct ath5k_hw</span>
<span class="cm"> * @channel: the currently set channel upon reset</span>
<span class="cm"> *</span>
<span class="cm"> * Write the delta slope coefficient (used on pilot tracking ?) for OFDM</span>
<span class="cm"> * operation on the AR5212 upon reset. This is a helper for ath5k_hw_phy_init.</span>
<span class="cm"> *</span>
<span class="cm"> * Since delta slope is floating point we split it on its exponent and</span>
<span class="cm"> * mantissa and provide these values on hw.</span>
<span class="cm"> *</span>
<span class="cm"> * For more infos i think this patent is related</span>
<span class="cm"> * &quot;http://www.freepatentsonline.com/7184495.html&quot;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ath5k_hw_write_ofdm_timings</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Get exponent and mantissa and set it */</span>
	<span class="n">u32</span> <span class="n">coef_scaled</span><span class="p">,</span> <span class="n">coef_exp</span><span class="p">,</span> <span class="n">coef_man</span><span class="p">,</span>
		<span class="n">ds_coef_exp</span><span class="p">,</span> <span class="n">ds_coef_man</span><span class="p">,</span> <span class="n">clock</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5212</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">hw_value</span> <span class="o">==</span> <span class="n">AR5K_MODE_11B</span><span class="p">));</span>

	<span class="cm">/* Get coefficient</span>
<span class="cm">	 * ALGO: coef = (5 * clock / carrier_freq) / 2</span>
<span class="cm">	 * we scale coef by shifting clock value by 24 for</span>
<span class="cm">	 * better precision since we use integers */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_bwmode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AR5K_BWMODE_40MHZ</span>:
		<span class="n">clock</span> <span class="o">=</span> <span class="mi">40</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_BWMODE_10MHZ</span>:
		<span class="n">clock</span> <span class="o">=</span> <span class="mi">40</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_BWMODE_5MHZ</span>:
		<span class="n">clock</span> <span class="o">=</span> <span class="mi">40</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">clock</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">coef_scaled</span> <span class="o">=</span> <span class="p">((</span><span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="n">clock</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span><span class="p">;</span>

	<span class="cm">/* Get exponent</span>
<span class="cm">	 * ALGO: coef_exp = 14 - highest set bit position */</span>
	<span class="n">coef_exp</span> <span class="o">=</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">coef_scaled</span><span class="p">);</span>

	<span class="cm">/* Doesn&#39;t make sense if it&#39;s zero*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">coef_scaled</span> <span class="o">||</span> <span class="o">!</span><span class="n">coef_exp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Note: we&#39;ve shifted coef_scaled by 24 */</span>
	<span class="n">coef_exp</span> <span class="o">=</span> <span class="mi">14</span> <span class="o">-</span> <span class="p">(</span><span class="n">coef_exp</span> <span class="o">-</span> <span class="mi">24</span><span class="p">);</span>


	<span class="cm">/* Get mantissa (significant digits)</span>
<span class="cm">	 * ALGO: coef_mant = floor(coef_scaled* 2^coef_exp+0.5) */</span>
	<span class="n">coef_man</span> <span class="o">=</span> <span class="n">coef_scaled</span> <span class="o">+</span>
		<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">24</span> <span class="o">-</span> <span class="n">coef_exp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

	<span class="cm">/* Calculate delta slope coefficient exponent</span>
<span class="cm">	 * and mantissa (remove scaling) and set them on hw */</span>
	<span class="n">ds_coef_man</span> <span class="o">=</span> <span class="n">coef_man</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">24</span> <span class="o">-</span> <span class="n">coef_exp</span><span class="p">);</span>
	<span class="n">ds_coef_exp</span> <span class="o">=</span> <span class="n">coef_exp</span> <span class="o">-</span> <span class="mi">16</span><span class="p">;</span>

	<span class="n">AR5K_REG_WRITE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_TIMING_3</span><span class="p">,</span>
		<span class="n">AR5K_PHY_TIMING_3_DSC_MAN</span><span class="p">,</span> <span class="n">ds_coef_man</span><span class="p">);</span>
	<span class="n">AR5K_REG_WRITE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_TIMING_3</span><span class="p">,</span>
		<span class="n">AR5K_PHY_TIMING_3_DSC_EXP</span><span class="p">,</span> <span class="n">ds_coef_exp</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_phy_disable() - Disable PHY</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ath5k_hw_phy_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*Just a try M.F.*/</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_ACT_DISABLE</span><span class="p">,</span> <span class="n">AR5K_PHY_ACT</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_wait_for_synth() - Wait for synth to settle</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @channel: The &amp;struct ieee80211_channel</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ath5k_hw_wait_for_synth</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * On 5211+ read activation -&gt; rx delay</span>
<span class="cm">	 * and use it (100ns steps).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">!=</span> <span class="n">AR5K_AR5210</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">delay</span><span class="p">;</span>
		<span class="n">delay</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_RX_DELAY</span><span class="p">)</span> <span class="o">&amp;</span>
			<span class="n">AR5K_PHY_RX_DELAY_M</span><span class="p">;</span>
		<span class="n">delay</span> <span class="o">=</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">hw_value</span> <span class="o">==</span> <span class="n">AR5K_MODE_11B</span><span class="p">)</span> <span class="o">?</span>
			<span class="p">((</span><span class="n">delay</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">22</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">delay</span> <span class="o">/</span> <span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_bwmode</span> <span class="o">==</span> <span class="n">AR5K_BWMODE_10MHZ</span><span class="p">)</span>
			<span class="n">delay</span> <span class="o">=</span> <span class="n">delay</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_bwmode</span> <span class="o">==</span> <span class="n">AR5K_BWMODE_5MHZ</span><span class="p">)</span>
			<span class="n">delay</span> <span class="o">=</span> <span class="n">delay</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
		<span class="cm">/* XXX: /2 on turbo ? Let&#39;s be safe</span>
<span class="cm">		 * for now */</span>
		<span class="n">usleep_range</span><span class="p">(</span><span class="mi">100</span> <span class="o">+</span> <span class="n">delay</span><span class="p">,</span> <span class="mi">100</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">delay</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">usleep_range</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1500</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/**********************\</span>
<span class="cm">* RF Gain optimization *</span>
<span class="cm">\**********************/</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: RF Gain optimization</span>
<span class="cm"> *</span>
<span class="cm"> * This code is used to optimize RF gain on different environments</span>
<span class="cm"> * (temperature mostly) based on feedback from a power detector.</span>
<span class="cm"> *</span>
<span class="cm"> * It&#39;s only used on RF5111 and RF5112, later RF chips seem to have</span>
<span class="cm"> * auto adjustment on hw -notice they have a much smaller BANK 7 and</span>
<span class="cm"> * no gain optimization ladder-.</span>
<span class="cm"> *</span>
<span class="cm"> * For more infos check out this patent doc</span>
<span class="cm"> * &quot;http://www.freepatentsonline.com/7400691.html&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * This paper describes power drops as seen on the receiver due to</span>
<span class="cm"> * probe packets</span>
<span class="cm"> * &quot;http://www.cnri.dit.ie/publications/ICT08%20-%20Practical%20Issues</span>
<span class="cm"> * %20of%20Power%20Control.pdf&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * And this is the MadWiFi bug entry related to the above</span>
<span class="cm"> * &quot;http://madwifi-project.org/ticket/1659&quot;</span>
<span class="cm"> * with various measurements and diagrams</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_rfgain_opt_init() - Initialize ah_gain during attach</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ath5k_hw_rfgain_opt_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Initialize the gain optimization values */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AR5K_RF5111</span>:
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_step_idx</span> <span class="o">=</span> <span class="n">rfgain_opt_5111</span><span class="p">.</span><span class="n">go_default</span><span class="p">;</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_low</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_high</span> <span class="o">=</span> <span class="mi">35</span><span class="p">;</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_state</span> <span class="o">=</span> <span class="n">AR5K_RFGAIN_ACTIVE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_RF5112</span>:
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_step_idx</span> <span class="o">=</span> <span class="n">rfgain_opt_5112</span><span class="p">.</span><span class="n">go_default</span><span class="p">;</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_low</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_high</span> <span class="o">=</span> <span class="mi">85</span><span class="p">;</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_state</span> <span class="o">=</span> <span class="n">AR5K_RFGAIN_ACTIVE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_request_rfgain_probe() - Request a PAPD probe packet</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> *</span>
<span class="cm"> * Schedules a gain probe check on the next transmitted packet.</span>
<span class="cm"> * That means our next packet is going to be sent with lower</span>
<span class="cm"> * tx power and a Peak to Average Power Detector (PAPD) will try</span>
<span class="cm"> * to measure the gain.</span>
<span class="cm"> *</span>
<span class="cm"> * TODO: Force a tx packet (bypassing PCU arbitrator etc)</span>
<span class="cm"> * just after we enable the probe so that we don&#39;t mess with</span>
<span class="cm"> * standard traffic.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ath5k_hw_request_rfgain_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/* Skip if gain calibration is inactive or</span>
<span class="cm">	 * we already handle a probe request */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_state</span> <span class="o">!=</span> <span class="n">AR5K_RFGAIN_ACTIVE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Send the packet with 2dB below max power as</span>
<span class="cm">	 * patent doc suggest */</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_REG_SM</span><span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_ofdm</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span>
			<span class="n">AR5K_PHY_PAPD_PROBE_TXPOWER</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">AR5K_PHY_PAPD_PROBE_TX_NEXT</span><span class="p">,</span> <span class="n">AR5K_PHY_PAPD_PROBE</span><span class="p">);</span>

	<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_state</span> <span class="o">=</span> <span class="n">AR5K_RFGAIN_READ_REQUESTED</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_rf_gainf_corr() - Calculate Gain_F measurement correction</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> *</span>
<span class="cm"> * Calculate Gain_F measurement correction</span>
<span class="cm"> * based on the current step for RF5112 rev. 2</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span>
<span class="nf">ath5k_hw_rf_gainf_corr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mix</span><span class="p">,</span> <span class="n">step</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">rf</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ath5k_gain_opt</span> <span class="o">*</span><span class="n">go</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ath5k_gain_opt_step</span> <span class="o">*</span><span class="n">g_step</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ath5k_rf_reg</span> <span class="o">*</span><span class="n">rf_regs</span><span class="p">;</span>

	<span class="cm">/* Only RF5112 Rev. 2 supports it */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio</span> <span class="o">!=</span> <span class="n">AR5K_RF5112</span><span class="p">)</span> <span class="o">||</span>
	<span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio_5ghz_revision</span> <span class="o">&lt;=</span> <span class="n">AR5K_SREV_RAD_5112A</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">go</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rfgain_opt_5112</span><span class="p">;</span>
	<span class="n">rf_regs</span> <span class="o">=</span> <span class="n">rf_regs_5112a</span><span class="p">;</span>
	<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_regs_count</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rf_regs_5112a</span><span class="p">);</span>

	<span class="n">g_step</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">go</span><span class="o">-&gt;</span><span class="n">go_step</span><span class="p">[</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_step_idx</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_banks</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rf</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_banks</span><span class="p">;</span>
	<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_f_corr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* No VGA (Variable Gain Amplifier) override, skip */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AR5K_RF_MIXVGA_OVR</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Mix gain stepping */</span>
	<span class="n">step</span> <span class="o">=</span> <span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AR5K_RF_MIXGAIN_STEP</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="cm">/* Mix gain override */</span>
	<span class="n">mix</span> <span class="o">=</span> <span class="n">g_step</span><span class="o">-&gt;</span><span class="n">gos_param</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mix</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_f_corr</span> <span class="o">=</span> <span class="n">step</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_f_corr</span> <span class="o">=</span> <span class="p">(</span><span class="n">step</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_f_corr</span> <span class="o">=</span> <span class="n">step</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_f_corr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_f_corr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_rf_check_gainf_readback() - Validate Gain_F feedback from detector</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> *</span>
<span class="cm"> * Check if current gain_F measurement is in the range of our</span>
<span class="cm"> * power detector windows. If we get a measurement outside range</span>
<span class="cm"> * we know it&#39;s not accurate (detectors can&#39;t measure anything outside</span>
<span class="cm"> * their detection window) so we must ignore it.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true if readback was O.K. or false on failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span>
<span class="nf">ath5k_hw_rf_check_gainf_readback</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ath5k_rf_reg</span> <span class="o">*</span><span class="n">rf_regs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">step</span><span class="p">,</span> <span class="n">mix_ovr</span><span class="p">,</span> <span class="n">level</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">rf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_banks</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">rf</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_banks</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio</span> <span class="o">==</span> <span class="n">AR5K_RF5111</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">rf_regs</span> <span class="o">=</span> <span class="n">rf_regs_5111</span><span class="p">;</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_regs_count</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rf_regs_5111</span><span class="p">);</span>

		<span class="n">step</span> <span class="o">=</span> <span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AR5K_RF_RFGAIN_STEP</span><span class="p">,</span>
			<span class="nb">false</span><span class="p">);</span>

		<span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">level</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">step</span> <span class="o">==</span> <span class="mi">63</span><span class="p">)</span> <span class="o">?</span> <span class="mi">50</span> <span class="o">:</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">level</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">step</span> <span class="o">!=</span> <span class="mi">63</span><span class="p">)</span> <span class="o">?</span> <span class="mi">64</span> <span class="o">:</span> <span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">level</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">level</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">50</span><span class="p">;</span>

		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_high</span> <span class="o">=</span> <span class="n">level</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span>
			<span class="p">(</span><span class="n">step</span> <span class="o">==</span> <span class="mi">63</span> <span class="o">?</span> <span class="n">AR5K_GAIN_DYN_ADJUST_HI_MARGIN</span> <span class="o">:</span> <span class="o">-</span><span class="mi">5</span><span class="p">);</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_low</span> <span class="o">=</span> <span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
			<span class="p">(</span><span class="n">step</span> <span class="o">==</span> <span class="mi">63</span> <span class="o">?</span> <span class="n">AR5K_GAIN_DYN_ADJUST_LO_MARGIN</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

		<span class="n">rf_regs</span> <span class="o">=</span> <span class="n">rf_regs_5112</span><span class="p">;</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_regs_count</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rf_regs_5112</span><span class="p">);</span>

		<span class="n">mix_ovr</span> <span class="o">=</span> <span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AR5K_RF_MIXVGA_OVR</span><span class="p">,</span>
			<span class="nb">false</span><span class="p">);</span>

		<span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">level</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mix_ovr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">level</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">level</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">83</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">level</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">level</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">107</span><span class="p">;</span>
			<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_high</span> <span class="o">=</span> <span class="mi">55</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_current</span> <span class="o">&gt;=</span> <span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
			<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_current</span> <span class="o">&lt;=</span> <span class="n">level</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_current</span> <span class="o">&gt;=</span> <span class="n">level</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
			<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_current</span> <span class="o">&lt;=</span> <span class="n">level</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_rf_gainf_adjust() - Perform Gain_F adjustment</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> *</span>
<span class="cm"> * Choose the right target gain based on current gain</span>
<span class="cm"> * and RF gain optimization ladder</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s8</span>
<span class="nf">ath5k_hw_rf_gainf_adjust</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ath5k_gain_opt</span> <span class="o">*</span><span class="n">go</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ath5k_gain_opt_step</span> <span class="o">*</span><span class="n">g_step</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AR5K_RF5111</span>:
		<span class="n">go</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rfgain_opt_5111</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_RF5112</span>:
		<span class="n">go</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rfgain_opt_5112</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">g_step</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">go</span><span class="o">-&gt;</span><span class="n">go_step</span><span class="p">[</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_step_idx</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_current</span> <span class="o">&gt;=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_high</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Reached maximum */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_step_idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_target</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_current</span><span class="p">;</span>
				<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_target</span> <span class="o">&gt;=</span>  <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_high</span> <span class="o">&amp;&amp;</span>
				<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_step_idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">g_step</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">go</span><span class="o">-&gt;</span><span class="n">go_step</span><span class="p">[</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_step_idx</span><span class="p">])</span>
			<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_target</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span>
			    <span class="p">(</span><span class="n">go</span><span class="o">-&gt;</span><span class="n">go_step</span><span class="p">[</span><span class="o">--</span><span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_step_idx</span><span class="p">)].</span><span class="n">gos_gain</span> <span class="o">-</span>
			    <span class="n">g_step</span><span class="o">-&gt;</span><span class="n">gos_gain</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_current</span> <span class="o">&lt;=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_low</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Reached minimum */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_step_idx</span> <span class="o">==</span> <span class="p">(</span><span class="n">go</span><span class="o">-&gt;</span><span class="n">go_steps_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_target</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_current</span><span class="p">;</span>
				<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_target</span> <span class="o">&lt;=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_low</span> <span class="o">&amp;&amp;</span>
				<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_step_idx</span> <span class="o">&lt;</span> <span class="n">go</span><span class="o">-&gt;</span><span class="n">go_steps_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">g_step</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">go</span><span class="o">-&gt;</span><span class="n">go_step</span><span class="p">[</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_step_idx</span><span class="p">])</span>
			<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_target</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span>
			    <span class="p">(</span><span class="n">go</span><span class="o">-&gt;</span><span class="n">go_step</span><span class="p">[</span><span class="o">++</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_step_idx</span><span class="p">].</span><span class="n">gos_gain</span> <span class="o">-</span>
			    <span class="n">g_step</span><span class="o">-&gt;</span><span class="n">gos_gain</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="n">ATH5K_DBG</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ATH5K_DEBUG_CALIBRATE</span><span class="p">,</span>
		<span class="s">&quot;ret %d, gain step %u, current gain %u, target gain %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ret</span><span class="p">,</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_step_idx</span><span class="p">,</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_current</span><span class="p">,</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_target</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_gainf_calibrate() - Do a gain_F calibration</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> *</span>
<span class="cm"> * Main callback for thermal RF gain calibration engine</span>
<span class="cm"> * Check for a new gain reading and schedule an adjustment</span>
<span class="cm"> * if needed.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns one of enum ath5k_rfgain codes</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ath5k_rfgain</span>
<span class="nf">ath5k_hw_gainf_calibrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">,</span> <span class="n">type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ath5k_eeprom_info</span> <span class="o">*</span><span class="n">ee</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_capabilities</span><span class="p">.</span><span class="n">cap_eeprom</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_banks</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
	<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_state</span> <span class="o">==</span> <span class="n">AR5K_RFGAIN_INACTIVE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">AR5K_RFGAIN_INACTIVE</span><span class="p">;</span>

	<span class="cm">/* No check requested, either engine is inactive</span>
<span class="cm">	 * or an adjustment is already requested */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_state</span> <span class="o">!=</span> <span class="n">AR5K_RFGAIN_READ_REQUESTED</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/* Read the PAPD (Peak to Average Power Detector)</span>
<span class="cm">	 * register */</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_PAPD_PROBE</span><span class="p">);</span>

	<span class="cm">/* No probe is scheduled, read gain_F measurement */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">AR5K_PHY_PAPD_PROBE_TX_NEXT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_current</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="n">AR5K_PHY_PAPD_PROBE_GAINF_S</span><span class="p">;</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">AR5K_REG_MS</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">AR5K_PHY_PAPD_PROBE_TYPE</span><span class="p">);</span>

		<span class="cm">/* If tx packet is CCK correct the gain_F measurement</span>
<span class="cm">		 * by cck ofdm gain delta */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">AR5K_PHY_PAPD_PROBE_TYPE_CCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio_5ghz_revision</span> <span class="o">&gt;=</span> <span class="n">AR5K_SREV_RAD_5112A</span><span class="p">)</span>
				<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_current</span> <span class="o">+=</span>
					<span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_cck_ofdm_gain_delta</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_current</span> <span class="o">+=</span>
					<span class="n">AR5K_GAIN_CCK_PROBE_CORR</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Further correct gain_F measurement for</span>
<span class="cm">		 * RF5112A radios */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio_5ghz_revision</span> <span class="o">&gt;=</span> <span class="n">AR5K_SREV_RAD_5112A</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ath5k_hw_rf_gainf_corr</span><span class="p">(</span><span class="n">ah</span><span class="p">);</span>
			<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_current</span> <span class="o">=</span>
				<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_current</span> <span class="o">&gt;=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_f_corr</span> <span class="o">?</span>
				<span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_current</span> <span class="o">-</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_f_corr</span><span class="p">)</span> <span class="o">:</span>
				<span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Check if measurement is ok and if we need</span>
<span class="cm">		 * to adjust gain, schedule a gain adjustment,</span>
<span class="cm">		 * else switch back to the active state */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ath5k_hw_rf_check_gainf_readback</span><span class="p">(</span><span class="n">ah</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">AR5K_GAIN_CHECK_ADJUST</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">ath5k_hw_rf_gainf_adjust</span><span class="p">(</span><span class="n">ah</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_state</span> <span class="o">=</span> <span class="n">AR5K_RFGAIN_NEED_CHANGE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_state</span> <span class="o">=</span> <span class="n">AR5K_RFGAIN_ACTIVE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_state</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_rfgain_init() - Write initial RF gain settings to hw</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @band: One of enum ieee80211_band</span>
<span class="cm"> *</span>
<span class="cm"> * Write initial RF gain table to set the RF sensitivity.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: This one works on all RF chips and has nothing to do</span>
<span class="cm"> * with Gain_F calibration</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ath5k_hw_rfgain_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ath5k_ini_rfgain</span> <span class="o">*</span><span class="n">ath5k_rfg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AR5K_RF5111</span>:
		<span class="n">ath5k_rfg</span> <span class="o">=</span> <span class="n">rfgain_5111</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rfgain_5111</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_RF5112</span>:
		<span class="n">ath5k_rfg</span> <span class="o">=</span> <span class="n">rfgain_5112</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rfgain_5112</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_RF2413</span>:
		<span class="n">ath5k_rfg</span> <span class="o">=</span> <span class="n">rfgain_2413</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rfgain_2413</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_RF2316</span>:
		<span class="n">ath5k_rfg</span> <span class="o">=</span> <span class="n">rfgain_2316</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rfgain_2316</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_RF5413</span>:
		<span class="n">ath5k_rfg</span> <span class="o">=</span> <span class="n">rfgain_5413</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rfgain_5413</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_RF2317</span>:
	<span class="k">case</span> <span class="n">AR5K_RF2425</span>:
		<span class="n">ath5k_rfg</span> <span class="o">=</span> <span class="n">rfgain_2425</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rfgain_2425</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">band</span> <span class="o">==</span> <span class="n">IEEE80211_BAND_2GHZ</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AR5K_REG_WAIT</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ath5k_rfg</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rfg_value</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
			<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">ath5k_rfg</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rfg_register</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/********************\</span>
<span class="cm">* RF Registers setup *</span>
<span class="cm">\********************/</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_rfregs_init() - Initialize RF register settings</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @channel: The &amp;struct ieee80211_channel</span>
<span class="cm"> * @mode: One of enum ath5k_driver_mode</span>
<span class="cm"> *</span>
<span class="cm"> * Setup RF registers by writing RF buffer on hw. For</span>
<span class="cm"> * more infos on this, check out rfbuffer.h</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ath5k_hw_rfregs_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ath5k_rf_reg</span> <span class="o">*</span><span class="n">rf_regs</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ath5k_ini_rfbuffer</span> <span class="o">*</span><span class="n">ini_rfb</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ath5k_gain_opt</span> <span class="o">*</span><span class="n">go</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ath5k_gain_opt_step</span> <span class="o">*</span><span class="n">g_step</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ath5k_eeprom_info</span> <span class="o">*</span><span class="n">ee</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_capabilities</span><span class="p">.</span><span class="n">cap_eeprom</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ee_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">rfb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">obdb</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bank</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AR5K_RF5111</span>:
		<span class="n">rf_regs</span> <span class="o">=</span> <span class="n">rf_regs_5111</span><span class="p">;</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_regs_count</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rf_regs_5111</span><span class="p">);</span>
		<span class="n">ini_rfb</span> <span class="o">=</span> <span class="n">rfb_5111</span><span class="p">;</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_banks_size</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rfb_5111</span><span class="p">);</span>
		<span class="n">go</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rfgain_opt_5111</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_RF5112</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio_5ghz_revision</span> <span class="o">&gt;=</span> <span class="n">AR5K_SREV_RAD_5112A</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rf_regs</span> <span class="o">=</span> <span class="n">rf_regs_5112a</span><span class="p">;</span>
			<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_regs_count</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rf_regs_5112a</span><span class="p">);</span>
			<span class="n">ini_rfb</span> <span class="o">=</span> <span class="n">rfb_5112a</span><span class="p">;</span>
			<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_banks_size</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rfb_5112a</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">rf_regs</span> <span class="o">=</span> <span class="n">rf_regs_5112</span><span class="p">;</span>
			<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_regs_count</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rf_regs_5112</span><span class="p">);</span>
			<span class="n">ini_rfb</span> <span class="o">=</span> <span class="n">rfb_5112</span><span class="p">;</span>
			<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_banks_size</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rfb_5112</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">go</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rfgain_opt_5112</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_RF2413</span>:
		<span class="n">rf_regs</span> <span class="o">=</span> <span class="n">rf_regs_2413</span><span class="p">;</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_regs_count</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rf_regs_2413</span><span class="p">);</span>
		<span class="n">ini_rfb</span> <span class="o">=</span> <span class="n">rfb_2413</span><span class="p">;</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_banks_size</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rfb_2413</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_RF2316</span>:
		<span class="n">rf_regs</span> <span class="o">=</span> <span class="n">rf_regs_2316</span><span class="p">;</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_regs_count</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rf_regs_2316</span><span class="p">);</span>
		<span class="n">ini_rfb</span> <span class="o">=</span> <span class="n">rfb_2316</span><span class="p">;</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_banks_size</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rfb_2316</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_RF5413</span>:
		<span class="n">rf_regs</span> <span class="o">=</span> <span class="n">rf_regs_5413</span><span class="p">;</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_regs_count</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rf_regs_5413</span><span class="p">);</span>
		<span class="n">ini_rfb</span> <span class="o">=</span> <span class="n">rfb_5413</span><span class="p">;</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_banks_size</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rfb_5413</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_RF2317</span>:
		<span class="n">rf_regs</span> <span class="o">=</span> <span class="n">rf_regs_2425</span><span class="p">;</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_regs_count</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rf_regs_2425</span><span class="p">);</span>
		<span class="n">ini_rfb</span> <span class="o">=</span> <span class="n">rfb_2317</span><span class="p">;</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_banks_size</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rfb_2317</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_RF2425</span>:
		<span class="n">rf_regs</span> <span class="o">=</span> <span class="n">rf_regs_2425</span><span class="p">;</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_regs_count</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rf_regs_2425</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_mac_srev</span> <span class="o">&lt;</span> <span class="n">AR5K_SREV_AR2417</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ini_rfb</span> <span class="o">=</span> <span class="n">rfb_2425</span><span class="p">;</span>
			<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_banks_size</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rfb_2425</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ini_rfb</span> <span class="o">=</span> <span class="n">rfb_2417</span><span class="p">;</span>
			<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_banks_size</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rfb_2417</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If it&#39;s the first time we set RF buffer, allocate</span>
<span class="cm">	 * ah-&gt;ah_rf_banks based on ah-&gt;ah_rf_banks_size</span>
<span class="cm">	 * we set above */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_banks</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_banks</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_banks_size</span><span class="p">,</span>
								<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_banks</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ATH5K_ERR</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="s">&quot;out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Copy values to modify them */</span>
	<span class="n">rfb</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_banks</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_banks_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ini_rfb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rfb_bank</span> <span class="o">&gt;=</span> <span class="n">AR5K_MAX_RF_BANKS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ATH5K_ERR</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="s">&quot;invalid bank</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Bank changed, write down the offset */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bank</span> <span class="o">!=</span> <span class="n">ini_rfb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rfb_bank</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bank</span> <span class="o">=</span> <span class="n">ini_rfb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rfb_bank</span><span class="p">;</span>
			<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_offset</span><span class="p">[</span><span class="n">bank</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rfb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ini_rfb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rfb_mode_data</span><span class="p">[</span><span class="n">mode</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="cm">/* Set Output and Driver bias current (OB/DB) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">band</span> <span class="o">==</span> <span class="n">IEEE80211_BAND_2GHZ</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">hw_value</span> <span class="o">==</span> <span class="n">AR5K_MODE_11B</span><span class="p">)</span>
			<span class="n">ee_mode</span> <span class="o">=</span> <span class="n">AR5K_EEPROM_MODE_11B</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ee_mode</span> <span class="o">=</span> <span class="n">AR5K_EEPROM_MODE_11G</span><span class="p">;</span>

		<span class="cm">/* For RF511X/RF211X combination we</span>
<span class="cm">		 * use b_OB and b_DB parameters stored</span>
<span class="cm">		 * in eeprom on ee-&gt;ee_ob[ee_mode][0]</span>
<span class="cm">		 *</span>
<span class="cm">		 * For all other chips we use OB/DB for 2GHz</span>
<span class="cm">		 * stored in the b/g modal section just like</span>
<span class="cm">		 * 802.11a on ee-&gt;ee_ob[ee_mode][1] */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio</span> <span class="o">==</span> <span class="n">AR5K_RF5111</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio</span> <span class="o">==</span> <span class="n">AR5K_RF5112</span><span class="p">))</span>
			<span class="n">obdb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">obdb</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_ob</span><span class="p">[</span><span class="n">ee_mode</span><span class="p">][</span><span class="n">obdb</span><span class="p">],</span>
						<span class="n">AR5K_RF_OB_2GHZ</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

		<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_db</span><span class="p">[</span><span class="n">ee_mode</span><span class="p">][</span><span class="n">obdb</span><span class="p">],</span>
						<span class="n">AR5K_RF_DB_2GHZ</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="cm">/* RF5111 always needs OB/DB for 5GHz, even if we use 2GHz */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">band</span> <span class="o">==</span> <span class="n">IEEE80211_BAND_5GHZ</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio</span> <span class="o">==</span> <span class="n">AR5K_RF5111</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* For 11a, Turbo and XR we need to choose</span>
<span class="cm">		 * OB/DB based on frequency range */</span>
		<span class="n">ee_mode</span> <span class="o">=</span> <span class="n">AR5K_EEPROM_MODE_11A</span><span class="p">;</span>
		<span class="n">obdb</span> <span class="o">=</span>	 <span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span> <span class="o">&gt;=</span> <span class="mi">5725</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span>
			<span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span> <span class="o">&gt;=</span> <span class="mi">5500</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span>
			<span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span> <span class="o">&gt;=</span> <span class="mi">5260</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span>
			 <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span> <span class="o">&gt;</span> <span class="mi">4000</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">)));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">obdb</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_ob</span><span class="p">[</span><span class="n">ee_mode</span><span class="p">][</span><span class="n">obdb</span><span class="p">],</span>
						<span class="n">AR5K_RF_OB_5GHZ</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

		<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_db</span><span class="p">[</span><span class="n">ee_mode</span><span class="p">][</span><span class="n">obdb</span><span class="p">],</span>
						<span class="n">AR5K_RF_DB_5GHZ</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">g_step</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">go</span><span class="o">-&gt;</span><span class="n">go_step</span><span class="p">[</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_step_idx</span><span class="p">];</span>

	<span class="cm">/* Set turbo mode (N/A on RF5413) */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_bwmode</span> <span class="o">==</span> <span class="n">AR5K_BWMODE_40MHZ</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	<span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio</span> <span class="o">!=</span> <span class="n">AR5K_RF5413</span><span class="p">))</span>
		<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">AR5K_RF_TURBO</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="cm">/* Bank Modifications (chip-specific) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio</span> <span class="o">==</span> <span class="n">AR5K_RF5111</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Set gain_F settings according to current step */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">hw_value</span> <span class="o">!=</span> <span class="n">AR5K_MODE_11B</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">AR5K_REG_WRITE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_FRAME_CTL</span><span class="p">,</span>
					<span class="n">AR5K_PHY_FRAME_CTL_TX_CLIP</span><span class="p">,</span>
					<span class="n">g_step</span><span class="o">-&gt;</span><span class="n">gos_param</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

			<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="n">g_step</span><span class="o">-&gt;</span><span class="n">gos_param</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
							<span class="n">AR5K_RF_PWD_90</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

			<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="n">g_step</span><span class="o">-&gt;</span><span class="n">gos_param</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
							<span class="n">AR5K_RF_PWD_84</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

			<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="n">g_step</span><span class="o">-&gt;</span><span class="n">gos_param</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
						<span class="n">AR5K_RF_RFGAIN_SEL</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

			<span class="cm">/* We programmed gain_F parameters, switch back</span>
<span class="cm">			 * to active state */</span>
			<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_state</span> <span class="o">=</span> <span class="n">AR5K_RFGAIN_ACTIVE</span><span class="p">;</span>

		<span class="p">}</span>

		<span class="cm">/* Bank 6/7 setup */</span>

		<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="o">!</span><span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_xpd</span><span class="p">[</span><span class="n">ee_mode</span><span class="p">],</span>
						<span class="n">AR5K_RF_PWD_XPD</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

		<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_x_gain</span><span class="p">[</span><span class="n">ee_mode</span><span class="p">],</span>
						<span class="n">AR5K_RF_XPD_GAIN</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

		<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_i_gain</span><span class="p">[</span><span class="n">ee_mode</span><span class="p">],</span>
						<span class="n">AR5K_RF_GAIN_I</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

		<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_xpd</span><span class="p">[</span><span class="n">ee_mode</span><span class="p">],</span>
						<span class="n">AR5K_RF_PLO_SEL</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

		<span class="cm">/* Tweak power detectors for half/quarter rate support */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_bwmode</span> <span class="o">==</span> <span class="n">AR5K_BWMODE_5MHZ</span> <span class="o">||</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_bwmode</span> <span class="o">==</span> <span class="n">AR5K_BWMODE_10MHZ</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">wait_i</span><span class="p">;</span>

			<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">,</span>
						<span class="n">AR5K_RF_WAIT_S</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

			<span class="n">wait_i</span> <span class="o">=</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_bwmode</span> <span class="o">==</span> <span class="n">AR5K_BWMODE_5MHZ</span><span class="p">)</span> <span class="o">?</span>
							<span class="mh">0x1f</span> <span class="o">:</span> <span class="mh">0x10</span><span class="p">;</span>

			<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="n">wait_i</span><span class="p">,</span>
						<span class="n">AR5K_RF_WAIT_I</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
			<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
						<span class="n">AR5K_RF_MAX_TIME</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio</span> <span class="o">==</span> <span class="n">AR5K_RF5112</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Set gain_F settings according to current step */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">hw_value</span> <span class="o">!=</span> <span class="n">AR5K_MODE_11B</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="n">g_step</span><span class="o">-&gt;</span><span class="n">gos_param</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
						<span class="n">AR5K_RF_MIXGAIN_OVR</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

			<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="n">g_step</span><span class="o">-&gt;</span><span class="n">gos_param</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
						<span class="n">AR5K_RF_PWD_138</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

			<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="n">g_step</span><span class="o">-&gt;</span><span class="n">gos_param</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
						<span class="n">AR5K_RF_PWD_137</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

			<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="n">g_step</span><span class="o">-&gt;</span><span class="n">gos_param</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
						<span class="n">AR5K_RF_PWD_136</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

			<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="n">g_step</span><span class="o">-&gt;</span><span class="n">gos_param</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
						<span class="n">AR5K_RF_PWD_132</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

			<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="n">g_step</span><span class="o">-&gt;</span><span class="n">gos_param</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
						<span class="n">AR5K_RF_PWD_131</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

			<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="n">g_step</span><span class="o">-&gt;</span><span class="n">gos_param</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span>
						<span class="n">AR5K_RF_PWD_130</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

			<span class="cm">/* We programmed gain_F parameters, switch back</span>
<span class="cm">			 * to active state */</span>
			<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_gain</span><span class="p">.</span><span class="n">g_state</span> <span class="o">=</span> <span class="n">AR5K_RFGAIN_ACTIVE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Bank 6/7 setup */</span>

		<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_xpd</span><span class="p">[</span><span class="n">ee_mode</span><span class="p">],</span>
						<span class="n">AR5K_RF_XPD_SEL</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio_5ghz_revision</span> <span class="o">&lt;</span> <span class="n">AR5K_SREV_RAD_5112A</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Rev. 1 supports only one xpd */</span>
			<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span>
						<span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_x_gain</span><span class="p">[</span><span class="n">ee_mode</span><span class="p">],</span>
						<span class="n">AR5K_RF_XPD_GAIN</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="o">*</span><span class="n">pdg_curve_to_idx</span> <span class="o">=</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_pdc_to_idx</span><span class="p">[</span><span class="n">ee_mode</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_pd_gains</span><span class="p">[</span><span class="n">ee_mode</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span>
						<span class="n">pdg_curve_to_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
						<span class="n">AR5K_RF_PD_GAIN_LO</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
				<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span>
						<span class="n">pdg_curve_to_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
						<span class="n">AR5K_RF_PD_GAIN_HI</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span>
						<span class="n">pdg_curve_to_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
						<span class="n">AR5K_RF_PD_GAIN_LO</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
				<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span>
						<span class="n">pdg_curve_to_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
						<span class="n">AR5K_RF_PD_GAIN_HI</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* Lower synth voltage on Rev 2 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio</span> <span class="o">==</span> <span class="n">AR5K_RF5112</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio_5ghz_revision</span> <span class="o">&amp;</span> <span class="n">AR5K_SREV_REV</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
						<span class="n">AR5K_RF_HIGH_VC_CP</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

				<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
						<span class="n">AR5K_RF_MID_VC_CP</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

				<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
						<span class="n">AR5K_RF_LOW_VC_CP</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

				<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
						<span class="n">AR5K_RF_PUSH_UP</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* Decrease power consumption on 5213+ BaseBand */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_phy_revision</span> <span class="o">&gt;=</span> <span class="n">AR5K_SREV_PHY_5212A</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
						<span class="n">AR5K_RF_PAD2GND</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

				<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
						<span class="n">AR5K_RF_XB2_LVL</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

				<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
						<span class="n">AR5K_RF_XB5_LVL</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

				<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
						<span class="n">AR5K_RF_PWD_167</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

				<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
						<span class="n">AR5K_RF_PWD_166</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_i_gain</span><span class="p">[</span><span class="n">ee_mode</span><span class="p">],</span>
						<span class="n">AR5K_RF_GAIN_I</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

		<span class="cm">/* Tweak power detector for half/quarter rates */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_bwmode</span> <span class="o">==</span> <span class="n">AR5K_BWMODE_5MHZ</span> <span class="o">||</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_bwmode</span> <span class="o">==</span> <span class="n">AR5K_BWMODE_10MHZ</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">pd_delay</span><span class="p">;</span>

			<span class="n">pd_delay</span> <span class="o">=</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_bwmode</span> <span class="o">==</span> <span class="n">AR5K_BWMODE_5MHZ</span><span class="p">)</span> <span class="o">?</span>
							<span class="mh">0xf</span> <span class="o">:</span> <span class="mh">0x8</span><span class="p">;</span>

			<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="n">pd_delay</span><span class="p">,</span>
						<span class="n">AR5K_RF_PD_PERIOD_A</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
			<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">,</span>
						<span class="n">AR5K_RF_PD_DELAY_A</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio</span> <span class="o">==</span> <span class="n">AR5K_RF5413</span> <span class="o">&amp;&amp;</span>
	<span class="n">channel</span><span class="o">-&gt;</span><span class="n">band</span> <span class="o">==</span> <span class="n">IEEE80211_BAND_2GHZ</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">AR5K_RF_DERBY_CHAN_SEL_MODE</span><span class="p">,</span>
									<span class="nb">true</span><span class="p">);</span>

		<span class="cm">/* Set optimum value for early revisions (on pci-e chips) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_mac_srev</span> <span class="o">&gt;=</span> <span class="n">AR5K_SREV_AR5424</span> <span class="o">&amp;&amp;</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_mac_srev</span> <span class="o">&lt;</span> <span class="n">AR5K_SREV_AR5413</span><span class="p">)</span>
			<span class="n">ath5k_hw_rfb_op</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rf_regs</span><span class="p">,</span> <span class="n">ath5k_hw_bitswap</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
						<span class="n">AR5K_RF_PWD_ICLOBUF_2G</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="cm">/* Write RF banks on hw */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_rf_banks_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AR5K_REG_WAIT</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">rfb</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ini_rfb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rfb_ctrl_register</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**************************\</span>
<span class="cm">  PHY/RF channel functions</span>
<span class="cm">\**************************/</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_rf5110_chan2athchan() - Convert channel freq on RF5110</span>
<span class="cm"> * @channel: The &amp;struct ieee80211_channel</span>
<span class="cm"> *</span>
<span class="cm"> * Map channel frequency to IEEE channel number and convert it</span>
<span class="cm"> * to an internal channel value used by the RF5110 chipset.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span>
<span class="nf">ath5k_hw_rf5110_chan2athchan</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">athchan</span><span class="p">;</span>

	<span class="n">athchan</span> <span class="o">=</span> <span class="p">(</span><span class="n">ath5k_hw_bitswap</span><span class="p">(</span>
			<span class="p">(</span><span class="n">ieee80211_frequency_to_channel</span><span class="p">(</span>
				<span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">24</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
				<span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">athchan</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_rf5110_channel() - Set channel frequency on RF5110</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @channel: The &amp;struct ieee80211_channel</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ath5k_hw_rf5110_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the channel and wait</span>
<span class="cm">	 */</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">ath5k_hw_rf5110_chan2athchan</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">AR5K_RF_BUFFER</span><span class="p">);</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AR5K_RF_BUFFER_CONTROL_0</span><span class="p">);</span>
	<span class="n">usleep_range</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1500</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_rf5111_chan2athchan() - Handle 2GHz channels on RF5111/2111</span>
<span class="cm"> * @ieee: IEEE channel number</span>
<span class="cm"> * @athchan: The &amp;struct ath5k_athchan_2ghz</span>
<span class="cm"> *</span>
<span class="cm"> * In order to enable the RF2111 frequency converter on RF5111/2111 setups</span>
<span class="cm"> * we need to add some offsets and extra flags to the data values we pass</span>
<span class="cm"> * on to the PHY. So for every 2GHz channel this function gets called</span>
<span class="cm"> * to do the conversion.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ath5k_hw_rf5111_chan2athchan</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ieee</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ath5k_athchan_2ghz</span> <span class="o">*</span><span class="n">athchan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">channel</span><span class="p">;</span>

	<span class="cm">/* Cast this value to catch negative channel numbers (&gt;= -19) */</span>
	<span class="n">channel</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ieee</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Map 2GHz IEEE channel to 5GHz Atheros channel</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&lt;=</span> <span class="mi">13</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">athchan</span><span class="o">-&gt;</span><span class="n">a2_athchan</span> <span class="o">=</span> <span class="mi">115</span> <span class="o">+</span> <span class="n">channel</span><span class="p">;</span>
		<span class="n">athchan</span><span class="o">-&gt;</span><span class="n">a2_flags</span> <span class="o">=</span> <span class="mh">0x46</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">==</span> <span class="mi">14</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">athchan</span><span class="o">-&gt;</span><span class="n">a2_athchan</span> <span class="o">=</span> <span class="mi">124</span><span class="p">;</span>
		<span class="n">athchan</span><span class="o">-&gt;</span><span class="n">a2_flags</span> <span class="o">=</span> <span class="mh">0x44</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&gt;=</span> <span class="mi">15</span> <span class="o">&amp;&amp;</span> <span class="n">channel</span> <span class="o">&lt;=</span> <span class="mi">26</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">athchan</span><span class="o">-&gt;</span><span class="n">a2_athchan</span> <span class="o">=</span> <span class="p">((</span><span class="n">channel</span> <span class="o">-</span> <span class="mi">14</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">132</span><span class="p">;</span>
		<span class="n">athchan</span><span class="o">-&gt;</span><span class="n">a2_flags</span> <span class="o">=</span> <span class="mh">0x46</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_rf5111_channel() - Set channel frequency on RF5111/2111</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @channel: The &amp;struct ieee80211_channel</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ath5k_hw_rf5111_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ath5k_athchan_2ghz</span> <span class="n">ath5k_channel_2ghz</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ath5k_channel</span> <span class="o">=</span>
		<span class="n">ieee80211_frequency_to_channel</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">data0</span><span class="p">,</span> <span class="n">data1</span><span class="p">,</span> <span class="n">clock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the channel on the RF5111 radio</span>
<span class="cm">	 */</span>
	<span class="n">data0</span> <span class="o">=</span> <span class="n">data1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">band</span> <span class="o">==</span> <span class="n">IEEE80211_BAND_2GHZ</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Map 2GHz channel to 5GHz Atheros channel ID */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ath5k_hw_rf5111_chan2athchan</span><span class="p">(</span>
			<span class="n">ieee80211_frequency_to_channel</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span><span class="p">),</span>
			<span class="o">&amp;</span><span class="n">ath5k_channel_2ghz</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">ath5k_channel</span> <span class="o">=</span> <span class="n">ath5k_channel_2ghz</span><span class="p">.</span><span class="n">a2_athchan</span><span class="p">;</span>
		<span class="n">data0</span> <span class="o">=</span> <span class="p">((</span><span class="n">ath5k_hw_bitswap</span><span class="p">(</span><span class="n">ath5k_channel_2ghz</span><span class="p">.</span><span class="n">a2_flags</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
		    <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ath5k_channel</span> <span class="o">&lt;</span> <span class="mi">145</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">ath5k_channel</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">clock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">data1</span> <span class="o">=</span> <span class="p">((</span><span class="n">ath5k_hw_bitswap</span><span class="p">(</span><span class="n">ath5k_channel</span> <span class="o">-</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">clock</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">clock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">data1</span> <span class="o">=</span> <span class="p">((</span><span class="n">ath5k_hw_bitswap</span><span class="p">((</span><span class="n">ath5k_channel</span> <span class="o">-</span> <span class="mi">24</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
			<span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">clock</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="p">(</span><span class="n">data1</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">data0</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>
			<span class="n">AR5K_RF_BUFFER</span><span class="p">);</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="p">((</span><span class="n">data1</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">data0</span> <span class="o">&amp;</span> <span class="mh">0xff00</span><span class="p">),</span>
			<span class="n">AR5K_RF_BUFFER_CONTROL_3</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_rf5112_channel() - Set channel frequency on 5112 and newer</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @channel: The &amp;struct ieee80211_channel</span>
<span class="cm"> *</span>
<span class="cm"> * On RF5112/2112 and newer we don&#39;t need to do any conversion.</span>
<span class="cm"> * We pass the frequency value after a few modifications to the</span>
<span class="cm"> * chip directly.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Make sure channel frequency given is within our range or else</span>
<span class="cm"> * we might damage the chip ! Use ath5k_channel_ok before calling this one.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ath5k_hw_rf5112_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">,</span> <span class="n">data0</span><span class="p">,</span> <span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">c</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">data0</span> <span class="o">=</span> <span class="n">data1</span> <span class="o">=</span> <span class="n">data2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span><span class="p">;</span>

	<span class="cm">/* My guess based on code:</span>
<span class="cm">	 * 2GHz RF has 2 synth modes, one with a Local Oscillator</span>
<span class="cm">	 * at 2224Hz and one with a LO at 2192Hz. IF is 1520Hz</span>
<span class="cm">	 * (3040/2). data0 is used to set the PLL divider and data1</span>
<span class="cm">	 * selects synth mode. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="mi">4800</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Channel 14 and all frequencies with 2Hz spacing</span>
<span class="cm">		 * below/above (non-standard channels) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">c</span> <span class="o">-</span> <span class="mi">2224</span><span class="p">)</span> <span class="o">%</span> <span class="mi">5</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Same as (c - 2224) / 5 */</span>
			<span class="n">data0</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="mi">704</span><span class="p">))</span> <span class="o">-</span> <span class="mi">3040</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
			<span class="n">data1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Channel 1 and all frequencies with 5Hz spacing</span>
<span class="cm">		 * below/above (standard channels without channel 14) */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">c</span> <span class="o">-</span> <span class="mi">2192</span><span class="p">)</span> <span class="o">%</span> <span class="mi">5</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Same as (c - 2192) / 5 */</span>
			<span class="n">data0</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="mi">672</span><span class="p">))</span> <span class="o">-</span> <span class="mi">3040</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
			<span class="n">data1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">data0</span> <span class="o">=</span> <span class="n">ath5k_hw_bitswap</span><span class="p">((</span><span class="n">data0</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="cm">/* This is more complex, we have a single synthesizer with</span>
<span class="cm">	 * 4 reference clock settings (?) based on frequency spacing</span>
<span class="cm">	 * and set using data2. LO is at 4800Hz and data0 is again used</span>
<span class="cm">	 * to set some divider.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE: There is an old atheros presentation at Stanford</span>
<span class="cm">	 * that mentions a method called dual direct conversion</span>
<span class="cm">	 * with 1GHz sliding IF for RF5110. Maybe that&#39;s what we</span>
<span class="cm">	 * have here, or an updated version. */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">c</span> <span class="o">%</span> <span class="mi">5</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="mi">5435</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span> <span class="o">%</span> <span class="mi">20</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&gt;=</span> <span class="mi">5120</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">data0</span> <span class="o">=</span> <span class="n">ath5k_hw_bitswap</span><span class="p">(((</span><span class="n">c</span> <span class="o">-</span> <span class="mi">4800</span><span class="p">)</span> <span class="o">/</span> <span class="mi">20</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">8</span><span class="p">);</span>
			<span class="n">data2</span> <span class="o">=</span> <span class="n">ath5k_hw_bitswap</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span> <span class="o">%</span> <span class="mi">10</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">data0</span> <span class="o">=</span> <span class="n">ath5k_hw_bitswap</span><span class="p">(((</span><span class="n">c</span> <span class="o">-</span> <span class="mi">4800</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">8</span><span class="p">);</span>
			<span class="n">data2</span> <span class="o">=</span> <span class="n">ath5k_hw_bitswap</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span> <span class="o">%</span> <span class="mi">5</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">data0</span> <span class="o">=</span> <span class="n">ath5k_hw_bitswap</span><span class="p">((</span><span class="n">c</span> <span class="o">-</span> <span class="mi">4800</span><span class="p">)</span> <span class="o">/</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
			<span class="n">data2</span> <span class="o">=</span> <span class="n">ath5k_hw_bitswap</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">data0</span> <span class="o">=</span> <span class="n">ath5k_hw_bitswap</span><span class="p">((</span><span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">4800</span><span class="p">))</span> <span class="o">/</span> <span class="mi">25</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">data2</span> <span class="o">=</span> <span class="n">ath5k_hw_bitswap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data0</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">data1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">data2</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x1001</span><span class="p">;</span>

	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">AR5K_RF_BUFFER</span><span class="p">);</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">,</span> <span class="n">AR5K_RF_BUFFER_CONTROL_5</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_rf2425_channel() - Set channel frequency on RF2425</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @channel: The &amp;struct ieee80211_channel</span>
<span class="cm"> *</span>
<span class="cm"> * AR2425/2417 have a different 2GHz RF so code changes</span>
<span class="cm"> * a little bit from RF5112.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ath5k_hw_rf2425_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">,</span> <span class="n">data0</span><span class="p">,</span> <span class="n">data2</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">c</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">data0</span> <span class="o">=</span> <span class="n">data2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="mi">4800</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data0</span> <span class="o">=</span> <span class="n">ath5k_hw_bitswap</span><span class="p">((</span><span class="n">c</span> <span class="o">-</span> <span class="mi">2272</span><span class="p">),</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">data2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* ? 5GHz ? */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">c</span> <span class="o">%</span> <span class="mi">5</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="mi">5435</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span> <span class="o">%</span> <span class="mi">20</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">5120</span><span class="p">)</span>
			<span class="n">data0</span> <span class="o">=</span> <span class="n">ath5k_hw_bitswap</span><span class="p">(((</span><span class="n">c</span> <span class="o">-</span> <span class="mi">4800</span><span class="p">)</span> <span class="o">/</span> <span class="mi">20</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">8</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span> <span class="o">%</span> <span class="mi">10</span><span class="p">))</span>
			<span class="n">data0</span> <span class="o">=</span> <span class="n">ath5k_hw_bitswap</span><span class="p">(((</span><span class="n">c</span> <span class="o">-</span> <span class="mi">4800</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">8</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span> <span class="o">%</span> <span class="mi">5</span><span class="p">))</span>
			<span class="n">data0</span> <span class="o">=</span> <span class="n">ath5k_hw_bitswap</span><span class="p">((</span><span class="n">c</span> <span class="o">-</span> <span class="mi">4800</span><span class="p">)</span> <span class="o">/</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">data2</span> <span class="o">=</span> <span class="n">ath5k_hw_bitswap</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">data0</span> <span class="o">=</span> <span class="n">ath5k_hw_bitswap</span><span class="p">((</span><span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">4800</span><span class="p">))</span> <span class="o">/</span> <span class="mi">25</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">data2</span> <span class="o">=</span> <span class="n">ath5k_hw_bitswap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data0</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">data2</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="o">|</span> <span class="mh">0x1001</span><span class="p">;</span>

	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">AR5K_RF_BUFFER</span><span class="p">);</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">,</span> <span class="n">AR5K_RF_BUFFER_CONTROL_5</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_channel() - Set a channel on the radio chip</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @channel: The &amp;struct ieee80211_channel</span>
<span class="cm"> *</span>
<span class="cm"> * This is the main function called to set a channel on the</span>
<span class="cm"> * radio chip based on the radio chip version.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ath5k_hw_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check bounds supported by the PHY (we don&#39;t care about regulatory</span>
<span class="cm">	 * restrictions at this point).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ath5k_channel_ok</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">channel</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ATH5K_ERR</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span>
			<span class="s">&quot;channel frequency (%u MHz) out of supported &quot;</span>
			<span class="s">&quot;band range</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the channel and wait</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AR5K_RF5110</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ath5k_hw_rf5110_channel</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_RF5111</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ath5k_hw_rf5111_channel</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_RF2317</span>:
	<span class="k">case</span> <span class="n">AR5K_RF2425</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ath5k_hw_rf2425_channel</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ath5k_hw_rf5112_channel</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Set JAPAN setting for channel 14 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span> <span class="o">==</span> <span class="mi">2484</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AR5K_REG_ENABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_CCKTXCTL</span><span class="p">,</span>
				<span class="n">AR5K_PHY_CCKTXCTL_JAPAN</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">AR5K_REG_ENABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_CCKTXCTL</span><span class="p">,</span>
				<span class="n">AR5K_PHY_CCKTXCTL_WORLD</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_current_channel</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*****************\</span>
<span class="cm">  PHY calibration</span>
<span class="cm">\*****************/</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: PHY Calibration routines</span>
<span class="cm"> *</span>
<span class="cm"> * Noise floor calibration: When we tell the hardware to</span>
<span class="cm"> * perform a noise floor calibration by setting the</span>
<span class="cm"> * AR5K_PHY_AGCCTL_NF bit on AR5K_PHY_AGCCTL, it will periodically</span>
<span class="cm"> * sample-and-hold the minimum noise level seen at the antennas.</span>
<span class="cm"> * This value is then stored in a ring buffer of recently measured</span>
<span class="cm"> * noise floor values so we have a moving window of the last few</span>
<span class="cm"> * samples. The median of the values in the history is then loaded</span>
<span class="cm"> * into the hardware for its own use for RSSI and CCA measurements.</span>
<span class="cm"> * This type of calibration doesn&#39;t interfere with traffic.</span>
<span class="cm"> *</span>
<span class="cm"> * AGC calibration: When we tell the hardware to perform</span>
<span class="cm"> * an AGC (Automatic Gain Control) calibration by setting the</span>
<span class="cm"> * AR5K_PHY_AGCCTL_CAL, hw disconnects the antennas and does</span>
<span class="cm"> * a calibration on the DC offsets of ADCs. During this period</span>
<span class="cm"> * rx/tx gets disabled so we have to deal with it on the driver</span>
<span class="cm"> * part.</span>
<span class="cm"> *</span>
<span class="cm"> * I/Q calibration: When we tell the hardware to perform</span>
<span class="cm"> * an I/Q calibration, it tries to correct I/Q imbalance and</span>
<span class="cm"> * fix QAM constellation by sampling data from rxed frames.</span>
<span class="cm"> * It doesn&#39;t interfere with traffic.</span>
<span class="cm"> *</span>
<span class="cm"> * For more infos on AGC and I/Q calibration check out patent doc</span>
<span class="cm"> * #03/094463.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_read_measured_noise_floor() - Read measured NF from hw</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span>
<span class="nf">ath5k_hw_read_measured_noise_floor</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_NF</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sign_extend32</span><span class="p">(</span><span class="n">AR5K_REG_MS</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">AR5K_PHY_NF_MINCCA_PWR</span><span class="p">),</span> <span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_init_nfcal_hist() - Initialize NF calibration history buffer</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ath5k_hw_init_nfcal_hist</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_nfcal_hist</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ATH5K_NF_CAL_HIST_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_nfcal_hist</span><span class="p">.</span><span class="n">nfval</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">AR5K_TUNE_CCA_MAX_GOOD_VALUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_update_nfcal_hist() - Update NF calibration history buffer</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @noise_floor: The NF we got from hw</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ath5k_hw_update_nfcal_hist</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">s16</span> <span class="n">noise_floor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ath5k_nfcal_hist</span> <span class="o">*</span><span class="n">hist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_nfcal_hist</span><span class="p">;</span>
	<span class="n">hist</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">hist</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATH5K_NF_CAL_HIST_MAX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">hist</span><span class="o">-&gt;</span><span class="n">nfval</span><span class="p">[</span><span class="n">hist</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">noise_floor</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_get_median_noise_floor() - Get median NF from history buffer</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s16</span>
<span class="nf">ath5k_hw_get_median_noise_floor</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s16</span> <span class="n">sort</span><span class="p">[</span><span class="n">ATH5K_NF_CAL_HIST_MAX</span><span class="p">];</span>
	<span class="n">s16</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">sort</span><span class="p">,</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_nfcal_hist</span><span class="p">.</span><span class="n">nfval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sort</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ATH5K_NF_CAL_HIST_MAX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ATH5K_NF_CAL_HIST_MAX</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sort</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">sort</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">tmp</span> <span class="o">=</span> <span class="n">sort</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
				<span class="n">sort</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sort</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
				<span class="n">sort</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ATH5K_NF_CAL_HIST_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ATH5K_DBG</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ATH5K_DEBUG_CALIBRATE</span><span class="p">,</span>
			<span class="s">&quot;cal %d:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">sort</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sort</span><span class="p">[(</span><span class="n">ATH5K_NF_CAL_HIST_MAX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_update_noise_floor() - Update NF on hardware</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> *</span>
<span class="cm"> * This is the main function we call to perform a NF calibration,</span>
<span class="cm"> * it reads NF from hardware, calculates the median and updates</span>
<span class="cm"> * NF on hw.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ath5k_hw_update_noise_floor</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ath5k_eeprom_info</span> <span class="o">*</span><span class="n">ee</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_capabilities</span><span class="p">.</span><span class="n">cap_eeprom</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">s16</span> <span class="n">nf</span><span class="p">,</span> <span class="n">threshold</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ee_mode</span><span class="p">;</span>

	<span class="cm">/* keep last value if calibration hasn&#39;t completed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_AGCCTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">AR5K_PHY_AGCCTL_NF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ATH5K_DBG</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ATH5K_DEBUG_CALIBRATE</span><span class="p">,</span>
			<span class="s">&quot;NF did not complete in calibration window</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_cal_mask</span> <span class="o">|=</span> <span class="n">AR5K_CALIBRATION_NF</span><span class="p">;</span>

	<span class="n">ee_mode</span> <span class="o">=</span> <span class="n">ath5k_eeprom_mode_from_channel</span><span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_current_channel</span><span class="p">);</span>

	<span class="cm">/* completed NF calibration, test threshold */</span>
	<span class="n">nf</span> <span class="o">=</span> <span class="n">ath5k_hw_read_measured_noise_floor</span><span class="p">(</span><span class="n">ah</span><span class="p">);</span>
	<span class="n">threshold</span> <span class="o">=</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_noise_floor_thr</span><span class="p">[</span><span class="n">ee_mode</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nf</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ATH5K_DBG</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ATH5K_DEBUG_CALIBRATE</span><span class="p">,</span>
			<span class="s">&quot;noise floor failure detected; &quot;</span>
			<span class="s">&quot;read %d, threshold %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">nf</span><span class="p">,</span> <span class="n">threshold</span><span class="p">);</span>

		<span class="n">nf</span> <span class="o">=</span> <span class="n">AR5K_TUNE_CCA_MAX_GOOD_VALUE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ath5k_hw_update_nfcal_hist</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">nf</span><span class="p">);</span>
	<span class="n">nf</span> <span class="o">=</span> <span class="n">ath5k_hw_get_median_noise_floor</span><span class="p">(</span><span class="n">ah</span><span class="p">);</span>

	<span class="cm">/* load noise floor (in .5 dBm) so the hardware will use it */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_NF</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">AR5K_PHY_NF_M</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="p">(</span><span class="n">nf</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">AR5K_PHY_NF_M</span><span class="p">;</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">AR5K_PHY_NF</span><span class="p">);</span>

	<span class="n">AR5K_REG_MASKED_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_AGCCTL</span><span class="p">,</span> <span class="n">AR5K_PHY_AGCCTL_NF</span><span class="p">,</span>
		<span class="o">~</span><span class="p">(</span><span class="n">AR5K_PHY_AGCCTL_NF_EN</span> <span class="o">|</span> <span class="n">AR5K_PHY_AGCCTL_NF_NOUPDATE</span><span class="p">));</span>

	<span class="n">ath5k_hw_register_timeout</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_AGCCTL</span><span class="p">,</span> <span class="n">AR5K_PHY_AGCCTL_NF</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Load a high max CCA Power value (-50 dBm in .5 dBm units)</span>
<span class="cm">	 * so that we&#39;re not capped by the median we just loaded.</span>
<span class="cm">	 * This will be used as the initial value for the next noise</span>
<span class="cm">	 * floor calibration.</span>
<span class="cm">	 */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">AR5K_PHY_NF_M</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="o">-</span><span class="mi">50</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">AR5K_PHY_NF_M</span><span class="p">);</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">AR5K_PHY_NF</span><span class="p">);</span>
	<span class="n">AR5K_REG_ENABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_AGCCTL</span><span class="p">,</span>
		<span class="n">AR5K_PHY_AGCCTL_NF_EN</span> <span class="o">|</span>
		<span class="n">AR5K_PHY_AGCCTL_NF_NOUPDATE</span> <span class="o">|</span>
		<span class="n">AR5K_PHY_AGCCTL_NF</span><span class="p">);</span>

	<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_noise_floor</span> <span class="o">=</span> <span class="n">nf</span><span class="p">;</span>

	<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_cal_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">AR5K_CALIBRATION_NF</span><span class="p">;</span>

	<span class="n">ATH5K_DBG</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ATH5K_DEBUG_CALIBRATE</span><span class="p">,</span>
		<span class="s">&quot;noise floor calibrated: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_rf5110_calibrate() - Perform a PHY calibration on RF5110</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @channel: The &amp;struct ieee80211_channel</span>
<span class="cm"> *</span>
<span class="cm"> * Do a complete PHY calibration (AGC + NF + I/Q) on RF5110</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ath5k_hw_rf5110_calibrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">phy_sig</span><span class="p">,</span> <span class="n">phy_agc</span><span class="p">,</span> <span class="n">phy_sat</span><span class="p">,</span> <span class="n">beacon</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_cal_mask</span> <span class="o">&amp;</span> <span class="n">AR5K_CALIBRATION_FULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable beacons and RX/TX queues, wait</span>
<span class="cm">	 */</span>
	<span class="n">AR5K_REG_ENABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_DIAG_SW_5210</span><span class="p">,</span>
		<span class="n">AR5K_DIAG_SW_DIS_TX_5210</span> <span class="o">|</span> <span class="n">AR5K_DIAG_SW_DIS_RX_5210</span><span class="p">);</span>
	<span class="n">beacon</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_BEACON_5210</span><span class="p">);</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">beacon</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">AR5K_BEACON_ENABLE</span><span class="p">,</span> <span class="n">AR5K_BEACON_5210</span><span class="p">);</span>

	<span class="n">usleep_range</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">2500</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the channel (with AGC turned off)</span>
<span class="cm">	 */</span>
	<span class="n">AR5K_REG_ENABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_AGC</span><span class="p">,</span> <span class="n">AR5K_PHY_AGC_DISABLE</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ath5k_hw_channel</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Activate PHY and wait</span>
<span class="cm">	 */</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_ACT_ENABLE</span><span class="p">,</span> <span class="n">AR5K_PHY_ACT</span><span class="p">);</span>
	<span class="n">usleep_range</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1500</span><span class="p">);</span>

	<span class="n">AR5K_REG_DISABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_AGC</span><span class="p">,</span> <span class="n">AR5K_PHY_AGC_DISABLE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calibrate the radio chip</span>
<span class="cm">	 */</span>

	<span class="cm">/* Remember normal state */</span>
	<span class="n">phy_sig</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_SIG</span><span class="p">);</span>
	<span class="n">phy_agc</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_AGCCOARSE</span><span class="p">);</span>
	<span class="n">phy_sat</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_ADCSAT</span><span class="p">);</span>

	<span class="cm">/* Update radio registers */</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="p">(</span><span class="n">phy_sig</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">AR5K_PHY_SIG_FIRPWR</span><span class="p">))</span> <span class="o">|</span>
		<span class="n">AR5K_REG_SM</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">AR5K_PHY_SIG_FIRPWR</span><span class="p">),</span> <span class="n">AR5K_PHY_SIG</span><span class="p">);</span>

	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="p">(</span><span class="n">phy_agc</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">AR5K_PHY_AGCCOARSE_HI</span> <span class="o">|</span>
			<span class="n">AR5K_PHY_AGCCOARSE_LO</span><span class="p">))</span> <span class="o">|</span>
		<span class="n">AR5K_REG_SM</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">AR5K_PHY_AGCCOARSE_HI</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">AR5K_REG_SM</span><span class="p">(</span><span class="o">-</span><span class="mi">127</span><span class="p">,</span> <span class="n">AR5K_PHY_AGCCOARSE_LO</span><span class="p">),</span> <span class="n">AR5K_PHY_AGCCOARSE</span><span class="p">);</span>

	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="p">(</span><span class="n">phy_sat</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">AR5K_PHY_ADCSAT_ICNT</span> <span class="o">|</span>
			<span class="n">AR5K_PHY_ADCSAT_THR</span><span class="p">))</span> <span class="o">|</span>
		<span class="n">AR5K_REG_SM</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">AR5K_PHY_ADCSAT_ICNT</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">AR5K_REG_SM</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">AR5K_PHY_ADCSAT_THR</span><span class="p">),</span> <span class="n">AR5K_PHY_ADCSAT</span><span class="p">);</span>

	<span class="n">udelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>

	<span class="n">AR5K_REG_ENABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_AGC</span><span class="p">,</span> <span class="n">AR5K_PHY_AGC_DISABLE</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_RFSTG_DISABLE</span><span class="p">,</span> <span class="n">AR5K_PHY_RFSTG</span><span class="p">);</span>
	<span class="n">AR5K_REG_DISABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_AGC</span><span class="p">,</span> <span class="n">AR5K_PHY_AGC_DISABLE</span><span class="p">);</span>

	<span class="n">usleep_range</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1500</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enable calibration and wait until completion</span>
<span class="cm">	 */</span>
	<span class="n">AR5K_REG_ENABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_AGCCTL</span><span class="p">,</span> <span class="n">AR5K_PHY_AGCCTL_CAL</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ath5k_hw_register_timeout</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_AGCCTL</span><span class="p">,</span>
			<span class="n">AR5K_PHY_AGCCTL_CAL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="cm">/* Reset to normal state */</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">phy_sig</span><span class="p">,</span> <span class="n">AR5K_PHY_SIG</span><span class="p">);</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">phy_agc</span><span class="p">,</span> <span class="n">AR5K_PHY_AGCCOARSE</span><span class="p">);</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">phy_sat</span><span class="p">,</span> <span class="n">AR5K_PHY_ADCSAT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ATH5K_ERR</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="s">&quot;calibration timeout (%uMHz)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Re-enable RX/TX and beacons</span>
<span class="cm">	 */</span>
	<span class="n">AR5K_REG_DISABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_DIAG_SW_5210</span><span class="p">,</span>
		<span class="n">AR5K_DIAG_SW_DIS_TX_5210</span> <span class="o">|</span> <span class="n">AR5K_DIAG_SW_DIS_RX_5210</span><span class="p">);</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">beacon</span><span class="p">,</span> <span class="n">AR5K_BEACON_5210</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_rf511x_iq_calibrate() - Perform I/Q calibration on RF5111 and newer</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ath5k_hw_rf511x_iq_calibrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i_pwr</span><span class="p">,</span> <span class="n">q_pwr</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">iq_corr</span><span class="p">,</span> <span class="n">i_coff</span><span class="p">,</span> <span class="n">i_coffd</span><span class="p">,</span> <span class="n">q_coff</span><span class="p">,</span> <span class="n">q_coffd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Skip if I/Q calibration is not needed or if it&#39;s still running */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_iq_cal_needed</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_IQ</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">AR5K_PHY_IQ_RUN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ATH5K_DBG_UNLIMIT</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ATH5K_DEBUG_CALIBRATE</span><span class="p">,</span>
				<span class="s">&quot;I/Q calibration still running&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Calibration has finished, get the results and re-run */</span>

	<span class="cm">/* Work around for empty results which can apparently happen on 5212:</span>
<span class="cm">	 * Read registers up to 10 times until we get both i_pr and q_pwr */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iq_corr</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_IQRES_CAL_CORR</span><span class="p">);</span>
		<span class="n">i_pwr</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_IQRES_CAL_PWR_I</span><span class="p">);</span>
		<span class="n">q_pwr</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_IQRES_CAL_PWR_Q</span><span class="p">);</span>
		<span class="n">ATH5K_DBG_UNLIMIT</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ATH5K_DEBUG_CALIBRATE</span><span class="p">,</span>
			<span class="s">&quot;iq_corr:%x i_pwr:%x q_pwr:%x&quot;</span><span class="p">,</span> <span class="n">iq_corr</span><span class="p">,</span> <span class="n">i_pwr</span><span class="p">,</span> <span class="n">q_pwr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_pwr</span> <span class="o">&amp;&amp;</span> <span class="n">q_pwr</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">i_coffd</span> <span class="o">=</span> <span class="p">((</span><span class="n">i_pwr</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">q_pwr</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5211</span><span class="p">)</span>
		<span class="n">q_coffd</span> <span class="o">=</span> <span class="n">q_pwr</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">q_coffd</span> <span class="o">=</span> <span class="n">q_pwr</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">;</span>

	<span class="cm">/* In case i_coffd became zero, cancel calibration</span>
<span class="cm">	 * not only it&#39;s too small, it&#39;ll also result a divide</span>
<span class="cm">	 * by zero later on. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_coffd</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">q_coffd</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ECANCELED</span><span class="p">;</span>

	<span class="cm">/* Protect against loss of sign bits */</span>

	<span class="n">i_coff</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">iq_corr</span><span class="p">)</span> <span class="o">/</span> <span class="n">i_coffd</span><span class="p">;</span>
	<span class="n">i_coff</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">i_coff</span><span class="p">,</span> <span class="o">-</span><span class="mi">32</span><span class="p">,</span> <span class="mi">31</span><span class="p">);</span> <span class="cm">/* signed 6 bit */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5211</span><span class="p">)</span>
		<span class="n">q_coff</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_pwr</span> <span class="o">/</span> <span class="n">q_coffd</span><span class="p">)</span> <span class="o">-</span> <span class="mi">64</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">q_coff</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_pwr</span> <span class="o">/</span> <span class="n">q_coffd</span><span class="p">)</span> <span class="o">-</span> <span class="mi">128</span><span class="p">;</span>
	<span class="n">q_coff</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">q_coff</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span> <span class="cm">/* signed 5 bit */</span>

	<span class="n">ATH5K_DBG_UNLIMIT</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ATH5K_DEBUG_CALIBRATE</span><span class="p">,</span>
			<span class="s">&quot;new I:%d Q:%d (i_coffd:%x q_coffd:%x)&quot;</span><span class="p">,</span>
			<span class="n">i_coff</span><span class="p">,</span> <span class="n">q_coff</span><span class="p">,</span> <span class="n">i_coffd</span><span class="p">,</span> <span class="n">q_coffd</span><span class="p">);</span>

	<span class="cm">/* Commit new I/Q values (set enable bit last to match HAL sources) */</span>
	<span class="n">AR5K_REG_WRITE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_IQ</span><span class="p">,</span> <span class="n">AR5K_PHY_IQ_CORR_Q_I_COFF</span><span class="p">,</span> <span class="n">i_coff</span><span class="p">);</span>
	<span class="n">AR5K_REG_WRITE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_IQ</span><span class="p">,</span> <span class="n">AR5K_PHY_IQ_CORR_Q_Q_COFF</span><span class="p">,</span> <span class="n">q_coff</span><span class="p">);</span>
	<span class="n">AR5K_REG_ENABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_IQ</span><span class="p">,</span> <span class="n">AR5K_PHY_IQ_CORR_ENABLE</span><span class="p">);</span>

	<span class="cm">/* Re-enable calibration -if we don&#39;t we&#39;ll commit</span>
<span class="cm">	 * the same values again and again */</span>
	<span class="n">AR5K_REG_WRITE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_IQ</span><span class="p">,</span>
			<span class="n">AR5K_PHY_IQ_CAL_NUM_LOG_MAX</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>
	<span class="n">AR5K_REG_ENABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_IQ</span><span class="p">,</span> <span class="n">AR5K_PHY_IQ_RUN</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_phy_calibrate() - Perform a PHY calibration</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @channel: The &amp;struct ieee80211_channel</span>
<span class="cm"> *</span>
<span class="cm"> * The main function we call from above to perform</span>
<span class="cm"> * a short or full PHY calibration based on RF chip</span>
<span class="cm"> * and current channel</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">ath5k_hw_phy_calibrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio</span> <span class="o">==</span> <span class="n">AR5K_RF5110</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ath5k_hw_rf5110_calibrate</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ath5k_hw_rf511x_iq_calibrate</span><span class="p">(</span><span class="n">ah</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ATH5K_DBG_UNLIMIT</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ATH5K_DEBUG_CALIBRATE</span><span class="p">,</span>
			<span class="s">&quot;No I/Q correction performed (%uMHz)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span><span class="p">);</span>

		<span class="cm">/* Happens all the time if there is not much</span>
<span class="cm">		 * traffic, consider it normal behaviour. */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* On full calibration request a PAPD probe for</span>
<span class="cm">	 * gainf calibration if needed */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_cal_mask</span> <span class="o">&amp;</span> <span class="n">AR5K_CALIBRATION_FULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio</span> <span class="o">==</span> <span class="n">AR5K_RF5111</span> <span class="o">||</span>
	     <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio</span> <span class="o">==</span> <span class="n">AR5K_RF5112</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">channel</span><span class="o">-&gt;</span><span class="n">hw_value</span> <span class="o">!=</span> <span class="n">AR5K_MODE_11B</span><span class="p">)</span>
		<span class="n">ath5k_hw_request_rfgain_probe</span><span class="p">(</span><span class="n">ah</span><span class="p">);</span>

	<span class="cm">/* Update noise floor */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_cal_mask</span> <span class="o">&amp;</span> <span class="n">AR5K_CALIBRATION_NF</span><span class="p">))</span>
		<span class="n">ath5k_hw_update_noise_floor</span><span class="p">(</span><span class="n">ah</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/***************************\</span>
<span class="cm">* Spur mitigation functions *</span>
<span class="cm">\***************************/</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_set_spur_mitigation_filter() - Configure SPUR filter</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @channel: The &amp;struct ieee80211_channel</span>
<span class="cm"> *</span>
<span class="cm"> * This function gets called during PHY initialization to</span>
<span class="cm"> * configure the spur filter for the given channel. Spur is noise</span>
<span class="cm"> * generated due to &quot;reflection&quot; effects, for more information on this</span>
<span class="cm"> * method check out patent US7643810</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ath5k_hw_set_spur_mitigation_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ath5k_eeprom_info</span> <span class="o">*</span><span class="n">ee</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_capabilities</span><span class="p">.</span><span class="n">cap_eeprom</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mag_mask</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
	<span class="n">u32</span> <span class="n">pilot_mask</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
	<span class="cm">/* Note: fbin values are scaled up by 2 */</span>
	<span class="n">u16</span> <span class="n">spur_chan_fbin</span><span class="p">,</span> <span class="n">chan_fbin</span><span class="p">,</span> <span class="n">symbol_width</span><span class="p">,</span> <span class="n">spur_detection_window</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">spur_delta_phase</span><span class="p">,</span> <span class="n">spur_freq_sigma_delta</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">spur_offset</span><span class="p">,</span> <span class="n">num_symbols_x16</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">num_symbol_offsets</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">freq_band</span><span class="p">;</span>

	<span class="cm">/* Convert current frequency to fbin value (the same way channels</span>
<span class="cm">	 * are stored on EEPROM, check out ath5k_eeprom_bin2freq) and scale</span>
<span class="cm">	 * up by 2 so we can compare it later */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">band</span> <span class="o">==</span> <span class="n">IEEE80211_BAND_2GHZ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chan_fbin</span> <span class="o">=</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span> <span class="o">-</span> <span class="mi">2300</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>
		<span class="n">freq_band</span> <span class="o">=</span> <span class="n">AR5K_EEPROM_BAND_2GHZ</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">chan_fbin</span> <span class="o">=</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span> <span class="o">-</span> <span class="mi">4900</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>
		<span class="n">freq_band</span> <span class="o">=</span> <span class="n">AR5K_EEPROM_BAND_5GHZ</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check if any spur_chan_fbin from EEPROM is</span>
<span class="cm">	 * within our current channel&#39;s spur detection range */</span>
	<span class="n">spur_chan_fbin</span> <span class="o">=</span> <span class="n">AR5K_EEPROM_NO_SPUR</span><span class="p">;</span>
	<span class="n">spur_detection_window</span> <span class="o">=</span> <span class="n">AR5K_SPUR_CHAN_WIDTH</span><span class="p">;</span>
	<span class="cm">/* XXX: Half/Quarter channels ?*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_bwmode</span> <span class="o">==</span> <span class="n">AR5K_BWMODE_40MHZ</span><span class="p">)</span>
		<span class="n">spur_detection_window</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AR5K_EEPROM_N_SPUR_CHANS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spur_chan_fbin</span> <span class="o">=</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_spur_chans</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">freq_band</span><span class="p">];</span>

		<span class="cm">/* Note: mask cleans AR5K_EEPROM_NO_SPUR flag</span>
<span class="cm">		 * so it&#39;s zero if we got nothing from EEPROM */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">spur_chan_fbin</span> <span class="o">==</span> <span class="n">AR5K_EEPROM_NO_SPUR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spur_chan_fbin</span> <span class="o">&amp;=</span> <span class="n">AR5K_EEPROM_SPUR_CHAN_MASK</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">chan_fbin</span> <span class="o">-</span> <span class="n">spur_detection_window</span> <span class="o">&lt;=</span>
		<span class="p">(</span><span class="n">spur_chan_fbin</span> <span class="o">&amp;</span> <span class="n">AR5K_EEPROM_SPUR_CHAN_MASK</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">chan_fbin</span> <span class="o">+</span> <span class="n">spur_detection_window</span> <span class="o">&gt;=</span>
		<span class="p">(</span><span class="n">spur_chan_fbin</span> <span class="o">&amp;</span> <span class="n">AR5K_EEPROM_SPUR_CHAN_MASK</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">spur_chan_fbin</span> <span class="o">&amp;=</span> <span class="n">AR5K_EEPROM_SPUR_CHAN_MASK</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* We need to enable spur filter for this channel */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spur_chan_fbin</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spur_offset</span> <span class="o">=</span> <span class="n">spur_chan_fbin</span> <span class="o">-</span> <span class="n">chan_fbin</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Calculate deltas:</span>
<span class="cm">		 * spur_freq_sigma_delta -&gt; spur_offset / sample_freq &lt;&lt; 21</span>
<span class="cm">		 * spur_delta_phase -&gt; spur_offset / chip_freq &lt;&lt; 11</span>
<span class="cm">		 * Note: Both values have 100Hz resolution</span>
<span class="cm">		 */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_bwmode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">AR5K_BWMODE_40MHZ</span>:
			<span class="cm">/* Both sample_freq and chip_freq are 80MHz */</span>
			<span class="n">spur_delta_phase</span> <span class="o">=</span> <span class="p">(</span><span class="n">spur_offset</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">/</span> <span class="mi">25</span><span class="p">;</span>
			<span class="n">spur_freq_sigma_delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">spur_delta_phase</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>
			<span class="n">symbol_width</span> <span class="o">=</span> <span class="n">AR5K_SPUR_SYMBOL_WIDTH_BASE_100Hz</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AR5K_BWMODE_10MHZ</span>:
			<span class="cm">/* Both sample_freq and chip_freq are 20MHz (?) */</span>
			<span class="n">spur_delta_phase</span> <span class="o">=</span> <span class="p">(</span><span class="n">spur_offset</span> <span class="o">&lt;&lt;</span> <span class="mi">18</span><span class="p">)</span> <span class="o">/</span> <span class="mi">25</span><span class="p">;</span>
			<span class="n">spur_freq_sigma_delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">spur_delta_phase</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>
			<span class="n">symbol_width</span> <span class="o">=</span> <span class="n">AR5K_SPUR_SYMBOL_WIDTH_BASE_100Hz</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AR5K_BWMODE_5MHZ</span>:
			<span class="cm">/* Both sample_freq and chip_freq are 10MHz (?) */</span>
			<span class="n">spur_delta_phase</span> <span class="o">=</span> <span class="p">(</span><span class="n">spur_offset</span> <span class="o">&lt;&lt;</span> <span class="mi">19</span><span class="p">)</span> <span class="o">/</span> <span class="mi">25</span><span class="p">;</span>
			<span class="n">spur_freq_sigma_delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">spur_delta_phase</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>
			<span class="n">symbol_width</span> <span class="o">=</span> <span class="n">AR5K_SPUR_SYMBOL_WIDTH_BASE_100Hz</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">band</span> <span class="o">==</span> <span class="n">IEEE80211_BAND_5GHZ</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Both sample_freq and chip_freq are 40MHz */</span>
				<span class="n">spur_delta_phase</span> <span class="o">=</span> <span class="p">(</span><span class="n">spur_offset</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">)</span> <span class="o">/</span> <span class="mi">25</span><span class="p">;</span>
				<span class="n">spur_freq_sigma_delta</span> <span class="o">=</span>
						<span class="p">(</span><span class="n">spur_delta_phase</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>
				<span class="n">symbol_width</span> <span class="o">=</span>
					<span class="n">AR5K_SPUR_SYMBOL_WIDTH_BASE_100Hz</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* sample_freq -&gt; 40MHz chip_freq -&gt; 44MHz</span>
<span class="cm">				 * (for b compatibility) */</span>
				<span class="n">spur_delta_phase</span> <span class="o">=</span> <span class="p">(</span><span class="n">spur_offset</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">)</span> <span class="o">/</span> <span class="mi">25</span><span class="p">;</span>
				<span class="n">spur_freq_sigma_delta</span> <span class="o">=</span>
						<span class="p">(</span><span class="n">spur_offset</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">/</span> <span class="mi">55</span><span class="p">;</span>
				<span class="n">symbol_width</span> <span class="o">=</span>
					<span class="n">AR5K_SPUR_SYMBOL_WIDTH_BASE_100Hz</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Calculate pilot and magnitude masks */</span>

		<span class="cm">/* Scale up spur_offset by 1000 to switch to 100HZ resolution</span>
<span class="cm">		 * and divide by symbol_width to find how many symbols we have</span>
<span class="cm">		 * Note: number of symbols is scaled up by 16 */</span>
		<span class="n">num_symbols_x16</span> <span class="o">=</span> <span class="p">((</span><span class="n">spur_offset</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">/</span> <span class="n">symbol_width</span><span class="p">;</span>

		<span class="cm">/* Spur is on a symbol if num_symbols_x16 % 16 is zero */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">num_symbols_x16</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">))</span>
			<span class="cm">/* _X_ */</span>
			<span class="n">num_symbol_offsets</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="cm">/* _xx_ */</span>
			<span class="n">num_symbol_offsets</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_symbol_offsets</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* Calculate pilot mask */</span>
			<span class="n">s32</span> <span class="n">curr_sym_off</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">num_symbols_x16</span> <span class="o">/</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">25</span><span class="p">;</span>

			<span class="cm">/* Pilot magnitude mask seems to be a way to</span>
<span class="cm">			 * declare the boundaries for our detection</span>
<span class="cm">			 * window or something, it&#39;s 2 for the middle</span>
<span class="cm">			 * value(s) where the symbol is expected to be</span>
<span class="cm">			 * and 1 on the boundary values */</span>
			<span class="n">u8</span> <span class="n">plt_mag_map</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">==</span> <span class="p">(</span><span class="n">num_symbol_offsets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
								<span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">2</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">curr_sym_off</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">curr_sym_off</span> <span class="o">&lt;=</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">curr_sym_off</span> <span class="o">&lt;=</span> <span class="mi">25</span><span class="p">)</span>
					<span class="n">pilot_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">curr_sym_off</span><span class="p">;</span>
				<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">curr_sym_off</span> <span class="o">&gt;=</span> <span class="mi">27</span><span class="p">)</span>
					<span class="n">pilot_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">curr_sym_off</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">curr_sym_off</span> <span class="o">&gt;=</span> <span class="mi">33</span> <span class="o">&amp;&amp;</span> <span class="n">curr_sym_off</span> <span class="o">&lt;=</span> <span class="mi">52</span><span class="p">)</span>
				<span class="n">pilot_mask</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">curr_sym_off</span> <span class="o">-</span> <span class="mi">33</span><span class="p">);</span>

			<span class="cm">/* Calculate magnitude mask (for viterbi decoder) */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">curr_sym_off</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">curr_sym_off</span> <span class="o">&lt;=</span> <span class="mi">14</span><span class="p">)</span>
				<span class="n">mag_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span>
					<span class="n">plt_mag_map</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">curr_sym_off</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">curr_sym_off</span> <span class="o">&gt;=</span> <span class="mi">15</span> <span class="o">&amp;&amp;</span> <span class="n">curr_sym_off</span> <span class="o">&lt;=</span> <span class="mi">30</span><span class="p">)</span>
				<span class="n">mag_mask</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|=</span>
					<span class="n">plt_mag_map</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">curr_sym_off</span> <span class="o">-</span> <span class="mi">15</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">curr_sym_off</span> <span class="o">&gt;=</span> <span class="mi">31</span> <span class="o">&amp;&amp;</span> <span class="n">curr_sym_off</span> <span class="o">&lt;=</span> <span class="mi">46</span><span class="p">)</span>
				<span class="n">mag_mask</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|=</span>
					<span class="n">plt_mag_map</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">curr_sym_off</span> <span class="o">-</span> <span class="mi">31</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">curr_sym_off</span> <span class="o">&gt;=</span> <span class="mi">47</span> <span class="o">&amp;&amp;</span> <span class="n">curr_sym_off</span> <span class="o">&lt;=</span> <span class="mi">53</span><span class="p">)</span>
				<span class="n">mag_mask</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">|=</span>
					<span class="n">plt_mag_map</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">curr_sym_off</span> <span class="o">-</span> <span class="mi">47</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>

		<span class="p">}</span>

		<span class="cm">/* Write settings on hw to enable spur filter */</span>
		<span class="n">AR5K_REG_WRITE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_BIN_MASK_CTL</span><span class="p">,</span>
					<span class="n">AR5K_PHY_BIN_MASK_CTL_RATE</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">);</span>
		<span class="cm">/* XXX: Self correlator also ? */</span>
		<span class="n">AR5K_REG_ENABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_IQ</span><span class="p">,</span>
					<span class="n">AR5K_PHY_IQ_PILOT_MASK_EN</span> <span class="o">|</span>
					<span class="n">AR5K_PHY_IQ_CHAN_MASK_EN</span> <span class="o">|</span>
					<span class="n">AR5K_PHY_IQ_SPUR_FILT_EN</span><span class="p">);</span>

		<span class="cm">/* Set delta phase and freq sigma delta */</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span>
				<span class="n">AR5K_REG_SM</span><span class="p">(</span><span class="n">spur_delta_phase</span><span class="p">,</span>
					<span class="n">AR5K_PHY_TIMING_11_SPUR_DELTA_PHASE</span><span class="p">)</span> <span class="o">|</span>
				<span class="n">AR5K_REG_SM</span><span class="p">(</span><span class="n">spur_freq_sigma_delta</span><span class="p">,</span>
				<span class="n">AR5K_PHY_TIMING_11_SPUR_FREQ_SD</span><span class="p">)</span> <span class="o">|</span>
				<span class="n">AR5K_PHY_TIMING_11_USE_SPUR_IN_AGC</span><span class="p">,</span>
				<span class="n">AR5K_PHY_TIMING_11</span><span class="p">);</span>

		<span class="cm">/* Write pilot masks */</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">pilot_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">AR5K_PHY_TIMING_7</span><span class="p">);</span>
		<span class="n">AR5K_REG_WRITE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_TIMING_8</span><span class="p">,</span>
					<span class="n">AR5K_PHY_TIMING_8_PILOT_MASK_2</span><span class="p">,</span>
					<span class="n">pilot_mask</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">pilot_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">AR5K_PHY_TIMING_9</span><span class="p">);</span>
		<span class="n">AR5K_REG_WRITE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_TIMING_10</span><span class="p">,</span>
					<span class="n">AR5K_PHY_TIMING_10_PILOT_MASK_2</span><span class="p">,</span>
					<span class="n">pilot_mask</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

		<span class="cm">/* Write magnitude masks */</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">mag_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">AR5K_PHY_BIN_MASK_1</span><span class="p">);</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">mag_mask</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">AR5K_PHY_BIN_MASK_2</span><span class="p">);</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">mag_mask</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">AR5K_PHY_BIN_MASK_3</span><span class="p">);</span>
		<span class="n">AR5K_REG_WRITE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_BIN_MASK_CTL</span><span class="p">,</span>
					<span class="n">AR5K_PHY_BIN_MASK_CTL_MASK_4</span><span class="p">,</span>
					<span class="n">mag_mask</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>

		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">mag_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">AR5K_PHY_BIN_MASK2_1</span><span class="p">);</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">mag_mask</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">AR5K_PHY_BIN_MASK2_2</span><span class="p">);</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">mag_mask</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">AR5K_PHY_BIN_MASK2_3</span><span class="p">);</span>
		<span class="n">AR5K_REG_WRITE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_BIN_MASK2_4</span><span class="p">,</span>
					<span class="n">AR5K_PHY_BIN_MASK2_4_MASK_4</span><span class="p">,</span>
					<span class="n">mag_mask</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_IQ</span><span class="p">)</span> <span class="o">&amp;</span>
	<span class="n">AR5K_PHY_IQ_SPUR_FILT_EN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Clean up spur mitigation settings and disable filter */</span>
		<span class="n">AR5K_REG_WRITE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_BIN_MASK_CTL</span><span class="p">,</span>
					<span class="n">AR5K_PHY_BIN_MASK_CTL_RATE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">AR5K_REG_DISABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_IQ</span><span class="p">,</span>
					<span class="n">AR5K_PHY_IQ_PILOT_MASK_EN</span> <span class="o">|</span>
					<span class="n">AR5K_PHY_IQ_CHAN_MASK_EN</span> <span class="o">|</span>
					<span class="n">AR5K_PHY_IQ_SPUR_FILT_EN</span><span class="p">);</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AR5K_PHY_TIMING_11</span><span class="p">);</span>

		<span class="cm">/* Clear pilot masks */</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AR5K_PHY_TIMING_7</span><span class="p">);</span>
		<span class="n">AR5K_REG_WRITE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_TIMING_8</span><span class="p">,</span>
					<span class="n">AR5K_PHY_TIMING_8_PILOT_MASK_2</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">);</span>

		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AR5K_PHY_TIMING_9</span><span class="p">);</span>
		<span class="n">AR5K_REG_WRITE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_TIMING_10</span><span class="p">,</span>
					<span class="n">AR5K_PHY_TIMING_10_PILOT_MASK_2</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* Clear magnitude masks */</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AR5K_PHY_BIN_MASK_1</span><span class="p">);</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AR5K_PHY_BIN_MASK_2</span><span class="p">);</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AR5K_PHY_BIN_MASK_3</span><span class="p">);</span>
		<span class="n">AR5K_REG_WRITE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_BIN_MASK_CTL</span><span class="p">,</span>
					<span class="n">AR5K_PHY_BIN_MASK_CTL_MASK_4</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">);</span>

		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AR5K_PHY_BIN_MASK2_1</span><span class="p">);</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AR5K_PHY_BIN_MASK2_2</span><span class="p">);</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AR5K_PHY_BIN_MASK2_3</span><span class="p">);</span>
		<span class="n">AR5K_REG_WRITE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_BIN_MASK2_4</span><span class="p">,</span>
					<span class="n">AR5K_PHY_BIN_MASK2_4_MASK_4</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*****************\</span>
<span class="cm">* Antenna control *</span>
<span class="cm">\*****************/</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: Antenna control</span>
<span class="cm"> *</span>
<span class="cm"> * Hw supports up to 14 antennas ! I haven&#39;t found any card that implements</span>
<span class="cm"> * that. The maximum number of antennas I&#39;ve seen is up to 4 (2 for 2GHz and 2</span>
<span class="cm"> * for 5GHz). Antenna 1 (MAIN) should be omnidirectional, 2 (AUX)</span>
<span class="cm"> * omnidirectional or sectorial and antennas 3-14 sectorial (or directional).</span>
<span class="cm"> *</span>
<span class="cm"> * We can have a single antenna for RX and multiple antennas for TX.</span>
<span class="cm"> * RX antenna is our &quot;default&quot; antenna (usually antenna 1) set on</span>
<span class="cm"> * DEFAULT_ANTENNA register and TX antenna is set on each TX control descriptor</span>
<span class="cm"> * (0 for automatic selection, 1 - 14 antenna number).</span>
<span class="cm"> *</span>
<span class="cm"> * We can let hw do all the work doing fast antenna diversity for both</span>
<span class="cm"> * tx and rx or we can do things manually. Here are the options we have</span>
<span class="cm"> * (all are bits of STA_ID1 register):</span>
<span class="cm"> *</span>
<span class="cm"> * AR5K_STA_ID1_DEFAULT_ANTENNA -&gt; When 0 is set as the TX antenna on TX</span>
<span class="cm"> * control descriptor, use the default antenna to transmit or else use the last</span>
<span class="cm"> * antenna on which we received an ACK.</span>
<span class="cm"> *</span>
<span class="cm"> * AR5K_STA_ID1_DESC_ANTENNA -&gt; Update default antenna after each TX frame to</span>
<span class="cm"> * the antenna on which we got the ACK for that frame.</span>
<span class="cm"> *</span>
<span class="cm"> * AR5K_STA_ID1_RTS_DEF_ANTENNA -&gt; Use default antenna for RTS or else use the</span>
<span class="cm"> * one on the TX descriptor.</span>
<span class="cm"> *</span>
<span class="cm"> * AR5K_STA_ID1_SELFGEN_DEF_ANT -&gt; Use default antenna for self generated frames</span>
<span class="cm"> * (ACKs etc), or else use current antenna (the one we just used for TX).</span>
<span class="cm"> *</span>
<span class="cm"> * Using the above we support the following scenarios:</span>
<span class="cm"> *</span>
<span class="cm"> * AR5K_ANTMODE_DEFAULT -&gt; Hw handles antenna diversity etc automatically</span>
<span class="cm"> *</span>
<span class="cm"> * AR5K_ANTMODE_FIXED_A	-&gt; Only antenna A (MAIN) is present</span>
<span class="cm"> *</span>
<span class="cm"> * AR5K_ANTMODE_FIXED_B	-&gt; Only antenna B (AUX) is present</span>
<span class="cm"> *</span>
<span class="cm"> * AR5K_ANTMODE_SINGLE_AP -&gt; Sta locked on a single ap</span>
<span class="cm"> *</span>
<span class="cm"> * AR5K_ANTMODE_SECTOR_AP -&gt; AP with tx antenna set on tx desc</span>
<span class="cm"> *</span>
<span class="cm"> * AR5K_ANTMODE_SECTOR_STA -&gt; STA with tx antenna set on tx desc</span>
<span class="cm"> *</span>
<span class="cm"> * AR5K_ANTMODE_DEBUG Debug mode -A -&gt; Rx, B-&gt; Tx-</span>
<span class="cm"> *</span>
<span class="cm"> * Also note that when setting antenna to F on tx descriptor card inverts</span>
<span class="cm"> * current tx antenna.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_set_def_antenna() - Set default rx antenna on AR5211/5212 and newer</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @ant: Antenna number</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ath5k_hw_set_def_antenna</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ant</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">!=</span> <span class="n">AR5K_AR5210</span><span class="p">)</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ant</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">,</span> <span class="n">AR5K_DEFAULT_ANTENNA</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_set_fast_div() -  Enable/disable fast rx antenna diversity</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @ee_mode: One of enum ath5k_driver_mode</span>
<span class="cm"> * @enable: True to enable, false to disable</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ath5k_hw_set_fast_div</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ee_mode</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ee_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AR5K_EEPROM_MODE_11G</span>:
		<span class="cm">/* XXX: This is set to</span>
<span class="cm">		 * disabled on initvals !!! */</span>
	<span class="k">case</span> <span class="n">AR5K_EEPROM_MODE_11A</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span>
			<span class="n">AR5K_REG_DISABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_AGCCTL</span><span class="p">,</span>
					<span class="n">AR5K_PHY_AGCCTL_OFDM_DIV_DIS</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">AR5K_REG_ENABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_AGCCTL</span><span class="p">,</span>
					<span class="n">AR5K_PHY_AGCCTL_OFDM_DIV_DIS</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_EEPROM_MODE_11B</span>:
		<span class="n">AR5K_REG_ENABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_AGCCTL</span><span class="p">,</span>
					<span class="n">AR5K_PHY_AGCCTL_OFDM_DIV_DIS</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AR5K_REG_WRITE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_RESTART</span><span class="p">,</span>
				<span class="n">AR5K_PHY_RESTART_DIV_GC</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

		<span class="n">AR5K_REG_ENABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_FAST_ANT_DIV</span><span class="p">,</span>
					<span class="n">AR5K_PHY_FAST_ANT_DIV_EN</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">AR5K_REG_WRITE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_RESTART</span><span class="p">,</span>
				<span class="n">AR5K_PHY_RESTART_DIV_GC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">AR5K_REG_DISABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_FAST_ANT_DIV</span><span class="p">,</span>
					<span class="n">AR5K_PHY_FAST_ANT_DIV_EN</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_set_antenna_switch() - Set up antenna switch table</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @ee_mode: One of enum ath5k_driver_mode</span>
<span class="cm"> *</span>
<span class="cm"> * Switch table comes from EEPROM and includes information on controlling</span>
<span class="cm"> * the 2 antenna RX attenuators</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ath5k_hw_set_antenna_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ee_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">ant0</span><span class="p">,</span> <span class="n">ant1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * In case a fixed antenna was set as default</span>
<span class="cm">	 * use the same switch table twice.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_ant_mode</span> <span class="o">==</span> <span class="n">AR5K_ANTMODE_FIXED_A</span><span class="p">)</span>
		<span class="n">ant0</span> <span class="o">=</span> <span class="n">ant1</span> <span class="o">=</span> <span class="n">AR5K_ANT_SWTABLE_A</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_ant_mode</span> <span class="o">==</span> <span class="n">AR5K_ANTMODE_FIXED_B</span><span class="p">)</span>
		<span class="n">ant0</span> <span class="o">=</span> <span class="n">ant1</span> <span class="o">=</span> <span class="n">AR5K_ANT_SWTABLE_B</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">ant0</span> <span class="o">=</span> <span class="n">AR5K_ANT_SWTABLE_A</span><span class="p">;</span>
		<span class="n">ant1</span> <span class="o">=</span> <span class="n">AR5K_ANT_SWTABLE_B</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set antenna idle switch table */</span>
	<span class="n">AR5K_REG_WRITE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_ANT_CTL</span><span class="p">,</span>
			<span class="n">AR5K_PHY_ANT_CTL_SWTABLE_IDLE</span><span class="p">,</span>
			<span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_ant_ctl</span><span class="p">[</span><span class="n">ee_mode</span><span class="p">][</span><span class="n">AR5K_ANT_CTL</span><span class="p">]</span> <span class="o">|</span>
			<span class="n">AR5K_PHY_ANT_CTL_TXRX_EN</span><span class="p">));</span>

	<span class="cm">/* Set antenna switch tables */</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_ant_ctl</span><span class="p">[</span><span class="n">ee_mode</span><span class="p">][</span><span class="n">ant0</span><span class="p">],</span>
		<span class="n">AR5K_PHY_ANT_SWITCH_TABLE_0</span><span class="p">);</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_ant_ctl</span><span class="p">[</span><span class="n">ee_mode</span><span class="p">][</span><span class="n">ant1</span><span class="p">],</span>
		<span class="n">AR5K_PHY_ANT_SWITCH_TABLE_1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_set_antenna_mode() -  Set antenna operating mode</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @ant_mode: One of enum ath5k_ant_mode</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ath5k_hw_set_antenna_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ant_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_current_channel</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">use_def_for_tx</span><span class="p">,</span> <span class="n">update_def_on_tx</span><span class="p">,</span> <span class="n">use_def_for_rts</span><span class="p">,</span> <span class="n">fast_div</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">use_def_for_sg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ee_mode</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">def_ant</span><span class="p">,</span> <span class="n">tx_ant</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sta_id1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* if channel is not initialized yet we can&#39;t set the antennas</span>
<span class="cm">	 * so just store the mode. it will be set on the next reset */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_ant_mode</span> <span class="o">=</span> <span class="n">ant_mode</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">def_ant</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_def_ant</span><span class="p">;</span>

	<span class="n">ee_mode</span> <span class="o">=</span> <span class="n">ath5k_eeprom_mode_from_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ee_mode</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ATH5K_ERR</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span>
			<span class="s">&quot;invalid channel: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ant_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AR5K_ANTMODE_DEFAULT</span>:
		<span class="n">tx_ant</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">use_def_for_tx</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">update_def_on_tx</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">use_def_for_rts</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">use_def_for_sg</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">fast_div</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_ANTMODE_FIXED_A</span>:
		<span class="n">def_ant</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">tx_ant</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">use_def_for_tx</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">update_def_on_tx</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">use_def_for_rts</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">use_def_for_sg</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">fast_div</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_ANTMODE_FIXED_B</span>:
		<span class="n">def_ant</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">tx_ant</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">use_def_for_tx</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">update_def_on_tx</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">use_def_for_rts</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">use_def_for_sg</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">fast_div</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_ANTMODE_SINGLE_AP</span>:
		<span class="n">def_ant</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* updated on tx */</span>
		<span class="n">tx_ant</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">use_def_for_tx</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">update_def_on_tx</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">use_def_for_rts</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">use_def_for_sg</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">fast_div</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_ANTMODE_SECTOR_AP</span>:
		<span class="n">tx_ant</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* variable */</span>
		<span class="n">use_def_for_tx</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">update_def_on_tx</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">use_def_for_rts</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">use_def_for_sg</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">fast_div</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_ANTMODE_SECTOR_STA</span>:
		<span class="n">tx_ant</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* variable */</span>
		<span class="n">use_def_for_tx</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">update_def_on_tx</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">use_def_for_rts</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">use_def_for_sg</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">fast_div</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_ANTMODE_DEBUG</span>:
		<span class="n">def_ant</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">tx_ant</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">use_def_for_tx</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">update_def_on_tx</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">use_def_for_rts</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">use_def_for_sg</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">fast_div</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_tx_ant</span> <span class="o">=</span> <span class="n">tx_ant</span><span class="p">;</span>
	<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_ant_mode</span> <span class="o">=</span> <span class="n">ant_mode</span><span class="p">;</span>
	<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_def_ant</span> <span class="o">=</span> <span class="n">def_ant</span><span class="p">;</span>

	<span class="n">sta_id1</span> <span class="o">|=</span> <span class="n">use_def_for_tx</span> <span class="o">?</span> <span class="n">AR5K_STA_ID1_DEFAULT_ANTENNA</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sta_id1</span> <span class="o">|=</span> <span class="n">update_def_on_tx</span> <span class="o">?</span> <span class="n">AR5K_STA_ID1_DESC_ANTENNA</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sta_id1</span> <span class="o">|=</span> <span class="n">use_def_for_rts</span> <span class="o">?</span> <span class="n">AR5K_STA_ID1_RTS_DEF_ANTENNA</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sta_id1</span> <span class="o">|=</span> <span class="n">use_def_for_sg</span> <span class="o">?</span> <span class="n">AR5K_STA_ID1_SELFGEN_DEF_ANT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">AR5K_REG_DISABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_STA_ID1</span><span class="p">,</span> <span class="n">AR5K_STA_ID1_ANTENNA_SETTINGS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sta_id1</span><span class="p">)</span>
		<span class="n">AR5K_REG_ENABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_STA_ID1</span><span class="p">,</span> <span class="n">sta_id1</span><span class="p">);</span>

	<span class="n">ath5k_hw_set_antenna_switch</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ee_mode</span><span class="p">);</span>
	<span class="cm">/* Note: set diversity before default antenna</span>
<span class="cm">	 * because it won&#39;t work correctly */</span>
	<span class="n">ath5k_hw_set_fast_div</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ee_mode</span><span class="p">,</span> <span class="n">fast_div</span><span class="p">);</span>
	<span class="n">ath5k_hw_set_def_antenna</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">def_ant</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/****************\</span>
<span class="cm">* TX power setup *</span>
<span class="cm">\****************/</span>

<span class="cm">/*</span>
<span class="cm"> * Helper functions</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_get_interpolated_value() - Get interpolated Y val between two points</span>
<span class="cm"> * @target: X value of the middle point</span>
<span class="cm"> * @x_left: X value of the left point</span>
<span class="cm"> * @x_right: X value of the right point</span>
<span class="cm"> * @y_left: Y value of the left point</span>
<span class="cm"> * @y_right: Y value of the right point</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s16</span>
<span class="nf">ath5k_get_interpolated_value</span><span class="p">(</span><span class="n">s16</span> <span class="n">target</span><span class="p">,</span> <span class="n">s16</span> <span class="n">x_left</span><span class="p">,</span> <span class="n">s16</span> <span class="n">x_right</span><span class="p">,</span>
					<span class="n">s16</span> <span class="n">y_left</span><span class="p">,</span> <span class="n">s16</span> <span class="n">y_right</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s16</span> <span class="n">ratio</span><span class="p">,</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* Avoid divide by zero and skip interpolation</span>
<span class="cm">	 * if we have the same point */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">x_left</span> <span class="o">==</span> <span class="n">x_right</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">y_left</span> <span class="o">==</span> <span class="n">y_right</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">y_left</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since we use ints and not fps, we need to scale up in</span>
<span class="cm">	 * order to get a sane ratio value (or else we &#39;ll eg. get</span>
<span class="cm">	 * always 1 instead of 1.25, 1.75 etc). We scale up by 100</span>
<span class="cm">	 * to have some accuracy both for 0.5 and 0.25 steps.</span>
<span class="cm">	 */</span>
	<span class="n">ratio</span> <span class="o">=</span> <span class="p">((</span><span class="mi">100</span> <span class="o">*</span> <span class="n">y_right</span> <span class="o">-</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">y_left</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">x_right</span> <span class="o">-</span> <span class="n">x_left</span><span class="p">));</span>

	<span class="cm">/* Now scale down to be in range */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">y_left</span> <span class="o">+</span> <span class="p">(</span><span class="n">ratio</span> <span class="o">*</span> <span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">x_left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_get_linear_pcdac_min() - Find vertical boundary (min pwr) for the</span>
<span class="cm"> * linear PCDAC curve</span>
<span class="cm"> * @stepL: Left array with y values (pcdac steps)</span>
<span class="cm"> * @stepR: Right array with y values (pcdac steps)</span>
<span class="cm"> * @pwrL: Left array with x values (power steps)</span>
<span class="cm"> * @pwrR: Right array with x values (power steps)</span>
<span class="cm"> *</span>
<span class="cm"> * Since we have the top of the curve and we draw the line below</span>
<span class="cm"> * until we reach 1 (1 pcdac step) we need to know which point</span>
<span class="cm"> * (x value) that is so that we don&#39;t go below x axis and have negative</span>
<span class="cm"> * pcdac values when creating the curve, or fill the table with zeros.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s16</span>
<span class="nf">ath5k_get_linear_pcdac_min</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">stepL</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">stepR</span><span class="p">,</span>
				<span class="k">const</span> <span class="n">s16</span> <span class="o">*</span><span class="n">pwrL</span><span class="p">,</span> <span class="k">const</span> <span class="n">s16</span> <span class="o">*</span><span class="n">pwrR</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s8</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">s16</span> <span class="n">min_pwrL</span><span class="p">,</span> <span class="n">min_pwrR</span><span class="p">;</span>
	<span class="n">s16</span> <span class="n">pwr_i</span><span class="p">;</span>

	<span class="cm">/* Some vendors write the same pcdac value twice !!! */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stepL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">stepL</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">||</span> <span class="n">stepR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">stepR</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">pwrL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pwrR</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pwrL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">pwrL</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="n">min_pwrL</span> <span class="o">=</span> <span class="n">pwrL</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">pwr_i</span> <span class="o">=</span> <span class="n">pwrL</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">pwr_i</span><span class="o">--</span><span class="p">;</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">s8</span><span class="p">)</span> <span class="n">ath5k_get_interpolated_value</span><span class="p">(</span><span class="n">pwr_i</span><span class="p">,</span>
							<span class="n">pwrL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pwrL</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
							<span class="n">stepL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">stepL</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">min_pwrL</span> <span class="o">=</span> <span class="n">pwr_i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pwrR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">pwrR</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="n">min_pwrR</span> <span class="o">=</span> <span class="n">pwrR</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">pwr_i</span> <span class="o">=</span> <span class="n">pwrR</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">pwr_i</span><span class="o">--</span><span class="p">;</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">s8</span><span class="p">)</span> <span class="n">ath5k_get_interpolated_value</span><span class="p">(</span><span class="n">pwr_i</span><span class="p">,</span>
							<span class="n">pwrR</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pwrR</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
							<span class="n">stepR</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">stepR</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">min_pwrR</span> <span class="o">=</span> <span class="n">pwr_i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Keep the right boundary so that it works for both curves */</span>
	<span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">min_pwrL</span><span class="p">,</span> <span class="n">min_pwrR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_create_power_curve() - Create a Power to PDADC or PCDAC curve</span>
<span class="cm"> * @pmin: Minimum power value (xmin)</span>
<span class="cm"> * @pmax: Maximum power value (xmax)</span>
<span class="cm"> * @pwr: Array of power steps (x values)</span>
<span class="cm"> * @vpd: Array of matching PCDAC/PDADC steps (y values)</span>
<span class="cm"> * @num_points: Number of provided points</span>
<span class="cm"> * @vpd_table: Array to fill with the full PCDAC/PDADC values (y values)</span>
<span class="cm"> * @type: One of enum ath5k_powertable_type (eeprom.h)</span>
<span class="cm"> *</span>
<span class="cm"> * Interpolate (pwr,vpd) points to create a Power to PDADC or a</span>
<span class="cm"> * Power to PCDAC curve.</span>
<span class="cm"> *</span>
<span class="cm"> * Each curve has power on x axis (in 0.5dB units) and PCDAC/PDADC</span>
<span class="cm"> * steps (offsets) on y axis. Power can go up to 31.5dB and max</span>
<span class="cm"> * PCDAC/PDADC step for each curve is 64 but we can write more than</span>
<span class="cm"> * one curves on hw so we can go up to 128 (which is the max step we</span>
<span class="cm"> * can write on the final table).</span>
<span class="cm"> *</span>
<span class="cm"> * We write y values (PCDAC/PDADC steps) on hw.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ath5k_create_power_curve</span><span class="p">(</span><span class="n">s16</span> <span class="n">pmin</span><span class="p">,</span> <span class="n">s16</span> <span class="n">pmax</span><span class="p">,</span>
			<span class="k">const</span> <span class="n">s16</span> <span class="o">*</span><span class="n">pwr</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">vpd</span><span class="p">,</span>
			<span class="n">u8</span> <span class="n">num_points</span><span class="p">,</span>
			<span class="n">u8</span> <span class="o">*</span><span class="n">vpd_table</span><span class="p">,</span> <span class="n">u8</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">idx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="p">};</span>
	<span class="n">s16</span> <span class="n">pwr_i</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pmin</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_points</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* We want the whole line, so adjust boundaries</span>
<span class="cm">	 * to cover the entire power range. Note that</span>
<span class="cm">	 * power values are already 0.25dB so no need</span>
<span class="cm">	 * to multiply pwr_i by 2 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">AR5K_PWRTABLE_LINEAR_PCDAC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pwr_i</span> <span class="o">=</span> <span class="n">pmin</span><span class="p">;</span>
		<span class="n">pmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pmax</span> <span class="o">=</span> <span class="mi">63</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Find surrounding turning points (TPs)</span>
<span class="cm">	 * and interpolate between them */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="p">(</span><span class="n">pmax</span> <span class="o">-</span> <span class="n">pmin</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	<span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">AR5K_EEPROM_POWER_TABLE_SIZE</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* We passed the right TP, move to the next set of TPs</span>
<span class="cm">		 * if we pass the last TP, extrapolate above using the last</span>
<span class="cm">		 * two TPs for ratio */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">pwr_i</span> <span class="o">&gt;</span> <span class="n">pwr</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">num_points</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
			<span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">vpd_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">ath5k_get_interpolated_value</span><span class="p">(</span><span class="n">pwr_i</span><span class="p">,</span>
						<span class="n">pwr</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">pwr</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
						<span class="n">vpd</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">vpd</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]);</span>

		<span class="cm">/* Increase by 0.5dB</span>
<span class="cm">		 * (0.25 dB units) */</span>
		<span class="n">pwr_i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_get_chan_pcal_surrounding_piers() - Get surrounding calibration piers</span>
<span class="cm"> * for a given channel.</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @channel: The &amp;struct ieee80211_channel</span>
<span class="cm"> * @pcinfo_l: The &amp;struct ath5k_chan_pcal_info to put the left cal. pier</span>
<span class="cm"> * @pcinfo_r: The &amp;struct ath5k_chan_pcal_info to put the right cal. pier</span>
<span class="cm"> *</span>
<span class="cm"> * Get the surrounding per-channel power calibration piers</span>
<span class="cm"> * for a given frequency so that we can interpolate between</span>
<span class="cm"> * them and come up with an appropriate dataset for our current</span>
<span class="cm"> * channel.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ath5k_get_chan_pcal_surrounding_piers</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ath5k_chan_pcal_info</span> <span class="o">**</span><span class="n">pcinfo_l</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ath5k_chan_pcal_info</span> <span class="o">**</span><span class="n">pcinfo_r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ath5k_eeprom_info</span> <span class="o">*</span><span class="n">ee</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_capabilities</span><span class="p">.</span><span class="n">cap_eeprom</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ath5k_chan_pcal_info</span> <span class="o">*</span><span class="n">pcinfo</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">idx_l</span><span class="p">,</span> <span class="n">idx_r</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">mode</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">target</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span><span class="p">;</span>

	<span class="n">idx_l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">idx_r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">hw_value</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AR5K_EEPROM_MODE_11A</span>:
		<span class="n">pcinfo</span> <span class="o">=</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_pwr_cal_a</span><span class="p">;</span>
		<span class="n">mode</span> <span class="o">=</span> <span class="n">AR5K_EEPROM_MODE_11A</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_EEPROM_MODE_11B</span>:
		<span class="n">pcinfo</span> <span class="o">=</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_pwr_cal_b</span><span class="p">;</span>
		<span class="n">mode</span> <span class="o">=</span> <span class="n">AR5K_EEPROM_MODE_11B</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_EEPROM_MODE_11G</span>:
	<span class="nl">default:</span>
		<span class="n">pcinfo</span> <span class="o">=</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_pwr_cal_g</span><span class="p">;</span>
		<span class="n">mode</span> <span class="o">=</span> <span class="n">AR5K_EEPROM_MODE_11G</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">max</span> <span class="o">=</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_n_piers</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Frequency is below our calibrated</span>
<span class="cm">	 * range. Use the lowest power curve</span>
<span class="cm">	 * we have */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">&lt;</span> <span class="n">pcinfo</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">freq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idx_l</span> <span class="o">=</span> <span class="n">idx_r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Frequency is above our calibrated</span>
<span class="cm">	 * range. Use the highest power curve</span>
<span class="cm">	 * we have */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">&gt;</span> <span class="n">pcinfo</span><span class="p">[</span><span class="n">max</span><span class="p">].</span><span class="n">freq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idx_l</span> <span class="o">=</span> <span class="n">idx_r</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Frequency is inside our calibrated</span>
<span class="cm">	 * channel range. Pick the surrounding</span>
<span class="cm">	 * calibration piers so that we can</span>
<span class="cm">	 * interpolate */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">max</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Frequency matches one of our calibration</span>
<span class="cm">		 * piers, no need to interpolate, just use</span>
<span class="cm">		 * that calibration pier */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcinfo</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">freq</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">idx_l</span> <span class="o">=</span> <span class="n">idx_r</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* We found a calibration pier that&#39;s above</span>
<span class="cm">		 * frequency, use this pier and the previous</span>
<span class="cm">		 * one to interpolate */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">&lt;</span> <span class="n">pcinfo</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">freq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">idx_r</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">idx_l</span> <span class="o">=</span> <span class="n">idx_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="o">*</span><span class="n">pcinfo_l</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pcinfo</span><span class="p">[</span><span class="n">idx_l</span><span class="p">];</span>
	<span class="o">*</span><span class="n">pcinfo_r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pcinfo</span><span class="p">[</span><span class="n">idx_r</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_get_rate_pcal_data() - Get the interpolated per-rate power</span>
<span class="cm"> * calibration data</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw *ah,</span>
<span class="cm"> * @channel: The &amp;struct ieee80211_channel</span>
<span class="cm"> * @rates: The &amp;struct ath5k_rate_pcal_info to fill</span>
<span class="cm"> *</span>
<span class="cm"> * Get the surrounding per-rate power calibration data</span>
<span class="cm"> * for a given frequency and interpolate between power</span>
<span class="cm"> * values to set max target power supported by hw for</span>
<span class="cm"> * each rate on this frequency.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ath5k_get_rate_pcal_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ath5k_rate_pcal_info</span> <span class="o">*</span><span class="n">rates</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ath5k_eeprom_info</span> <span class="o">*</span><span class="n">ee</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_capabilities</span><span class="p">.</span><span class="n">cap_eeprom</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ath5k_rate_pcal_info</span> <span class="o">*</span><span class="n">rpinfo</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">idx_l</span><span class="p">,</span> <span class="n">idx_r</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">mode</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">target</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span><span class="p">;</span>

	<span class="n">idx_l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">idx_r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">hw_value</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AR5K_MODE_11A</span>:
		<span class="n">rpinfo</span> <span class="o">=</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_rate_tpwr_a</span><span class="p">;</span>
		<span class="n">mode</span> <span class="o">=</span> <span class="n">AR5K_EEPROM_MODE_11A</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_MODE_11B</span>:
		<span class="n">rpinfo</span> <span class="o">=</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_rate_tpwr_b</span><span class="p">;</span>
		<span class="n">mode</span> <span class="o">=</span> <span class="n">AR5K_EEPROM_MODE_11B</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_MODE_11G</span>:
	<span class="nl">default:</span>
		<span class="n">rpinfo</span> <span class="o">=</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_rate_tpwr_g</span><span class="p">;</span>
		<span class="n">mode</span> <span class="o">=</span> <span class="n">AR5K_EEPROM_MODE_11G</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">max</span> <span class="o">=</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_rate_target_pwr_num</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Get the surrounding calibration</span>
<span class="cm">	 * piers - same as above */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">&lt;</span> <span class="n">rpinfo</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">freq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idx_l</span> <span class="o">=</span> <span class="n">idx_r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">&gt;</span> <span class="n">rpinfo</span><span class="p">[</span><span class="n">max</span><span class="p">].</span><span class="n">freq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idx_l</span> <span class="o">=</span> <span class="n">idx_r</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">max</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rpinfo</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">freq</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">idx_l</span> <span class="o">=</span> <span class="n">idx_r</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">&lt;</span> <span class="n">rpinfo</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">freq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">idx_r</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">idx_l</span> <span class="o">=</span> <span class="n">idx_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="cm">/* Now interpolate power value, based on the frequency */</span>
	<span class="n">rates</span><span class="o">-&gt;</span><span class="n">freq</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>

	<span class="n">rates</span><span class="o">-&gt;</span><span class="n">target_power_6to24</span> <span class="o">=</span>
		<span class="n">ath5k_get_interpolated_value</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">rpinfo</span><span class="p">[</span><span class="n">idx_l</span><span class="p">].</span><span class="n">freq</span><span class="p">,</span>
					<span class="n">rpinfo</span><span class="p">[</span><span class="n">idx_r</span><span class="p">].</span><span class="n">freq</span><span class="p">,</span>
					<span class="n">rpinfo</span><span class="p">[</span><span class="n">idx_l</span><span class="p">].</span><span class="n">target_power_6to24</span><span class="p">,</span>
					<span class="n">rpinfo</span><span class="p">[</span><span class="n">idx_r</span><span class="p">].</span><span class="n">target_power_6to24</span><span class="p">);</span>

	<span class="n">rates</span><span class="o">-&gt;</span><span class="n">target_power_36</span> <span class="o">=</span>
		<span class="n">ath5k_get_interpolated_value</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">rpinfo</span><span class="p">[</span><span class="n">idx_l</span><span class="p">].</span><span class="n">freq</span><span class="p">,</span>
					<span class="n">rpinfo</span><span class="p">[</span><span class="n">idx_r</span><span class="p">].</span><span class="n">freq</span><span class="p">,</span>
					<span class="n">rpinfo</span><span class="p">[</span><span class="n">idx_l</span><span class="p">].</span><span class="n">target_power_36</span><span class="p">,</span>
					<span class="n">rpinfo</span><span class="p">[</span><span class="n">idx_r</span><span class="p">].</span><span class="n">target_power_36</span><span class="p">);</span>

	<span class="n">rates</span><span class="o">-&gt;</span><span class="n">target_power_48</span> <span class="o">=</span>
		<span class="n">ath5k_get_interpolated_value</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">rpinfo</span><span class="p">[</span><span class="n">idx_l</span><span class="p">].</span><span class="n">freq</span><span class="p">,</span>
					<span class="n">rpinfo</span><span class="p">[</span><span class="n">idx_r</span><span class="p">].</span><span class="n">freq</span><span class="p">,</span>
					<span class="n">rpinfo</span><span class="p">[</span><span class="n">idx_l</span><span class="p">].</span><span class="n">target_power_48</span><span class="p">,</span>
					<span class="n">rpinfo</span><span class="p">[</span><span class="n">idx_r</span><span class="p">].</span><span class="n">target_power_48</span><span class="p">);</span>

	<span class="n">rates</span><span class="o">-&gt;</span><span class="n">target_power_54</span> <span class="o">=</span>
		<span class="n">ath5k_get_interpolated_value</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">rpinfo</span><span class="p">[</span><span class="n">idx_l</span><span class="p">].</span><span class="n">freq</span><span class="p">,</span>
					<span class="n">rpinfo</span><span class="p">[</span><span class="n">idx_r</span><span class="p">].</span><span class="n">freq</span><span class="p">,</span>
					<span class="n">rpinfo</span><span class="p">[</span><span class="n">idx_l</span><span class="p">].</span><span class="n">target_power_54</span><span class="p">,</span>
					<span class="n">rpinfo</span><span class="p">[</span><span class="n">idx_r</span><span class="p">].</span><span class="n">target_power_54</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_get_max_ctl_power() - Get max edge power for a given frequency</span>
<span class="cm"> * @ah: the &amp;struct ath5k_hw</span>
<span class="cm"> * @channel: The &amp;struct ieee80211_channel</span>
<span class="cm"> *</span>
<span class="cm"> * Get the max edge power for this channel if</span>
<span class="cm"> * we have such data from EEPROM&#39;s Conformance Test</span>
<span class="cm"> * Limits (CTL), and limit max power if needed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ath5k_get_max_ctl_power</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ath_regulatory</span> <span class="o">*</span><span class="n">regulatory</span> <span class="o">=</span> <span class="n">ath5k_hw_regulatory</span><span class="p">(</span><span class="n">ah</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ath5k_eeprom_info</span> <span class="o">*</span><span class="n">ee</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_capabilities</span><span class="p">.</span><span class="n">cap_eeprom</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ath5k_edge_power</span> <span class="o">*</span><span class="n">rep</span> <span class="o">=</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_ctl_pwr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">ctl_val</span> <span class="o">=</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_ctl</span><span class="p">;</span>
	<span class="n">s16</span> <span class="n">max_chan_pwr</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_max_pwr</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">s16</span> <span class="n">edge_pwr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">rep_idx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">i</span><span class="p">,</span> <span class="n">ctl_mode</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ctl_idx</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">target</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span><span class="p">;</span>

	<span class="n">ctl_mode</span> <span class="o">=</span> <span class="n">ath_regd_get_band_ctl</span><span class="p">(</span><span class="n">regulatory</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">band</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">hw_value</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AR5K_MODE_11A</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_bwmode</span> <span class="o">==</span> <span class="n">AR5K_BWMODE_40MHZ</span><span class="p">)</span>
			<span class="n">ctl_mode</span> <span class="o">|=</span> <span class="n">AR5K_CTL_TURBO</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ctl_mode</span> <span class="o">|=</span> <span class="n">AR5K_CTL_11A</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_MODE_11G</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_bwmode</span> <span class="o">==</span> <span class="n">AR5K_BWMODE_40MHZ</span><span class="p">)</span>
			<span class="n">ctl_mode</span> <span class="o">|=</span> <span class="n">AR5K_CTL_TURBOG</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ctl_mode</span> <span class="o">|=</span> <span class="n">AR5K_CTL_11G</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_MODE_11B</span>:
		<span class="n">ctl_mode</span> <span class="o">|=</span> <span class="n">AR5K_CTL_11B</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_ctls</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctl_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">ctl_mode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ctl_idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* If we have a CTL dataset available grab it and find the</span>
<span class="cm">	 * edge power for our frequency */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctl_idx</span> <span class="o">==</span> <span class="mh">0xFF</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Edge powers are sorted by frequency from lower</span>
<span class="cm">	 * to higher. Each CTL corresponds to 8 edge power</span>
<span class="cm">	 * measurements. */</span>
	<span class="n">rep_idx</span> <span class="o">=</span> <span class="n">ctl_idx</span> <span class="o">*</span> <span class="n">AR5K_EEPROM_N_EDGES</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t do boundaries check because we</span>
<span class="cm">	 * might have more that one bands defined</span>
<span class="cm">	 * for this mode */</span>

	<span class="cm">/* Get the edge power that&#39;s closer to our</span>
<span class="cm">	 * frequency */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AR5K_EEPROM_N_EDGES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rep_idx</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">&lt;=</span> <span class="n">rep</span><span class="p">[</span><span class="n">rep_idx</span><span class="p">].</span><span class="n">freq</span><span class="p">)</span>
			<span class="n">edge_pwr</span> <span class="o">=</span> <span class="p">(</span><span class="n">s16</span><span class="p">)</span> <span class="n">rep</span><span class="p">[</span><span class="n">rep_idx</span><span class="p">].</span><span class="n">edge</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">edge_pwr</span><span class="p">)</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_max_pwr</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">min</span><span class="p">(</span><span class="n">edge_pwr</span><span class="p">,</span> <span class="n">max_chan_pwr</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Power to PCDAC table functions</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: Power to PCDAC table functions</span>
<span class="cm"> *</span>
<span class="cm"> * For RF5111 we have an XPD -eXternal Power Detector- curve</span>
<span class="cm"> * for each calibrated channel. Each curve has 0,5dB Power steps</span>
<span class="cm"> * on x axis and PCDAC steps (offsets) on y axis and looks like an</span>
<span class="cm"> * exponential function. To recreate the curve we read 11 points</span>
<span class="cm"> * from eeprom (eeprom.c) and interpolate here.</span>
<span class="cm"> *</span>
<span class="cm"> * For RF5112 we have 4 XPD -eXternal Power Detector- curves</span>
<span class="cm"> * for each calibrated channel on 0, -6, -12 and -18dBm but we only</span>
<span class="cm"> * use the higher (3) and the lower (0) curves. Each curve again has 0.5dB</span>
<span class="cm"> * power steps on x axis and PCDAC steps on y axis and looks like a</span>
<span class="cm"> * linear function. To recreate the curve and pass the power values</span>
<span class="cm"> * on hw, we get 4 points for xpd 0 (lower gain -&gt; max power)</span>
<span class="cm"> * and 3 points for xpd 3 (higher gain -&gt; lower power) from eeprom (eeprom.c)</span>
<span class="cm"> * and interpolate here.</span>
<span class="cm"> *</span>
<span class="cm"> * For a given channel we get the calibrated points (piers) for it or</span>
<span class="cm"> * -if we don&#39;t have calibration data for this specific channel- from the</span>
<span class="cm"> * available surrounding channels we have calibration data for, after we do a</span>
<span class="cm"> * linear interpolation between them. Then since we have our calibrated points</span>
<span class="cm"> * for this channel, we do again a linear interpolation between them to get the</span>
<span class="cm"> * whole curve.</span>
<span class="cm"> *</span>
<span class="cm"> * We finally write the Y values of the curve(s) (the PCDAC values) on hw</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_fill_pwr_to_pcdac_table() - Fill Power to PCDAC table on RF5111</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @table_min: Minimum power (x min)</span>
<span class="cm"> * @table_max: Maximum power (x max)</span>
<span class="cm"> *</span>
<span class="cm"> * No further processing is needed for RF5111, the only thing we have to</span>
<span class="cm"> * do is fill the values below and above calibration range since eeprom data</span>
<span class="cm"> * may not cover the entire PCDAC table.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ath5k_fill_pwr_to_pcdac_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">s16</span><span class="o">*</span> <span class="n">table_min</span><span class="p">,</span>
							<span class="n">s16</span> <span class="o">*</span><span class="n">table_max</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span>	<span class="o">*</span><span class="n">pcdac_out</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_pd_table</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="o">*</span><span class="n">pcdac_tmp</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">tmpL</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">u8</span>	<span class="n">pcdac_0</span><span class="p">,</span> <span class="n">pcdac_n</span><span class="p">,</span> <span class="n">pcdac_i</span><span class="p">,</span> <span class="n">pwr_idx</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">s16</span>	<span class="n">min_pwr</span><span class="p">,</span> <span class="n">max_pwr</span><span class="p">;</span>

	<span class="cm">/* Get table boundaries */</span>
	<span class="n">min_pwr</span> <span class="o">=</span> <span class="n">table_min</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">pcdac_0</span> <span class="o">=</span> <span class="n">pcdac_tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">max_pwr</span> <span class="o">=</span> <span class="n">table_max</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">pcdac_n</span> <span class="o">=</span> <span class="n">pcdac_tmp</span><span class="p">[</span><span class="n">table_max</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">table_min</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span>

	<span class="cm">/* Extrapolate below minimum using pcdac_0 */</span>
	<span class="n">pcdac_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">min_pwr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pcdac_out</span><span class="p">[</span><span class="n">pcdac_i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcdac_0</span><span class="p">;</span>

	<span class="cm">/* Copy values from pcdac_tmp */</span>
	<span class="n">pwr_idx</span> <span class="o">=</span> <span class="n">min_pwr</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pwr_idx</span> <span class="o">&lt;=</span> <span class="n">max_pwr</span> <span class="o">&amp;&amp;</span>
		    <span class="n">pcdac_i</span> <span class="o">&lt;</span> <span class="n">AR5K_EEPROM_POWER_TABLE_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pcdac_out</span><span class="p">[</span><span class="n">pcdac_i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcdac_tmp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">pwr_idx</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Extrapolate above maximum */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pcdac_i</span> <span class="o">&lt;</span> <span class="n">AR5K_EEPROM_POWER_TABLE_SIZE</span><span class="p">)</span>
		<span class="n">pcdac_out</span><span class="p">[</span><span class="n">pcdac_i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcdac_n</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_combine_linear_pcdac_curves() - Combine available PCDAC Curves</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @table_min: Minimum power (x min)</span>
<span class="cm"> * @table_max: Maximum power (x max)</span>
<span class="cm"> * @pdcurves: Number of pd curves</span>
<span class="cm"> *</span>
<span class="cm"> * Combine available XPD Curves and fill Linear Power to PCDAC table on RF5112</span>
<span class="cm"> * RFX112 can have up to 2 curves (one for low txpower range and one for</span>
<span class="cm"> * higher txpower range). We need to put them both on pcdac_out and place</span>
<span class="cm"> * them in the correct location. In case we only have one curve available</span>
<span class="cm"> * just fit it on pcdac_out (it&#39;s supposed to cover the entire range of</span>
<span class="cm"> * available pwr levels since it&#39;s always the higher power curve). Extrapolate</span>
<span class="cm"> * below and above final table if needed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ath5k_combine_linear_pcdac_curves</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">s16</span><span class="o">*</span> <span class="n">table_min</span><span class="p">,</span>
						<span class="n">s16</span> <span class="o">*</span><span class="n">table_max</span><span class="p">,</span> <span class="n">u8</span> <span class="n">pdcurves</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span>	<span class="o">*</span><span class="n">pcdac_out</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_pd_table</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="o">*</span><span class="n">pcdac_low_pwr</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="o">*</span><span class="n">pcdac_high_pwr</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="o">*</span><span class="n">pcdac_tmp</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">pwr</span><span class="p">;</span>
	<span class="n">s16</span>	<span class="n">max_pwr_idx</span><span class="p">;</span>
	<span class="n">s16</span>	<span class="n">min_pwr_idx</span><span class="p">;</span>
	<span class="n">s16</span>	<span class="n">mid_pwr_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Edge flag turns on the 7nth bit on the PCDAC</span>
<span class="cm">	 * to declare the higher power curve (force values</span>
<span class="cm">	 * to be greater than 64). If we only have one curve</span>
<span class="cm">	 * we don&#39;t need to set this, if we have 2 curves and</span>
<span class="cm">	 * fill the table backwards this can also be used to</span>
<span class="cm">	 * switch from higher power curve to lower power curve */</span>
	<span class="n">u8</span>	<span class="n">edge_flag</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>

	<span class="cm">/* When we have only one curve available</span>
<span class="cm">	 * that&#39;s the higher power curve. If we have</span>
<span class="cm">	 * two curves the first is the high power curve</span>
<span class="cm">	 * and the next is the low power curve. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdcurves</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pcdac_low_pwr</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">tmpL</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">pcdac_high_pwr</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">tmpL</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">mid_pwr_idx</span> <span class="o">=</span> <span class="n">table_max</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">table_min</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">max_pwr_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">table_max</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">table_min</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

		<span class="cm">/* If table size goes beyond 31.5dB, keep the</span>
<span class="cm">		 * upper 31.5dB range when setting tx power.</span>
<span class="cm">		 * Note: 126 = 31.5 dB in quarter dB steps */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">table_max</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">table_min</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">126</span><span class="p">)</span>
			<span class="n">min_pwr_idx</span> <span class="o">=</span> <span class="n">table_max</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">126</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">min_pwr_idx</span> <span class="o">=</span> <span class="n">table_min</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

		<span class="cm">/* Since we fill table backwards</span>
<span class="cm">		 * start from high power curve */</span>
		<span class="n">pcdac_tmp</span> <span class="o">=</span> <span class="n">pcdac_high_pwr</span><span class="p">;</span>

		<span class="n">edge_flag</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pcdac_low_pwr</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">tmpL</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="cm">/* Zeroed */</span>
		<span class="n">pcdac_high_pwr</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">tmpL</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">min_pwr_idx</span> <span class="o">=</span> <span class="n">table_min</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">max_pwr_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">table_max</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">table_min</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">pcdac_tmp</span> <span class="o">=</span> <span class="n">pcdac_high_pwr</span><span class="p">;</span>
		<span class="n">edge_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* This is used when setting tx power*/</span>
	<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_min_idx</span> <span class="o">=</span> <span class="n">min_pwr_idx</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* Fill Power to PCDAC table backwards */</span>
	<span class="n">pwr</span> <span class="o">=</span> <span class="n">max_pwr_idx</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">63</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Entering lower power range, reset</span>
<span class="cm">		 * edge flag and set pcdac_tmp to lower</span>
<span class="cm">		 * power curve.*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">edge_flag</span> <span class="o">==</span> <span class="mh">0x40</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pwr</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">table_max</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">table_min</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">||</span> <span class="n">pwr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">edge_flag</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
			<span class="n">pcdac_tmp</span> <span class="o">=</span> <span class="n">pcdac_low_pwr</span><span class="p">;</span>
			<span class="n">pwr</span> <span class="o">=</span> <span class="n">mid_pwr_idx</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Don&#39;t go below 1, extrapolate below if we have</span>
<span class="cm">		 * already switched to the lower power curve -or</span>
<span class="cm">		 * we only have one curve and edge_flag is zero</span>
<span class="cm">		 * anyway */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcdac_tmp</span><span class="p">[</span><span class="n">pwr</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">edge_flag</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pcdac_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcdac_out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
				<span class="n">i</span><span class="o">--</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pcdac_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcdac_tmp</span><span class="p">[</span><span class="n">pwr</span><span class="p">]</span> <span class="o">|</span> <span class="n">edge_flag</span><span class="p">;</span>

		<span class="cm">/* Extrapolate above if pcdac is greater than</span>
<span class="cm">		 * 126 -this can happen because we OR pcdac_out</span>
<span class="cm">		 * value with edge_flag on high power curve */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcdac_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">126</span><span class="p">)</span>
			<span class="n">pcdac_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">126</span><span class="p">;</span>

		<span class="cm">/* Decrease by a 0.5dB step */</span>
		<span class="n">pwr</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_write_pcdac_table() - Write the PCDAC values on hw</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ath5k_write_pcdac_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span>	<span class="o">*</span><span class="n">pcdac_out</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_pd_table</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write TX power values</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">AR5K_EEPROM_POWER_TABLE_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span>
			<span class="p">(((</span><span class="n">pcdac_out</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(((</span><span class="n">pcdac_out</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">),</span>
			<span class="n">AR5K_PHY_PCDAC_TXPOWER</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Power to PDADC table functions</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: Power to PDADC table functions</span>
<span class="cm"> *</span>
<span class="cm"> * For RF2413 and later we have a Power to PDADC table (Power Detector)</span>
<span class="cm"> * instead of a PCDAC (Power Control) and 4 pd gain curves for each</span>
<span class="cm"> * calibrated channel. Each curve has power on x axis in 0.5 db steps and</span>
<span class="cm"> * PDADC steps on y axis and looks like an exponential function like the</span>
<span class="cm"> * RF5111 curve.</span>
<span class="cm"> *</span>
<span class="cm"> * To recreate the curves we read the points from eeprom (eeprom.c)</span>
<span class="cm"> * and interpolate here. Note that in most cases only 2 (higher and lower)</span>
<span class="cm"> * curves are used (like RF5112) but vendors have the opportunity to include</span>
<span class="cm"> * all 4 curves on eeprom. The final curve (higher power) has an extra</span>
<span class="cm"> * point for better accuracy like RF5112.</span>
<span class="cm"> *</span>
<span class="cm"> * The process is similar to what we do above for RF5111/5112</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_combine_pwr_to_pdadc_curves() - Combine the various PDADC curves</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @pwr_min: Minimum power (x min)</span>
<span class="cm"> * @pwr_max: Maximum power (x max)</span>
<span class="cm"> * @pdcurves: Number of available curves</span>
<span class="cm"> *</span>
<span class="cm"> * Combine the various pd curves and create the final Power to PDADC table</span>
<span class="cm"> * We can have up to 4 pd curves, we need to do a similar process</span>
<span class="cm"> * as we do for RF5112. This time we don&#39;t have an edge_flag but we</span>
<span class="cm"> * set the gain boundaries on a separate register.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ath5k_combine_pwr_to_pdadc_curves</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span>
			<span class="n">s16</span> <span class="o">*</span><span class="n">pwr_min</span><span class="p">,</span> <span class="n">s16</span> <span class="o">*</span><span class="n">pwr_max</span><span class="p">,</span> <span class="n">u8</span> <span class="n">pdcurves</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">gain_boundaries</span><span class="p">[</span><span class="n">AR5K_EEPROM_N_PD_GAINS</span><span class="p">];</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">pdadc_out</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_pd_table</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">pdadc_tmp</span><span class="p">;</span>
	<span class="n">s16</span> <span class="n">pdadc_0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pdadc_i</span><span class="p">,</span> <span class="n">pdadc_n</span><span class="p">,</span> <span class="n">pwr_step</span><span class="p">,</span> <span class="n">pdg</span><span class="p">,</span> <span class="n">max_idx</span><span class="p">,</span> <span class="n">table_size</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pd_gain_overlap</span><span class="p">;</span>

	<span class="cm">/* Note: Register value is initialized on initvals</span>
<span class="cm">	 * there is no feedback from hw.</span>
<span class="cm">	 * XXX: What about pd_gain_overlap from EEPROM ? */</span>
	<span class="n">pd_gain_overlap</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_TPC_RG5</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="n">AR5K_PHY_TPC_RG5_PD_GAIN_OVERLAP</span><span class="p">;</span>

	<span class="cm">/* Create final PDADC table */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pdg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pdadc_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pdg</span> <span class="o">&lt;</span> <span class="n">pdcurves</span><span class="p">;</span> <span class="n">pdg</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pdadc_tmp</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">tmpL</span><span class="p">[</span><span class="n">pdg</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pdg</span> <span class="o">==</span> <span class="n">pdcurves</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="cm">/* 2 dB boundary stretch for last</span>
<span class="cm">			 * (higher power) curve */</span>
			<span class="n">gain_boundaries</span><span class="p">[</span><span class="n">pdg</span><span class="p">]</span> <span class="o">=</span> <span class="n">pwr_max</span><span class="p">[</span><span class="n">pdg</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="cm">/* Set gain boundary in the middle</span>
<span class="cm">			 * between this curve and the next one */</span>
			<span class="n">gain_boundaries</span><span class="p">[</span><span class="n">pdg</span><span class="p">]</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">pwr_max</span><span class="p">[</span><span class="n">pdg</span><span class="p">]</span> <span class="o">+</span> <span class="n">pwr_min</span><span class="p">[</span><span class="n">pdg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

		<span class="cm">/* Sanity check in case our 2 db stretch got out of</span>
<span class="cm">		 * range. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gain_boundaries</span><span class="p">[</span><span class="n">pdg</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">AR5K_TUNE_MAX_TXPOWER</span><span class="p">)</span>
			<span class="n">gain_boundaries</span><span class="p">[</span><span class="n">pdg</span><span class="p">]</span> <span class="o">=</span> <span class="n">AR5K_TUNE_MAX_TXPOWER</span><span class="p">;</span>

		<span class="cm">/* For the first curve (lower power)</span>
<span class="cm">		 * start from 0 dB */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdg</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">pdadc_0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="cm">/* For the other curves use the gain overlap */</span>
			<span class="n">pdadc_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">gain_boundaries</span><span class="p">[</span><span class="n">pdg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pwr_min</span><span class="p">[</span><span class="n">pdg</span><span class="p">])</span> <span class="o">-</span>
							<span class="n">pd_gain_overlap</span><span class="p">;</span>

		<span class="cm">/* Force each power step to be at least 0.5 dB */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">pdadc_tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pdadc_tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">pwr_step</span> <span class="o">=</span> <span class="n">pdadc_tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pdadc_tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">else</span>
			<span class="n">pwr_step</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* If pdadc_0 is negative, we need to extrapolate</span>
<span class="cm">		 * below this pdgain by a number of pwr_steps */</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">pdadc_0</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pdadc_i</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">s16</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">pdadc_tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">pdadc_0</span> <span class="o">*</span> <span class="n">pwr_step</span><span class="p">;</span>
			<span class="n">pdadc_out</span><span class="p">[</span><span class="n">pdadc_i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="n">pdadc_0</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Set last pwr level, using gain boundaries */</span>
		<span class="n">pdadc_n</span> <span class="o">=</span> <span class="n">gain_boundaries</span><span class="p">[</span><span class="n">pdg</span><span class="p">]</span> <span class="o">+</span> <span class="n">pd_gain_overlap</span> <span class="o">-</span> <span class="n">pwr_min</span><span class="p">[</span><span class="n">pdg</span><span class="p">];</span>
		<span class="cm">/* Limit it to be inside pwr range */</span>
		<span class="n">table_size</span> <span class="o">=</span> <span class="n">pwr_max</span><span class="p">[</span><span class="n">pdg</span><span class="p">]</span> <span class="o">-</span> <span class="n">pwr_min</span><span class="p">[</span><span class="n">pdg</span><span class="p">];</span>
		<span class="n">max_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">pdadc_n</span> <span class="o">&lt;</span> <span class="n">table_size</span><span class="p">)</span> <span class="o">?</span> <span class="n">pdadc_n</span> <span class="o">:</span> <span class="n">table_size</span><span class="p">;</span>

		<span class="cm">/* Fill pdadc_out table */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">pdadc_0</span> <span class="o">&lt;</span> <span class="n">max_idx</span> <span class="o">&amp;&amp;</span> <span class="n">pdadc_i</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">)</span>
			<span class="n">pdadc_out</span><span class="p">[</span><span class="n">pdadc_i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdadc_tmp</span><span class="p">[</span><span class="n">pdadc_0</span><span class="o">++</span><span class="p">];</span>

		<span class="cm">/* Need to extrapolate above this pdgain? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdadc_n</span> <span class="o">&lt;=</span> <span class="n">max_idx</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Force each power step to be at least 0.5 dB */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">pdadc_tmp</span><span class="p">[</span><span class="n">table_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pdadc_tmp</span><span class="p">[</span><span class="n">table_size</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">pwr_step</span> <span class="o">=</span> <span class="n">pdadc_tmp</span><span class="p">[</span><span class="n">table_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span>
						<span class="n">pdadc_tmp</span><span class="p">[</span><span class="n">table_size</span> <span class="o">-</span> <span class="mi">2</span><span class="p">];</span>
		<span class="k">else</span>
			<span class="n">pwr_step</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Extrapolate above */</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">pdadc_0</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">s16</span><span class="p">)</span> <span class="n">pdadc_n</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">pdadc_i</span> <span class="o">&lt;</span> <span class="n">AR5K_EEPROM_POWER_TABLE_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">s16</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">pdadc_tmp</span><span class="p">[</span><span class="n">table_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
					<span class="p">(</span><span class="n">pdadc_0</span> <span class="o">-</span> <span class="n">max_idx</span><span class="p">)</span> <span class="o">*</span> <span class="n">pwr_step</span><span class="p">;</span>
			<span class="n">pdadc_out</span><span class="p">[</span><span class="n">pdadc_i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="mi">127</span><span class="p">)</span> <span class="o">?</span> <span class="mi">127</span> <span class="o">:</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="n">pdadc_0</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">pdg</span> <span class="o">&lt;</span> <span class="n">AR5K_EEPROM_N_PD_GAINS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gain_boundaries</span><span class="p">[</span><span class="n">pdg</span><span class="p">]</span> <span class="o">=</span> <span class="n">gain_boundaries</span><span class="p">[</span><span class="n">pdg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
		<span class="n">pdg</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">pdadc_i</span> <span class="o">&lt;</span> <span class="n">AR5K_EEPROM_POWER_TABLE_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pdadc_out</span><span class="p">[</span><span class="n">pdadc_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdadc_out</span><span class="p">[</span><span class="n">pdadc_i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
		<span class="n">pdadc_i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set gain boundaries */</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span>
		<span class="n">AR5K_REG_SM</span><span class="p">(</span><span class="n">pd_gain_overlap</span><span class="p">,</span>
			<span class="n">AR5K_PHY_TPC_RG5_PD_GAIN_OVERLAP</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">AR5K_REG_SM</span><span class="p">(</span><span class="n">gain_boundaries</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			<span class="n">AR5K_PHY_TPC_RG5_PD_GAIN_BOUNDARY_1</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">AR5K_REG_SM</span><span class="p">(</span><span class="n">gain_boundaries</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
			<span class="n">AR5K_PHY_TPC_RG5_PD_GAIN_BOUNDARY_2</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">AR5K_REG_SM</span><span class="p">(</span><span class="n">gain_boundaries</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
			<span class="n">AR5K_PHY_TPC_RG5_PD_GAIN_BOUNDARY_3</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">AR5K_REG_SM</span><span class="p">(</span><span class="n">gain_boundaries</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
			<span class="n">AR5K_PHY_TPC_RG5_PD_GAIN_BOUNDARY_4</span><span class="p">),</span>
		<span class="n">AR5K_PHY_TPC_RG5</span><span class="p">);</span>

	<span class="cm">/* Used for setting rate power table */</span>
	<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_min_idx</span> <span class="o">=</span> <span class="n">pwr_min</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_write_pwr_to_pdadc_table() - Write the PDADC values on hw</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @ee_mode: One of enum ath5k_driver_mode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ath5k_write_pwr_to_pdadc_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ee_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ath5k_eeprom_info</span> <span class="o">*</span><span class="n">ee</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_capabilities</span><span class="p">.</span><span class="n">cap_eeprom</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">pdadc_out</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_pd_table</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">pdg_to_idx</span> <span class="o">=</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_pdc_to_idx</span><span class="p">[</span><span class="n">ee_mode</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">pdcurves</span> <span class="o">=</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_pd_gains</span><span class="p">[</span><span class="n">ee_mode</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Select the right pdgain curves */</span>

	<span class="cm">/* Clear current settings */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_TPC_RG1</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">AR5K_PHY_TPC_RG1_PDGAIN_1</span> <span class="o">|</span>
		<span class="n">AR5K_PHY_TPC_RG1_PDGAIN_2</span> <span class="o">|</span>
		<span class="n">AR5K_PHY_TPC_RG1_PDGAIN_3</span> <span class="o">|</span>
		<span class="n">AR5K_PHY_TPC_RG1_NUM_PD_GAIN</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use pd_gains curve from eeprom</span>
<span class="cm">	 *</span>
<span class="cm">	 * This overrides the default setting from initvals</span>
<span class="cm">	 * in case some vendors (e.g. Zcomax) don&#39;t use the default</span>
<span class="cm">	 * curves. If we don&#39;t honor their settings we &#39;ll get a</span>
<span class="cm">	 * 5dB (1 * gain overlap ?) drop.</span>
<span class="cm">	 */</span>
	<span class="n">reg</span> <span class="o">|=</span> <span class="n">AR5K_REG_SM</span><span class="p">(</span><span class="n">pdcurves</span><span class="p">,</span> <span class="n">AR5K_PHY_TPC_RG1_NUM_PD_GAIN</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">pdcurves</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">reg</span> <span class="o">|=</span> <span class="n">AR5K_REG_SM</span><span class="p">(</span><span class="n">pdg_to_idx</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">AR5K_PHY_TPC_RG1_PDGAIN_3</span><span class="p">);</span>
		<span class="cm">/* Fall through */</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">reg</span> <span class="o">|=</span> <span class="n">AR5K_REG_SM</span><span class="p">(</span><span class="n">pdg_to_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">AR5K_PHY_TPC_RG1_PDGAIN_2</span><span class="p">);</span>
		<span class="cm">/* Fall through */</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">reg</span> <span class="o">|=</span> <span class="n">AR5K_REG_SM</span><span class="p">(</span><span class="n">pdg_to_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">AR5K_PHY_TPC_RG1_PDGAIN_1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">AR5K_PHY_TPC_RG1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write TX power values</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">AR5K_EEPROM_POWER_TABLE_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">val</span> <span class="o">=</span> <span class="n">get_unaligned_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdadc_out</span><span class="p">[</span><span class="mi">4</span> <span class="o">*</span> <span class="n">i</span><span class="p">]);</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">AR5K_PHY_PDADC_TXPOWER</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Common code for PCDAC/PDADC tables</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_setup_channel_powertable() - Set up power table for this channel</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @channel: The &amp;struct ieee80211_channel</span>
<span class="cm"> * @ee_mode: One of enum ath5k_driver_mode</span>
<span class="cm"> * @type: One of enum ath5k_powertable_type (eeprom.h)</span>
<span class="cm"> *</span>
<span class="cm"> * This is the main function that uses all of the above</span>
<span class="cm"> * to set PCDAC/PDADC table on hw for the current channel.</span>
<span class="cm"> * This table is used for tx power calibration on the baseband,</span>
<span class="cm"> * without it we get weird tx power levels and in some cases</span>
<span class="cm"> * distorted spectral mask</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ath5k_setup_channel_powertable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
			<span class="n">u8</span> <span class="n">ee_mode</span><span class="p">,</span> <span class="n">u8</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ath5k_pdgain_info</span> <span class="o">*</span><span class="n">pdg_L</span><span class="p">,</span> <span class="o">*</span><span class="n">pdg_R</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ath5k_chan_pcal_info</span> <span class="o">*</span><span class="n">pcinfo_L</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ath5k_chan_pcal_info</span> <span class="o">*</span><span class="n">pcinfo_R</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ath5k_eeprom_info</span> <span class="o">*</span><span class="n">ee</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_capabilities</span><span class="p">.</span><span class="n">cap_eeprom</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">pdg_curve_to_idx</span> <span class="o">=</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_pdc_to_idx</span><span class="p">[</span><span class="n">ee_mode</span><span class="p">];</span>
	<span class="n">s16</span> <span class="n">table_min</span><span class="p">[</span><span class="n">AR5K_EEPROM_N_PD_GAINS</span><span class="p">];</span>
	<span class="n">s16</span> <span class="n">table_max</span><span class="p">[</span><span class="n">AR5K_EEPROM_N_PD_GAINS</span><span class="p">];</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">tmpL</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">tmpR</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">target</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pdg</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Get surrounding freq piers for this channel */</span>
	<span class="n">ath5k_get_chan_pcal_surrounding_piers</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">pcinfo_L</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">pcinfo_R</span><span class="p">);</span>

	<span class="cm">/* Loop over pd gain curves on</span>
<span class="cm">	 * surrounding freq piers by index */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pdg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pdg</span> <span class="o">&lt;</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_pd_gains</span><span class="p">[</span><span class="n">ee_mode</span><span class="p">];</span> <span class="n">pdg</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Fill curves in reverse order</span>
<span class="cm">		 * from lower power (max gain)</span>
<span class="cm">		 * to higher power. Use curve -&gt; idx</span>
<span class="cm">		 * backmapping we did on eeprom init */</span>
		<span class="n">u8</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">pdg_curve_to_idx</span><span class="p">[</span><span class="n">pdg</span><span class="p">];</span>

		<span class="cm">/* Grab the needed curves by index */</span>
		<span class="n">pdg_L</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pcinfo_L</span><span class="o">-&gt;</span><span class="n">pd_curves</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
		<span class="n">pdg_R</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pcinfo_R</span><span class="o">-&gt;</span><span class="n">pd_curves</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>

		<span class="cm">/* Initialize the temp tables */</span>
		<span class="n">tmpL</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">tmpL</span><span class="p">[</span><span class="n">pdg</span><span class="p">];</span>
		<span class="n">tmpR</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">tmpR</span><span class="p">[</span><span class="n">pdg</span><span class="p">];</span>

		<span class="cm">/* Set curve&#39;s x boundaries and create</span>
<span class="cm">		 * curves so that they cover the same</span>
<span class="cm">		 * range (if we don&#39;t do that one table</span>
<span class="cm">		 * will have values on some range and the</span>
<span class="cm">		 * other one won&#39;t have any so interpolation</span>
<span class="cm">		 * will fail) */</span>
		<span class="n">table_min</span><span class="p">[</span><span class="n">pdg</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">pdg_L</span><span class="o">-&gt;</span><span class="n">pd_pwr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					<span class="n">pdg_R</span><span class="o">-&gt;</span><span class="n">pd_pwr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

		<span class="n">table_max</span><span class="p">[</span><span class="n">pdg</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">pdg_L</span><span class="o">-&gt;</span><span class="n">pd_pwr</span><span class="p">[</span><span class="n">pdg_L</span><span class="o">-&gt;</span><span class="n">pd_points</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
				<span class="n">pdg_R</span><span class="o">-&gt;</span><span class="n">pd_pwr</span><span class="p">[</span><span class="n">pdg_R</span><span class="o">-&gt;</span><span class="n">pd_points</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

		<span class="cm">/* Now create the curves on surrounding channels</span>
<span class="cm">		 * and interpolate if needed to get the final</span>
<span class="cm">		 * curve for this gain on this channel */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">AR5K_PWRTABLE_LINEAR_PCDAC</span>:
			<span class="cm">/* Override min/max so that we don&#39;t loose</span>
<span class="cm">			 * accuracy (don&#39;t divide by 2) */</span>
			<span class="n">table_min</span><span class="p">[</span><span class="n">pdg</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">pdg_L</span><span class="o">-&gt;</span><span class="n">pd_pwr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
						<span class="n">pdg_R</span><span class="o">-&gt;</span><span class="n">pd_pwr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

			<span class="n">table_max</span><span class="p">[</span><span class="n">pdg</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">max</span><span class="p">(</span><span class="n">pdg_L</span><span class="o">-&gt;</span><span class="n">pd_pwr</span><span class="p">[</span><span class="n">pdg_L</span><span class="o">-&gt;</span><span class="n">pd_points</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
					<span class="n">pdg_R</span><span class="o">-&gt;</span><span class="n">pd_pwr</span><span class="p">[</span><span class="n">pdg_R</span><span class="o">-&gt;</span><span class="n">pd_points</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>

			<span class="cm">/* Override minimum so that we don&#39;t get</span>
<span class="cm">			 * out of bounds while extrapolating</span>
<span class="cm">			 * below. Don&#39;t do this when we have 2</span>
<span class="cm">			 * curves and we are on the high power curve</span>
<span class="cm">			 * because table_min is ok in this case */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_pd_gains</span><span class="p">[</span><span class="n">ee_mode</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">pdg</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>

				<span class="n">table_min</span><span class="p">[</span><span class="n">pdg</span><span class="p">]</span> <span class="o">=</span>
					<span class="n">ath5k_get_linear_pcdac_min</span><span class="p">(</span><span class="n">pdg_L</span><span class="o">-&gt;</span><span class="n">pd_step</span><span class="p">,</span>
								<span class="n">pdg_R</span><span class="o">-&gt;</span><span class="n">pd_step</span><span class="p">,</span>
								<span class="n">pdg_L</span><span class="o">-&gt;</span><span class="n">pd_pwr</span><span class="p">,</span>
								<span class="n">pdg_R</span><span class="o">-&gt;</span><span class="n">pd_pwr</span><span class="p">);</span>

				<span class="cm">/* Don&#39;t go too low because we will</span>
<span class="cm">				 * miss the upper part of the curve.</span>
<span class="cm">				 * Note: 126 = 31.5dB (max power supported)</span>
<span class="cm">				 * in 0.25dB units */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">table_max</span><span class="p">[</span><span class="n">pdg</span><span class="p">]</span> <span class="o">-</span> <span class="n">table_min</span><span class="p">[</span><span class="n">pdg</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">126</span><span class="p">)</span>
					<span class="n">table_min</span><span class="p">[</span><span class="n">pdg</span><span class="p">]</span> <span class="o">=</span> <span class="n">table_max</span><span class="p">[</span><span class="n">pdg</span><span class="p">]</span> <span class="o">-</span> <span class="mi">126</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Fall through */</span>
		<span class="k">case</span> <span class="n">AR5K_PWRTABLE_PWR_TO_PCDAC</span>:
		<span class="k">case</span> <span class="n">AR5K_PWRTABLE_PWR_TO_PDADC</span>:

			<span class="n">ath5k_create_power_curve</span><span class="p">(</span><span class="n">table_min</span><span class="p">[</span><span class="n">pdg</span><span class="p">],</span>
						<span class="n">table_max</span><span class="p">[</span><span class="n">pdg</span><span class="p">],</span>
						<span class="n">pdg_L</span><span class="o">-&gt;</span><span class="n">pd_pwr</span><span class="p">,</span>
						<span class="n">pdg_L</span><span class="o">-&gt;</span><span class="n">pd_step</span><span class="p">,</span>
						<span class="n">pdg_L</span><span class="o">-&gt;</span><span class="n">pd_points</span><span class="p">,</span> <span class="n">tmpL</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>

			<span class="cm">/* We are in a calibration</span>
<span class="cm">			 * pier, no need to interpolate</span>
<span class="cm">			 * between freq piers */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pcinfo_L</span> <span class="o">==</span> <span class="n">pcinfo_R</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">ath5k_create_power_curve</span><span class="p">(</span><span class="n">table_min</span><span class="p">[</span><span class="n">pdg</span><span class="p">],</span>
						<span class="n">table_max</span><span class="p">[</span><span class="n">pdg</span><span class="p">],</span>
						<span class="n">pdg_R</span><span class="o">-&gt;</span><span class="n">pd_pwr</span><span class="p">,</span>
						<span class="n">pdg_R</span><span class="o">-&gt;</span><span class="n">pd_step</span><span class="p">,</span>
						<span class="n">pdg_R</span><span class="o">-&gt;</span><span class="n">pd_points</span><span class="p">,</span> <span class="n">tmpR</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Interpolate between curves</span>
<span class="cm">		 * of surrounding freq piers to</span>
<span class="cm">		 * get the final curve for this</span>
<span class="cm">		 * pd gain. Re-use tmpL for interpolation</span>
<span class="cm">		 * output */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="p">(</span><span class="n">table_max</span><span class="p">[</span><span class="n">pdg</span><span class="p">]</span> <span class="o">-</span> <span class="n">table_min</span><span class="p">[</span><span class="n">pdg</span><span class="p">]))</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">AR5K_EEPROM_POWER_TABLE_SIZE</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmpL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">ath5k_get_interpolated_value</span><span class="p">(</span><span class="n">target</span><span class="p">,</span>
							<span class="p">(</span><span class="n">s16</span><span class="p">)</span> <span class="n">pcinfo_L</span><span class="o">-&gt;</span><span class="n">freq</span><span class="p">,</span>
							<span class="p">(</span><span class="n">s16</span><span class="p">)</span> <span class="n">pcinfo_R</span><span class="o">-&gt;</span><span class="n">freq</span><span class="p">,</span>
							<span class="p">(</span><span class="n">s16</span><span class="p">)</span> <span class="n">tmpL</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
							<span class="p">(</span><span class="n">s16</span><span class="p">)</span> <span class="n">tmpR</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Now we have a set of curves for this</span>
<span class="cm">	 * channel on tmpL (x range is table_max - table_min</span>
<span class="cm">	 * and y values are tmpL[pdg][]) sorted in the same</span>
<span class="cm">	 * order as EEPROM (because we&#39;ve used the backmapping).</span>
<span class="cm">	 * So for RF5112 it&#39;s from higher power to lower power</span>
<span class="cm">	 * and for RF2413 it&#39;s from lower power to higher power.</span>
<span class="cm">	 * For RF5111 we only have one curve. */</span>

	<span class="cm">/* Fill min and max power levels for this</span>
<span class="cm">	 * channel by interpolating the values on</span>
<span class="cm">	 * surrounding channels to complete the dataset */</span>
	<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_min_pwr</span> <span class="o">=</span> <span class="n">ath5k_get_interpolated_value</span><span class="p">(</span><span class="n">target</span><span class="p">,</span>
					<span class="p">(</span><span class="n">s16</span><span class="p">)</span> <span class="n">pcinfo_L</span><span class="o">-&gt;</span><span class="n">freq</span><span class="p">,</span>
					<span class="p">(</span><span class="n">s16</span><span class="p">)</span> <span class="n">pcinfo_R</span><span class="o">-&gt;</span><span class="n">freq</span><span class="p">,</span>
					<span class="n">pcinfo_L</span><span class="o">-&gt;</span><span class="n">min_pwr</span><span class="p">,</span> <span class="n">pcinfo_R</span><span class="o">-&gt;</span><span class="n">min_pwr</span><span class="p">);</span>

	<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_max_pwr</span> <span class="o">=</span> <span class="n">ath5k_get_interpolated_value</span><span class="p">(</span><span class="n">target</span><span class="p">,</span>
					<span class="p">(</span><span class="n">s16</span><span class="p">)</span> <span class="n">pcinfo_L</span><span class="o">-&gt;</span><span class="n">freq</span><span class="p">,</span>
					<span class="p">(</span><span class="n">s16</span><span class="p">)</span> <span class="n">pcinfo_R</span><span class="o">-&gt;</span><span class="n">freq</span><span class="p">,</span>
					<span class="n">pcinfo_L</span><span class="o">-&gt;</span><span class="n">max_pwr</span><span class="p">,</span> <span class="n">pcinfo_R</span><span class="o">-&gt;</span><span class="n">max_pwr</span><span class="p">);</span>

	<span class="cm">/* Fill PCDAC/PDADC table */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AR5K_PWRTABLE_LINEAR_PCDAC</span>:
		<span class="cm">/* For RF5112 we can have one or two curves</span>
<span class="cm">		 * and each curve covers a certain power lvl</span>
<span class="cm">		 * range so we need to do some more processing */</span>
		<span class="n">ath5k_combine_linear_pcdac_curves</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">table_min</span><span class="p">,</span> <span class="n">table_max</span><span class="p">,</span>
						<span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_pd_gains</span><span class="p">[</span><span class="n">ee_mode</span><span class="p">]);</span>

		<span class="cm">/* Set txp.offset so that we can</span>
<span class="cm">		 * match max power value with max</span>
<span class="cm">		 * table index */</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_offset</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">-</span> <span class="p">(</span><span class="n">table_max</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_PWRTABLE_PWR_TO_PCDAC</span>:
		<span class="cm">/* We are done for RF5111 since it has only</span>
<span class="cm">		 * one curve, just fit the curve on the table */</span>
		<span class="n">ath5k_fill_pwr_to_pcdac_table</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">table_min</span><span class="p">,</span> <span class="n">table_max</span><span class="p">);</span>

		<span class="cm">/* No rate powertable adjustment for RF5111 */</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_min_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_PWRTABLE_PWR_TO_PDADC</span>:
		<span class="cm">/* Set PDADC boundaries and fill</span>
<span class="cm">		 * final PDADC table */</span>
		<span class="n">ath5k_combine_pwr_to_pdadc_curves</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">table_min</span><span class="p">,</span> <span class="n">table_max</span><span class="p">,</span>
						<span class="n">ee</span><span class="o">-&gt;</span><span class="n">ee_pd_gains</span><span class="p">[</span><span class="n">ee_mode</span><span class="p">]);</span>

		<span class="cm">/* Set txp.offset, note that table_min</span>
<span class="cm">		 * can be negative */</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_offset</span> <span class="o">=</span> <span class="n">table_min</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_setup</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_write_channel_powertable() - Set power table for current channel on hw</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @ee_mode: One of enum ath5k_driver_mode</span>
<span class="cm"> * @type: One of enum ath5k_powertable_type (eeprom.h)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ath5k_write_channel_powertable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ee_mode</span><span class="p">,</span> <span class="n">u8</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">AR5K_PWRTABLE_PWR_TO_PDADC</span><span class="p">)</span>
		<span class="n">ath5k_write_pwr_to_pdadc_table</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ee_mode</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ath5k_write_pcdac_table</span><span class="p">(</span><span class="n">ah</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * DOC: Per-rate tx power setting</span>
<span class="cm"> *</span>
<span class="cm"> * This is the code that sets the desired tx power limit (below</span>
<span class="cm"> * maximum) on hw for each rate (we also have TPC that sets</span>
<span class="cm"> * power per packet type). We do that by providing an index on the</span>
<span class="cm"> * PCDAC/PDADC table we set up above, for each rate.</span>
<span class="cm"> *</span>
<span class="cm"> * For now we only limit txpower based on maximum tx power</span>
<span class="cm"> * supported by hw (what&#39;s inside rate_info) + conformance test</span>
<span class="cm"> * limits. We need to limit this even more, based on regulatory domain</span>
<span class="cm"> * etc to be safe. Normally this is done from above so we don&#39;t care</span>
<span class="cm"> * here, all we care is that the tx power we set will be O.K.</span>
<span class="cm"> * for the hw (e.g. won&#39;t create noise on PA etc).</span>
<span class="cm"> *</span>
<span class="cm"> * Rate power table contains indices to PCDAC/PDADC table (0.5dB steps -</span>
<span class="cm"> * x values) and is indexed as follows:</span>
<span class="cm"> * rates[0] - rates[7] -&gt; OFDM rates</span>
<span class="cm"> * rates[8] - rates[14] -&gt; CCK rates</span>
<span class="cm"> * rates[15] -&gt; XR rates (they all have the same power)</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_setup_rate_powertable() - Set up rate power table for a given tx power</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @max_pwr: The maximum tx power requested in 0.5dB steps</span>
<span class="cm"> * @rate_info: The &amp;struct ath5k_rate_pcal_info to fill</span>
<span class="cm"> * @ee_mode: One of enum ath5k_driver_mode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ath5k_setup_rate_powertable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u16</span> <span class="n">max_pwr</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ath5k_rate_pcal_info</span> <span class="o">*</span><span class="n">rate_info</span><span class="p">,</span>
			<span class="n">u8</span> <span class="n">ee_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">rates</span><span class="p">;</span>

	<span class="cm">/* max_pwr is power level we got from driver/user in 0.5dB</span>
<span class="cm">	 * units, switch to 0.25dB units so we can compare */</span>
	<span class="n">max_pwr</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">max_pwr</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">max_pwr</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_max_pwr</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* apply rate limits */</span>
	<span class="n">rates</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_rates_power_table</span><span class="p">;</span>

	<span class="cm">/* OFDM rates 6 to 24Mb/s */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">rates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">max_pwr</span><span class="p">,</span> <span class="n">rate_info</span><span class="o">-&gt;</span><span class="n">target_power_6to24</span><span class="p">);</span>

	<span class="cm">/* Rest OFDM rates */</span>
	<span class="n">rates</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">rates</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rate_info</span><span class="o">-&gt;</span><span class="n">target_power_36</span><span class="p">);</span>
	<span class="n">rates</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">rates</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rate_info</span><span class="o">-&gt;</span><span class="n">target_power_48</span><span class="p">);</span>
	<span class="n">rates</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">rates</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rate_info</span><span class="o">-&gt;</span><span class="n">target_power_54</span><span class="p">);</span>

	<span class="cm">/* CCK rates */</span>
	<span class="cm">/* 1L */</span>
	<span class="n">rates</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">rates</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rate_info</span><span class="o">-&gt;</span><span class="n">target_power_6to24</span><span class="p">);</span>
	<span class="cm">/* 2L */</span>
	<span class="n">rates</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">rates</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rate_info</span><span class="o">-&gt;</span><span class="n">target_power_36</span><span class="p">);</span>
	<span class="cm">/* 2S */</span>
	<span class="n">rates</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">rates</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rate_info</span><span class="o">-&gt;</span><span class="n">target_power_36</span><span class="p">);</span>
	<span class="cm">/* 5L */</span>
	<span class="n">rates</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">rates</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rate_info</span><span class="o">-&gt;</span><span class="n">target_power_48</span><span class="p">);</span>
	<span class="cm">/* 5S */</span>
	<span class="n">rates</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">rates</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rate_info</span><span class="o">-&gt;</span><span class="n">target_power_48</span><span class="p">);</span>
	<span class="cm">/* 11L */</span>
	<span class="n">rates</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">rates</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rate_info</span><span class="o">-&gt;</span><span class="n">target_power_54</span><span class="p">);</span>
	<span class="cm">/* 11S */</span>
	<span class="n">rates</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">rates</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rate_info</span><span class="o">-&gt;</span><span class="n">target_power_54</span><span class="p">);</span>

	<span class="cm">/* XR rates */</span>
	<span class="n">rates</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">rates</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rate_info</span><span class="o">-&gt;</span><span class="n">target_power_6to24</span><span class="p">);</span>

	<span class="cm">/* CCK rates have different peak to average ratio</span>
<span class="cm">	 * so we have to tweak their power so that gainf</span>
<span class="cm">	 * correction works ok. For this we use OFDM to</span>
<span class="cm">	 * CCK delta from eeprom */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ee_mode</span> <span class="o">==</span> <span class="n">AR5K_EEPROM_MODE_11G</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	<span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_phy_revision</span> <span class="o">&lt;</span> <span class="n">AR5K_SREV_PHY_5212A</span><span class="p">))</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">15</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">rates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_cck_ofdm_gainf_delta</span><span class="p">;</span>

	<span class="cm">/* Now that we have all rates setup use table offset to</span>
<span class="cm">	 * match the power range set by user with the power indices</span>
<span class="cm">	 * on PCDAC/PDADC table */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_offset</span><span class="p">;</span>
		<span class="cm">/* Don&#39;t get out of bounds */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">63</span><span class="p">)</span>
			<span class="n">rates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">63</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Min/max in 0.25dB units */</span>
	<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_min_pwr</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">rates</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
	<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_cur_pwr</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">rates</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_ofdm</span> <span class="o">=</span> <span class="n">rates</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_txpower() - Set transmission power limit for a given channel</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @channel: The &amp;struct ieee80211_channel</span>
<span class="cm"> * @txpower: Requested tx power in 0.5dB steps</span>
<span class="cm"> *</span>
<span class="cm"> * Combines all of the above to set the requested tx power limit</span>
<span class="cm"> * on hw.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ath5k_hw_txpower</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
		 <span class="n">u8</span> <span class="n">txpower</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ath5k_rate_pcal_info</span> <span class="n">rate_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">curr_channel</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_current_channel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ee_mode</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">txpower</span> <span class="o">&gt;</span> <span class="n">AR5K_TUNE_MAX_TXPOWER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ATH5K_ERR</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="s">&quot;invalid tx power: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">txpower</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ee_mode</span> <span class="o">=</span> <span class="n">ath5k_eeprom_mode_from_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ee_mode</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ATH5K_ERR</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span>
			<span class="s">&quot;invalid channel: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize TX power table */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AR5K_RF5110</span>:
		<span class="cm">/* TODO */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_RF5111</span>:
		<span class="n">type</span> <span class="o">=</span> <span class="n">AR5K_PWRTABLE_PWR_TO_PCDAC</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_RF5112</span>:
		<span class="n">type</span> <span class="o">=</span> <span class="n">AR5K_PWRTABLE_LINEAR_PCDAC</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_RF2413</span>:
	<span class="k">case</span> <span class="n">AR5K_RF5413</span>:
	<span class="k">case</span> <span class="n">AR5K_RF2316</span>:
	<span class="k">case</span> <span class="n">AR5K_RF2317</span>:
	<span class="k">case</span> <span class="n">AR5K_RF2425</span>:
		<span class="n">type</span> <span class="o">=</span> <span class="n">AR5K_PWRTABLE_PWR_TO_PDADC</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we don&#39;t change channel/mode skip tx powertable calculation</span>
<span class="cm">	 * and use the cached one.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_setup</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">hw_value</span> <span class="o">!=</span> <span class="n">curr_channel</span><span class="o">-&gt;</span><span class="n">hw_value</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span> <span class="o">!=</span> <span class="n">curr_channel</span><span class="o">-&gt;</span><span class="n">center_freq</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Reset TX power values */</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">));</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_tpc</span> <span class="o">=</span> <span class="n">AR5K_TUNE_TPC_TXPOWER</span><span class="p">;</span>

		<span class="cm">/* Calculate the powertable */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ath5k_setup_channel_powertable</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span>
							<span class="n">ee_mode</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Write table on hw */</span>
	<span class="n">ath5k_write_channel_powertable</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ee_mode</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>

	<span class="cm">/* Limit max power if we have a CTL available */</span>
	<span class="n">ath5k_get_max_ctl_power</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>

	<span class="cm">/* FIXME: Antenna reduction stuff */</span>

	<span class="cm">/* FIXME: Limit power on turbo modes */</span>

	<span class="cm">/* FIXME: TPC scale reduction */</span>

	<span class="cm">/* Get surrounding channels for per-rate power table</span>
<span class="cm">	 * calibration */</span>
	<span class="n">ath5k_get_rate_pcal_data</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rate_info</span><span class="p">);</span>

	<span class="cm">/* Setup rate power table */</span>
	<span class="n">ath5k_setup_rate_powertable</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">txpower</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rate_info</span><span class="p">,</span> <span class="n">ee_mode</span><span class="p">);</span>

	<span class="cm">/* Write rate power table on hw */</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_TXPOWER_OFDM</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">AR5K_TXPOWER_OFDM</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">AR5K_TXPOWER_OFDM</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">AR5K_TXPOWER_OFDM</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">AR5K_PHY_TXPOWER_RATE1</span><span class="p">);</span>

	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_TXPOWER_OFDM</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">AR5K_TXPOWER_OFDM</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">AR5K_TXPOWER_OFDM</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">AR5K_TXPOWER_OFDM</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">AR5K_PHY_TXPOWER_RATE2</span><span class="p">);</span>

	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_TXPOWER_CCK</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">AR5K_TXPOWER_CCK</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">AR5K_TXPOWER_CCK</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">AR5K_TXPOWER_CCK</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">AR5K_PHY_TXPOWER_RATE3</span><span class="p">);</span>

	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_TXPOWER_CCK</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">AR5K_TXPOWER_CCK</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">AR5K_TXPOWER_CCK</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">AR5K_TXPOWER_CCK</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">AR5K_PHY_TXPOWER_RATE4</span><span class="p">);</span>

	<span class="cm">/* FIXME: TPC support */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_tpc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_TXPOWER_RATE_MAX_TPC_ENABLE</span> <span class="o">|</span>
			<span class="n">AR5K_TUNE_MAX_TXPOWER</span><span class="p">,</span> <span class="n">AR5K_PHY_TXPOWER_RATE_MAX</span><span class="p">);</span>

		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span>
			<span class="n">AR5K_REG_MS</span><span class="p">(</span><span class="n">AR5K_TUNE_MAX_TXPOWER</span><span class="p">,</span> <span class="n">AR5K_TPC_ACK</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">AR5K_REG_MS</span><span class="p">(</span><span class="n">AR5K_TUNE_MAX_TXPOWER</span><span class="p">,</span> <span class="n">AR5K_TPC_CTS</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">AR5K_REG_MS</span><span class="p">(</span><span class="n">AR5K_TUNE_MAX_TXPOWER</span><span class="p">,</span> <span class="n">AR5K_TPC_CHIRP</span><span class="p">),</span>
			<span class="n">AR5K_TPC</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_TXPOWER_RATE_MAX</span> <span class="o">|</span>
			<span class="n">AR5K_TUNE_MAX_TXPOWER</span><span class="p">,</span> <span class="n">AR5K_PHY_TXPOWER_RATE_MAX</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_set_txpower_limit() - Set txpower limit for the current channel</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @txpower: The requested tx power limit in 0.5dB steps</span>
<span class="cm"> *</span>
<span class="cm"> * This function provides access to ath5k_hw_txpower to the driver in</span>
<span class="cm"> * case user or an application changes it while PHY is running.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">ath5k_hw_set_txpower_limit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u8</span> <span class="n">txpower</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ATH5K_DBG</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ATH5K_DEBUG_TXPOWER</span><span class="p">,</span>
		<span class="s">&quot;changing txpower to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">txpower</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ath5k_hw_txpower</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_current_channel</span><span class="p">,</span> <span class="n">txpower</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*************\</span>
<span class="cm"> Init function</span>
<span class="cm">\*************/</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_phy_init() - Initialize PHY</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @channel: The @struct ieee80211_channel</span>
<span class="cm"> * @mode: One of enum ath5k_driver_mode</span>
<span class="cm"> * @fast: Try a fast channel switch instead</span>
<span class="cm"> *</span>
<span class="cm"> * This is the main function used during reset to initialize PHY</span>
<span class="cm"> * or do a fast channel change if possible.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Do not call this one from the driver, it assumes PHY is in a</span>
<span class="cm"> * warm reset state !</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">ath5k_hw_phy_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
		      <span class="n">u8</span> <span class="n">mode</span><span class="p">,</span> <span class="n">bool</span> <span class="n">fast</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">curr_channel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">phy_tst1</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sanity check for fast flag</span>
<span class="cm">	 * Don&#39;t try fast channel change when changing modulation</span>
<span class="cm">	 * mode/band. We check for chip compatibility on</span>
<span class="cm">	 * ath5k_hw_reset.</span>
<span class="cm">	 */</span>
	<span class="n">curr_channel</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_current_channel</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fast</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">hw_value</span> <span class="o">!=</span> <span class="n">curr_channel</span><span class="o">-&gt;</span><span class="n">hw_value</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * On fast channel change we only set the synth parameters</span>
<span class="cm">	 * while PHY is running, enable calibration and skip the rest.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fast</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AR5K_REG_ENABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_RFBUS_REQ</span><span class="p">,</span>
				    <span class="n">AR5K_PHY_RFBUS_REQ_REQUEST</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_RFBUS_GRANT</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Failed */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">100</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

		<span class="cm">/* Set channel and wait for synth */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ath5k_hw_channel</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">ath5k_hw_wait_for_synth</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set TX power</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: We need to do that before we set</span>
<span class="cm">	 * RF buffer settings on 5211/5212+ so that we</span>
<span class="cm">	 * properly set curve indices.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ath5k_hw_txpower</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_cur_pwr</span> <span class="o">?</span>
			<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txpower</span><span class="p">.</span><span class="n">txp_cur_pwr</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">:</span> <span class="n">AR5K_TUNE_MAX_TXPOWER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Write OFDM timings on 5212*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5212</span> <span class="o">&amp;&amp;</span>
		<span class="n">channel</span><span class="o">-&gt;</span><span class="n">hw_value</span> <span class="o">!=</span> <span class="n">AR5K_MODE_11B</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">ath5k_hw_write_ofdm_timings</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="cm">/* Spur info is available only from EEPROM versions</span>
<span class="cm">		 * greater than 5.3, but the EEPROM routines will use</span>
<span class="cm">		 * static values for older versions */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_mac_srev</span> <span class="o">&gt;=</span> <span class="n">AR5K_SREV_AR5424</span><span class="p">)</span>
			<span class="n">ath5k_hw_set_spur_mitigation_filter</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span>
							    <span class="n">channel</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* If we used fast channel switching</span>
<span class="cm">	 * we are done, release RF bus and</span>
<span class="cm">	 * fire up NF calibration.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: Only NF calibration due to</span>
<span class="cm">	 * channel change, not AGC calibration</span>
<span class="cm">	 * since AGC is still running !</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fast</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Release RF Bus grant</span>
<span class="cm">		 */</span>
		<span class="n">AR5K_REG_DISABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_RFBUS_REQ</span><span class="p">,</span>
				    <span class="n">AR5K_PHY_RFBUS_REQ_REQUEST</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Start NF calibration</span>
<span class="cm">		 */</span>
		<span class="n">AR5K_REG_ENABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_AGCCTL</span><span class="p">,</span>
					<span class="n">AR5K_PHY_AGCCTL_NF</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * For 5210 we do all initialization using</span>
<span class="cm">	 * initvals, so we don&#39;t have to modify</span>
<span class="cm">	 * any settings (5210 also only supports</span>
<span class="cm">	 * a/aturbo modes)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">!=</span> <span class="n">AR5K_AR5210</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * Write initial RF gain settings</span>
<span class="cm">		 * This should work for both 5111/5112</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ath5k_hw_rfgain_init</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">band</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">usleep_range</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1500</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Write RF buffer</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ath5k_hw_rfregs_init</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="cm">/*Enable/disable 802.11b mode on 5111</span>
<span class="cm">		(enable 2111 frequency converter + CCK)*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_radio</span> <span class="o">==</span> <span class="n">AR5K_RF5111</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">AR5K_MODE_11B</span><span class="p">)</span>
				<span class="n">AR5K_REG_ENABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_TXCFG</span><span class="p">,</span>
				    <span class="n">AR5K_TXCFG_B_MODE</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">AR5K_REG_DISABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_TXCFG</span><span class="p">,</span>
				    <span class="n">AR5K_TXCFG_B_MODE</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5210</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usleep_range</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1500</span><span class="p">);</span>
		<span class="cm">/* Disable phy and wait */</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_ACT_DISABLE</span><span class="p">,</span> <span class="n">AR5K_PHY_ACT</span><span class="p">);</span>
		<span class="n">usleep_range</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1500</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Set channel on PHY */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ath5k_hw_channel</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enable the PHY and wait until completion</span>
<span class="cm">	 * This includes BaseBand and Synthesizer</span>
<span class="cm">	 * activation.</span>
<span class="cm">	 */</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_ACT_ENABLE</span><span class="p">,</span> <span class="n">AR5K_PHY_ACT</span><span class="p">);</span>

	<span class="n">ath5k_hw_wait_for_synth</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Perform ADC test to see if baseband is ready</span>
<span class="cm">	 * Set tx hold and check adc test register</span>
<span class="cm">	 */</span>
	<span class="n">phy_tst1</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_TST1</span><span class="p">);</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_TST1_TXHOLD</span><span class="p">,</span> <span class="n">AR5K_PHY_TST1</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_ADC_TEST</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">usleep_range</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">250</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">phy_tst1</span><span class="p">,</span> <span class="n">AR5K_PHY_TST1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start automatic gain control calibration</span>
<span class="cm">	 *</span>
<span class="cm">	 * During AGC calibration RX path is re-routed to</span>
<span class="cm">	 * a power detector so we don&#39;t receive anything.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This method is used to calibrate some static offsets</span>
<span class="cm">	 * used together with on-the fly I/Q calibration (the</span>
<span class="cm">	 * one performed via ath5k_hw_phy_calibrate), which doesn&#39;t</span>
<span class="cm">	 * interrupt rx path.</span>
<span class="cm">	 *</span>
<span class="cm">	 * While rx path is re-routed to the power detector we also</span>
<span class="cm">	 * start a noise floor calibration to measure the</span>
<span class="cm">	 * card&#39;s noise floor (the noise we measure when we are not</span>
<span class="cm">	 * transmitting or receiving anything).</span>
<span class="cm">	 *</span>
<span class="cm">	 * If we are in a noisy environment, AGC calibration may time</span>
<span class="cm">	 * out and/or noise floor calibration might timeout.</span>
<span class="cm">	 */</span>
	<span class="n">AR5K_REG_ENABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_AGCCTL</span><span class="p">,</span>
				<span class="n">AR5K_PHY_AGCCTL_CAL</span> <span class="o">|</span> <span class="n">AR5K_PHY_AGCCTL_NF</span><span class="p">);</span>

	<span class="cm">/* At the same time start I/Q calibration for QAM constellation</span>
<span class="cm">	 * -no need for CCK- */</span>
	<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_iq_cal_needed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">AR5K_MODE_11B</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_iq_cal_needed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">AR5K_REG_WRITE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_IQ</span><span class="p">,</span>
				<span class="n">AR5K_PHY_IQ_CAL_NUM_LOG_MAX</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>
		<span class="n">AR5K_REG_ENABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_IQ</span><span class="p">,</span>
				<span class="n">AR5K_PHY_IQ_RUN</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Wait for gain calibration to finish (we check for I/Q calibration</span>
<span class="cm">	 * during ath5k_phy_calibrate) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ath5k_hw_register_timeout</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_AGCCTL</span><span class="p">,</span>
			<span class="n">AR5K_PHY_AGCCTL_CAL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">false</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ATH5K_ERR</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="s">&quot;gain calibration timeout (%uMHz)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Restore antenna mode */</span>
	<span class="n">ath5k_hw_set_antenna_mode</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_ant_mode</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
