<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › ath › ath5k › dma.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>dma.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2004-2008 Reyk Floeter &lt;reyk@openbsd.org&gt;</span>
<span class="cm"> * Copyright (c) 2006-2008 Nick Kossifidis &lt;mickflemm@gmail.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Permission to use, copy, modify, and distribute this software for any</span>
<span class="cm"> * purpose with or without fee is hereby granted, provided that the above</span>
<span class="cm"> * copyright notice and this permission notice appear in all copies.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES</span>
<span class="cm"> * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR</span>
<span class="cm"> * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="cm"> * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="cm"> * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</span>
<span class="cm"> * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*************************************\</span>
<span class="cm">* DMA and interrupt masking functions *</span>
<span class="cm">\*************************************/</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: DMA and interrupt masking functions</span>
<span class="cm"> *</span>
<span class="cm"> * Here we setup descriptor pointers (rxdp/txdp) start/stop dma engine and</span>
<span class="cm"> * handle queue setup for 5210 chipset (rest are handled on qcu.c).</span>
<span class="cm"> * Also we setup interrupt mask register (IMR) and read the various interrupt</span>
<span class="cm"> * status registers (ISR).</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &quot;ath5k.h&quot;</span>
<span class="cp">#include &quot;reg.h&quot;</span>
<span class="cp">#include &quot;debug.h&quot;</span>


<span class="cm">/*********\</span>
<span class="cm">* Receive *</span>
<span class="cm">\*********/</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_start_rx_dma() - Start DMA receive</span>
<span class="cm"> * @ah:	The &amp;struct ath5k_hw</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ath5k_hw_start_rx_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_CR_RXE</span><span class="p">,</span> <span class="n">AR5K_CR</span><span class="p">);</span>
	<span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_CR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_stop_rx_dma() - Stop DMA receive</span>
<span class="cm"> * @ah:	The &amp;struct ath5k_hw</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ath5k_hw_stop_rx_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_CR_RXD</span><span class="p">,</span> <span class="n">AR5K_CR</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * It may take some time to disable the DMA receive unit</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_CR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">AR5K_CR_RXE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span>
		<span class="n">ATH5K_DBG</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ATH5K_DEBUG_DMA</span><span class="p">,</span>
				<span class="s">&quot;failed to stop RX DMA !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">i</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_get_rxdp() - Get RX Descriptor&#39;s address</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> */</span>
<span class="n">u32</span>
<span class="nf">ath5k_hw_get_rxdp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_RXDP</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_set_rxdp() - Set RX Descriptor&#39;s address</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @phys_addr: RX descriptor address</span>
<span class="cm"> *</span>
<span class="cm"> * Returns -EIO if rx is active</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">ath5k_hw_set_rxdp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u32</span> <span class="n">phys_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_CR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">AR5K_CR_RXE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ATH5K_DBG</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ATH5K_DEBUG_DMA</span><span class="p">,</span>
				<span class="s">&quot;tried to set RXDP while rx was active !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">phys_addr</span><span class="p">,</span> <span class="n">AR5K_RXDP</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**********\</span>
<span class="cm">* Transmit *</span>
<span class="cm">\**********/</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_start_tx_dma() - Start DMA transmit for a specific queue</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @queue: The hw queue number</span>
<span class="cm"> *</span>
<span class="cm"> * Start DMA transmit for a specific queue and since 5210 doesn&#39;t have</span>
<span class="cm"> * QCU/DCU, set up queue parameters for 5210 here based on queue type (one</span>
<span class="cm"> * queue for normal data and one queue for beacons). For queue setup</span>
<span class="cm"> * on newer chips check out qcu.c. Returns -EINVAL if queue number is out</span>
<span class="cm"> * of range or if queue is already disabled.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Must be called after setting up tx control descriptor for that</span>
<span class="cm"> * queue (see below).</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">ath5k_hw_start_tx_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tx_queue</span><span class="p">;</span>

	<span class="n">AR5K_ASSERT_ENTRY</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_capabilities</span><span class="p">.</span><span class="n">cap_queues</span><span class="p">.</span><span class="n">q_tx_num</span><span class="p">);</span>

	<span class="cm">/* Return if queue is declared inactive */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txq</span><span class="p">[</span><span class="n">queue</span><span class="p">].</span><span class="n">tqi_type</span> <span class="o">==</span> <span class="n">AR5K_TX_QUEUE_INACTIVE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5210</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tx_queue</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_CR</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Set the queue by type on 5210</span>
<span class="cm">		 */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txq</span><span class="p">[</span><span class="n">queue</span><span class="p">].</span><span class="n">tqi_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">AR5K_TX_QUEUE_DATA</span>:
			<span class="n">tx_queue</span> <span class="o">|=</span> <span class="n">AR5K_CR_TXE0</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">AR5K_CR_TXD0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AR5K_TX_QUEUE_BEACON</span>:
			<span class="n">tx_queue</span> <span class="o">|=</span> <span class="n">AR5K_CR_TXE1</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">AR5K_CR_TXD1</span><span class="p">;</span>
			<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_BCR_TQ1V</span> <span class="o">|</span> <span class="n">AR5K_BCR_BDMAE</span><span class="p">,</span>
					<span class="n">AR5K_BSR</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AR5K_TX_QUEUE_CAB</span>:
			<span class="n">tx_queue</span> <span class="o">|=</span> <span class="n">AR5K_CR_TXE1</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">AR5K_CR_TXD1</span><span class="p">;</span>
			<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_BCR_TQ1FV</span> <span class="o">|</span> <span class="n">AR5K_BCR_TQ1V</span> <span class="o">|</span>
				<span class="n">AR5K_BCR_BDMAE</span><span class="p">,</span> <span class="n">AR5K_BSR</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Start queue */</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">tx_queue</span><span class="p">,</span> <span class="n">AR5K_CR</span><span class="p">);</span>
		<span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_CR</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Return if queue is disabled */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">AR5K_REG_READ_Q</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_QCU_TXD</span><span class="p">,</span> <span class="n">queue</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

		<span class="cm">/* Start queue */</span>
		<span class="n">AR5K_REG_WRITE_Q</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_QCU_TXE</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_stop_tx_dma() - Stop DMA transmit on a specific queue</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @queue: The hw queue number</span>
<span class="cm"> *</span>
<span class="cm"> * Stop DMA transmit on a specific hw queue and drain queue so we don&#39;t</span>
<span class="cm"> * have any pending frames. Returns -EBUSY if we still have pending frames,</span>
<span class="cm"> * -EINVAL if queue number is out of range or inactive.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ath5k_hw_stop_tx_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx_queue</span><span class="p">,</span> <span class="n">pending</span><span class="p">;</span>

	<span class="n">AR5K_ASSERT_ENTRY</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_capabilities</span><span class="p">.</span><span class="n">cap_queues</span><span class="p">.</span><span class="n">q_tx_num</span><span class="p">);</span>

	<span class="cm">/* Return if queue is declared inactive */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txq</span><span class="p">[</span><span class="n">queue</span><span class="p">].</span><span class="n">tqi_type</span> <span class="o">==</span> <span class="n">AR5K_TX_QUEUE_INACTIVE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5210</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tx_queue</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_CR</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Set by queue type</span>
<span class="cm">		 */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txq</span><span class="p">[</span><span class="n">queue</span><span class="p">].</span><span class="n">tqi_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">AR5K_TX_QUEUE_DATA</span>:
			<span class="n">tx_queue</span> <span class="o">|=</span> <span class="n">AR5K_CR_TXD0</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">AR5K_CR_TXE0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AR5K_TX_QUEUE_BEACON</span>:
		<span class="k">case</span> <span class="n">AR5K_TX_QUEUE_CAB</span>:
			<span class="cm">/* XXX Fix me... */</span>
			<span class="n">tx_queue</span> <span class="o">|=</span> <span class="n">AR5K_CR_TXD1</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">AR5K_CR_TXD1</span><span class="p">;</span>
			<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AR5K_BSR</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Stop queue */</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">tx_queue</span><span class="p">,</span> <span class="n">AR5K_CR</span><span class="p">);</span>
		<span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_CR</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * Enable DCU early termination to quickly</span>
<span class="cm">		 * flush any pending frames from QCU</span>
<span class="cm">		 */</span>
		<span class="n">AR5K_REG_ENABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_QUEUE_MISC</span><span class="p">(</span><span class="n">queue</span><span class="p">),</span>
					<span class="n">AR5K_QCU_MISC_DCU_EARLY</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Schedule TX disable and wait until queue is empty</span>
<span class="cm">		 */</span>
		<span class="n">AR5K_REG_WRITE_Q</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_QCU_TXD</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>

		<span class="cm">/* Wait for queue to stop */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">AR5K_REG_READ_Q</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_QCU_TXE</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">i</span><span class="o">--</span><span class="p">)</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">AR5K_REG_READ_Q</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_QCU_TXE</span><span class="p">,</span> <span class="n">queue</span><span class="p">))</span>
			<span class="n">ATH5K_DBG</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ATH5K_DEBUG_DMA</span><span class="p">,</span>
				<span class="s">&quot;queue %i didn&#39;t stop !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>

		<span class="cm">/* Check for pending frames */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">pending</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span>
				<span class="n">AR5K_QUEUE_STATUS</span><span class="p">(</span><span class="n">queue</span><span class="p">))</span> <span class="o">&amp;</span>
				<span class="n">AR5K_QCU_STS_FRMPENDCNT</span><span class="p">;</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">pending</span><span class="p">);</span>

		<span class="cm">/* For 2413+ order PCU to drop packets using</span>
<span class="cm">		 * QUIET mechanism */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_mac_version</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">AR5K_SREV_AR2414</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">pending</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Set periodicity and duration */</span>
			<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span>
				<span class="n">AR5K_REG_SM</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">AR5K_QUIET_CTL2_QT_PER</span><span class="p">)</span><span class="o">|</span>
				<span class="n">AR5K_REG_SM</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">AR5K_QUIET_CTL2_QT_DUR</span><span class="p">),</span>
				<span class="n">AR5K_QUIET_CTL2</span><span class="p">);</span>

			<span class="cm">/* Enable quiet period for current TSF */</span>
			<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span>
				<span class="n">AR5K_QUIET_CTL1_QT_EN</span> <span class="o">|</span>
				<span class="n">AR5K_REG_SM</span><span class="p">(</span><span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span>
						<span class="n">AR5K_TSF_L32_5211</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span>
						<span class="n">AR5K_QUIET_CTL1_NEXT_QT_TSF</span><span class="p">),</span>
				<span class="n">AR5K_QUIET_CTL1</span><span class="p">);</span>

			<span class="cm">/* Force channel idle high */</span>
			<span class="n">AR5K_REG_ENABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_DIAG_SW_5211</span><span class="p">,</span>
					<span class="n">AR5K_DIAG_SW_CHANNEL_IDLE_HIGH</span><span class="p">);</span>

			<span class="cm">/* Wait a while and disable mechanism */</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">400</span><span class="p">);</span>
			<span class="n">AR5K_REG_DISABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_QUIET_CTL1</span><span class="p">,</span>
						<span class="n">AR5K_QUIET_CTL1_QT_EN</span><span class="p">);</span>

			<span class="cm">/* Re-check for pending frames */</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
			<span class="k">do</span> <span class="p">{</span>
				<span class="n">pending</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span>
					<span class="n">AR5K_QUEUE_STATUS</span><span class="p">(</span><span class="n">queue</span><span class="p">))</span> <span class="o">&amp;</span>
					<span class="n">AR5K_QCU_STS_FRMPENDCNT</span><span class="p">;</span>
				<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">pending</span><span class="p">);</span>

			<span class="n">AR5K_REG_DISABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_DIAG_SW_5211</span><span class="p">,</span>
					<span class="n">AR5K_DIAG_SW_CHANNEL_IDLE_HIGH</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">pending</span><span class="p">)</span>
				<span class="n">ATH5K_DBG</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ATH5K_DEBUG_DMA</span><span class="p">,</span>
					<span class="s">&quot;quiet mechanism didn&#39;t work q:%i !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">queue</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Disable DCU early termination</span>
<span class="cm">		 */</span>
		<span class="n">AR5K_REG_DISABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_QUEUE_MISC</span><span class="p">(</span><span class="n">queue</span><span class="p">),</span>
					<span class="n">AR5K_QCU_MISC_DCU_EARLY</span><span class="p">);</span>

		<span class="cm">/* Clear register */</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AR5K_QCU_TXD</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pending</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ATH5K_DBG</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ATH5K_DEBUG_DMA</span><span class="p">,</span>
					<span class="s">&quot;tx dma didn&#39;t stop (q:%i, frm:%i) !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">queue</span><span class="p">,</span> <span class="n">pending</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* TODO: Check for success on 5210 else return error */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_stop_beacon_queue() - Stop beacon queue</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @queue: The queue number</span>
<span class="cm"> *</span>
<span class="cm"> * Returns -EIO if queue didn&#39;t stop</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">ath5k_hw_stop_beacon_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ath5k_hw_stop_tx_dma</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ATH5K_DBG</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ATH5K_DEBUG_DMA</span><span class="p">,</span>
				<span class="s">&quot;beacon queue didn&#39;t stop !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_get_txdp() - Get TX Descriptor&#39;s address for a specific queue</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @queue: The hw queue number</span>
<span class="cm"> *</span>
<span class="cm"> * Get TX descriptor&#39;s address for a specific queue. For 5210 we ignore</span>
<span class="cm"> * the queue number and use tx queue type since we only have 2 queues.</span>
<span class="cm"> * We use TXDP0 for normal data queue and TXDP1 for beacon queue.</span>
<span class="cm"> * For newer chips with QCU/DCU we just read the corresponding TXDP register.</span>
<span class="cm"> *</span>
<span class="cm"> * XXX: Is TXDP read and clear ?</span>
<span class="cm"> */</span>
<span class="n">u32</span>
<span class="nf">ath5k_hw_get_txdp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">tx_reg</span><span class="p">;</span>

	<span class="n">AR5K_ASSERT_ENTRY</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_capabilities</span><span class="p">.</span><span class="n">cap_queues</span><span class="p">.</span><span class="n">q_tx_num</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the transmit queue descriptor pointer from the selected queue</span>
<span class="cm">	 */</span>
	<span class="cm">/*5210 doesn&#39;t have QCU*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5210</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txq</span><span class="p">[</span><span class="n">queue</span><span class="p">].</span><span class="n">tqi_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">AR5K_TX_QUEUE_DATA</span>:
			<span class="n">tx_reg</span> <span class="o">=</span> <span class="n">AR5K_NOQCU_TXDP0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AR5K_TX_QUEUE_BEACON</span>:
		<span class="k">case</span> <span class="n">AR5K_TX_QUEUE_CAB</span>:
			<span class="n">tx_reg</span> <span class="o">=</span> <span class="n">AR5K_NOQCU_TXDP1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="mh">0xffffffff</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tx_reg</span> <span class="o">=</span> <span class="n">AR5K_QUEUE_TXDP</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">tx_reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_set_txdp() - Set TX Descriptor&#39;s address for a specific queue</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @queue: The hw queue number</span>
<span class="cm"> * @phys_addr: The physical address</span>
<span class="cm"> *</span>
<span class="cm"> * Set TX descriptor&#39;s address for a specific queue. For 5210 we ignore</span>
<span class="cm"> * the queue number and we use tx queue type since we only have 2 queues</span>
<span class="cm"> * so as above we use TXDP0 for normal data queue and TXDP1 for beacon queue.</span>
<span class="cm"> * For newer chips with QCU/DCU we just set the corresponding TXDP register.</span>
<span class="cm"> * Returns -EINVAL if queue type is invalid for 5210 and -EIO if queue is still</span>
<span class="cm"> * active.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">ath5k_hw_set_txdp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">,</span> <span class="n">u32</span> <span class="n">phys_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">tx_reg</span><span class="p">;</span>

	<span class="n">AR5K_ASSERT_ENTRY</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_capabilities</span><span class="p">.</span><span class="n">cap_queues</span><span class="p">.</span><span class="n">q_tx_num</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the transmit queue descriptor pointer register by type</span>
<span class="cm">	 * on 5210</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5210</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txq</span><span class="p">[</span><span class="n">queue</span><span class="p">].</span><span class="n">tqi_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">AR5K_TX_QUEUE_DATA</span>:
			<span class="n">tx_reg</span> <span class="o">=</span> <span class="n">AR5K_NOQCU_TXDP0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AR5K_TX_QUEUE_BEACON</span>:
		<span class="k">case</span> <span class="n">AR5K_TX_QUEUE_CAB</span>:
			<span class="n">tx_reg</span> <span class="o">=</span> <span class="n">AR5K_NOQCU_TXDP1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set the transmit queue descriptor pointer for</span>
<span class="cm">		 * the selected queue on QCU for 5211+</span>
<span class="cm">		 * (this won&#39;t work if the queue is still active)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">AR5K_REG_READ_Q</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_QCU_TXE</span><span class="p">,</span> <span class="n">queue</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

		<span class="n">tx_reg</span> <span class="o">=</span> <span class="n">AR5K_QUEUE_TXDP</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Set descriptor pointer */</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">phys_addr</span><span class="p">,</span> <span class="n">tx_reg</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_update_tx_triglevel() - Update tx trigger level</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @increase: Flag to force increase of trigger level</span>
<span class="cm"> *</span>
<span class="cm"> * This function increases/decreases the tx trigger level for the tx fifo</span>
<span class="cm"> * buffer (aka FIFO threshold) that is used to indicate when PCU flushes</span>
<span class="cm"> * the buffer and transmits its data. Lowering this results sending small</span>
<span class="cm"> * frames more quickly but can lead to tx underruns, raising it a lot can</span>
<span class="cm"> * result other problems. Right now we start with the lowest possible</span>
<span class="cm"> * (64Bytes) and if we get tx underrun we increase it using the increase</span>
<span class="cm"> * flag. Returns -EIO if we have reached maximum/minimum.</span>
<span class="cm"> *</span>
<span class="cm"> * XXX: Link this with tx DMA size ?</span>
<span class="cm"> * XXX2: Use it to save interrupts ?</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">ath5k_hw_update_tx_triglevel</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">bool</span> <span class="n">increase</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">trigger_level</span><span class="p">,</span> <span class="n">imr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable interrupts by setting the mask</span>
<span class="cm">	 */</span>
	<span class="n">imr</span> <span class="o">=</span> <span class="n">ath5k_hw_set_imr</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_imr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">AR5K_INT_GLOBAL</span><span class="p">);</span>

	<span class="n">trigger_level</span> <span class="o">=</span> <span class="n">AR5K_REG_MS</span><span class="p">(</span><span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_TXCFG</span><span class="p">),</span>
			<span class="n">AR5K_TXCFG_TXFULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">increase</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">trigger_level</span> <span class="o">&lt;</span> <span class="n">AR5K_TUNE_MIN_TX_FIFO_THRES</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">trigger_level</span> <span class="o">+=</span>
			<span class="p">((</span><span class="n">AR5K_TUNE_MAX_TX_FIFO_THRES</span> <span class="o">-</span> <span class="n">trigger_level</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update trigger level on success</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5210</span><span class="p">)</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">trigger_level</span><span class="p">,</span> <span class="n">AR5K_TRIG_LVL</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">AR5K_REG_WRITE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_TXCFG</span><span class="p">,</span>
				<span class="n">AR5K_TXCFG_TXFULL</span><span class="p">,</span> <span class="n">trigger_level</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">done:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Restore interrupt mask</span>
<span class="cm">	 */</span>
	<span class="n">ath5k_hw_set_imr</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">imr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*******************\</span>
<span class="cm">* Interrupt masking *</span>
<span class="cm">\*******************/</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_is_intr_pending() - Check if we have pending interrupts</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> *</span>
<span class="cm"> * Check if we have pending interrupts to process. Returns 1 if we</span>
<span class="cm"> * have pending interrupts and 0 if we haven&#39;t.</span>
<span class="cm"> */</span>
<span class="n">bool</span>
<span class="nf">ath5k_hw_is_intr_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_INTPEND</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_get_isr() - Get interrupt status</span>
<span class="cm"> * @ah: The @struct ath5k_hw</span>
<span class="cm"> * @interrupt_mask: Driver&#39;s interrupt mask used to filter out</span>
<span class="cm"> * interrupts in sw.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used inside our interrupt handler to determine the reason</span>
<span class="cm"> * for the interrupt by reading Primary Interrupt Status Register. Returns an</span>
<span class="cm"> * abstract interrupt status mask which is mostly ISR with some uncommon bits</span>
<span class="cm"> * being mapped on some standard non hw-specific positions</span>
<span class="cm"> * (check out &amp;ath5k_int).</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: We do write-to-clear, so the active PISR/SISR bits at the time this</span>
<span class="cm"> * function gets called are cleared on return.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">ath5k_hw_get_isr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ath5k_int</span> <span class="o">*</span><span class="n">interrupt_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read interrupt status from Primary Interrupt</span>
<span class="cm">	 * Register.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: PISR/SISR Not available on 5210</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5210</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">isr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">isr</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_ISR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">isr</span> <span class="o">==</span> <span class="n">AR5K_INT_NOCARD</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">interrupt_mask</span> <span class="o">=</span> <span class="n">isr</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Filter out the non-common bits from the interrupt</span>
<span class="cm">		 * status.</span>
<span class="cm">		 */</span>
		<span class="o">*</span><span class="n">interrupt_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">isr</span> <span class="o">&amp;</span> <span class="n">AR5K_INT_COMMON</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_imr</span><span class="p">;</span>

		<span class="cm">/* Hanlde INT_FATAL */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">isr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AR5K_ISR_SSERR</span> <span class="o">|</span> <span class="n">AR5K_ISR_MCABT</span>
						<span class="o">|</span> <span class="n">AR5K_ISR_DPERR</span><span class="p">)))</span>
			<span class="o">*</span><span class="n">interrupt_mask</span> <span class="o">|=</span> <span class="n">AR5K_INT_FATAL</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * XXX: BMISS interrupts may occur after association.</span>
<span class="cm">		 * I found this on 5210 code but it needs testing. If this is</span>
<span class="cm">		 * true we should disable them before assoc and re-enable them</span>
<span class="cm">		 * after a successful assoc + some jiffies.</span>
<span class="cm">			interrupt_mask &amp;= ~AR5K_INT_BMISS;</span>
<span class="cm">		 */</span>

		<span class="n">data</span> <span class="o">=</span> <span class="n">isr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">pisr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">pisr_clear</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">sisr0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">sisr1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">sisr2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">sisr3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">sisr4</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Read PISR and SISRs... */</span>
		<span class="n">pisr</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PISR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pisr</span> <span class="o">==</span> <span class="n">AR5K_INT_NOCARD</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">interrupt_mask</span> <span class="o">=</span> <span class="n">pisr</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sisr0</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_SISR0</span><span class="p">);</span>
		<span class="n">sisr1</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_SISR1</span><span class="p">);</span>
		<span class="n">sisr2</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_SISR2</span><span class="p">);</span>
		<span class="n">sisr3</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_SISR3</span><span class="p">);</span>
		<span class="n">sisr4</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_SISR4</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * PISR holds the logical OR of interrupt bits</span>
<span class="cm">		 * from SISR registers:</span>
<span class="cm">		 *</span>
<span class="cm">		 * TXOK and TXDESC  -&gt; Logical OR of TXOK and TXDESC</span>
<span class="cm">		 *			per-queue bits on SISR0</span>
<span class="cm">		 *</span>
<span class="cm">		 * TXERR and TXEOL -&gt; Logical OR of TXERR and TXEOL</span>
<span class="cm">		 *			per-queue bits on SISR1</span>
<span class="cm">		 *</span>
<span class="cm">		 * TXURN -&gt; Logical OR of TXURN per-queue bits on SISR2</span>
<span class="cm">		 *</span>
<span class="cm">		 * HIUERR -&gt; Logical OR of MCABT, SSERR and DPER bits on SISR2</span>
<span class="cm">		 *</span>
<span class="cm">		 * BCNMISC -&gt; Logical OR of TIM, CAB_END, DTIM_SYNC</span>
<span class="cm">		 *		BCN_TIMEOUT, CAB_TIMEOUT and DTIM</span>
<span class="cm">		 *		(and TSFOOR ?) bits on SISR2</span>
<span class="cm">		 *</span>
<span class="cm">		 * QCBRORN and QCBRURN -&gt; Logical OR of QCBRORN and</span>
<span class="cm">		 *			QCBRURN per-queue bits on SISR3</span>
<span class="cm">		 * QTRIG -&gt; Logical OR of QTRIG per-queue bits on SISR4</span>
<span class="cm">		 *</span>
<span class="cm">		 * If we clean these bits on PISR we &#39;ll also clear all</span>
<span class="cm">		 * related bits from SISRs, e.g. if we write the TXOK bit on</span>
<span class="cm">		 * PISR we &#39;ll clean all TXOK bits from SISR0 so if a new TXOK</span>
<span class="cm">		 * interrupt got fired for another queue while we were reading</span>
<span class="cm">		 * the interrupt registers and we write back the TXOK bit on</span>
<span class="cm">		 * PISR we &#39;ll lose it. So make sure that we don&#39;t write back</span>
<span class="cm">		 * on PISR any bits that come from SISRs. Clearing them from</span>
<span class="cm">		 * SISRs will also clear PISR so no need to worry here.</span>
<span class="cm">		 */</span>

		<span class="n">pisr_clear</span> <span class="o">=</span> <span class="n">pisr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">AR5K_ISR_BITS_FROM_SISRS</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Write to clear them...</span>
<span class="cm">		 * Note: This means that each bit we write back</span>
<span class="cm">		 * to the registers will get cleared, leaving the</span>
<span class="cm">		 * rest unaffected. So this won&#39;t affect new interrupts</span>
<span class="cm">		 * we didn&#39;t catch while reading/processing, we &#39;ll get</span>
<span class="cm">		 * them next time get_isr gets called.</span>
<span class="cm">		 */</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">sisr0</span><span class="p">,</span> <span class="n">AR5K_SISR0</span><span class="p">);</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">sisr1</span><span class="p">,</span> <span class="n">AR5K_SISR1</span><span class="p">);</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">sisr2</span><span class="p">,</span> <span class="n">AR5K_SISR2</span><span class="p">);</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">sisr3</span><span class="p">,</span> <span class="n">AR5K_SISR3</span><span class="p">);</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">sisr4</span><span class="p">,</span> <span class="n">AR5K_SISR4</span><span class="p">);</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">pisr_clear</span><span class="p">,</span> <span class="n">AR5K_PISR</span><span class="p">);</span>
		<span class="cm">/* Flush previous write */</span>
		<span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PISR</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Filter out the non-common bits from the interrupt</span>
<span class="cm">		 * status.</span>
<span class="cm">		 */</span>
		<span class="o">*</span><span class="n">interrupt_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">pisr</span> <span class="o">&amp;</span> <span class="n">AR5K_INT_COMMON</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_imr</span><span class="p">;</span>


		<span class="cm">/* We treat TXOK,TXDESC, TXERR and TXEOL</span>
<span class="cm">		 * the same way (schedule the tx tasklet)</span>
<span class="cm">		 * so we track them all together per queue */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pisr</span> <span class="o">&amp;</span> <span class="n">AR5K_ISR_TXOK</span><span class="p">)</span>
			<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txq_isr_txok_all</span> <span class="o">|=</span> <span class="n">AR5K_REG_MS</span><span class="p">(</span><span class="n">sisr0</span><span class="p">,</span>
						<span class="n">AR5K_SISR0_QCU_TXOK</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pisr</span> <span class="o">&amp;</span> <span class="n">AR5K_ISR_TXDESC</span><span class="p">)</span>
			<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txq_isr_txok_all</span> <span class="o">|=</span> <span class="n">AR5K_REG_MS</span><span class="p">(</span><span class="n">sisr0</span><span class="p">,</span>
						<span class="n">AR5K_SISR0_QCU_TXDESC</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pisr</span> <span class="o">&amp;</span> <span class="n">AR5K_ISR_TXERR</span><span class="p">)</span>
			<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txq_isr_txok_all</span> <span class="o">|=</span> <span class="n">AR5K_REG_MS</span><span class="p">(</span><span class="n">sisr1</span><span class="p">,</span>
						<span class="n">AR5K_SISR1_QCU_TXERR</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pisr</span> <span class="o">&amp;</span> <span class="n">AR5K_ISR_TXEOL</span><span class="p">)</span>
			<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txq_isr_txok_all</span> <span class="o">|=</span> <span class="n">AR5K_REG_MS</span><span class="p">(</span><span class="n">sisr1</span><span class="p">,</span>
						<span class="n">AR5K_SISR1_QCU_TXEOL</span><span class="p">);</span>

		<span class="cm">/* Currently this is not much usefull since we treat</span>
<span class="cm">		 * all queues the same way if we get a TXURN (update</span>
<span class="cm">		 * tx trigger level) but we might need it later on*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pisr</span> <span class="o">&amp;</span> <span class="n">AR5K_ISR_TXURN</span><span class="p">)</span>
			<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txq_isr_txurn</span> <span class="o">|=</span> <span class="n">AR5K_REG_MS</span><span class="p">(</span><span class="n">sisr2</span><span class="p">,</span>
						<span class="n">AR5K_SISR2_QCU_TXURN</span><span class="p">);</span>

		<span class="cm">/* Misc Beacon related interrupts */</span>

		<span class="cm">/* For AR5211 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pisr</span> <span class="o">&amp;</span> <span class="n">AR5K_ISR_TIM</span><span class="p">)</span>
			<span class="o">*</span><span class="n">interrupt_mask</span> <span class="o">|=</span> <span class="n">AR5K_INT_TIM</span><span class="p">;</span>

		<span class="cm">/* For AR5212+ */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pisr</span> <span class="o">&amp;</span> <span class="n">AR5K_ISR_BCNMISC</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sisr2</span> <span class="o">&amp;</span> <span class="n">AR5K_SISR2_TIM</span><span class="p">)</span>
				<span class="o">*</span><span class="n">interrupt_mask</span> <span class="o">|=</span> <span class="n">AR5K_INT_TIM</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sisr2</span> <span class="o">&amp;</span> <span class="n">AR5K_SISR2_DTIM</span><span class="p">)</span>
				<span class="o">*</span><span class="n">interrupt_mask</span> <span class="o">|=</span> <span class="n">AR5K_INT_DTIM</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sisr2</span> <span class="o">&amp;</span> <span class="n">AR5K_SISR2_DTIM_SYNC</span><span class="p">)</span>
				<span class="o">*</span><span class="n">interrupt_mask</span> <span class="o">|=</span> <span class="n">AR5K_INT_DTIM_SYNC</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sisr2</span> <span class="o">&amp;</span> <span class="n">AR5K_SISR2_BCN_TIMEOUT</span><span class="p">)</span>
				<span class="o">*</span><span class="n">interrupt_mask</span> <span class="o">|=</span> <span class="n">AR5K_INT_BCN_TIMEOUT</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sisr2</span> <span class="o">&amp;</span> <span class="n">AR5K_SISR2_CAB_TIMEOUT</span><span class="p">)</span>
				<span class="o">*</span><span class="n">interrupt_mask</span> <span class="o">|=</span> <span class="n">AR5K_INT_CAB_TIMEOUT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Below interrupts are unlikely to happen */</span>

		<span class="cm">/* HIU = Host Interface Unit (PCI etc)</span>
<span class="cm">		 * Can be one of MCABT, SSERR, DPERR from SISR2 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pisr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AR5K_ISR_HIUERR</span><span class="p">)))</span>
			<span class="o">*</span><span class="n">interrupt_mask</span> <span class="o">|=</span> <span class="n">AR5K_INT_FATAL</span><span class="p">;</span>

		<span class="cm">/*Beacon Not Ready*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pisr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AR5K_ISR_BNR</span><span class="p">)))</span>
			<span class="o">*</span><span class="n">interrupt_mask</span> <span class="o">|=</span> <span class="n">AR5K_INT_BNR</span><span class="p">;</span>

		<span class="cm">/* A queue got CBR overrun */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pisr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AR5K_ISR_QCBRORN</span><span class="p">)))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">interrupt_mask</span> <span class="o">|=</span> <span class="n">AR5K_INT_QCBRORN</span><span class="p">;</span>
			<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txq_isr_qcborn</span> <span class="o">|=</span> <span class="n">AR5K_REG_MS</span><span class="p">(</span><span class="n">sisr3</span><span class="p">,</span>
						<span class="n">AR5K_SISR3_QCBRORN</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* A queue got CBR underrun */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pisr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AR5K_ISR_QCBRURN</span><span class="p">)))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">interrupt_mask</span> <span class="o">|=</span> <span class="n">AR5K_INT_QCBRURN</span><span class="p">;</span>
			<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txq_isr_qcburn</span> <span class="o">|=</span> <span class="n">AR5K_REG_MS</span><span class="p">(</span><span class="n">sisr3</span><span class="p">,</span>
						<span class="n">AR5K_SISR3_QCBRURN</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* A queue got triggered */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pisr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AR5K_ISR_QTRIG</span><span class="p">)))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">interrupt_mask</span> <span class="o">|=</span> <span class="n">AR5K_INT_QTRIG</span><span class="p">;</span>
			<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_txq_isr_qtrig</span> <span class="o">|=</span> <span class="n">AR5K_REG_MS</span><span class="p">(</span><span class="n">sisr4</span><span class="p">,</span>
						<span class="n">AR5K_SISR4_QTRIG</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">data</span> <span class="o">=</span> <span class="n">pisr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * In case we didn&#39;t handle anything,</span>
<span class="cm">	 * print the register value.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">*</span><span class="n">interrupt_mask</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">net_ratelimit</span><span class="p">()))</span>
		<span class="n">ATH5K_PRINTF</span><span class="p">(</span><span class="s">&quot;ISR: 0x%08x IMR: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_imr</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_set_imr() - Set interrupt mask</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @new_mask: The new interrupt mask to be set</span>
<span class="cm"> *</span>
<span class="cm"> * Set the interrupt mask in hw to save interrupts. We do that by mapping</span>
<span class="cm"> * ath5k_int bits to hw-specific bits to remove abstraction and writing</span>
<span class="cm"> * Interrupt Mask Register.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ath5k_int</span>
<span class="nf">ath5k_hw_set_imr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ath5k_int</span> <span class="n">new_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">ath5k_int</span> <span class="n">old_mask</span><span class="p">,</span> <span class="n">int_mask</span><span class="p">;</span>

	<span class="n">old_mask</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_imr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable card interrupts to prevent any race conditions</span>
<span class="cm">	 * (they will be re-enabled afterwards if AR5K_INT GLOBAL</span>
<span class="cm">	 * is set again on the new mask).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_mask</span> <span class="o">&amp;</span> <span class="n">AR5K_INT_GLOBAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_IER_DISABLE</span><span class="p">,</span> <span class="n">AR5K_IER</span><span class="p">);</span>
		<span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_IER</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Add additional, chipset-dependent interrupt mask flags</span>
<span class="cm">	 * and write them to the IMR (interrupt mask register).</span>
<span class="cm">	 */</span>
	<span class="n">int_mask</span> <span class="o">=</span> <span class="n">new_mask</span> <span class="o">&amp;</span> <span class="n">AR5K_INT_COMMON</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">!=</span> <span class="n">AR5K_AR5210</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Preserve per queue TXURN interrupt mask */</span>
		<span class="n">u32</span> <span class="n">simr2</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_SIMR2</span><span class="p">)</span>
				<span class="o">&amp;</span> <span class="n">AR5K_SIMR2_QCU_TXURN</span><span class="p">;</span>

		<span class="cm">/* Fatal interrupt abstraction for 5211+ */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_mask</span> <span class="o">&amp;</span> <span class="n">AR5K_INT_FATAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">int_mask</span> <span class="o">|=</span> <span class="n">AR5K_IMR_HIUERR</span><span class="p">;</span>
			<span class="n">simr2</span> <span class="o">|=</span> <span class="p">(</span><span class="n">AR5K_SIMR2_MCABT</span> <span class="o">|</span> <span class="n">AR5K_SIMR2_SSERR</span>
				<span class="o">|</span> <span class="n">AR5K_SIMR2_DPERR</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Misc beacon related interrupts */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_mask</span> <span class="o">&amp;</span> <span class="n">AR5K_INT_TIM</span><span class="p">)</span>
			<span class="n">int_mask</span> <span class="o">|=</span> <span class="n">AR5K_IMR_TIM</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">new_mask</span> <span class="o">&amp;</span> <span class="n">AR5K_INT_TIM</span><span class="p">)</span>
			<span class="n">simr2</span> <span class="o">|=</span> <span class="n">AR5K_SISR2_TIM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_mask</span> <span class="o">&amp;</span> <span class="n">AR5K_INT_DTIM</span><span class="p">)</span>
			<span class="n">simr2</span> <span class="o">|=</span> <span class="n">AR5K_SISR2_DTIM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_mask</span> <span class="o">&amp;</span> <span class="n">AR5K_INT_DTIM_SYNC</span><span class="p">)</span>
			<span class="n">simr2</span> <span class="o">|=</span> <span class="n">AR5K_SISR2_DTIM_SYNC</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_mask</span> <span class="o">&amp;</span> <span class="n">AR5K_INT_BCN_TIMEOUT</span><span class="p">)</span>
			<span class="n">simr2</span> <span class="o">|=</span> <span class="n">AR5K_SISR2_BCN_TIMEOUT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_mask</span> <span class="o">&amp;</span> <span class="n">AR5K_INT_CAB_TIMEOUT</span><span class="p">)</span>
			<span class="n">simr2</span> <span class="o">|=</span> <span class="n">AR5K_SISR2_CAB_TIMEOUT</span><span class="p">;</span>

		<span class="cm">/*Beacon Not Ready*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_mask</span> <span class="o">&amp;</span> <span class="n">AR5K_INT_BNR</span><span class="p">)</span>
			<span class="n">int_mask</span> <span class="o">|=</span> <span class="n">AR5K_INT_BNR</span><span class="p">;</span>

		<span class="cm">/* Note: Per queue interrupt masks</span>
<span class="cm">		 * are set via ath5k_hw_reset_tx_queue() (qcu.c) */</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">int_mask</span><span class="p">,</span> <span class="n">AR5K_PIMR</span><span class="p">);</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">simr2</span><span class="p">,</span> <span class="n">AR5K_SIMR2</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Fatal interrupt abstraction for 5210 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_mask</span> <span class="o">&amp;</span> <span class="n">AR5K_INT_FATAL</span><span class="p">)</span>
			<span class="n">int_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="n">AR5K_IMR_SSERR</span> <span class="o">|</span> <span class="n">AR5K_IMR_MCABT</span>
				<span class="o">|</span> <span class="n">AR5K_IMR_HIUERR</span> <span class="o">|</span> <span class="n">AR5K_IMR_DPERR</span><span class="p">);</span>

		<span class="cm">/* Only common interrupts left for 5210 (no SIMRs) */</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">int_mask</span><span class="p">,</span> <span class="n">AR5K_IMR</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* If RXNOFRM interrupt is masked disable it</span>
<span class="cm">	 * by setting AR5K_RXNOFRM to zero */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">new_mask</span> <span class="o">&amp;</span> <span class="n">AR5K_INT_RXNOFRM</span><span class="p">))</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AR5K_RXNOFRM</span><span class="p">);</span>

	<span class="cm">/* Store new interrupt mask */</span>
	<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_imr</span> <span class="o">=</span> <span class="n">new_mask</span><span class="p">;</span>

	<span class="cm">/* ..re-enable interrupts if AR5K_INT_GLOBAL is set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_mask</span> <span class="o">&amp;</span> <span class="n">AR5K_INT_GLOBAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_IER_ENABLE</span><span class="p">,</span> <span class="n">AR5K_IER</span><span class="p">);</span>
		<span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_IER</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">old_mask</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/********************\</span>
<span class="cm"> Init/Stop functions</span>
<span class="cm">\********************/</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_dma_init() - Initialize DMA unit</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> *</span>
<span class="cm"> * Set DMA size and pre-enable interrupts</span>
<span class="cm"> * (driver handles tx/rx buffer setup and</span>
<span class="cm"> * dma start/stop)</span>
<span class="cm"> *</span>
<span class="cm"> * XXX: Save/restore RXDP/TXDP registers ?</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ath5k_hw_dma_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set Rx/Tx DMA Configuration</span>
<span class="cm">	 *</span>
<span class="cm">	 * Set standard DMA size (128). Note that</span>
<span class="cm">	 * a DMA size of 512 causes rx overruns and tx errors</span>
<span class="cm">	 * on pci-e cards (tested on 5424 but since rx overruns</span>
<span class="cm">	 * also occur on 5416/5418 with madwifi we set 128</span>
<span class="cm">	 * for all PCI-E cards to be safe).</span>
<span class="cm">	 *</span>
<span class="cm">	 * XXX: need to check 5210 for this</span>
<span class="cm">	 * TODO: Check out tx trigger level, it&#39;s always 64 on dumps but I</span>
<span class="cm">	 * guess we can tweak it and see how it goes ;-)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">!=</span> <span class="n">AR5K_AR5210</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AR5K_REG_WRITE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_TXCFG</span><span class="p">,</span>
			<span class="n">AR5K_TXCFG_SDMAMR</span><span class="p">,</span> <span class="n">AR5K_DMASIZE_128B</span><span class="p">);</span>
		<span class="n">AR5K_REG_WRITE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_RXCFG</span><span class="p">,</span>
			<span class="n">AR5K_RXCFG_SDMAMW</span><span class="p">,</span> <span class="n">AR5K_DMASIZE_128B</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Pre-enable interrupts on 5211/5212*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">!=</span> <span class="n">AR5K_AR5210</span><span class="p">)</span>
		<span class="n">ath5k_hw_set_imr</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_imr</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_dma_stop() - stop DMA unit</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> *</span>
<span class="cm"> * Stop tx/rx DMA and interrupts. Returns</span>
<span class="cm"> * -EBUSY if tx or rx dma failed to stop.</span>
<span class="cm"> *</span>
<span class="cm"> * XXX: Sometimes DMA unit hangs and we have</span>
<span class="cm"> * stuck frames on tx queues, only a reset</span>
<span class="cm"> * can fix that.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">ath5k_hw_dma_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">qmax</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Disable interrupts */</span>
	<span class="n">ath5k_hw_set_imr</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Stop rx dma */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ath5k_hw_stop_rx_dma</span><span class="p">(</span><span class="n">ah</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Clear any pending interrupts</span>
<span class="cm">	 * and disable tx dma */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">!=</span> <span class="n">AR5K_AR5210</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">AR5K_PISR</span><span class="p">);</span>
		<span class="n">qmax</span> <span class="o">=</span> <span class="n">AR5K_NUM_TX_QUEUES</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* PISR/SISR Not available on 5210 */</span>
		<span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_ISR</span><span class="p">);</span>
		<span class="n">qmax</span> <span class="o">=</span> <span class="n">AR5K_NUM_TX_QUEUES_NOQCU</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">qmax</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ath5k_hw_stop_tx_dma</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="cm">/* -EINVAL -&gt; queue inactive */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
