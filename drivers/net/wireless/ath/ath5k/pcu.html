<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › ath › ath5k › pcu.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>pcu.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2004-2008 Reyk Floeter &lt;reyk@openbsd.org&gt;</span>
<span class="cm"> * Copyright (c) 2006-2008 Nick Kossifidis &lt;mickflemm@gmail.com&gt;</span>
<span class="cm"> * Copyright (c) 2007-2008 Matthew W. S. Bell  &lt;mentor@madwifi.org&gt;</span>
<span class="cm"> * Copyright (c) 2007-2008 Luis Rodriguez &lt;mcgrof@winlab.rutgers.edu&gt;</span>
<span class="cm"> * Copyright (c) 2007-2008 Pavel Roskin &lt;proski@gnu.org&gt;</span>
<span class="cm"> * Copyright (c) 2007-2008 Jiri Slaby &lt;jirislaby@gmail.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Permission to use, copy, modify, and distribute this software for any</span>
<span class="cm"> * purpose with or without fee is hereby granted, provided that the above</span>
<span class="cm"> * copyright notice and this permission notice appear in all copies.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES</span>
<span class="cm"> * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR</span>
<span class="cm"> * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="cm"> * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="cm"> * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</span>
<span class="cm"> * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*********************************\</span>
<span class="cm">* Protocol Control Unit Functions *</span>
<span class="cm">\*********************************/</span>

<span class="cp">#include &lt;asm/unaligned.h&gt;</span>

<span class="cp">#include &quot;ath5k.h&quot;</span>
<span class="cp">#include &quot;reg.h&quot;</span>
<span class="cp">#include &quot;debug.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: Protocol Control Unit (PCU) functions</span>
<span class="cm"> *</span>
<span class="cm"> * Protocol control unit is responsible to maintain various protocol</span>
<span class="cm"> * properties before a frame is send and after a frame is received to/from</span>
<span class="cm"> * baseband. To be more specific, PCU handles:</span>
<span class="cm"> *</span>
<span class="cm"> * - Buffering of RX and TX frames (after QCU/DCUs)</span>
<span class="cm"> *</span>
<span class="cm"> * - Encrypting and decrypting (using the built-in engine)</span>
<span class="cm"> *</span>
<span class="cm"> * - Generating ACKs, RTS/CTS frames</span>
<span class="cm"> *</span>
<span class="cm"> * - Maintaining TSF</span>
<span class="cm"> *</span>
<span class="cm"> * - FCS</span>
<span class="cm"> *</span>
<span class="cm"> * - Updating beacon data (with TSF etc)</span>
<span class="cm"> *</span>
<span class="cm"> * - Generating virtual CCA</span>
<span class="cm"> *</span>
<span class="cm"> * - RX/Multicast filtering</span>
<span class="cm"> *</span>
<span class="cm"> * - BSSID filtering</span>
<span class="cm"> *</span>
<span class="cm"> * - Various statistics</span>
<span class="cm"> *</span>
<span class="cm"> * -Different operating modes: AP, STA, IBSS</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Most of these functions can be tweaked/bypassed so you can do</span>
<span class="cm"> * them on sw above for debugging or research. For more infos check out PCU</span>
<span class="cm"> * registers on reg.h.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: ACK rates</span>
<span class="cm"> *</span>
<span class="cm"> * AR5212+ can use higher rates for ack transmission</span>
<span class="cm"> * based on current tx rate instead of the base rate.</span>
<span class="cm"> * It does this to better utilize channel usage.</span>
<span class="cm"> * There is a mapping between G rates (that cover both</span>
<span class="cm"> * CCK and OFDM) and ack rates that we use when setting</span>
<span class="cm"> * rate -&gt; duration table. This mapping is hw-based so</span>
<span class="cm"> * don&#39;t change anything.</span>
<span class="cm"> *</span>
<span class="cm"> * To enable this functionality we must set</span>
<span class="cm"> * ah-&gt;ah_ack_bitrate_high to true else base rate is</span>
<span class="cm"> * used (1Mb for CCK, 6Mb for OFDM).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ack_rates_high</span><span class="p">[]</span> <span class="o">=</span>
<span class="cm">/* Tx	-&gt; ACK	*/</span>
<span class="cm">/* 1Mb	-&gt; 1Mb	*/</span>	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span>
<span class="cm">/* 2MB	-&gt; 2Mb	*/</span>	<span class="mi">1</span><span class="p">,</span>
<span class="cm">/* 5.5Mb -&gt; 2Mb	*/</span>	<span class="mi">1</span><span class="p">,</span>
<span class="cm">/* 11Mb	-&gt; 2Mb	*/</span>	<span class="mi">1</span><span class="p">,</span>
<span class="cm">/* 6Mb	-&gt; 6Mb	*/</span>	<span class="mi">4</span><span class="p">,</span>
<span class="cm">/* 9Mb	-&gt; 6Mb	*/</span>	<span class="mi">4</span><span class="p">,</span>
<span class="cm">/* 12Mb	-&gt; 12Mb	*/</span>	<span class="mi">6</span><span class="p">,</span>
<span class="cm">/* 18Mb	-&gt; 12Mb	*/</span>	<span class="mi">6</span><span class="p">,</span>
<span class="cm">/* 24Mb	-&gt; 24Mb	*/</span>	<span class="mi">8</span><span class="p">,</span>
<span class="cm">/* 36Mb	-&gt; 24Mb	*/</span>	<span class="mi">8</span><span class="p">,</span>
<span class="cm">/* 48Mb	-&gt; 24Mb	*/</span>	<span class="mi">8</span><span class="p">,</span>
<span class="cm">/* 54Mb	-&gt; 24Mb	*/</span>	<span class="mi">8</span> <span class="p">};</span>

<span class="cm">/*******************\</span>
<span class="cm">* Helper functions *</span>
<span class="cm">\*******************/</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_get_frame_duration() - Get tx time of a frame</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @len: Frame&#39;s length in bytes</span>
<span class="cm"> * @rate: The @struct ieee80211_rate</span>
<span class="cm"> * @shortpre: Indicate short preample</span>
<span class="cm"> *</span>
<span class="cm"> * Calculate tx duration of a frame given it&#39;s rate and length</span>
<span class="cm"> * It extends ieee80211_generic_frame_duration for non standard</span>
<span class="cm"> * bwmodes.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">ath5k_hw_get_frame_duration</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_rate</span> <span class="o">*</span><span class="n">rate</span><span class="p">,</span> <span class="n">bool</span> <span class="n">shortpre</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sifs</span><span class="p">,</span> <span class="n">preamble</span><span class="p">,</span> <span class="n">plcp_bits</span><span class="p">,</span> <span class="n">sym_time</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bitrate</span><span class="p">,</span> <span class="n">bits</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">symbol_bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dur</span><span class="p">;</span>

	<span class="cm">/* Fallback */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_bwmode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__le16</span> <span class="n">raw_dur</span> <span class="o">=</span> <span class="n">ieee80211_generic_frame_duration</span><span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span>
					<span class="nb">NULL</span><span class="p">,</span> <span class="n">band</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">rate</span><span class="p">);</span>

		<span class="cm">/* subtract difference between long and short preamble */</span>
		<span class="n">dur</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_dur</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">shortpre</span><span class="p">)</span>
			<span class="n">dur</span> <span class="o">-=</span> <span class="mi">96</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">dur</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bitrate</span> <span class="o">=</span> <span class="n">rate</span><span class="o">-&gt;</span><span class="n">bitrate</span><span class="p">;</span>
	<span class="n">preamble</span> <span class="o">=</span> <span class="n">AR5K_INIT_OFDM_PREAMPLE_TIME</span><span class="p">;</span>
	<span class="n">plcp_bits</span> <span class="o">=</span> <span class="n">AR5K_INIT_OFDM_PLCP_BITS</span><span class="p">;</span>
	<span class="n">sym_time</span> <span class="o">=</span> <span class="n">AR5K_INIT_OFDM_SYMBOL_TIME</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_bwmode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AR5K_BWMODE_40MHZ</span>:
		<span class="n">sifs</span> <span class="o">=</span> <span class="n">AR5K_INIT_SIFS_TURBO</span><span class="p">;</span>
		<span class="n">preamble</span> <span class="o">=</span> <span class="n">AR5K_INIT_OFDM_PREAMBLE_TIME_MIN</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_BWMODE_10MHZ</span>:
		<span class="n">sifs</span> <span class="o">=</span> <span class="n">AR5K_INIT_SIFS_HALF_RATE</span><span class="p">;</span>
		<span class="n">preamble</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">sym_time</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_BWMODE_5MHZ</span>:
		<span class="n">sifs</span> <span class="o">=</span> <span class="n">AR5K_INIT_SIFS_QUARTER_RATE</span><span class="p">;</span>
		<span class="n">preamble</span> <span class="o">*=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">sym_time</span> <span class="o">*=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">sifs</span> <span class="o">=</span> <span class="n">AR5K_INIT_SIFS_DEFAULT_BG</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bits</span> <span class="o">=</span> <span class="n">plcp_bits</span> <span class="o">+</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="cm">/* Bit rate is in 100Kbits */</span>
	<span class="n">symbol_bits</span> <span class="o">=</span> <span class="n">bitrate</span> <span class="o">*</span> <span class="n">sym_time</span><span class="p">;</span>
	<span class="n">symbols</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">bits</span> <span class="o">*</span> <span class="mi">10</span><span class="p">,</span> <span class="n">symbol_bits</span><span class="p">);</span>

	<span class="n">dur</span> <span class="o">=</span> <span class="n">sifs</span> <span class="o">+</span> <span class="n">preamble</span> <span class="o">+</span> <span class="p">(</span><span class="n">sym_time</span> <span class="o">*</span> <span class="n">symbols</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">dur</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_get_default_slottime() - Get the default slot time for current mode</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">ath5k_hw_get_default_slottime</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_current_channel</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slot_time</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_bwmode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AR5K_BWMODE_40MHZ</span>:
		<span class="n">slot_time</span> <span class="o">=</span> <span class="n">AR5K_INIT_SLOT_TIME_TURBO</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_BWMODE_10MHZ</span>:
		<span class="n">slot_time</span> <span class="o">=</span> <span class="n">AR5K_INIT_SLOT_TIME_HALF_RATE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_BWMODE_5MHZ</span>:
		<span class="n">slot_time</span> <span class="o">=</span> <span class="n">AR5K_INIT_SLOT_TIME_QUARTER_RATE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_BWMODE_DEFAULT</span>:
	<span class="nl">default:</span>
		<span class="n">slot_time</span> <span class="o">=</span> <span class="n">AR5K_INIT_SLOT_TIME_DEFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">hw_value</span> <span class="o">==</span> <span class="n">AR5K_MODE_11B</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_short_slot</span><span class="p">)</span>
			<span class="n">slot_time</span> <span class="o">=</span> <span class="n">AR5K_INIT_SLOT_TIME_B</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">slot_time</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_get_default_sifs() - Get the default SIFS for current mode</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">ath5k_hw_get_default_sifs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span> <span class="o">=</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_current_channel</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sifs</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_bwmode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AR5K_BWMODE_40MHZ</span>:
		<span class="n">sifs</span> <span class="o">=</span> <span class="n">AR5K_INIT_SIFS_TURBO</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_BWMODE_10MHZ</span>:
		<span class="n">sifs</span> <span class="o">=</span> <span class="n">AR5K_INIT_SIFS_HALF_RATE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_BWMODE_5MHZ</span>:
		<span class="n">sifs</span> <span class="o">=</span> <span class="n">AR5K_INIT_SIFS_QUARTER_RATE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AR5K_BWMODE_DEFAULT</span>:
		<span class="n">sifs</span> <span class="o">=</span> <span class="n">AR5K_INIT_SIFS_DEFAULT_BG</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">band</span> <span class="o">==</span> <span class="n">IEEE80211_BAND_5GHZ</span><span class="p">)</span>
			<span class="n">sifs</span> <span class="o">=</span> <span class="n">AR5K_INIT_SIFS_DEFAULT_A</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sifs</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_update_mib_counters() - Update MIB counters (mac layer statistics)</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> *</span>
<span class="cm"> * Reads MIB counters from PCU and updates sw statistics. Is called after a</span>
<span class="cm"> * MIB interrupt, because one of these counters might have reached their maximum</span>
<span class="cm"> * and triggered the MIB interrupt, to let us read and clear the counter.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Is called in interrupt context!</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ath5k_hw_update_mib_counters</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ath5k_statistics</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>

	<span class="cm">/* Read-And-Clear */</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">ack_fail</span> <span class="o">+=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_ACK_FAIL</span><span class="p">);</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rts_fail</span> <span class="o">+=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_RTS_FAIL</span><span class="p">);</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rts_ok</span> <span class="o">+=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_RTS_OK</span><span class="p">);</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">fcs_error</span> <span class="o">+=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_FCS_FAIL</span><span class="p">);</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">beacons</span> <span class="o">+=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_BEACON_CNT</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/******************\</span>
<span class="cm">* ACK/CTS Timeouts *</span>
<span class="cm">\******************/</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_write_rate_duration() - Fill rate code to duration table</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> *</span>
<span class="cm"> * Write the rate code to duration table upon hw reset. This is a helper for</span>
<span class="cm"> * ath5k_hw_pcu_init(). It seems all this is doing is setting an ACK timeout on</span>
<span class="cm"> * the hardware, based on current mode, for each rate. The rates which are</span>
<span class="cm"> * capable of short preamble (802.11b rates 2Mbps, 5.5Mbps, and 11Mbps) have</span>
<span class="cm"> * different rate code so we write their value twice (one for long preamble</span>
<span class="cm"> * and one for short).</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Band doesn&#39;t matter here, if we set the values for OFDM it works</span>
<span class="cm"> * on both a and g modes. So all we have to do is set values for all g rates</span>
<span class="cm"> * that include all OFDM and CCK rates.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ath5k_hw_write_rate_duration</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_rate</span> <span class="o">*</span><span class="n">rate</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="cm">/* 802.11g covers both OFDM and CCK */</span>
	<span class="n">u8</span> <span class="n">band</span> <span class="o">=</span> <span class="n">IEEE80211_BAND_2GHZ</span><span class="p">;</span>

	<span class="cm">/* Write rate duration table */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">sbands</span><span class="p">[</span><span class="n">band</span><span class="p">].</span><span class="n">n_bitrates</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">reg</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">tx_time</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_ack_bitrate_high</span><span class="p">)</span>
			<span class="n">rate</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">sbands</span><span class="p">[</span><span class="n">band</span><span class="p">].</span><span class="n">bitrates</span><span class="p">[</span><span class="n">ack_rates_high</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
		<span class="cm">/* CCK -&gt; 1Mb */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">rate</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">sbands</span><span class="p">[</span><span class="n">band</span><span class="p">].</span><span class="n">bitrates</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="cm">/* OFDM -&gt; 6Mb */</span>
		<span class="k">else</span>
			<span class="n">rate</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">sbands</span><span class="p">[</span><span class="n">band</span><span class="p">].</span><span class="n">bitrates</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

		<span class="cm">/* Set ACK timeout */</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">AR5K_RATE_DUR</span><span class="p">(</span><span class="n">rate</span><span class="o">-&gt;</span><span class="n">hw_value</span><span class="p">);</span>

		<span class="cm">/* An ACK frame consists of 10 bytes. If you add the FCS,</span>
<span class="cm">		 * which ieee80211_generic_frame_duration() adds,</span>
<span class="cm">		 * its 14 bytes. Note we use the control rate and not the</span>
<span class="cm">		 * actual rate for this rate. See mac80211 tx.c</span>
<span class="cm">		 * ieee80211_duration() for a brief description of</span>
<span class="cm">		 * what rate we should choose to TX ACKs. */</span>
		<span class="n">tx_time</span> <span class="o">=</span> <span class="n">ath5k_hw_get_frame_duration</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">band</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span>
					<span class="n">rate</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">tx_time</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rate</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IEEE80211_RATE_SHORT_PREAMBLE</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">tx_time</span> <span class="o">=</span> <span class="n">ath5k_hw_get_frame_duration</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">band</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">tx_time</span><span class="p">,</span>
			<span class="n">reg</span> <span class="o">+</span> <span class="p">(</span><span class="n">AR5K_SET_SHORT_PREAMBLE</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_set_ack_timeout() - Set ACK timeout on PCU</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @timeout: Timeout in usec</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ath5k_hw_set_ack_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ath5k_hw_clocktoh</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_REG_MS</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">AR5K_TIME_OUT_ACK</span><span class="p">))</span>
			<span class="o">&lt;=</span> <span class="n">timeout</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">AR5K_REG_WRITE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_TIME_OUT</span><span class="p">,</span> <span class="n">AR5K_TIME_OUT_ACK</span><span class="p">,</span>
		<span class="n">ath5k_hw_htoclock</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">timeout</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_set_cts_timeout() - Set CTS timeout on PCU</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @timeout: Timeout in usec</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ath5k_hw_set_cts_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ath5k_hw_clocktoh</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_REG_MS</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">AR5K_TIME_OUT_CTS</span><span class="p">))</span>
			<span class="o">&lt;=</span> <span class="n">timeout</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">AR5K_REG_WRITE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_TIME_OUT</span><span class="p">,</span> <span class="n">AR5K_TIME_OUT_CTS</span><span class="p">,</span>
			<span class="n">ath5k_hw_htoclock</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">timeout</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*******************\</span>
<span class="cm">* RX filter Control *</span>
<span class="cm">\*******************/</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_set_lladdr() - Set station id</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @mac: The card&#39;s mac address (array of octets)</span>
<span class="cm"> *</span>
<span class="cm"> * Set station id on hw using the provided mac address</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">ath5k_hw_set_lladdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ath_common</span> <span class="o">*</span><span class="n">common</span> <span class="o">=</span> <span class="n">ath5k_hw_common</span><span class="p">(</span><span class="n">ah</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">low_id</span><span class="p">,</span> <span class="n">high_id</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pcu_reg</span><span class="p">;</span>

	<span class="cm">/* Set new station ID */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">macaddr</span><span class="p">,</span> <span class="n">mac</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="n">pcu_reg</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_STA_ID1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">;</span>

	<span class="n">low_id</span> <span class="o">=</span> <span class="n">get_unaligned_le32</span><span class="p">(</span><span class="n">mac</span><span class="p">);</span>
	<span class="n">high_id</span> <span class="o">=</span> <span class="n">get_unaligned_le16</span><span class="p">(</span><span class="n">mac</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>

	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">low_id</span><span class="p">,</span> <span class="n">AR5K_STA_ID0</span><span class="p">);</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">pcu_reg</span> <span class="o">|</span> <span class="n">high_id</span><span class="p">,</span> <span class="n">AR5K_STA_ID1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_set_bssid() - Set current BSSID on hw</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the current BSSID and BSSID mask we have from the</span>
<span class="cm"> * common struct into the hardware</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ath5k_hw_set_bssid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ath_common</span> <span class="o">*</span><span class="n">common</span> <span class="o">=</span> <span class="n">ath5k_hw_common</span><span class="p">(</span><span class="n">ah</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">tim_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set BSSID mask on 5212</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5212</span><span class="p">)</span>
		<span class="n">ath_hw_setbssidmask</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set BSSID</span>
<span class="cm">	 */</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span>
			   <span class="n">get_unaligned_le32</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">curbssid</span><span class="p">),</span>
			   <span class="n">AR5K_BSS_ID0</span><span class="p">);</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span>
			   <span class="n">get_unaligned_le16</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">curbssid</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span>
			   <span class="p">((</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">curaid</span> <span class="o">&amp;</span> <span class="mh">0x3fff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">AR5K_BSS_ID1_AID_S</span><span class="p">),</span>
			   <span class="n">AR5K_BSS_ID1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">curaid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ath5k_hw_disable_pspoll</span><span class="p">(</span><span class="n">ah</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">AR5K_REG_WRITE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_BEACON</span><span class="p">,</span> <span class="n">AR5K_BEACON_TIM</span><span class="p">,</span>
			    <span class="n">tim_offset</span> <span class="o">?</span> <span class="n">tim_offset</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">ath5k_hw_enable_pspoll</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_set_bssid_mask() - Filter out bssids we listen</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @mask: The BSSID mask to set (array of octets)</span>
<span class="cm"> *</span>
<span class="cm"> * BSSID masking is a method used by AR5212 and newer hardware to inform PCU</span>
<span class="cm"> * which bits of the interface&#39;s MAC address should be looked at when trying</span>
<span class="cm"> * to decide which packets to ACK. In station mode and AP mode with a single</span>
<span class="cm"> * BSS every bit matters since we lock to only one BSS. In AP mode with</span>
<span class="cm"> * multiple BSSes (virtual interfaces) not every bit matters because hw must</span>
<span class="cm"> * accept frames for all BSSes and so we tweak some bits of our mac address</span>
<span class="cm"> * in order to have multiple BSSes.</span>
<span class="cm"> *</span>
<span class="cm"> * For more information check out ../hw.c of the common ath module.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ath5k_hw_set_bssid_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ath_common</span> <span class="o">*</span><span class="n">common</span> <span class="o">=</span> <span class="n">ath5k_hw_common</span><span class="p">(</span><span class="n">ah</span><span class="p">);</span>

	<span class="cm">/* Cache bssid mask so that we can restore it</span>
<span class="cm">	 * on reset */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">bssidmask</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5212</span><span class="p">)</span>
		<span class="n">ath_hw_setbssidmask</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_set_mcast_filter() - Set multicast filter</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @filter0: Lower 32bits of muticast filter</span>
<span class="cm"> * @filter1: Higher 16bits of multicast filter</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ath5k_hw_set_mcast_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u32</span> <span class="n">filter0</span><span class="p">,</span> <span class="n">u32</span> <span class="n">filter1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">filter0</span><span class="p">,</span> <span class="n">AR5K_MCAST_FILTER0</span><span class="p">);</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">filter1</span><span class="p">,</span> <span class="n">AR5K_MCAST_FILTER1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_get_rx_filter() - Get current rx filter</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the RX filter by reading rx filter and</span>
<span class="cm"> * phy error filter registers. RX filter is used</span>
<span class="cm"> * to set the allowed frame types that PCU will accept</span>
<span class="cm"> * and pass to the driver. For a list of frame types</span>
<span class="cm"> * check out reg.h.</span>
<span class="cm"> */</span>
<span class="n">u32</span>
<span class="nf">ath5k_hw_get_rx_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">,</span> <span class="n">filter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">filter</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_RX_FILTER</span><span class="p">);</span>

	<span class="cm">/*Radar detection for 5212*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5212</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_PHY_ERR_FIL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">AR5K_PHY_ERR_FIL_RADAR</span><span class="p">)</span>
			<span class="n">filter</span> <span class="o">|=</span> <span class="n">AR5K_RX_FILTER_RADARERR</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AR5K_PHY_ERR_FIL_OFDM</span> <span class="o">|</span> <span class="n">AR5K_PHY_ERR_FIL_CCK</span><span class="p">))</span>
			<span class="n">filter</span> <span class="o">|=</span> <span class="n">AR5K_RX_FILTER_PHYERR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">filter</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_set_rx_filter() - Set rx filter</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @filter: RX filter mask (see reg.h)</span>
<span class="cm"> *</span>
<span class="cm"> * Sets RX filter register and also handles PHY error filter</span>
<span class="cm"> * register on 5212 and newer chips so that we have proper PHY</span>
<span class="cm"> * error reporting.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ath5k_hw_set_rx_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u32</span> <span class="n">filter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Set PHY error filter register on 5212*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5212</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filter</span> <span class="o">&amp;</span> <span class="n">AR5K_RX_FILTER_RADARERR</span><span class="p">)</span>
			<span class="n">data</span> <span class="o">|=</span> <span class="n">AR5K_PHY_ERR_FIL_RADAR</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filter</span> <span class="o">&amp;</span> <span class="n">AR5K_RX_FILTER_PHYERR</span><span class="p">)</span>
			<span class="n">data</span> <span class="o">|=</span> <span class="n">AR5K_PHY_ERR_FIL_OFDM</span> <span class="o">|</span> <span class="n">AR5K_PHY_ERR_FIL_CCK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The AR5210 uses promiscuous mode to detect radar activity</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5210</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">filter</span> <span class="o">&amp;</span> <span class="n">AR5K_RX_FILTER_RADARERR</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">filter</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">AR5K_RX_FILTER_RADARERR</span><span class="p">;</span>
		<span class="n">filter</span> <span class="o">|=</span> <span class="n">AR5K_RX_FILTER_PROM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*Zero length DMA (phy error reporting) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span>
		<span class="n">AR5K_REG_ENABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_RXCFG</span><span class="p">,</span> <span class="n">AR5K_RXCFG_ZLFDMA</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">AR5K_REG_DISABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_RXCFG</span><span class="p">,</span> <span class="n">AR5K_RXCFG_ZLFDMA</span><span class="p">);</span>

	<span class="cm">/*Write RX Filter register*/</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">filter</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">AR5K_RX_FILTER</span><span class="p">);</span>

	<span class="cm">/*Write PHY error filter register on 5212*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5212</span><span class="p">)</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">AR5K_PHY_ERR_FIL</span><span class="p">);</span>

<span class="p">}</span>


<span class="cm">/****************\</span>
<span class="cm">* Beacon control *</span>
<span class="cm">\****************/</span>

<span class="cp">#define ATH5K_MAX_TSF_READ 10</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_get_tsf64() - Get the full 64bit TSF</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the current TSF</span>
<span class="cm"> */</span>
<span class="n">u64</span>
<span class="nf">ath5k_hw_get_tsf64</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tsf_lower</span><span class="p">,</span> <span class="n">tsf_upper1</span><span class="p">,</span> <span class="n">tsf_upper2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* This code is time critical - we don&#39;t want to be interrupted here */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * While reading TSF upper and then lower part, the clock is still</span>
<span class="cm">	 * counting (or jumping in case of IBSS merge) so we might get</span>
<span class="cm">	 * inconsistent values. To avoid this, we read the upper part again</span>
<span class="cm">	 * and check it has not been changed. We make the hypothesis that a</span>
<span class="cm">	 * maximum of 3 changes can happens in a row (we use 10 as a safe</span>
<span class="cm">	 * value).</span>
<span class="cm">	 *</span>
<span class="cm">	 * Impact on performance is pretty small, since in most cases, only</span>
<span class="cm">	 * 3 register reads are needed.</span>
<span class="cm">	 */</span>

	<span class="n">tsf_upper1</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_TSF_U32</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ATH5K_MAX_TSF_READ</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tsf_lower</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_TSF_L32</span><span class="p">);</span>
		<span class="n">tsf_upper2</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_TSF_U32</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tsf_upper2</span> <span class="o">==</span> <span class="n">tsf_upper1</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">tsf_upper1</span> <span class="o">=</span> <span class="n">tsf_upper2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">ATH5K_MAX_TSF_READ</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">tsf_upper1</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="n">tsf_lower</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#undef ATH5K_MAX_TSF_READ</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_set_tsf64() - Set a new 64bit TSF</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @tsf64: The new 64bit TSF</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the new TSF</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ath5k_hw_set_tsf64</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u64</span> <span class="n">tsf64</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">tsf64</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">AR5K_TSF_L32</span><span class="p">);</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="p">(</span><span class="n">tsf64</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">AR5K_TSF_U32</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_reset_tsf() - Force a TSF reset</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> *</span>
<span class="cm"> * Forces a TSF reset on PCU</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ath5k_hw_reset_tsf</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_BEACON</span><span class="p">)</span> <span class="o">|</span> <span class="n">AR5K_BEACON_RESET_TSF</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Each write to the RESET_TSF bit toggles a hardware internal</span>
<span class="cm">	 * signal to reset TSF, but if left high it will cause a TSF reset</span>
<span class="cm">	 * on the next chip reset as well.  Thus we always write the value</span>
<span class="cm">	 * twice to clear the signal.</span>
<span class="cm">	 */</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">AR5K_BEACON</span><span class="p">);</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">AR5K_BEACON</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_init_beacon_timers() - Initialize beacon timers</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @next_beacon: Next TBTT</span>
<span class="cm"> * @interval: Current beacon interval</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used to initialize beacon timers based on current</span>
<span class="cm"> * operation mode and settings.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ath5k_hw_init_beacon_timers</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u32</span> <span class="n">next_beacon</span><span class="p">,</span> <span class="n">u32</span> <span class="n">interval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">timer1</span><span class="p">,</span> <span class="n">timer2</span><span class="p">,</span> <span class="n">timer3</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the additional timers by mode</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">opmode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NL80211_IFTYPE_MONITOR</span>:
	<span class="k">case</span> <span class="n">NL80211_IFTYPE_STATION</span>:
		<span class="cm">/* In STA mode timer1 is used as next wakeup</span>
<span class="cm">		 * timer and timer2 as next CFP duration start</span>
<span class="cm">		 * timer. Both in 1/8TUs. */</span>
		<span class="cm">/* TODO: PCF handling */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5210</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">timer1</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span>
			<span class="n">timer2</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">timer1</span> <span class="o">=</span> <span class="mh">0x0000ffff</span><span class="p">;</span>
			<span class="n">timer2</span> <span class="o">=</span> <span class="mh">0x0007ffff</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Mark associated AP as PCF incapable for now */</span>
		<span class="n">AR5K_REG_DISABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_STA_ID1</span><span class="p">,</span> <span class="n">AR5K_STA_ID1_PCF</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NL80211_IFTYPE_ADHOC</span>:
		<span class="n">AR5K_REG_ENABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_TXCFG</span><span class="p">,</span> <span class="n">AR5K_TXCFG_ADHOC_BCN_ATIM</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="cm">/* On non-STA modes timer1 is used as next DMA</span>
<span class="cm">		 * beacon alert (DBA) timer and timer2 as next</span>
<span class="cm">		 * software beacon alert. Both in 1/8TUs. */</span>
		<span class="n">timer1</span> <span class="o">=</span> <span class="p">(</span><span class="n">next_beacon</span> <span class="o">-</span> <span class="n">AR5K_TUNE_DMA_BEACON_RESP</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">timer2</span> <span class="o">=</span> <span class="p">(</span><span class="n">next_beacon</span> <span class="o">-</span> <span class="n">AR5K_TUNE_SW_BEACON_RESP</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Timer3 marks the end of our ATIM window</span>
<span class="cm">	 * a zero length window is not allowed because</span>
<span class="cm">	 * we &#39;ll get no beacons */</span>
	<span class="n">timer3</span> <span class="o">=</span> <span class="n">next_beacon</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the beacon register and enable all timers.</span>
<span class="cm">	 */</span>
	<span class="cm">/* When in AP or Mesh Point mode zero timer0 to start TSF */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">opmode</span> <span class="o">==</span> <span class="n">NL80211_IFTYPE_AP</span> <span class="o">||</span>
	    <span class="n">ah</span><span class="o">-&gt;</span><span class="n">opmode</span> <span class="o">==</span> <span class="n">NL80211_IFTYPE_MESH_POINT</span><span class="p">)</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AR5K_TIMER0</span><span class="p">);</span>

	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">next_beacon</span><span class="p">,</span> <span class="n">AR5K_TIMER0</span><span class="p">);</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">timer1</span><span class="p">,</span> <span class="n">AR5K_TIMER1</span><span class="p">);</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">timer2</span><span class="p">,</span> <span class="n">AR5K_TIMER2</span><span class="p">);</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">timer3</span><span class="p">,</span> <span class="n">AR5K_TIMER3</span><span class="p">);</span>

	<span class="cm">/* Force a TSF reset if requested and enable beacons */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">interval</span> <span class="o">&amp;</span> <span class="n">AR5K_BEACON_RESET_TSF</span><span class="p">)</span>
		<span class="n">ath5k_hw_reset_tsf</span><span class="p">(</span><span class="n">ah</span><span class="p">);</span>

	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">interval</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AR5K_BEACON_PERIOD</span> <span class="o">|</span>
					<span class="n">AR5K_BEACON_ENABLE</span><span class="p">),</span>
						<span class="n">AR5K_BEACON</span><span class="p">);</span>

	<span class="cm">/* Flush any pending BMISS interrupts on ISR by</span>
<span class="cm">	 * performing a clear-on-write operation on PISR</span>
<span class="cm">	 * register for the BMISS bit (writing a bit on</span>
<span class="cm">	 * ISR toggles a reset for that bit and leaves</span>
<span class="cm">	 * the remaining bits intact) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5210</span><span class="p">)</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_ISR_BMISS</span><span class="p">,</span> <span class="n">AR5K_ISR</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_ISR_BMISS</span><span class="p">,</span> <span class="n">AR5K_PISR</span><span class="p">);</span>

	<span class="cm">/* TODO: Set enhanced sleep registers on AR5212</span>
<span class="cm">	 * based on vif-&gt;bss_conf params, until then</span>
<span class="cm">	 * disable power save reporting.*/</span>
	<span class="n">AR5K_REG_DISABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_STA_ID1</span><span class="p">,</span> <span class="n">AR5K_STA_ID1_PWR_SV</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_check_timer_win() - Check if timer B is timer A + window</span>
<span class="cm"> * @a: timer a (before b)</span>
<span class="cm"> * @b: timer b (after a)</span>
<span class="cm"> * @window: difference between a and b</span>
<span class="cm"> * @intval: timers are increased by this interval</span>
<span class="cm"> *</span>
<span class="cm"> * This helper function checks if timer B is timer A + window and covers</span>
<span class="cm"> * cases where timer A or B might have already been updated or wrapped</span>
<span class="cm"> * around (Timers are 16 bit).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true if O.K.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span>
<span class="nf">ath5k_check_timer_win</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">window</span><span class="p">,</span> <span class="kt">int</span> <span class="n">intval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * 1.) usually B should be A + window</span>
<span class="cm">	 * 2.) A already updated, B not updated yet</span>
<span class="cm">	 * 3.) A already updated and has wrapped around</span>
<span class="cm">	 * 4.) B has wrapped around</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span> <span class="o">==</span> <span class="n">window</span><span class="p">)</span> <span class="o">||</span>				<span class="cm">/* 1.) */</span>
	    <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span> <span class="o">==</span> <span class="n">intval</span> <span class="o">-</span> <span class="n">window</span><span class="p">)</span> <span class="o">||</span>			<span class="cm">/* 2.) */</span>
	    <span class="p">((</span><span class="n">a</span> <span class="o">|</span> <span class="mh">0x10000</span><span class="p">)</span> <span class="o">-</span> <span class="n">b</span> <span class="o">==</span> <span class="n">intval</span> <span class="o">-</span> <span class="n">window</span><span class="p">)</span> <span class="o">||</span>		<span class="cm">/* 3.) */</span>
	    <span class="p">((</span><span class="n">b</span> <span class="o">|</span> <span class="mh">0x10000</span><span class="p">)</span> <span class="o">-</span> <span class="n">a</span> <span class="o">==</span> <span class="n">window</span><span class="p">))</span>			<span class="cm">/* 4.) */</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="cm">/* O.K. */</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_check_beacon_timers() - Check if the beacon timers are correct</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @intval: beacon interval</span>
<span class="cm"> *</span>
<span class="cm"> * This is a workaround for IBSS mode</span>
<span class="cm"> *</span>
<span class="cm"> * The need for this function arises from the fact that we have 4 separate</span>
<span class="cm"> * HW timer registers (TIMER0 - TIMER3), which are closely related to the</span>
<span class="cm"> * next beacon target time (NBTT), and that the HW updates these timers</span>
<span class="cm"> * separately based on the current TSF value. The hardware increments each</span>
<span class="cm"> * timer by the beacon interval, when the local TSF converted to TU is equal</span>
<span class="cm"> * to the value stored in the timer.</span>
<span class="cm"> *</span>
<span class="cm"> * The reception of a beacon with the same BSSID can update the local HW TSF</span>
<span class="cm"> * at any time - this is something we can&#39;t avoid. If the TSF jumps to a</span>
<span class="cm"> * time which is later than the time stored in a timer, this timer will not</span>
<span class="cm"> * be updated until the TSF in TU wraps around at 16 bit (the size of the</span>
<span class="cm"> * timers) and reaches the time which is stored in the timer.</span>
<span class="cm"> *</span>
<span class="cm"> * The problem is that these timers are closely related to TIMER0 (NBTT) and</span>
<span class="cm"> * that they define a time &quot;window&quot;. When the TSF jumps between two timers</span>
<span class="cm"> * (e.g. ATIM and NBTT), the one in the past will be left behind (not</span>
<span class="cm"> * updated), while the one in the future will be updated every beacon</span>
<span class="cm"> * interval. This causes the window to get larger, until the TSF wraps</span>
<span class="cm"> * around as described above and the timer which was left behind gets</span>
<span class="cm"> * updated again. But - because the beacon interval is usually not an exact</span>
<span class="cm"> * divisor of the size of the timers (16 bit), an unwanted &quot;window&quot; between</span>
<span class="cm"> * these timers has developed!</span>
<span class="cm"> *</span>
<span class="cm"> * This is especially important with the ATIM window, because during</span>
<span class="cm"> * the ATIM window only ATIM frames and no data frames are allowed to be</span>
<span class="cm"> * sent, which creates transmission pauses after each beacon. This symptom</span>
<span class="cm"> * has been described as &quot;ramping ping&quot; because ping times increase linearly</span>
<span class="cm"> * for some time and then drop down again. A wrong window on the DMA beacon</span>
<span class="cm"> * timer has the same effect, so we check for these two conditions.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true if O.K.</span>
<span class="cm"> */</span>
<span class="n">bool</span>
<span class="nf">ath5k_hw_check_beacon_timers</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="kt">int</span> <span class="n">intval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nbtt</span><span class="p">,</span> <span class="n">atim</span><span class="p">,</span> <span class="n">dma</span><span class="p">;</span>

	<span class="n">nbtt</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_TIMER0</span><span class="p">);</span>
	<span class="n">atim</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_TIMER3</span><span class="p">);</span>
	<span class="n">dma</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_TIMER1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>

	<span class="cm">/* NOTE: SWBA is different. Having a wrong window there does not</span>
<span class="cm">	 * stop us from sending data and this condition is caught by</span>
<span class="cm">	 * other means (SWBA interrupt) */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ath5k_check_timer_win</span><span class="p">(</span><span class="n">nbtt</span><span class="p">,</span> <span class="n">atim</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">intval</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ath5k_check_timer_win</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span> <span class="n">nbtt</span><span class="p">,</span> <span class="n">AR5K_TUNE_DMA_BEACON_RESP</span><span class="p">,</span>
				  <span class="n">intval</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="cm">/* O.K. */</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_set_coverage_class() - Set IEEE 802.11 coverage class</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @coverage_class: IEEE 802.11 coverage class number</span>
<span class="cm"> *</span>
<span class="cm"> * Sets IFS intervals and ACK/CTS timeouts for given coverage class.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ath5k_hw_set_coverage_class</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="n">u8</span> <span class="n">coverage_class</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* As defined by IEEE 802.11-2007 17.3.8.6 */</span>
	<span class="kt">int</span> <span class="n">slot_time</span> <span class="o">=</span> <span class="n">ath5k_hw_get_default_slottime</span><span class="p">(</span><span class="n">ah</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">coverage_class</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ack_timeout</span> <span class="o">=</span> <span class="n">ath5k_hw_get_default_sifs</span><span class="p">(</span><span class="n">ah</span><span class="p">)</span> <span class="o">+</span> <span class="n">slot_time</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cts_timeout</span> <span class="o">=</span> <span class="n">ack_timeout</span><span class="p">;</span>

	<span class="n">ath5k_hw_set_ifs_intervals</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">slot_time</span><span class="p">);</span>
	<span class="n">ath5k_hw_set_ack_timeout</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ack_timeout</span><span class="p">);</span>
	<span class="n">ath5k_hw_set_cts_timeout</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">cts_timeout</span><span class="p">);</span>

	<span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_coverage_class</span> <span class="o">=</span> <span class="n">coverage_class</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/***************************\</span>
<span class="cm">* Init/Start/Stop functions *</span>
<span class="cm">\***************************/</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_start_rx_pcu() - Start RX engine</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> *</span>
<span class="cm"> * Starts RX engine on PCU so that hw can process RXed frames</span>
<span class="cm"> * (ACK etc).</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: RX DMA should be already enabled using ath5k_hw_start_rx_dma</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ath5k_hw_start_rx_pcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">AR5K_REG_DISABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_DIAG_SW</span><span class="p">,</span> <span class="n">AR5K_DIAG_SW_DIS_RX</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * at5k_hw_stop_rx_pcu() - Stop RX engine</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> *</span>
<span class="cm"> * Stops RX engine on PCU</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ath5k_hw_stop_rx_pcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">AR5K_REG_ENABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_DIAG_SW</span><span class="p">,</span> <span class="n">AR5K_DIAG_SW_DIS_RX</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_set_opmode() - Set PCU operating mode</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @op_mode: One of enum nl80211_iftype</span>
<span class="cm"> *</span>
<span class="cm"> * Configure PCU for the various operating modes (AP/STA etc)</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">ath5k_hw_set_opmode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">enum</span> <span class="n">nl80211_iftype</span> <span class="n">op_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ath_common</span> <span class="o">*</span><span class="n">common</span> <span class="o">=</span> <span class="n">ath5k_hw_common</span><span class="p">(</span><span class="n">ah</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">pcu_reg</span><span class="p">,</span> <span class="n">beacon_reg</span><span class="p">,</span> <span class="n">low_id</span><span class="p">,</span> <span class="n">high_id</span><span class="p">;</span>

	<span class="n">ATH5K_DBG</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ATH5K_DEBUG_MODE</span><span class="p">,</span> <span class="s">&quot;mode %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">op_mode</span><span class="p">);</span>

	<span class="cm">/* Preserve rest settings */</span>
	<span class="n">pcu_reg</span> <span class="o">=</span> <span class="n">ath5k_hw_reg_read</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_STA_ID1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">;</span>
	<span class="n">pcu_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">AR5K_STA_ID1_ADHOC</span> <span class="o">|</span> <span class="n">AR5K_STA_ID1_AP</span>
			<span class="o">|</span> <span class="n">AR5K_STA_ID1_KEYSRCH_MODE</span>
			<span class="o">|</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5210</span> <span class="o">?</span>
			<span class="p">(</span><span class="n">AR5K_STA_ID1_PWR_SV</span> <span class="o">|</span> <span class="n">AR5K_STA_ID1_NO_PSPOLL</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>

	<span class="n">beacon_reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">op_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NL80211_IFTYPE_ADHOC</span>:
		<span class="n">pcu_reg</span> <span class="o">|=</span> <span class="n">AR5K_STA_ID1_ADHOC</span> <span class="o">|</span> <span class="n">AR5K_STA_ID1_KEYSRCH_MODE</span><span class="p">;</span>
		<span class="n">beacon_reg</span> <span class="o">|=</span> <span class="n">AR5K_BCR_ADHOC</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5210</span><span class="p">)</span>
			<span class="n">pcu_reg</span> <span class="o">|=</span> <span class="n">AR5K_STA_ID1_NO_PSPOLL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">AR5K_REG_ENABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_CFG</span><span class="p">,</span> <span class="n">AR5K_CFG_IBSS</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">NL80211_IFTYPE_AP</span>:
	<span class="k">case</span> <span class="n">NL80211_IFTYPE_MESH_POINT</span>:
		<span class="n">pcu_reg</span> <span class="o">|=</span> <span class="n">AR5K_STA_ID1_AP</span> <span class="o">|</span> <span class="n">AR5K_STA_ID1_KEYSRCH_MODE</span><span class="p">;</span>
		<span class="n">beacon_reg</span> <span class="o">|=</span> <span class="n">AR5K_BCR_AP</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5210</span><span class="p">)</span>
			<span class="n">pcu_reg</span> <span class="o">|=</span> <span class="n">AR5K_STA_ID1_NO_PSPOLL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">AR5K_REG_DISABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_CFG</span><span class="p">,</span> <span class="n">AR5K_CFG_IBSS</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">NL80211_IFTYPE_STATION</span>:
		<span class="n">pcu_reg</span> <span class="o">|=</span> <span class="n">AR5K_STA_ID1_KEYSRCH_MODE</span>
			<span class="o">|</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5210</span> <span class="o">?</span>
				<span class="n">AR5K_STA_ID1_PWR_SV</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">NL80211_IFTYPE_MONITOR</span>:
		<span class="n">pcu_reg</span> <span class="o">|=</span> <span class="n">AR5K_STA_ID1_KEYSRCH_MODE</span>
			<span class="o">|</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5210</span> <span class="o">?</span>
				<span class="n">AR5K_STA_ID1_NO_PSPOLL</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set PCU registers</span>
<span class="cm">	 */</span>
	<span class="n">low_id</span> <span class="o">=</span> <span class="n">get_unaligned_le32</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">macaddr</span><span class="p">);</span>
	<span class="n">high_id</span> <span class="o">=</span> <span class="n">get_unaligned_le16</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">macaddr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">low_id</span><span class="p">,</span> <span class="n">AR5K_STA_ID0</span><span class="p">);</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">pcu_reg</span> <span class="o">|</span> <span class="n">high_id</span><span class="p">,</span> <span class="n">AR5K_STA_ID1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set Beacon Control Register on 5210</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5210</span><span class="p">)</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">beacon_reg</span><span class="p">,</span> <span class="n">AR5K_BCR</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ath5k_hw_pcu_init() - Initialize PCU</span>
<span class="cm"> * @ah: The &amp;struct ath5k_hw</span>
<span class="cm"> * @op_mode: One of enum nl80211_iftype</span>
<span class="cm"> * @mode: One of enum ath5k_driver_mode</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used to initialize PCU by setting current</span>
<span class="cm"> * operation mode and various other settings.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ath5k_hw_pcu_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ath5k_hw</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">enum</span> <span class="n">nl80211_iftype</span> <span class="n">op_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Set bssid and bssid mask */</span>
	<span class="n">ath5k_hw_set_bssid</span><span class="p">(</span><span class="n">ah</span><span class="p">);</span>

	<span class="cm">/* Set PCU config */</span>
	<span class="n">ath5k_hw_set_opmode</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">op_mode</span><span class="p">);</span>

	<span class="cm">/* Write rate duration table only on AR5212 and if</span>
<span class="cm">	 * virtual interface has already been brought up</span>
<span class="cm">	 * XXX: rethink this after new mode changes to</span>
<span class="cm">	 * mac80211 are integrated */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5212</span> <span class="o">&amp;&amp;</span>
		<span class="n">ah</span><span class="o">-&gt;</span><span class="n">nvifs</span><span class="p">)</span>
		<span class="n">ath5k_hw_write_rate_duration</span><span class="p">(</span><span class="n">ah</span><span class="p">);</span>

	<span class="cm">/* Set RSSI/BRSSI thresholds</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: If we decide to set this value</span>
<span class="cm">	 * dynamically, have in mind that when AR5K_RSSI_THR</span>
<span class="cm">	 * register is read it might return 0x40 if we haven&#39;t</span>
<span class="cm">	 * wrote anything to it plus BMISS RSSI threshold is zeroed.</span>
<span class="cm">	 * So doing a save/restore procedure here isn&#39;t the right</span>
<span class="cm">	 * choice. Instead store it on ath5k_hw */</span>
	<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="p">(</span><span class="n">AR5K_TUNE_RSSI_THRES</span> <span class="o">|</span>
				<span class="n">AR5K_TUNE_BMISS_THRES</span> <span class="o">&lt;&lt;</span>
				<span class="n">AR5K_RSSI_THR_BMISS_S</span><span class="p">),</span>
				<span class="n">AR5K_RSSI_THR</span><span class="p">);</span>

	<span class="cm">/* MIC QoS support */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_mac_srev</span> <span class="o">&gt;=</span> <span class="n">AR5K_SREV_AR2413</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="mh">0x000100aa</span><span class="p">,</span> <span class="n">AR5K_MIC_QOS_CTL</span><span class="p">);</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="mh">0x00003210</span><span class="p">,</span> <span class="n">AR5K_MIC_QOS_SEL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* QoS NOACK Policy */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5212</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ath5k_hw_reg_write</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span>
			<span class="n">AR5K_REG_SM</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">AR5K_QOS_NOACK_2BIT_VALUES</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">AR5K_REG_SM</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">AR5K_QOS_NOACK_BIT_OFFSET</span><span class="p">)</span>  <span class="o">|</span>
			<span class="n">AR5K_REG_SM</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">AR5K_QOS_NOACK_BYTE_OFFSET</span><span class="p">),</span>
			<span class="n">AR5K_QOS_NOACK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Restore slot time and ACK timeouts */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_coverage_class</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ath5k_hw_set_coverage_class</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_coverage_class</span><span class="p">);</span>

	<span class="cm">/* Set ACK bitrate mode (see ack_rates_high) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_version</span> <span class="o">==</span> <span class="n">AR5K_AR5212</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">val</span> <span class="o">=</span> <span class="n">AR5K_STA_ID1_BASE_RATE_11B</span> <span class="o">|</span> <span class="n">AR5K_STA_ID1_ACKCTS_6MB</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ah</span><span class="o">-&gt;</span><span class="n">ah_ack_bitrate_high</span><span class="p">)</span>
			<span class="n">AR5K_REG_DISABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_STA_ID1</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">AR5K_REG_ENABLE_BITS</span><span class="p">(</span><span class="n">ah</span><span class="p">,</span> <span class="n">AR5K_STA_ID1</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
