<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › ath › carl9170 › cmd.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>cmd.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Atheros CARL9170 driver</span>
<span class="cm"> *</span>
<span class="cm"> * Basic HW register/memory/command access functions</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2008, Johannes Berg &lt;johannes@sipsolutions.net&gt;</span>
<span class="cm"> * Copyright 2010, Christian Lamparter &lt;chunkeey@googlemail.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; see the file COPYING.  If not, see</span>
<span class="cm"> * http://www.gnu.org/licenses/.</span>
<span class="cm"> *</span>
<span class="cm"> * This file incorporates work covered by the following copyright and</span>
<span class="cm"> * permission notice:</span>
<span class="cm"> *    Copyright (c) 2007-2008 Atheros Communications, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> *    Permission to use, copy, modify, and/or distribute this software for any</span>
<span class="cm"> *    purpose with or without fee is hereby granted, provided that the above</span>
<span class="cm"> *    copyright notice and this permission notice appear in all copies.</span>
<span class="cm"> *</span>
<span class="cm"> *    THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES</span>
<span class="cm"> *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="cm"> *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR</span>
<span class="cm"> *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="cm"> *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="cm"> *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</span>
<span class="cm"> *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __CMD_H</span>
<span class="cp">#define __CMD_H</span>

<span class="cp">#include &quot;carl9170.h&quot;</span>

<span class="cm">/* basic HW access */</span>
<span class="kt">int</span> <span class="n">carl9170_write_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ar9170</span> <span class="o">*</span><span class="n">ar</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">val</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">carl9170_read_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ar9170</span> <span class="o">*</span><span class="n">ar</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">carl9170_read_mreg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ar9170</span> <span class="o">*</span><span class="n">ar</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">nregs</span><span class="p">,</span>
		       <span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">out</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">carl9170_echo_test</span><span class="p">(</span><span class="k">struct</span> <span class="n">ar9170</span> <span class="o">*</span><span class="n">ar</span><span class="p">,</span> <span class="n">u32</span> <span class="n">v</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">carl9170_reboot</span><span class="p">(</span><span class="k">struct</span> <span class="n">ar9170</span> <span class="o">*</span><span class="n">ar</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">carl9170_mac_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ar9170</span> <span class="o">*</span><span class="n">ar</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">carl9170_powersave</span><span class="p">(</span><span class="k">struct</span> <span class="n">ar9170</span> <span class="o">*</span><span class="n">ar</span><span class="p">,</span> <span class="k">const</span> <span class="n">bool</span> <span class="n">power_on</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">carl9170_collect_tally</span><span class="p">(</span><span class="k">struct</span> <span class="n">ar9170</span> <span class="o">*</span><span class="n">ar</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">carl9170_bcn_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ar9170</span> <span class="o">*</span><span class="n">ar</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vif_id</span><span class="p">,</span>
		       <span class="k">const</span> <span class="n">u32</span> <span class="n">mode</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">len</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">carl9170_flush_cab</span><span class="p">(</span><span class="k">struct</span> <span class="n">ar9170</span> <span class="o">*</span><span class="n">ar</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vif_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">carl9170_bcn_ctrl</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="n">vif_id</span><span class="p">,</span> <span class="n">CARL9170_BCN_CTRL_DRAIN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">carl9170_rx_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ar9170</span> <span class="o">*</span><span class="n">ar</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">_rx_filter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__le32</span> <span class="n">rx_filter</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">_rx_filter</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">carl9170_exec_cmd</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="n">CARL9170_CMD_RX_FILTER</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">rx_filter</span><span class="p">),</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rx_filter</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">carl9170_cmd</span> <span class="o">*</span><span class="n">carl9170_cmd_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">ar9170</span> <span class="o">*</span><span class="n">ar</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">enum</span> <span class="n">carl9170_cmd_oids</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Macros to facilitate writing multiple registers in a single</span>
<span class="cm"> * write-combining USB command. Note that when the first group</span>
<span class="cm"> * fails the whole thing will fail without any others attempted,</span>
<span class="cm"> * but you won&#39;t know which write in the group failed.</span>
<span class="cm"> */</span>
<span class="cp">#define carl9170_regwrite_begin(ar)					\</span>
<span class="cp">do {									\</span>
<span class="cp">	int __nreg = 0, __err = 0;					\</span>
<span class="cp">	struct ar9170 *__ar = ar;</span>

<span class="cp">#define carl9170_regwrite(r, v) do {					\</span>
<span class="cp">	__ar-&gt;cmd_buf[2 * __nreg + 1] = cpu_to_le32(r);			\</span>
<span class="cp">	__ar-&gt;cmd_buf[2 * __nreg + 2] = cpu_to_le32(v);			\</span>
<span class="cp">	__nreg++;							\</span>
<span class="cp">	if ((__nreg &gt;= PAYLOAD_MAX / 2)) {				\</span>
<span class="cp">		if (IS_ACCEPTING_CMD(__ar))				\</span>
<span class="cp">			__err = carl9170_exec_cmd(__ar,			\</span>
<span class="cp">				CARL9170_CMD_WREG, 8 * __nreg,		\</span>
<span class="cp">				(u8 *) &amp;__ar-&gt;cmd_buf[1], 0, NULL);	\</span>
<span class="cp">		else							\</span>
<span class="cp">			goto __regwrite_out;				\</span>
<span class="cp">									\</span>
<span class="cp">		__nreg = 0;						\</span>
<span class="cp">		if (__err)						\</span>
<span class="cp">			goto __regwrite_out;				\</span>
<span class="cp">	}								\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define carl9170_regwrite_finish()					\</span>
<span class="cp">__regwrite_out :							\</span>
<span class="cp">	if (__err == 0 &amp;&amp; __nreg) {					\</span>
<span class="cp">		if (IS_ACCEPTING_CMD(__ar))				\</span>
<span class="cp">			__err = carl9170_exec_cmd(__ar,			\</span>
<span class="cp">				CARL9170_CMD_WREG, 8 * __nreg,		\</span>
<span class="cp">				(u8 *) &amp;__ar-&gt;cmd_buf[1], 0, NULL);	\</span>
<span class="cp">		__nreg = 0;						\</span>
<span class="cp">	}</span>

<span class="cp">#define carl9170_regwrite_result()					\</span>
<span class="cp">	__err;								\</span>
<span class="cp">} while (0)</span>


<span class="cp">#define carl9170_async_regwrite_get_buf()				\</span>
<span class="cp">do {									\</span>
<span class="cp">	__nreg = 0;							\</span>
<span class="cp">	__cmd = carl9170_cmd_buf(__carl, CARL9170_CMD_WREG_ASYNC,	\</span>
<span class="cp">				 CARL9170_MAX_CMD_PAYLOAD_LEN);		\</span>
<span class="cp">	if (__cmd == NULL) {						\</span>
<span class="cp">		__err = -ENOMEM;					\</span>
<span class="cp">		goto __async_regwrite_out;				\</span>
<span class="cp">	}								\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define carl9170_async_regwrite_begin(carl)				\</span>
<span class="cp">do {									\</span>
<span class="cp">	struct ar9170 *__carl = carl;					\</span>
<span class="cp">	struct carl9170_cmd *__cmd;					\</span>
<span class="cp">	unsigned int __nreg;						\</span>
<span class="cp">	int  __err = 0;							\</span>
<span class="cp">	carl9170_async_regwrite_get_buf();				\</span>

<span class="cp">#define carl9170_async_regwrite_flush()					\</span>
<span class="cp">do {									\</span>
<span class="cp">	if (__cmd == NULL || __nreg == 0)				\</span>
<span class="cp">		break;							\</span>
<span class="cp">									\</span>
<span class="cp">	if (IS_ACCEPTING_CMD(__carl) &amp;&amp; __nreg) {			\</span>
<span class="cp">		__cmd-&gt;hdr.len = 8 * __nreg;				\</span>
<span class="cp">		__err = __carl9170_exec_cmd(__carl, __cmd, true);	\</span>
<span class="cp">		__cmd = NULL;						\</span>
<span class="cp">		break;							\</span>
<span class="cp">	}								\</span>
<span class="cp">	goto __async_regwrite_out;					\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define carl9170_async_regwrite(r, v) do {				\</span>
<span class="cp">	if (__cmd == NULL)						\</span>
<span class="cp">		carl9170_async_regwrite_get_buf();			\</span>
<span class="cp">	__cmd-&gt;wreg.regs[__nreg].addr = cpu_to_le32(r);			\</span>
<span class="cp">	__cmd-&gt;wreg.regs[__nreg].val = cpu_to_le32(v);			\</span>
<span class="cp">	__nreg++;							\</span>
<span class="cp">	if ((__nreg &gt;= PAYLOAD_MAX / 2))				\</span>
<span class="cp">		carl9170_async_regwrite_flush();			\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define carl9170_async_regwrite_finish() do {				\</span>
<span class="cp">__async_regwrite_out:							\</span>
<span class="cp">	if (__cmd != NULL &amp;&amp; __err == 0)				\</span>
<span class="cp">		carl9170_async_regwrite_flush();			\</span>
<span class="cp">	kfree(__cmd);							\</span>
<span class="cp">} while (0)								\</span>

<span class="cp">#define carl9170_async_regwrite_result()				\</span>
<span class="cp">	__err;								\</span>
<span class="cp">} while (0)</span>

<span class="cp">#endif </span><span class="cm">/* __CMD_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
