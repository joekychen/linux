<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › iwlegacy › 4965-calib.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>4965-calib.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * This file is provided under a dual BSD/GPLv2 license.  When using or</span>
<span class="cm"> * redistributing this file, you may do so under either license.</span>
<span class="cm"> *</span>
<span class="cm"> * GPL LICENSE SUMMARY</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of version 2 of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,</span>
<span class="cm"> * USA</span>
<span class="cm"> *</span>
<span class="cm"> * The full GNU General Public License is included in this distribution</span>
<span class="cm"> * in the file called LICENSE.GPL.</span>
<span class="cm"> *</span>
<span class="cm"> * Contact Information:</span>
<span class="cm"> *  Intel Linux Wireless &lt;ilw@linux.intel.com&gt;</span>
<span class="cm"> * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>
<span class="cm"> *</span>
<span class="cm"> * BSD LICENSE</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2005 - 2011 Intel Corporation. All rights reserved.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> *</span>
<span class="cm"> *  * Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *  * Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer in</span>
<span class="cm"> *    the documentation and/or other materials provided with the</span>
<span class="cm"> *    distribution.</span>
<span class="cm"> *  * Neither the name Intel Corporation nor the names of its</span>
<span class="cm"> *    contributors may be used to endorse or promote products derived</span>
<span class="cm"> *    from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="cm"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="cm"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="cm"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="cm"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;net/mac80211.h&gt;</span>

<span class="cp">#include &quot;common.h&quot;</span>
<span class="cp">#include &quot;4965.h&quot;</span>

<span class="cm">/*****************************************************************************</span>
<span class="cm"> * INIT calibrations framework</span>
<span class="cm"> *****************************************************************************/</span>

<span class="k">struct</span> <span class="n">stats_general_data</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">beacon_silence_rssi_a</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">beacon_silence_rssi_b</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">beacon_silence_rssi_c</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">beacon_energy_a</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">beacon_energy_b</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">beacon_energy_c</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*****************************************************************************</span>
<span class="cm"> * RUNTIME calibrations framework</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cm">/* &quot;false alarms&quot; are signals that our DSP tries to lock onto,</span>
<span class="cm"> *   but then determines that they are either noise, or transmissions</span>
<span class="cm"> *   from a distant wireless network (also &quot;noise&quot;, really) that get</span>
<span class="cm"> *   &quot;stepped on&quot; by stronger transmissions within our own network.</span>
<span class="cm"> * This algorithm attempts to set a sensitivity level that is high</span>
<span class="cm"> *   enough to receive all of our own network traffic, but not so</span>
<span class="cm"> *   high that our DSP gets too busy trying to lock onto non-network</span>
<span class="cm"> *   activity/noise. */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">il4965_sens_energy_cck</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="n">norm_fa</span><span class="p">,</span> <span class="n">u32</span> <span class="n">rx_enable_time</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">stats_general_data</span> <span class="o">*</span><span class="n">rx_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">max_nrg_cck</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">max_silence_rssi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">silence_ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">silence_rssi_a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">silence_rssi_b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">silence_rssi_c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>

	<span class="cm">/* &quot;false_alarms&quot; values below are cross-multiplications to assess the</span>
<span class="cm">	 *   numbers of false alarms within the measured period of actual Rx</span>
<span class="cm">	 *   (Rx is off when we&#39;re txing), vs the min/max expected false alarms</span>
<span class="cm">	 *   (some should be expected if rx is sensitive enough) in a</span>
<span class="cm">	 *   hypothetical listening period of 200 time units (TU), 204.8 msec:</span>
<span class="cm">	 *</span>
<span class="cm">	 * MIN_FA/fixed-time &lt; false_alarms/actual-rx-time &lt; MAX_FA/beacon-time</span>
<span class="cm">	 *</span>
<span class="cm">	 * */</span>
	<span class="n">u32</span> <span class="n">false_alarms</span> <span class="o">=</span> <span class="n">norm_fa</span> <span class="o">*</span> <span class="mi">200</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">max_false_alarms</span> <span class="o">=</span> <span class="n">MAX_FA_CCK</span> <span class="o">*</span> <span class="n">rx_enable_time</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">min_false_alarms</span> <span class="o">=</span> <span class="n">MIN_FA_CCK</span> <span class="o">*</span> <span class="n">rx_enable_time</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_sensitivity_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">il_sensitivity_ranges</span> <span class="o">*</span><span class="n">ranges</span> <span class="o">=</span> <span class="n">il</span><span class="o">-&gt;</span><span class="n">hw_params</span><span class="p">.</span><span class="n">sens</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">sensitivity_data</span><span class="p">);</span>

	<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_auto_corr_silence_diff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Find max silence rssi among all 3 receivers.</span>
<span class="cm">	 * This is background noise, which may include transmissions from other</span>
<span class="cm">	 *    networks, measured during silence before our network&#39;s beacon */</span>
	<span class="n">silence_rssi_a</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">((</span><span class="n">rx_info</span><span class="o">-&gt;</span><span class="n">beacon_silence_rssi_a</span> <span class="o">&amp;</span> <span class="n">ALL_BAND_FILTER</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">silence_rssi_b</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">((</span><span class="n">rx_info</span><span class="o">-&gt;</span><span class="n">beacon_silence_rssi_b</span> <span class="o">&amp;</span> <span class="n">ALL_BAND_FILTER</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">silence_rssi_c</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">((</span><span class="n">rx_info</span><span class="o">-&gt;</span><span class="n">beacon_silence_rssi_c</span> <span class="o">&amp;</span> <span class="n">ALL_BAND_FILTER</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">silence_rssi_b</span><span class="p">,</span> <span class="n">silence_rssi_c</span><span class="p">);</span>
	<span class="n">max_silence_rssi</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">silence_rssi_a</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">val</span><span class="p">);</span>

	<span class="cm">/* Store silence rssi in 20-beacon history table */</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_silence_rssi</span><span class="p">[</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_silence_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_silence_rssi</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_silence_idx</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_silence_idx</span> <span class="o">&gt;=</span> <span class="n">NRG_NUM_PREV_STAT_L</span><span class="p">)</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_silence_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Find max silence rssi across 20 beacon history */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NRG_NUM_PREV_STAT_L</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_silence_rssi</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">silence_ref</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">silence_ref</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;silence a %u, b %u, c %u, 20-bcn max %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">silence_rssi_a</span><span class="p">,</span>
		<span class="n">silence_rssi_b</span><span class="p">,</span> <span class="n">silence_rssi_c</span><span class="p">,</span> <span class="n">silence_ref</span><span class="p">);</span>

	<span class="cm">/* Find max rx energy (min value!) among all 3 receivers,</span>
<span class="cm">	 *   measured during beacon frame.</span>
<span class="cm">	 * Save it in 10-beacon history table. */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_energy_idx</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">rx_info</span><span class="o">-&gt;</span><span class="n">beacon_energy_b</span><span class="p">,</span> <span class="n">rx_info</span><span class="o">-&gt;</span><span class="n">beacon_energy_c</span><span class="p">);</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">rx_info</span><span class="o">-&gt;</span><span class="n">beacon_energy_a</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_energy_idx</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_energy_idx</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">)</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_energy_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Find min rx energy (max value) across 10 beacon history.</span>
<span class="cm">	 * This is the minimum signal level that we want to receive well.</span>
<span class="cm">	 * Add backoff (margin so we don&#39;t miss slightly lower energy frames).</span>
<span class="cm">	 * This establishes an upper bound (min value) for energy threshold. */</span>
	<span class="n">max_nrg_cck</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_value</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">max_nrg_cck</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">max</span><span class="p">(</span><span class="n">max_nrg_cck</span><span class="p">,</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_value</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
	<span class="n">max_nrg_cck</span> <span class="o">+=</span> <span class="mi">6</span><span class="p">;</span>

	<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;rx energy a %u, b %u, c %u, 10-bcn max/min %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">rx_info</span><span class="o">-&gt;</span><span class="n">beacon_energy_a</span><span class="p">,</span> <span class="n">rx_info</span><span class="o">-&gt;</span><span class="n">beacon_energy_b</span><span class="p">,</span>
		<span class="n">rx_info</span><span class="o">-&gt;</span><span class="n">beacon_energy_c</span><span class="p">,</span> <span class="n">max_nrg_cck</span> <span class="o">-</span> <span class="mi">6</span><span class="p">);</span>

	<span class="cm">/* Count number of consecutive beacons with fewer-than-desired</span>
<span class="cm">	 *   false alarms. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">false_alarms</span> <span class="o">&lt;</span> <span class="n">min_false_alarms</span><span class="p">)</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">num_in_cck_no_fa</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">num_in_cck_no_fa</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;consecutive bcns with few false alarms = %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">num_in_cck_no_fa</span><span class="p">);</span>

	<span class="cm">/* If we got too many false alarms this time, reduce sensitivity */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">false_alarms</span> <span class="o">&gt;</span> <span class="n">max_false_alarms</span> <span class="o">&amp;&amp;</span>
	    <span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_cck</span> <span class="o">&gt;</span> <span class="n">AUTO_CORR_MAX_TH_CCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;norm FA %u &gt; max FA %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">false_alarms</span><span class="p">,</span>
			<span class="n">max_false_alarms</span><span class="p">);</span>
		<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;... reducing sensitivity</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_curr_state</span> <span class="o">=</span> <span class="n">IL_FA_TOO_MANY</span><span class="p">;</span>
		<span class="cm">/* Store for &quot;fewer than desired&quot; on later beacon */</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_silence_ref</span> <span class="o">=</span> <span class="n">silence_ref</span><span class="p">;</span>

		<span class="cm">/* increase energy threshold (reduce nrg value)</span>
<span class="cm">		 *   to decrease sensitivity */</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_th_cck</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_th_cck</span> <span class="o">-</span> <span class="n">NRG_STEP_CCK</span><span class="p">;</span>
		<span class="cm">/* Else if we got fewer than desired, increase sensitivity */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">false_alarms</span> <span class="o">&lt;</span> <span class="n">min_false_alarms</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_curr_state</span> <span class="o">=</span> <span class="n">IL_FA_TOO_FEW</span><span class="p">;</span>

		<span class="cm">/* Compare silence level with silence level for most recent</span>
<span class="cm">		 *   healthy number or too many false alarms */</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_auto_corr_silence_diff</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">s32</span><span class="p">)</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_silence_ref</span> <span class="o">-</span> <span class="p">(</span><span class="n">s32</span><span class="p">)</span> <span class="n">silence_ref</span><span class="p">;</span>

		<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;norm FA %u &lt; min FA %u, silence diff %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">false_alarms</span><span class="p">,</span> <span class="n">min_false_alarms</span><span class="p">,</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_auto_corr_silence_diff</span><span class="p">);</span>

		<span class="cm">/* Increase value to increase sensitivity, but only if:</span>
<span class="cm">		 * 1a) previous beacon did *not* have *too many* false alarms</span>
<span class="cm">		 * 1b) AND there&#39;s a significant difference in Rx levels</span>
<span class="cm">		 *      from a previous beacon with too many, or healthy # FAs</span>
<span class="cm">		 * OR 2) We&#39;ve seen a lot of beacons (100) with too few</span>
<span class="cm">		 *       false alarms */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_prev_state</span> <span class="o">!=</span> <span class="n">IL_FA_TOO_MANY</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_auto_corr_silence_diff</span> <span class="o">&gt;</span> <span class="n">NRG_DIFF</span> <span class="o">||</span>
		     <span class="n">data</span><span class="o">-&gt;</span><span class="n">num_in_cck_no_fa</span> <span class="o">&gt;</span> <span class="n">MAX_NUMBER_CCK_NO_FA</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;... increasing sensitivity</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="cm">/* Increase nrg value to increase sensitivity */</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_th_cck</span> <span class="o">+</span> <span class="n">NRG_STEP_CCK</span><span class="p">;</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_th_cck</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">ranges</span><span class="o">-&gt;</span><span class="n">min_nrg_cck</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;... but not changing sensitivity</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Else we got a healthy number of false alarms, keep status quo */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot; FA in safe zone</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_curr_state</span> <span class="o">=</span> <span class="n">IL_FA_GOOD_RANGE</span><span class="p">;</span>

		<span class="cm">/* Store for use in &quot;fewer than desired&quot; with later beacon */</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_silence_ref</span> <span class="o">=</span> <span class="n">silence_ref</span><span class="p">;</span>

		<span class="cm">/* If previous beacon had too many false alarms,</span>
<span class="cm">		 *   give it some extra margin by reducing sensitivity again</span>
<span class="cm">		 *   (but don&#39;t go below measured energy of desired Rx) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IL_FA_TOO_MANY</span> <span class="o">==</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_prev_state</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;... increasing margin</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_th_cck</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">max_nrg_cck</span> <span class="o">+</span> <span class="n">NRG_MARGIN</span><span class="p">))</span>
				<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_th_cck</span> <span class="o">-=</span> <span class="n">NRG_MARGIN</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_th_cck</span> <span class="o">=</span> <span class="n">max_nrg_cck</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure the energy threshold does not go above the measured</span>
<span class="cm">	 * energy of the desired Rx signals (reduced by backoff margin),</span>
<span class="cm">	 * or else we might start missing Rx frames.</span>
<span class="cm">	 * Lower value is higher energy, so we use max()!</span>
<span class="cm">	 */</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_th_cck</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">max_nrg_cck</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_th_cck</span><span class="p">);</span>
	<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;new nrg_th_cck %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_th_cck</span><span class="p">);</span>

	<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_prev_state</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_curr_state</span><span class="p">;</span>

	<span class="cm">/* Auto-correlation CCK algorithm */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">false_alarms</span> <span class="o">&gt;</span> <span class="n">min_false_alarms</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* increase auto_corr values to decrease sensitivity</span>
<span class="cm">		 * so the DSP won&#39;t be disturbed by the noise</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_cck</span> <span class="o">&lt;</span> <span class="n">AUTO_CORR_MAX_TH_CCK</span><span class="p">)</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_cck</span> <span class="o">=</span> <span class="n">AUTO_CORR_MAX_TH_CCK</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_cck</span> <span class="o">+</span> <span class="n">AUTO_CORR_STEP_CCK</span><span class="p">;</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_cck</span> <span class="o">=</span>
			    <span class="n">min</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">ranges</span><span class="o">-&gt;</span><span class="n">auto_corr_max_cck</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_cck_mrc</span> <span class="o">+</span> <span class="n">AUTO_CORR_STEP_CCK</span><span class="p">;</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_cck_mrc</span> <span class="o">=</span>
		    <span class="n">min</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">ranges</span><span class="o">-&gt;</span><span class="n">auto_corr_max_cck_mrc</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">false_alarms</span> <span class="o">&lt;</span> <span class="n">min_false_alarms</span> <span class="o">&amp;&amp;</span>
		   <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_auto_corr_silence_diff</span> <span class="o">&gt;</span> <span class="n">NRG_DIFF</span> <span class="o">||</span>
		    <span class="n">data</span><span class="o">-&gt;</span><span class="n">num_in_cck_no_fa</span> <span class="o">&gt;</span> <span class="n">MAX_NUMBER_CCK_NO_FA</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* Decrease auto_corr values to increase sensitivity */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_cck</span> <span class="o">-</span> <span class="n">AUTO_CORR_STEP_CCK</span><span class="p">;</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_cck</span> <span class="o">=</span> <span class="n">max</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">ranges</span><span class="o">-&gt;</span><span class="n">auto_corr_min_cck</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_cck_mrc</span> <span class="o">-</span> <span class="n">AUTO_CORR_STEP_CCK</span><span class="p">;</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_cck_mrc</span> <span class="o">=</span>
		    <span class="n">max</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">ranges</span><span class="o">-&gt;</span><span class="n">auto_corr_min_cck_mrc</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">il4965_sens_auto_corr_ofdm</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="n">norm_fa</span><span class="p">,</span> <span class="n">u32</span> <span class="n">rx_enable_time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">false_alarms</span> <span class="o">=</span> <span class="n">norm_fa</span> <span class="o">*</span> <span class="mi">200</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">max_false_alarms</span> <span class="o">=</span> <span class="n">MAX_FA_OFDM</span> <span class="o">*</span> <span class="n">rx_enable_time</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">min_false_alarms</span> <span class="o">=</span> <span class="n">MIN_FA_OFDM</span> <span class="o">*</span> <span class="n">rx_enable_time</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_sensitivity_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">il_sensitivity_ranges</span> <span class="o">*</span><span class="n">ranges</span> <span class="o">=</span> <span class="n">il</span><span class="o">-&gt;</span><span class="n">hw_params</span><span class="p">.</span><span class="n">sens</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">sensitivity_data</span><span class="p">);</span>

	<span class="cm">/* If we got too many false alarms this time, reduce sensitivity */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">false_alarms</span> <span class="o">&gt;</span> <span class="n">max_false_alarms</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;norm FA %u &gt; max FA %u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">false_alarms</span><span class="p">,</span>
			<span class="n">max_false_alarms</span><span class="p">);</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm</span> <span class="o">+</span> <span class="n">AUTO_CORR_STEP_OFDM</span><span class="p">;</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm</span> <span class="o">=</span>
		    <span class="n">min</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">ranges</span><span class="o">-&gt;</span><span class="n">auto_corr_max_ofdm</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm_mrc</span> <span class="o">+</span> <span class="n">AUTO_CORR_STEP_OFDM</span><span class="p">;</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm_mrc</span> <span class="o">=</span>
		    <span class="n">min</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">ranges</span><span class="o">-&gt;</span><span class="n">auto_corr_max_ofdm_mrc</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm_x1</span> <span class="o">+</span> <span class="n">AUTO_CORR_STEP_OFDM</span><span class="p">;</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm_x1</span> <span class="o">=</span>
		    <span class="n">min</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">ranges</span><span class="o">-&gt;</span><span class="n">auto_corr_max_ofdm_x1</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm_mrc_x1</span> <span class="o">+</span> <span class="n">AUTO_CORR_STEP_OFDM</span><span class="p">;</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm_mrc_x1</span> <span class="o">=</span>
		    <span class="n">min</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">ranges</span><span class="o">-&gt;</span><span class="n">auto_corr_max_ofdm_mrc_x1</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Else if we got fewer than desired, increase sensitivity */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">false_alarms</span> <span class="o">&lt;</span> <span class="n">min_false_alarms</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;norm FA %u &lt; min FA %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">false_alarms</span><span class="p">,</span>
			<span class="n">min_false_alarms</span><span class="p">);</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm</span> <span class="o">-</span> <span class="n">AUTO_CORR_STEP_OFDM</span><span class="p">;</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm</span> <span class="o">=</span>
		    <span class="n">max</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">ranges</span><span class="o">-&gt;</span><span class="n">auto_corr_min_ofdm</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm_mrc</span> <span class="o">-</span> <span class="n">AUTO_CORR_STEP_OFDM</span><span class="p">;</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm_mrc</span> <span class="o">=</span>
		    <span class="n">max</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">ranges</span><span class="o">-&gt;</span><span class="n">auto_corr_min_ofdm_mrc</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm_x1</span> <span class="o">-</span> <span class="n">AUTO_CORR_STEP_OFDM</span><span class="p">;</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm_x1</span> <span class="o">=</span>
		    <span class="n">max</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">ranges</span><span class="o">-&gt;</span><span class="n">auto_corr_min_ofdm_x1</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm_mrc_x1</span> <span class="o">-</span> <span class="n">AUTO_CORR_STEP_OFDM</span><span class="p">;</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm_mrc_x1</span> <span class="o">=</span>
		    <span class="n">max</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">ranges</span><span class="o">-&gt;</span><span class="n">auto_corr_min_ofdm_mrc_x1</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;min FA %u &lt; norm FA %u &lt; max FA %u OK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">min_false_alarms</span><span class="p">,</span> <span class="n">false_alarms</span><span class="p">,</span> <span class="n">max_false_alarms</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">il4965_prepare_legacy_sensitivity_tbl</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">il_sensitivity_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				      <span class="n">__le16</span> <span class="o">*</span><span class="n">tbl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tbl</span><span class="p">[</span><span class="n">HD_AUTO_CORR32_X4_TH_ADD_MIN_IDX</span><span class="p">]</span> <span class="o">=</span>
	    <span class="n">cpu_to_le16</span><span class="p">((</span><span class="n">u16</span><span class="p">)</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm</span><span class="p">);</span>
	<span class="n">tbl</span><span class="p">[</span><span class="n">HD_AUTO_CORR32_X4_TH_ADD_MIN_MRC_IDX</span><span class="p">]</span> <span class="o">=</span>
	    <span class="n">cpu_to_le16</span><span class="p">((</span><span class="n">u16</span><span class="p">)</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm_mrc</span><span class="p">);</span>
	<span class="n">tbl</span><span class="p">[</span><span class="n">HD_AUTO_CORR32_X1_TH_ADD_MIN_IDX</span><span class="p">]</span> <span class="o">=</span>
	    <span class="n">cpu_to_le16</span><span class="p">((</span><span class="n">u16</span><span class="p">)</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm_x1</span><span class="p">);</span>
	<span class="n">tbl</span><span class="p">[</span><span class="n">HD_AUTO_CORR32_X1_TH_ADD_MIN_MRC_IDX</span><span class="p">]</span> <span class="o">=</span>
	    <span class="n">cpu_to_le16</span><span class="p">((</span><span class="n">u16</span><span class="p">)</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm_mrc_x1</span><span class="p">);</span>

	<span class="n">tbl</span><span class="p">[</span><span class="n">HD_AUTO_CORR40_X4_TH_ADD_MIN_IDX</span><span class="p">]</span> <span class="o">=</span>
	    <span class="n">cpu_to_le16</span><span class="p">((</span><span class="n">u16</span><span class="p">)</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_cck</span><span class="p">);</span>
	<span class="n">tbl</span><span class="p">[</span><span class="n">HD_AUTO_CORR40_X4_TH_ADD_MIN_MRC_IDX</span><span class="p">]</span> <span class="o">=</span>
	    <span class="n">cpu_to_le16</span><span class="p">((</span><span class="n">u16</span><span class="p">)</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_cck_mrc</span><span class="p">);</span>

	<span class="n">tbl</span><span class="p">[</span><span class="n">HD_MIN_ENERGY_CCK_DET_IDX</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">((</span><span class="n">u16</span><span class="p">)</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_th_cck</span><span class="p">);</span>
	<span class="n">tbl</span><span class="p">[</span><span class="n">HD_MIN_ENERGY_OFDM_DET_IDX</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">((</span><span class="n">u16</span><span class="p">)</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_th_ofdm</span><span class="p">);</span>

	<span class="n">tbl</span><span class="p">[</span><span class="n">HD_BARKER_CORR_TH_ADD_MIN_IDX</span><span class="p">]</span> <span class="o">=</span>
	    <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">barker_corr_th_min</span><span class="p">);</span>
	<span class="n">tbl</span><span class="p">[</span><span class="n">HD_BARKER_CORR_TH_ADD_MIN_MRC_IDX</span><span class="p">]</span> <span class="o">=</span>
	    <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">barker_corr_th_min_mrc</span><span class="p">);</span>
	<span class="n">tbl</span><span class="p">[</span><span class="n">HD_OFDM_ENERGY_TH_IN_IDX</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_th_cca</span><span class="p">);</span>

	<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;ofdm: ac %u mrc %u x1 %u mrc_x1 %u thresh %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm_mrc</span><span class="p">,</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm_x1</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm_mrc_x1</span><span class="p">,</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_th_ofdm</span><span class="p">);</span>

	<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;cck: ac %u mrc %u thresh %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_cck</span><span class="p">,</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_cck_mrc</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_th_cck</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Prepare a C_SENSITIVITY, send to uCode if values have changed */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">il4965_sensitivity_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">il_sensitivity_cmd</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_sensitivity_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_host_cmd</span> <span class="n">cmd_out</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">C_SENSITIVITY</span><span class="p">,</span>
		<span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_sensitivity_cmd</span><span class="p">),</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">CMD_ASYNC</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">sensitivity_data</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>

	<span class="n">il4965_prepare_legacy_sensitivity_tbl</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="cm">/* Update uCode&#39;s &quot;work&quot; table, and copy it to DSP */</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">control</span> <span class="o">=</span> <span class="n">C_SENSITIVITY_CONTROL_WORK_TBL</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t send command to uCode if nothing has changed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span>
	    <span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">sensitivity_tbl</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
	     <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="o">*</span> <span class="n">HD_TBL_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;No change in C_SENSITIVITY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Copy table for comparison next time */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">sensitivity_tbl</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="o">*</span> <span class="n">HD_TBL_SIZE</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">il_send_cmd</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd_out</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">il4965_init_sensitivity</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_sensitivity_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">il_sensitivity_ranges</span> <span class="o">*</span><span class="n">ranges</span> <span class="o">=</span> <span class="n">il</span><span class="o">-&gt;</span><span class="n">hw_params</span><span class="p">.</span><span class="n">sens</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">disable_sens_cal</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;Start il4965_init_sensitivity</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Clear driver&#39;s sensitivity algo data */</span>
	<span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">sensitivity_data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ranges</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_sensitivity_data</span><span class="p">));</span>

	<span class="n">data</span><span class="o">-&gt;</span><span class="n">num_in_cck_no_fa</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_curr_state</span> <span class="o">=</span> <span class="n">IL_FA_TOO_MANY</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_prev_state</span> <span class="o">=</span> <span class="n">IL_FA_TOO_MANY</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_silence_ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_silence_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_energy_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NRG_NUM_PREV_STAT_L</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_silence_rssi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm</span> <span class="o">=</span> <span class="n">ranges</span><span class="o">-&gt;</span><span class="n">auto_corr_min_ofdm</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm_mrc</span> <span class="o">=</span> <span class="n">ranges</span><span class="o">-&gt;</span><span class="n">auto_corr_min_ofdm_mrc</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm_x1</span> <span class="o">=</span> <span class="n">ranges</span><span class="o">-&gt;</span><span class="n">auto_corr_min_ofdm_x1</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_ofdm_mrc_x1</span> <span class="o">=</span> <span class="n">ranges</span><span class="o">-&gt;</span><span class="n">auto_corr_min_ofdm_mrc_x1</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_cck</span> <span class="o">=</span> <span class="n">AUTO_CORR_CCK_MIN_VAL_DEF</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">auto_corr_cck_mrc</span> <span class="o">=</span> <span class="n">ranges</span><span class="o">-&gt;</span><span class="n">auto_corr_min_cck_mrc</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_th_cck</span> <span class="o">=</span> <span class="n">ranges</span><span class="o">-&gt;</span><span class="n">nrg_th_cck</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_th_ofdm</span> <span class="o">=</span> <span class="n">ranges</span><span class="o">-&gt;</span><span class="n">nrg_th_ofdm</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">barker_corr_th_min</span> <span class="o">=</span> <span class="n">ranges</span><span class="o">-&gt;</span><span class="n">barker_corr_th_min</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">barker_corr_th_min_mrc</span> <span class="o">=</span> <span class="n">ranges</span><span class="o">-&gt;</span><span class="n">barker_corr_th_min_mrc</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">nrg_th_cca</span> <span class="o">=</span> <span class="n">ranges</span><span class="o">-&gt;</span><span class="n">nrg_th_cca</span><span class="p">;</span>

	<span class="n">data</span><span class="o">-&gt;</span><span class="n">last_bad_plcp_cnt_ofdm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">last_fa_cnt_ofdm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">last_bad_plcp_cnt_cck</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">last_fa_cnt_cck</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">|=</span> <span class="n">il4965_sensitivity_write</span><span class="p">(</span><span class="n">il</span><span class="p">);</span>
	<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;&lt;&lt;return 0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">il4965_sensitivity_calibration</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">resp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">rx_enable_time</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fa_cck</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fa_ofdm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bad_plcp_cck</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bad_plcp_ofdm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">norm_fa_ofdm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">norm_fa_cck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_sensitivity_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">stats_rx_non_phy</span> <span class="o">*</span><span class="n">rx_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">stats_rx_phy</span> <span class="o">*</span><span class="n">ofdm</span><span class="p">,</span> <span class="o">*</span><span class="n">cck</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">stats_general_data</span> <span class="n">statis</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">disable_sens_cal</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">sensitivity_data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">il_is_any_associated</span><span class="p">(</span><span class="n">il</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;&lt;&lt; - not associated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">rx_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(((</span><span class="k">struct</span> <span class="n">il_notif_stats</span> <span class="o">*</span><span class="p">)</span><span class="n">resp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">general</span><span class="p">);</span>
	<span class="n">ofdm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(((</span><span class="k">struct</span> <span class="n">il_notif_stats</span> <span class="o">*</span><span class="p">)</span><span class="n">resp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">ofdm</span><span class="p">);</span>
	<span class="n">cck</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(((</span><span class="k">struct</span> <span class="n">il_notif_stats</span> <span class="o">*</span><span class="p">)</span><span class="n">resp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">cck</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rx_info</span><span class="o">-&gt;</span><span class="n">interference_data_flag</span> <span class="o">!=</span> <span class="n">INTERFERENCE_DATA_AVAILABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;&lt;&lt; invalid data.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Extract Statistics: */</span>
	<span class="n">rx_enable_time</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_info</span><span class="o">-&gt;</span><span class="n">channel_load</span><span class="p">);</span>
	<span class="n">fa_cck</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cck</span><span class="o">-&gt;</span><span class="n">false_alarm_cnt</span><span class="p">);</span>
	<span class="n">fa_ofdm</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ofdm</span><span class="o">-&gt;</span><span class="n">false_alarm_cnt</span><span class="p">);</span>
	<span class="n">bad_plcp_cck</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cck</span><span class="o">-&gt;</span><span class="n">plcp_err</span><span class="p">);</span>
	<span class="n">bad_plcp_ofdm</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ofdm</span><span class="o">-&gt;</span><span class="n">plcp_err</span><span class="p">);</span>

	<span class="n">statis</span><span class="p">.</span><span class="n">beacon_silence_rssi_a</span> <span class="o">=</span>
	    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_info</span><span class="o">-&gt;</span><span class="n">beacon_silence_rssi_a</span><span class="p">);</span>
	<span class="n">statis</span><span class="p">.</span><span class="n">beacon_silence_rssi_b</span> <span class="o">=</span>
	    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_info</span><span class="o">-&gt;</span><span class="n">beacon_silence_rssi_b</span><span class="p">);</span>
	<span class="n">statis</span><span class="p">.</span><span class="n">beacon_silence_rssi_c</span> <span class="o">=</span>
	    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_info</span><span class="o">-&gt;</span><span class="n">beacon_silence_rssi_c</span><span class="p">);</span>
	<span class="n">statis</span><span class="p">.</span><span class="n">beacon_energy_a</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_info</span><span class="o">-&gt;</span><span class="n">beacon_energy_a</span><span class="p">);</span>
	<span class="n">statis</span><span class="p">.</span><span class="n">beacon_energy_b</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_info</span><span class="o">-&gt;</span><span class="n">beacon_energy_b</span><span class="p">);</span>
	<span class="n">statis</span><span class="p">.</span><span class="n">beacon_energy_c</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_info</span><span class="o">-&gt;</span><span class="n">beacon_energy_c</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;rx_enable_time = %u usecs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rx_enable_time</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx_enable_time</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;&lt;&lt; RX Enable Time == 0!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* These stats increase monotonically, and do not reset</span>
<span class="cm">	 *   at each beacon.  Calculate difference from last value, or just</span>
<span class="cm">	 *   use the new stats value if it has reset or wrapped around. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">last_bad_plcp_cnt_cck</span> <span class="o">&gt;</span> <span class="n">bad_plcp_cck</span><span class="p">)</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">last_bad_plcp_cnt_cck</span> <span class="o">=</span> <span class="n">bad_plcp_cck</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">bad_plcp_cck</span> <span class="o">-=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">last_bad_plcp_cnt_cck</span><span class="p">;</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">last_bad_plcp_cnt_cck</span> <span class="o">+=</span> <span class="n">bad_plcp_cck</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">last_bad_plcp_cnt_ofdm</span> <span class="o">&gt;</span> <span class="n">bad_plcp_ofdm</span><span class="p">)</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">last_bad_plcp_cnt_ofdm</span> <span class="o">=</span> <span class="n">bad_plcp_ofdm</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">bad_plcp_ofdm</span> <span class="o">-=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">last_bad_plcp_cnt_ofdm</span><span class="p">;</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">last_bad_plcp_cnt_ofdm</span> <span class="o">+=</span> <span class="n">bad_plcp_ofdm</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">last_fa_cnt_ofdm</span> <span class="o">&gt;</span> <span class="n">fa_ofdm</span><span class="p">)</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">last_fa_cnt_ofdm</span> <span class="o">=</span> <span class="n">fa_ofdm</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">fa_ofdm</span> <span class="o">-=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">last_fa_cnt_ofdm</span><span class="p">;</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">last_fa_cnt_ofdm</span> <span class="o">+=</span> <span class="n">fa_ofdm</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">last_fa_cnt_cck</span> <span class="o">&gt;</span> <span class="n">fa_cck</span><span class="p">)</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">last_fa_cnt_cck</span> <span class="o">=</span> <span class="n">fa_cck</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">fa_cck</span> <span class="o">-=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">last_fa_cnt_cck</span><span class="p">;</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">last_fa_cnt_cck</span> <span class="o">+=</span> <span class="n">fa_cck</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Total aborted signal locks */</span>
	<span class="n">norm_fa_ofdm</span> <span class="o">=</span> <span class="n">fa_ofdm</span> <span class="o">+</span> <span class="n">bad_plcp_ofdm</span><span class="p">;</span>
	<span class="n">norm_fa_cck</span> <span class="o">=</span> <span class="n">fa_cck</span> <span class="o">+</span> <span class="n">bad_plcp_cck</span><span class="p">;</span>

	<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;cck: fa %u badp %u  ofdm: fa %u badp %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fa_cck</span><span class="p">,</span>
		<span class="n">bad_plcp_cck</span><span class="p">,</span> <span class="n">fa_ofdm</span><span class="p">,</span> <span class="n">bad_plcp_ofdm</span><span class="p">);</span>

	<span class="n">il4965_sens_auto_corr_ofdm</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">norm_fa_ofdm</span><span class="p">,</span> <span class="n">rx_enable_time</span><span class="p">);</span>
	<span class="n">il4965_sens_energy_cck</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">norm_fa_cck</span><span class="p">,</span> <span class="n">rx_enable_time</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">statis</span><span class="p">);</span>

	<span class="n">il4965_sensitivity_write</span><span class="p">(</span><span class="n">il</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span>
<span class="nf">il4965_find_first_chain</span><span class="p">(</span><span class="n">u8</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">ANT_A</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">CHAIN_A</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">ANT_B</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">CHAIN_B</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">CHAIN_C</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Run disconnected antenna algorithm to find out which antennas are</span>
<span class="cm"> * disconnected.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">il4965_find_disconn_antenna</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span> <span class="n">average_sig</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">il_chain_noise_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">active_chains</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">max_average_sig</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">max_average_sig_antenna_i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">num_tx_chains</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">first_chain</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">average_sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
	    <span class="n">data</span><span class="o">-&gt;</span><span class="n">chain_signal_a</span> <span class="o">/</span>
	    <span class="n">il</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">chain_noise_num_beacons</span><span class="p">;</span>
	<span class="n">average_sig</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
	    <span class="n">data</span><span class="o">-&gt;</span><span class="n">chain_signal_b</span> <span class="o">/</span>
	    <span class="n">il</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">chain_noise_num_beacons</span><span class="p">;</span>
	<span class="n">average_sig</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>
	    <span class="n">data</span><span class="o">-&gt;</span><span class="n">chain_signal_c</span> <span class="o">/</span>
	    <span class="n">il</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">chain_noise_num_beacons</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">average_sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">average_sig</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">max_average_sig</span> <span class="o">=</span> <span class="n">average_sig</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">max_average_sig_antenna_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">active_chains</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">max_average_sig_antenna_i</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">max_average_sig</span> <span class="o">=</span> <span class="n">average_sig</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">max_average_sig_antenna_i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">active_chains</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">max_average_sig_antenna_i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">average_sig</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">max_average_sig</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">max_average_sig</span> <span class="o">=</span> <span class="n">average_sig</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
		<span class="n">max_average_sig_antenna_i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">active_chains</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">max_average_sig_antenna_i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;average_sig: a %d b %d c %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">average_sig</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">average_sig</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
		<span class="n">average_sig</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;max_average_sig = %d, antenna %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">max_average_sig</span><span class="p">,</span>
		<span class="n">max_average_sig_antenna_i</span><span class="p">);</span>

	<span class="cm">/* Compare signal strengths for all 3 receivers. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_RX_CHAINS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">max_average_sig_antenna_i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">s32</span> <span class="n">rssi_delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_average_sig</span> <span class="o">-</span> <span class="n">average_sig</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

			<span class="cm">/* If signal is very weak, compared with</span>
<span class="cm">			 * strongest, mark it as disconnected. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rssi_delta</span> <span class="o">&gt;</span> <span class="n">MAXIMUM_ALLOWED_PATHLOSS</span><span class="p">)</span>
				<span class="n">data</span><span class="o">-&gt;</span><span class="n">disconn_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">active_chains</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;i = %d  rssiDelta = %d  &quot;</span>
				<span class="s">&quot;disconn_array[i] = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">rssi_delta</span><span class="p">,</span>
				<span class="n">data</span><span class="o">-&gt;</span><span class="n">disconn_array</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The above algorithm sometimes fails when the ucode</span>
<span class="cm">	 * reports 0 for all chains. It&#39;s not clear why that</span>
<span class="cm">	 * happens to start with, but it is then causing trouble</span>
<span class="cm">	 * because this can make us enable more chains than the</span>
<span class="cm">	 * hardware really has.</span>
<span class="cm">	 *</span>
<span class="cm">	 * To be safe, simply mask out any chains that we know</span>
<span class="cm">	 * are not on the device.</span>
<span class="cm">	 */</span>
	<span class="n">active_chains</span> <span class="o">&amp;=</span> <span class="n">il</span><span class="o">-&gt;</span><span class="n">hw_params</span><span class="p">.</span><span class="n">valid_rx_ant</span><span class="p">;</span>

	<span class="n">num_tx_chains</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_RX_CHAINS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* loops on all the bits of</span>
<span class="cm">		 * il-&gt;hw_setting.valid_tx_ant */</span>
		<span class="n">u8</span> <span class="n">ant_msk</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">hw_params</span><span class="p">.</span><span class="n">valid_tx_ant</span> <span class="o">&amp;</span> <span class="n">ant_msk</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">num_tx_chains</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">disconn_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="cm">/* there is a Tx antenna connected */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num_tx_chains</span> <span class="o">==</span> <span class="n">il</span><span class="o">-&gt;</span><span class="n">hw_params</span><span class="p">.</span><span class="n">tx_chains_num</span> <span class="o">&amp;&amp;</span>
		    <span class="n">data</span><span class="o">-&gt;</span><span class="n">disconn_array</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If all chains are disconnected</span>
<span class="cm">			 * connect the first valid tx chain</span>
<span class="cm">			 */</span>
			<span class="n">first_chain</span> <span class="o">=</span>
			    <span class="n">il4965_find_first_chain</span><span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">valid_tx_ant</span><span class="p">);</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">disconn_array</span><span class="p">[</span><span class="n">first_chain</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">active_chains</span> <span class="o">|=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">first_chain</span><span class="p">);</span>
			<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;All Tx chains are disconnected&quot;</span>
				<span class="s">&quot;- declare %d as connected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">first_chain</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">active_chains</span> <span class="o">!=</span> <span class="n">il</span><span class="o">-&gt;</span><span class="n">hw_params</span><span class="p">.</span><span class="n">valid_rx_ant</span> <span class="o">&amp;&amp;</span>
	    <span class="n">active_chains</span> <span class="o">!=</span> <span class="n">il</span><span class="o">-&gt;</span><span class="n">chain_noise_data</span><span class="p">.</span><span class="n">active_chains</span><span class="p">)</span>
		<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;Detected that not all antennas are connected! &quot;</span>
			<span class="s">&quot;Connected: %#x, valid: %#x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">active_chains</span><span class="p">,</span>
			<span class="n">il</span><span class="o">-&gt;</span><span class="n">hw_params</span><span class="p">.</span><span class="n">valid_rx_ant</span><span class="p">);</span>

	<span class="cm">/* Save for use within RXON, TX, SCAN commands, etc. */</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">active_chains</span> <span class="o">=</span> <span class="n">active_chains</span><span class="p">;</span>
	<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;active_chains (bitwise) = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">active_chains</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">il4965_gain_computation</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span> <span class="n">average_noise</span><span class="p">,</span>
			<span class="n">u16</span> <span class="n">min_average_noise_antenna_i</span><span class="p">,</span> <span class="n">u32</span> <span class="n">min_average_noise</span><span class="p">,</span>
			<span class="n">u8</span> <span class="n">default_chain</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_chain_noise_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">chain_noise_data</span><span class="p">;</span>

	<span class="n">data</span><span class="o">-&gt;</span><span class="n">delta_gain_code</span><span class="p">[</span><span class="n">min_average_noise_antenna_i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">default_chain</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_RX_CHAINS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s32</span> <span class="n">delta_g</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">disconn_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
		    <span class="n">data</span><span class="o">-&gt;</span><span class="n">delta_gain_code</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span>
		    <span class="n">CHAIN_NOISE_DELTA_GAIN_INIT_VAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">delta_g</span> <span class="o">=</span> <span class="n">average_noise</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_average_noise</span><span class="p">;</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">delta_gain_code</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">((</span><span class="n">delta_g</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span> <span class="o">/</span> <span class="mi">15</span><span class="p">);</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">delta_gain_code</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			    <span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">delta_gain_code</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				<span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">CHAIN_NOISE_MAX_DELTA_GAIN_CODE</span><span class="p">);</span>

			<span class="n">data</span><span class="o">-&gt;</span><span class="n">delta_gain_code</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">delta_gain_code</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">delta_gain_code</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;delta_gain_codes: a %d b %d c %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">delta_gain_code</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">delta_gain_code</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">delta_gain_code</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

	<span class="cm">/* Differential gain gets sent to uCode only once */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">radio_write</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">il_calib_diff_gain_cmd</span> <span class="n">cmd</span><span class="p">;</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">radio_write</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">op_code</span> <span class="o">=</span> <span class="n">IL_PHY_CALIBRATE_DIFF_GAIN_CMD</span><span class="p">;</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">diff_gain_a</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">delta_gain_code</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">diff_gain_b</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">delta_gain_code</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">diff_gain_c</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">delta_gain_code</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">il_send_cmd_pdu</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">C_PHY_CALIBRATION</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;fail sending cmd &quot;</span> <span class="s">&quot;C_PHY_CALIBRATION</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* TODO we might want recalculate</span>
<span class="cm">		 * rx_chain in rxon cmd */</span>

		<span class="cm">/* Mark so we run this algo only once! */</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">IL_CHAIN_NOISE_CALIBRATED</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Accumulate 16 beacons of signal and noise stats for each of</span>
<span class="cm"> *   3 receivers/antennas/rx-chains, then figure out:</span>
<span class="cm"> * 1)  Which antennas are connected.</span>
<span class="cm"> * 2)  Differential rx gain settings to balance the 3 receivers.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">il4965_chain_noise_calibration</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">stat_resp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">il_chain_noise_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">chain_noise_a</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chain_noise_b</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chain_noise_c</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chain_sig_a</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chain_sig_b</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chain_sig_c</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">average_sig</span><span class="p">[</span><span class="n">NUM_RX_CHAINS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">INITIALIZATION_VALUE</span> <span class="p">};</span>
	<span class="n">u32</span> <span class="n">average_noise</span><span class="p">[</span><span class="n">NUM_RX_CHAINS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">INITIALIZATION_VALUE</span> <span class="p">};</span>
	<span class="n">u32</span> <span class="n">min_average_noise</span> <span class="o">=</span> <span class="n">MIN_AVERAGE_NOISE_MAX_VALUE</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">min_average_noise_antenna_i</span> <span class="o">=</span> <span class="n">INITIALIZATION_VALUE</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">rxon_chnum</span> <span class="o">=</span> <span class="n">INITIALIZATION_VALUE</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">stat_chnum</span> <span class="o">=</span> <span class="n">INITIALIZATION_VALUE</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">rxon_band24</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">stat_band24</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">stats_rx_non_phy</span> <span class="o">*</span><span class="n">rx_info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">disable_chain_noise_cal</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">chain_noise_data</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Accumulate just the first &quot;chain_noise_num_beacons&quot; after</span>
<span class="cm">	 * the first association, then we&#39;re done forever.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">IL_CHAIN_NOISE_ACCUMULATE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">IL_CHAIN_NOISE_ALIVE</span><span class="p">)</span>
			<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;Wait for noise calib reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">rx_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(((</span><span class="k">struct</span> <span class="n">il_notif_stats</span> <span class="o">*</span><span class="p">)</span><span class="n">stat_resp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">general</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rx_info</span><span class="o">-&gt;</span><span class="n">interference_data_flag</span> <span class="o">!=</span> <span class="n">INTERFERENCE_DATA_AVAILABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot; &lt;&lt; Interference data unavailable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rxon_band24</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">staging</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RXON_FLG_BAND_24G_MSK</span><span class="p">);</span>
	<span class="n">rxon_chnum</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">staging</span><span class="p">.</span><span class="n">channel</span><span class="p">);</span>

	<span class="n">stat_band24</span> <span class="o">=</span>
	    <span class="o">!!</span><span class="p">(((</span><span class="k">struct</span> <span class="n">il_notif_stats</span> <span class="o">*</span><span class="p">)</span><span class="n">stat_resp</span><span class="p">)</span><span class="o">-&gt;</span>
	       <span class="n">flag</span> <span class="o">&amp;</span> <span class="n">STATS_REPLY_FLG_BAND_24G_MSK</span><span class="p">);</span>
	<span class="n">stat_chnum</span> <span class="o">=</span>
	    <span class="n">le32_to_cpu</span><span class="p">(((</span><span class="k">struct</span> <span class="n">il_notif_stats</span> <span class="o">*</span><span class="p">)</span><span class="n">stat_resp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>

	<span class="cm">/* Make sure we accumulate data for just the associated channel</span>
<span class="cm">	 *   (even if scanning). */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rxon_chnum</span> <span class="o">!=</span> <span class="n">stat_chnum</span> <span class="o">||</span> <span class="n">rxon_band24</span> <span class="o">!=</span> <span class="n">stat_band24</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;Stats not from chan=%d, band24=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rxon_chnum</span><span class="p">,</span>
			<span class="n">rxon_band24</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Accumulate beacon stats values across</span>
<span class="cm">	 * &quot;chain_noise_num_beacons&quot;</span>
<span class="cm">	 */</span>
	<span class="n">chain_noise_a</span> <span class="o">=</span>
	    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_info</span><span class="o">-&gt;</span><span class="n">beacon_silence_rssi_a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IN_BAND_FILTER</span><span class="p">;</span>
	<span class="n">chain_noise_b</span> <span class="o">=</span>
	    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_info</span><span class="o">-&gt;</span><span class="n">beacon_silence_rssi_b</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IN_BAND_FILTER</span><span class="p">;</span>
	<span class="n">chain_noise_c</span> <span class="o">=</span>
	    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_info</span><span class="o">-&gt;</span><span class="n">beacon_silence_rssi_c</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IN_BAND_FILTER</span><span class="p">;</span>

	<span class="n">chain_sig_a</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_info</span><span class="o">-&gt;</span><span class="n">beacon_rssi_a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IN_BAND_FILTER</span><span class="p">;</span>
	<span class="n">chain_sig_b</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_info</span><span class="o">-&gt;</span><span class="n">beacon_rssi_b</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IN_BAND_FILTER</span><span class="p">;</span>
	<span class="n">chain_sig_c</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_info</span><span class="o">-&gt;</span><span class="n">beacon_rssi_c</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IN_BAND_FILTER</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">data</span><span class="o">-&gt;</span><span class="n">beacon_count</span><span class="o">++</span><span class="p">;</span>

	<span class="n">data</span><span class="o">-&gt;</span><span class="n">chain_noise_a</span> <span class="o">=</span> <span class="p">(</span><span class="n">chain_noise_a</span> <span class="o">+</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">chain_noise_a</span><span class="p">);</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">chain_noise_b</span> <span class="o">=</span> <span class="p">(</span><span class="n">chain_noise_b</span> <span class="o">+</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">chain_noise_b</span><span class="p">);</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">chain_noise_c</span> <span class="o">=</span> <span class="p">(</span><span class="n">chain_noise_c</span> <span class="o">+</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">chain_noise_c</span><span class="p">);</span>

	<span class="n">data</span><span class="o">-&gt;</span><span class="n">chain_signal_a</span> <span class="o">=</span> <span class="p">(</span><span class="n">chain_sig_a</span> <span class="o">+</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">chain_signal_a</span><span class="p">);</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">chain_signal_b</span> <span class="o">=</span> <span class="p">(</span><span class="n">chain_sig_b</span> <span class="o">+</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">chain_signal_b</span><span class="p">);</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">chain_signal_c</span> <span class="o">=</span> <span class="p">(</span><span class="n">chain_sig_c</span> <span class="o">+</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">chain_signal_c</span><span class="p">);</span>

	<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;chan=%d, band24=%d, beacon=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rxon_chnum</span><span class="p">,</span> <span class="n">rxon_band24</span><span class="p">,</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">beacon_count</span><span class="p">);</span>
	<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;chain_sig: a %d b %d c %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chain_sig_a</span><span class="p">,</span> <span class="n">chain_sig_b</span><span class="p">,</span>
		<span class="n">chain_sig_c</span><span class="p">);</span>
	<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;chain_noise: a %d b %d c %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chain_noise_a</span><span class="p">,</span> <span class="n">chain_noise_b</span><span class="p">,</span>
		<span class="n">chain_noise_c</span><span class="p">);</span>

	<span class="cm">/* If this is the &quot;chain_noise_num_beacons&quot;, determine:</span>
<span class="cm">	 * 1)  Disconnected antennas (using signal strengths)</span>
<span class="cm">	 * 2)  Differential gain (using silence noise) to balance receivers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">beacon_count</span> <span class="o">!=</span> <span class="n">il</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">chain_noise_num_beacons</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Analyze signal for disconnected antenna */</span>
	<span class="n">il4965_find_disconn_antenna</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">average_sig</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="cm">/* Analyze noise for rx balance */</span>
	<span class="n">average_noise</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
	    <span class="n">data</span><span class="o">-&gt;</span><span class="n">chain_noise_a</span> <span class="o">/</span> <span class="n">il</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">chain_noise_num_beacons</span><span class="p">;</span>
	<span class="n">average_noise</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
	    <span class="n">data</span><span class="o">-&gt;</span><span class="n">chain_noise_b</span> <span class="o">/</span> <span class="n">il</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">chain_noise_num_beacons</span><span class="p">;</span>
	<span class="n">average_noise</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>
	    <span class="n">data</span><span class="o">-&gt;</span><span class="n">chain_noise_c</span> <span class="o">/</span> <span class="n">il</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">chain_noise_num_beacons</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_RX_CHAINS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">disconn_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
		    <span class="n">average_noise</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">min_average_noise</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This means that chain i is active and has</span>
<span class="cm">			 * lower noise values so far: */</span>
			<span class="n">min_average_noise</span> <span class="o">=</span> <span class="n">average_noise</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">min_average_noise_antenna_i</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;average_noise: a %d b %d c %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">average_noise</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		<span class="n">average_noise</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">average_noise</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

	<span class="n">D_CALIB</span><span class="p">(</span><span class="s">&quot;min_average_noise = %d, antenna %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">min_average_noise</span><span class="p">,</span>
		<span class="n">min_average_noise_antenna_i</span><span class="p">);</span>

	<span class="n">il4965_gain_computation</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">average_noise</span><span class="p">,</span> <span class="n">min_average_noise_antenna_i</span><span class="p">,</span>
				<span class="n">min_average_noise</span><span class="p">,</span>
				<span class="n">il4965_find_first_chain</span><span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">valid_rx_ant</span><span class="p">));</span>

	<span class="cm">/* Some power changes may have been made during the calibration.</span>
<span class="cm">	 * Update and commit the RXON</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">update_chain_flags</span><span class="p">)</span>
		<span class="n">il</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">update_chain_flags</span><span class="p">(</span><span class="n">il</span><span class="p">);</span>

	<span class="n">data</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">IL_CHAIN_NOISE_DONE</span><span class="p">;</span>
	<span class="n">il_power_update_mode</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">il4965_reset_run_time_calib</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">sensitivity_data</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_sensitivity_data</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">chain_noise_data</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_chain_noise_data</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_RX_CHAINS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">il</span><span class="o">-&gt;</span><span class="n">chain_noise_data</span><span class="p">.</span><span class="n">delta_gain_code</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
		    <span class="n">CHAIN_NOISE_DELTA_GAIN_INIT_VAL</span><span class="p">;</span>

	<span class="cm">/* Ask for stats now, the uCode will send notification</span>
<span class="cm">	 * periodically after association */</span>
	<span class="n">il_send_stats_request</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">CMD_ASYNC</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
