<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › iwlegacy › 4965.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>4965.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * GPL LICENSE SUMMARY</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of version 2 of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,</span>
<span class="cm"> * USA</span>
<span class="cm"> *</span>
<span class="cm"> * The full GNU General Public License is included in this distribution</span>
<span class="cm"> * in the file called LICENSE.GPL.</span>
<span class="cm"> *</span>
<span class="cm"> * Contact Information:</span>
<span class="cm"> *  Intel Linux Wireless &lt;ilw@linux.intel.com&gt;</span>
<span class="cm"> * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cp">#ifndef __il_4965_h__</span>
<span class="cp">#define __il_4965_h__</span>

<span class="k">struct</span> <span class="n">il_rx_queue</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">il_rx_buf</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">il_rx_pkt</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">il_tx_queue</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">il_rxon_context</span><span class="p">;</span>

<span class="cm">/* configuration for the _4965 devices */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">il_cfg</span> <span class="n">il4965_cfg</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">il_ops</span> <span class="n">il4965_ops</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">il_mod_params</span> <span class="n">il4965_mod_params</span><span class="p">;</span>

<span class="cm">/* tx queue */</span>
<span class="kt">void</span> <span class="n">il4965_free_tfds_in_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sta_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tid</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">freed</span><span class="p">);</span>

<span class="cm">/* RXON */</span>
<span class="kt">void</span> <span class="n">il4965_set_rxon_chain</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>

<span class="cm">/* uCode */</span>
<span class="kt">int</span> <span class="n">il4965_verify_ucode</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>

<span class="cm">/* lib */</span>
<span class="kt">void</span> <span class="n">il4965_check_abort_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u8</span> <span class="n">frame_count</span><span class="p">,</span> <span class="n">u32</span> <span class="n">status</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">il4965_rx_queue_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_rx_queue</span> <span class="o">*</span><span class="n">rxq</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_rx_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_rx_queue</span> <span class="o">*</span><span class="n">rxq</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_hw_nic_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_dump_fh</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">buf</span><span class="p">,</span> <span class="n">bool</span> <span class="n">display</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">il4965_nic_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>

<span class="cm">/* rx */</span>
<span class="kt">void</span> <span class="n">il4965_rx_queue_restock</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il4965_rx_replenish</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il4965_rx_replenish_now</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il4965_rx_queue_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_rx_queue</span> <span class="o">*</span><span class="n">rxq</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_rxq_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_hwrate_to_mac80211_idx</span><span class="p">(</span><span class="n">u32</span> <span class="n">rate_n_flags</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il4965_rx_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>

<span class="cm">/* tx */</span>
<span class="kt">void</span> <span class="n">il4965_hw_txq_free_tfd</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_hw_txq_attach_buf_to_tfd</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">,</span>
				    <span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u16</span> <span class="n">len</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reset</span><span class="p">,</span> <span class="n">u8</span> <span class="n">pad</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_hw_tx_queue_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il4965_hwrate_to_tx_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="n">rate_n_flags</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ieee80211_tx_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_tx_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_tx_agg_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="n">u16</span> <span class="n">tid</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span> <span class="n">ssn</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_tx_agg_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="n">u16</span> <span class="n">tid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_txq_check_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sta_id</span><span class="p">,</span> <span class="n">u8</span> <span class="n">tid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">txq_id</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_tx_queue_reclaim</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="kt">int</span> <span class="n">txq_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il4965_hw_txq_ctx_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_txq_ctx_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il4965_txq_ctx_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il4965_txq_ctx_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il4965_txq_set_sched</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Acquire il-&gt;lock before calling this function !</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">il4965_set_wr_ptrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="kt">int</span> <span class="n">txq_id</span><span class="p">,</span> <span class="n">u32</span> <span class="n">idx</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * il4965_tx_queue_set_status - (optionally) start Tx/Cmd queue</span>
<span class="cm"> * @tx_fifo_id: Tx DMA/FIFO channel (range 0-7) that the queue will feed</span>
<span class="cm"> * @scd_retry: (1) Indicates queue will be used in aggregation mode</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  Acquire il-&gt;lock before calling this function !</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">il4965_tx_queue_set_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">tx_fifo_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">scd_retry</span><span class="p">);</span>

<span class="cm">/* scan */</span>
<span class="kt">int</span> <span class="n">il4965_request_scan</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>

<span class="cm">/* station mgmt */</span>
<span class="kt">int</span> <span class="n">il4965_manage_ibss_station</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
			       <span class="n">bool</span> <span class="n">add</span><span class="p">);</span>

<span class="cm">/* hcmd */</span>
<span class="kt">int</span> <span class="n">il4965_send_beacon_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_IWLEGACY_DEBUG</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">il4965_get_tx_fail_reason</span><span class="p">(</span><span class="n">u32</span> <span class="n">status</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">il4965_get_tx_fail_reason</span><span class="p">(</span><span class="n">u32</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* station management */</span>
<span class="kt">int</span> <span class="n">il4965_alloc_bcast_station</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_add_bssid_station</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">sta_id_r</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_remove_default_wep_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ieee80211_key_conf</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_set_default_wep_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ieee80211_key_conf</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_restore_default_wep_keys</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_set_dynamic_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">ieee80211_key_conf</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">u8</span> <span class="n">sta_id</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_remove_dynamic_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ieee80211_key_conf</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">u8</span> <span class="n">sta_id</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il4965_update_tkip_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ieee80211_key_conf</span> <span class="o">*</span><span class="n">keyconf</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="n">u32</span> <span class="n">iv32</span><span class="p">,</span>
			    <span class="n">u16</span> <span class="o">*</span><span class="n">phase1key</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_sta_tx_modify_enable_tid</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sta_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_sta_rx_agg_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">tid</span><span class="p">,</span> <span class="n">u16</span> <span class="n">ssn</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_sta_rx_agg_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">tid</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il4965_sta_modify_sleep_tx_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sta_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_update_bcast_stations</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>

<span class="cm">/* rate */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span>
<span class="nf">il4965_hw_get_rate</span><span class="p">(</span><span class="n">__le32</span> <span class="n">rate_n_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rate_n_flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* eeprom */</span>
<span class="kt">void</span> <span class="n">il4965_eeprom_get_mac</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span> <span class="n">mac</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_eeprom_acquire_semaphore</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il4965_eeprom_release_semaphore</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_eeprom_check_version</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>

<span class="cm">/* mac80211 handlers (for 4965) */</span>
<span class="kt">void</span> <span class="n">il4965_mac_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_mac_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il4965_mac_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il4965_configure_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">changed_flags</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">total_flags</span><span class="p">,</span> <span class="n">u64</span> <span class="n">multicast</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_mac_set_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">enum</span> <span class="n">set_key_cmd</span> <span class="n">cmd</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">ieee80211_key_conf</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il4965_mac_update_tkip_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ieee80211_key_conf</span> <span class="o">*</span><span class="n">keyconf</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="n">u32</span> <span class="n">iv32</span><span class="p">,</span>
				<span class="n">u16</span> <span class="o">*</span><span class="n">phase1key</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_mac_ampdu_action</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
			    <span class="k">enum</span> <span class="n">ieee80211_ampdu_mlme_action</span> <span class="n">action</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="n">u16</span> <span class="n">tid</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span> <span class="n">ssn</span><span class="p">,</span>
			    <span class="n">u8</span> <span class="n">buf_size</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il4965_mac_sta_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il4965_mac_channel_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ieee80211_channel_switch</span> <span class="o">*</span><span class="n">ch_switch</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">il4965_led_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>

<span class="cm">/* EEPROM */</span>
<span class="cp">#define IL4965_EEPROM_IMG_SIZE			1024</span>

<span class="cm">/*</span>
<span class="cm"> * uCode queue management definitions ...</span>
<span class="cm"> * The first queue used for block-ack aggregation is #7 (4965 only).</span>
<span class="cm"> * All block-ack aggregation queues should map to Tx DMA/FIFO channel 7.</span>
<span class="cm"> */</span>
<span class="cp">#define IL49_FIRST_AMPDU_QUEUE	7</span>

<span class="cm">/* Sizes and addresses for instruction and data memory (SRAM) in</span>
<span class="cm"> * 4965&#39;s embedded processor.  Driver access is via HBUS_TARG_MEM_* regs. */</span>
<span class="cp">#define IL49_RTC_INST_LOWER_BOUND		(0x000000)</span>
<span class="cp">#define IL49_RTC_INST_UPPER_BOUND		(0x018000)</span>

<span class="cp">#define IL49_RTC_DATA_LOWER_BOUND		(0x800000)</span>
<span class="cp">#define IL49_RTC_DATA_UPPER_BOUND		(0x80A000)</span>

<span class="cp">#define IL49_RTC_INST_SIZE  (IL49_RTC_INST_UPPER_BOUND - \</span>
<span class="cp">				IL49_RTC_INST_LOWER_BOUND)</span>
<span class="cp">#define IL49_RTC_DATA_SIZE  (IL49_RTC_DATA_UPPER_BOUND - \</span>
<span class="cp">				IL49_RTC_DATA_LOWER_BOUND)</span>

<span class="cp">#define IL49_MAX_INST_SIZE IL49_RTC_INST_SIZE</span>
<span class="cp">#define IL49_MAX_DATA_SIZE IL49_RTC_DATA_SIZE</span>

<span class="cm">/* Size of uCode instruction memory in bootstrap state machine */</span>
<span class="cp">#define IL49_MAX_BSM_SIZE BSM_SRAM_SIZE</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">il4965_hw_valid_rtc_data_addr</span><span class="p">(</span><span class="n">u32</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">IL49_RTC_DATA_LOWER_BOUND</span> <span class="o">&amp;&amp;</span>
		<span class="n">addr</span> <span class="o">&lt;</span> <span class="n">IL49_RTC_DATA_UPPER_BOUND</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/********************* START TEMPERATURE *************************************/</span>

<span class="cm">/**</span>
<span class="cm"> * 4965 temperature calculation.</span>
<span class="cm"> *</span>
<span class="cm"> * The driver must calculate the device temperature before calculating</span>
<span class="cm"> * a txpower setting (amplifier gain is temperature dependent).  The</span>
<span class="cm"> * calculation uses 4 measurements, 3 of which (R1, R2, R3) are calibration</span>
<span class="cm"> * values used for the life of the driver, and one of which (R4) is the</span>
<span class="cm"> * real-time temperature indicator.</span>
<span class="cm"> *</span>
<span class="cm"> * uCode provides all 4 values to the driver via the &quot;initialize alive&quot;</span>
<span class="cm"> * notification (see struct il4965_init_alive_resp).  After the runtime uCode</span>
<span class="cm"> * image loads, uCode updates the R4 value via stats notifications</span>
<span class="cm"> * (see N_STATS), which occur after each received beacon</span>
<span class="cm"> * when associated, or can be requested via C_STATS.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  uCode provides the R4 value as a 23-bit signed value.  Driver</span>
<span class="cm"> *        must sign-extend to 32 bits before applying formula below.</span>
<span class="cm"> *</span>
<span class="cm"> * Formula:</span>
<span class="cm"> *</span>
<span class="cm"> * degrees Kelvin = ((97 * 259 * (R4 - R2) / (R3 - R1)) / 100) + 8</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  The basic formula is 259 * (R4-R2) / (R3-R1).  The 97/100 is</span>
<span class="cm"> * an additional correction, which should be centered around 0 degrees</span>
<span class="cm"> * Celsius (273 degrees Kelvin).  The 8 (3 percent of 273) compensates for</span>
<span class="cm"> * centering the 97/100 correction around 0 degrees K.</span>
<span class="cm"> *</span>
<span class="cm"> * Add 273 to Kelvin value to find degrees Celsius, for comparing current</span>
<span class="cm"> * temperature with factory-measured temperatures when calculating txpower</span>
<span class="cm"> * settings.</span>
<span class="cm"> */</span>
<span class="cp">#define TEMPERATURE_CALIB_KELVIN_OFFSET 8</span>
<span class="cp">#define TEMPERATURE_CALIB_A_VAL 259</span>

<span class="cm">/* Limit range of calculated temperature to be between these Kelvin values */</span>
<span class="cp">#define IL_TX_POWER_TEMPERATURE_MIN  (263)</span>
<span class="cp">#define IL_TX_POWER_TEMPERATURE_MAX  (410)</span>

<span class="cp">#define IL_TX_POWER_TEMPERATURE_OUT_OF_RANGE(t) \</span>
<span class="cp">	((t) &lt; IL_TX_POWER_TEMPERATURE_MIN || \</span>
<span class="cp">	 (t) &gt; IL_TX_POWER_TEMPERATURE_MAX)</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">il4965_temperature_calib</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="cm">/********************* END TEMPERATURE ***************************************/</span>

<span class="cm">/********************* START TXPOWER *****************************************/</span>

<span class="cm">/**</span>
<span class="cm"> * 4965 txpower calculations rely on information from three sources:</span>
<span class="cm"> *</span>
<span class="cm"> *     1) EEPROM</span>
<span class="cm"> *     2) &quot;initialize&quot; alive notification</span>
<span class="cm"> *     3) stats notifications</span>
<span class="cm"> *</span>
<span class="cm"> * EEPROM data consists of:</span>
<span class="cm"> *</span>
<span class="cm"> * 1)  Regulatory information (max txpower and channel usage flags) is provided</span>
<span class="cm"> *     separately for each channel that can possibly supported by 4965.</span>
<span class="cm"> *     40 MHz wide (.11n HT40) channels are listed separately from 20 MHz</span>
<span class="cm"> *     (legacy) channels.</span>
<span class="cm"> *</span>
<span class="cm"> *     See struct il4965_eeprom_channel for format, and struct il4965_eeprom</span>
<span class="cm"> *     for locations in EEPROM.</span>
<span class="cm"> *</span>
<span class="cm"> * 2)  Factory txpower calibration information is provided separately for</span>
<span class="cm"> *     sub-bands of contiguous channels.  2.4GHz has just one sub-band,</span>
<span class="cm"> *     but 5 GHz has several sub-bands.</span>
<span class="cm"> *</span>
<span class="cm"> *     In addition, per-band (2.4 and 5 Ghz) saturation txpowers are provided.</span>
<span class="cm"> *</span>
<span class="cm"> *     See struct il4965_eeprom_calib_info (and the tree of structures</span>
<span class="cm"> *     contained within it) for format, and struct il4965_eeprom for</span>
<span class="cm"> *     locations in EEPROM.</span>
<span class="cm"> *</span>
<span class="cm"> * &quot;Initialization alive&quot; notification (see struct il4965_init_alive_resp)</span>
<span class="cm"> * consists of:</span>
<span class="cm"> *</span>
<span class="cm"> * 1)  Temperature calculation parameters.</span>
<span class="cm"> *</span>
<span class="cm"> * 2)  Power supply voltage measurement.</span>
<span class="cm"> *</span>
<span class="cm"> * 3)  Tx gain compensation to balance 2 transmitters for MIMO use.</span>
<span class="cm"> *</span>
<span class="cm"> * Statistics notifications deliver:</span>
<span class="cm"> *</span>
<span class="cm"> * 1)  Current values for temperature param R4.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * To calculate a txpower setting for a given desired target txpower, channel,</span>
<span class="cm"> * modulation bit rate, and transmitter chain (4965 has 2 transmitters to</span>
<span class="cm"> * support MIMO and transmit diversity), driver must do the following:</span>
<span class="cm"> *</span>
<span class="cm"> * 1)  Compare desired txpower vs. (EEPROM) regulatory limit for this channel.</span>
<span class="cm"> *     Do not exceed regulatory limit; reduce target txpower if necessary.</span>
<span class="cm"> *</span>
<span class="cm"> *     If setting up txpowers for MIMO rates (rate idxes 8-15, 24-31),</span>
<span class="cm"> *     2 transmitters will be used simultaneously; driver must reduce the</span>
<span class="cm"> *     regulatory limit by 3 dB (half-power) for each transmitter, so the</span>
<span class="cm"> *     combined total output of the 2 transmitters is within regulatory limits.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * 2)  Compare target txpower vs. (EEPROM) saturation txpower *reduced by</span>
<span class="cm"> *     backoff for this bit rate*.  Do not exceed (saturation - backoff[rate]);</span>
<span class="cm"> *     reduce target txpower if necessary.</span>
<span class="cm"> *</span>
<span class="cm"> *     Backoff values below are in 1/2 dB units (equivalent to steps in</span>
<span class="cm"> *     txpower gain tables):</span>
<span class="cm"> *</span>
<span class="cm"> *     OFDM 6 - 36 MBit:  10 steps (5 dB)</span>
<span class="cm"> *     OFDM 48 MBit:      15 steps (7.5 dB)</span>
<span class="cm"> *     OFDM 54 MBit:      17 steps (8.5 dB)</span>
<span class="cm"> *     OFDM 60 MBit:      20 steps (10 dB)</span>
<span class="cm"> *     CCK all rates:     10 steps (5 dB)</span>
<span class="cm"> *</span>
<span class="cm"> *     Backoff values apply to saturation txpower on a per-transmitter basis;</span>
<span class="cm"> *     when using MIMO (2 transmitters), each transmitter uses the same</span>
<span class="cm"> *     saturation level provided in EEPROM, and the same backoff values;</span>
<span class="cm"> *     no reduction (such as with regulatory txpower limits) is required.</span>
<span class="cm"> *</span>
<span class="cm"> *     Saturation and Backoff values apply equally to 20 Mhz (legacy) channel</span>
<span class="cm"> *     widths and 40 Mhz (.11n HT40) channel widths; there is no separate</span>
<span class="cm"> *     factory measurement for ht40 channels.</span>
<span class="cm"> *</span>
<span class="cm"> *     The result of this step is the final target txpower.  The rest of</span>
<span class="cm"> *     the steps figure out the proper settings for the device to achieve</span>
<span class="cm"> *     that target txpower.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * 3)  Determine (EEPROM) calibration sub band for the target channel, by</span>
<span class="cm"> *     comparing against first and last channels in each sub band</span>
<span class="cm"> *     (see struct il4965_eeprom_calib_subband_info).</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * 4)  Linearly interpolate (EEPROM) factory calibration measurement sets,</span>
<span class="cm"> *     referencing the 2 factory-measured (sample) channels within the sub band.</span>
<span class="cm"> *</span>
<span class="cm"> *     Interpolation is based on difference between target channel&#39;s frequency</span>
<span class="cm"> *     and the sample channels&#39; frequencies.  Since channel numbers are based</span>
<span class="cm"> *     on frequency (5 MHz between each channel number), this is equivalent</span>
<span class="cm"> *     to interpolating based on channel number differences.</span>
<span class="cm"> *</span>
<span class="cm"> *     Note that the sample channels may or may not be the channels at the</span>
<span class="cm"> *     edges of the sub band.  The target channel may be &quot;outside&quot; of the</span>
<span class="cm"> *     span of the sampled channels.</span>
<span class="cm"> *</span>
<span class="cm"> *     Driver may choose the pair (for 2 Tx chains) of measurements (see</span>
<span class="cm"> *     struct il4965_eeprom_calib_ch_info) for which the actual measured</span>
<span class="cm"> *     txpower comes closest to the desired txpower.  Usually, though,</span>
<span class="cm"> *     the middle set of measurements is closest to the regulatory limits,</span>
<span class="cm"> *     and is therefore a good choice for all txpower calculations (this</span>
<span class="cm"> *     assumes that high accuracy is needed for maximizing legal txpower,</span>
<span class="cm"> *     while lower txpower configurations do not need as much accuracy).</span>
<span class="cm"> *</span>
<span class="cm"> *     Driver should interpolate both members of the chosen measurement pair,</span>
<span class="cm"> *     i.e. for both Tx chains (radio transmitters), unless the driver knows</span>
<span class="cm"> *     that only one of the chains will be used (e.g. only one tx antenna</span>
<span class="cm"> *     connected, but this should be unusual).  The rate scaling algorithm</span>
<span class="cm"> *     switches antennas to find best performance, so both Tx chains will</span>
<span class="cm"> *     be used (although only one at a time) even for non-MIMO transmissions.</span>
<span class="cm"> *</span>
<span class="cm"> *     Driver should interpolate factory values for temperature, gain table</span>
<span class="cm"> *     idx, and actual power.  The power amplifier detector values are</span>
<span class="cm"> *     not used by the driver.</span>
<span class="cm"> *</span>
<span class="cm"> *     Sanity check:  If the target channel happens to be one of the sample</span>
<span class="cm"> *     channels, the results should agree with the sample channel&#39;s</span>
<span class="cm"> *     measurements!</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * 5)  Find difference between desired txpower and (interpolated)</span>
<span class="cm"> *     factory-measured txpower.  Using (interpolated) factory gain table idx</span>
<span class="cm"> *     (shown elsewhere) as a starting point, adjust this idx lower to</span>
<span class="cm"> *     increase txpower, or higher to decrease txpower, until the target</span>
<span class="cm"> *     txpower is reached.  Each step in the gain table is 1/2 dB.</span>
<span class="cm"> *</span>
<span class="cm"> *     For example, if factory measured txpower is 16 dBm, and target txpower</span>
<span class="cm"> *     is 13 dBm, add 6 steps to the factory gain idx to reduce txpower</span>
<span class="cm"> *     by 3 dB.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * 6)  Find difference between current device temperature and (interpolated)</span>
<span class="cm"> *     factory-measured temperature for sub-band.  Factory values are in</span>
<span class="cm"> *     degrees Celsius.  To calculate current temperature, see comments for</span>
<span class="cm"> *     &quot;4965 temperature calculation&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> *     If current temperature is higher than factory temperature, driver must</span>
<span class="cm"> *     increase gain (lower gain table idx), and vice verse.</span>
<span class="cm"> *</span>
<span class="cm"> *     Temperature affects gain differently for different channels:</span>
<span class="cm"> *</span>
<span class="cm"> *     2.4 GHz all channels:  3.5 degrees per half-dB step</span>
<span class="cm"> *     5 GHz channels 34-43:  4.5 degrees per half-dB step</span>
<span class="cm"> *     5 GHz channels &gt;= 44:  4.0 degrees per half-dB step</span>
<span class="cm"> *</span>
<span class="cm"> *     NOTE:  Temperature can increase rapidly when transmitting, especially</span>
<span class="cm"> *            with heavy traffic at high txpowers.  Driver should update</span>
<span class="cm"> *            temperature calculations often under these conditions to</span>
<span class="cm"> *            maintain strong txpower in the face of rising temperature.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * 7)  Find difference between current power supply voltage indicator</span>
<span class="cm"> *     (from &quot;initialize alive&quot;) and factory-measured power supply voltage</span>
<span class="cm"> *     indicator (EEPROM).</span>
<span class="cm"> *</span>
<span class="cm"> *     If the current voltage is higher (indicator is lower) than factory</span>
<span class="cm"> *     voltage, gain should be reduced (gain table idx increased) by:</span>
<span class="cm"> *</span>
<span class="cm"> *     (eeprom - current) / 7</span>
<span class="cm"> *</span>
<span class="cm"> *     If the current voltage is lower (indicator is higher) than factory</span>
<span class="cm"> *     voltage, gain should be increased (gain table idx decreased) by:</span>
<span class="cm"> *</span>
<span class="cm"> *     2 * (current - eeprom) / 7</span>
<span class="cm"> *</span>
<span class="cm"> *     If number of idx steps in either direction turns out to be &gt; 2,</span>
<span class="cm"> *     something is wrong ... just use 0.</span>
<span class="cm"> *</span>
<span class="cm"> *     NOTE:  Voltage compensation is independent of band/channel.</span>
<span class="cm"> *</span>
<span class="cm"> *     NOTE:  &quot;Initialize&quot; uCode measures current voltage, which is assumed</span>
<span class="cm"> *            to be constant after this initial measurement.  Voltage</span>
<span class="cm"> *            compensation for txpower (number of steps in gain table)</span>
<span class="cm"> *            may be calculated once and used until the next uCode bootload.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * 8)  If setting up txpowers for MIMO rates (rate idxes 8-15, 24-31),</span>
<span class="cm"> *     adjust txpower for each transmitter chain, so txpower is balanced</span>
<span class="cm"> *     between the two chains.  There are 5 pairs of tx_atten[group][chain]</span>
<span class="cm"> *     values in &quot;initialize alive&quot;, one pair for each of 5 channel ranges:</span>
<span class="cm"> *</span>
<span class="cm"> *     Group 0:  5 GHz channel 34-43</span>
<span class="cm"> *     Group 1:  5 GHz channel 44-70</span>
<span class="cm"> *     Group 2:  5 GHz channel 71-124</span>
<span class="cm"> *     Group 3:  5 GHz channel 125-200</span>
<span class="cm"> *     Group 4:  2.4 GHz all channels</span>
<span class="cm"> *</span>
<span class="cm"> *     Add the tx_atten[group][chain] value to the idx for the target chain.</span>
<span class="cm"> *     The values are signed, but are in pairs of 0 and a non-negative number,</span>
<span class="cm"> *     so as to reduce gain (if necessary) of the &quot;hotter&quot; channel.  This</span>
<span class="cm"> *     avoids any need to double-check for regulatory compliance after</span>
<span class="cm"> *     this step.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * 9)  If setting up for a CCK rate, lower the gain by adding a CCK compensation</span>
<span class="cm"> *     value to the idx:</span>
<span class="cm"> *</span>
<span class="cm"> *     Hardware rev B:  9 steps (4.5 dB)</span>
<span class="cm"> *     Hardware rev C:  5 steps (2.5 dB)</span>
<span class="cm"> *</span>
<span class="cm"> *     Hardware rev for 4965 can be determined by reading CSR_HW_REV_WA_REG,</span>
<span class="cm"> *     bits [3:2], 1 = B, 2 = C.</span>
<span class="cm"> *</span>
<span class="cm"> *     NOTE:  This compensation is in addition to any saturation backoff that</span>
<span class="cm"> *            might have been applied in an earlier step.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * 10) Select the gain table, based on band (2.4 vs 5 GHz).</span>
<span class="cm"> *</span>
<span class="cm"> *     Limit the adjusted idx to stay within the table!</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * 11) Read gain table entries for DSP and radio gain, place into appropriate</span>
<span class="cm"> *     location(s) in command (struct il4965_txpowertable_cmd).</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * When MIMO is used (2 transmitters operating simultaneously), driver should</span>
<span class="cm"> * limit each transmitter to deliver a max of 3 dB below the regulatory limit</span>
<span class="cm"> * for the device.  That is, use half power for each transmitter, so total</span>
<span class="cm"> * txpower is within regulatory limits.</span>
<span class="cm"> *</span>
<span class="cm"> * The value &quot;6&quot; represents number of steps in gain table to reduce power 3 dB.</span>
<span class="cm"> * Each step is 1/2 dB.</span>
<span class="cm"> */</span>
<span class="cp">#define IL_TX_POWER_MIMO_REGULATORY_COMPENSATION (6)</span>

<span class="cm">/**</span>
<span class="cm"> * CCK gain compensation.</span>
<span class="cm"> *</span>
<span class="cm"> * When calculating txpowers for CCK, after making sure that the target power</span>
<span class="cm"> * is within regulatory and saturation limits, driver must additionally</span>
<span class="cm"> * back off gain by adding these values to the gain table idx.</span>
<span class="cm"> *</span>
<span class="cm"> * Hardware rev for 4965 can be determined by reading CSR_HW_REV_WA_REG,</span>
<span class="cm"> * bits [3:2], 1 = B, 2 = C.</span>
<span class="cm"> */</span>
<span class="cp">#define IL_TX_POWER_CCK_COMPENSATION_B_STEP (9)</span>
<span class="cp">#define IL_TX_POWER_CCK_COMPENSATION_C_STEP (5)</span>

<span class="cm">/*</span>
<span class="cm"> * 4965 power supply voltage compensation for txpower</span>
<span class="cm"> */</span>
<span class="cp">#define TX_POWER_IL_VOLTAGE_CODES_PER_03V   (7)</span>

<span class="cm">/**</span>
<span class="cm"> * Gain tables.</span>
<span class="cm"> *</span>
<span class="cm"> * The following tables contain pair of values for setting txpower, i.e.</span>
<span class="cm"> * gain settings for the output of the device&#39;s digital signal processor (DSP),</span>
<span class="cm"> * and for the analog gain structure of the transmitter.</span>
<span class="cm"> *</span>
<span class="cm"> * Each entry in the gain tables represents a step of 1/2 dB.  Note that these</span>
<span class="cm"> * are *relative* steps, not indications of absolute output power.  Output</span>
<span class="cm"> * power varies with temperature, voltage, and channel frequency, and also</span>
<span class="cm"> * requires consideration of average power (to satisfy regulatory constraints),</span>
<span class="cm"> * and peak power (to avoid distortion of the output signal).</span>
<span class="cm"> *</span>
<span class="cm"> * Each entry contains two values:</span>
<span class="cm"> * 1)  DSP gain (or sometimes called DSP attenuation).  This is a fine-grained</span>
<span class="cm"> *     linear value that multiplies the output of the digital signal processor,</span>
<span class="cm"> *     before being sent to the analog radio.</span>
<span class="cm"> * 2)  Radio gain.  This sets the analog gain of the radio Tx path.</span>
<span class="cm"> *     It is a coarser setting, and behaves in a logarithmic (dB) fashion.</span>
<span class="cm"> *</span>
<span class="cm"> * EEPROM contains factory calibration data for txpower.  This maps actual</span>
<span class="cm"> * measured txpower levels to gain settings in the &quot;well known&quot; tables</span>
<span class="cm"> * below (&quot;well-known&quot; means here that both factory calibration *and* the</span>
<span class="cm"> * driver work with the same table).</span>
<span class="cm"> *</span>
<span class="cm"> * There are separate tables for 2.4 GHz and 5 GHz bands.  The 5 GHz table</span>
<span class="cm"> * has an extension (into negative idxes), in case the driver needs to</span>
<span class="cm"> * boost power setting for high device temperatures (higher than would be</span>
<span class="cm"> * present during factory calibration).  A 5 Ghz EEPROM idx of &quot;40&quot;</span>
<span class="cm"> * corresponds to the 49th entry in the table used by the driver.</span>
<span class="cm"> */</span>
<span class="cp">#define MIN_TX_GAIN_IDX		(0)	</span><span class="cm">/* highest gain, lowest idx, 2.4 */</span><span class="cp"></span>
<span class="cp">#define MIN_TX_GAIN_IDX_52GHZ_EXT	(-9)	</span><span class="cm">/* highest gain, lowest idx, 5 */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * 2.4 GHz gain table</span>
<span class="cm"> *</span>
<span class="cm"> * Index    Dsp gain   Radio gain</span>
<span class="cm"> *   0        110         0x3f      (highest gain)</span>
<span class="cm"> *   1        104         0x3f</span>
<span class="cm"> *   2         98         0x3f</span>
<span class="cm"> *   3        110         0x3e</span>
<span class="cm"> *   4        104         0x3e</span>
<span class="cm"> *   5         98         0x3e</span>
<span class="cm"> *   6        110         0x3d</span>
<span class="cm"> *   7        104         0x3d</span>
<span class="cm"> *   8         98         0x3d</span>
<span class="cm"> *   9        110         0x3c</span>
<span class="cm"> *  10        104         0x3c</span>
<span class="cm"> *  11         98         0x3c</span>
<span class="cm"> *  12        110         0x3b</span>
<span class="cm"> *  13        104         0x3b</span>
<span class="cm"> *  14         98         0x3b</span>
<span class="cm"> *  15        110         0x3a</span>
<span class="cm"> *  16        104         0x3a</span>
<span class="cm"> *  17         98         0x3a</span>
<span class="cm"> *  18        110         0x39</span>
<span class="cm"> *  19        104         0x39</span>
<span class="cm"> *  20         98         0x39</span>
<span class="cm"> *  21        110         0x38</span>
<span class="cm"> *  22        104         0x38</span>
<span class="cm"> *  23         98         0x38</span>
<span class="cm"> *  24        110         0x37</span>
<span class="cm"> *  25        104         0x37</span>
<span class="cm"> *  26         98         0x37</span>
<span class="cm"> *  27        110         0x36</span>
<span class="cm"> *  28        104         0x36</span>
<span class="cm"> *  29         98         0x36</span>
<span class="cm"> *  30        110         0x35</span>
<span class="cm"> *  31        104         0x35</span>
<span class="cm"> *  32         98         0x35</span>
<span class="cm"> *  33        110         0x34</span>
<span class="cm"> *  34        104         0x34</span>
<span class="cm"> *  35         98         0x34</span>
<span class="cm"> *  36        110         0x33</span>
<span class="cm"> *  37        104         0x33</span>
<span class="cm"> *  38         98         0x33</span>
<span class="cm"> *  39        110         0x32</span>
<span class="cm"> *  40        104         0x32</span>
<span class="cm"> *  41         98         0x32</span>
<span class="cm"> *  42        110         0x31</span>
<span class="cm"> *  43        104         0x31</span>
<span class="cm"> *  44         98         0x31</span>
<span class="cm"> *  45        110         0x30</span>
<span class="cm"> *  46        104         0x30</span>
<span class="cm"> *  47         98         0x30</span>
<span class="cm"> *  48        110          0x6</span>
<span class="cm"> *  49        104          0x6</span>
<span class="cm"> *  50         98          0x6</span>
<span class="cm"> *  51        110          0x5</span>
<span class="cm"> *  52        104          0x5</span>
<span class="cm"> *  53         98          0x5</span>
<span class="cm"> *  54        110          0x4</span>
<span class="cm"> *  55        104          0x4</span>
<span class="cm"> *  56         98          0x4</span>
<span class="cm"> *  57        110          0x3</span>
<span class="cm"> *  58        104          0x3</span>
<span class="cm"> *  59         98          0x3</span>
<span class="cm"> *  60        110          0x2</span>
<span class="cm"> *  61        104          0x2</span>
<span class="cm"> *  62         98          0x2</span>
<span class="cm"> *  63        110          0x1</span>
<span class="cm"> *  64        104          0x1</span>
<span class="cm"> *  65         98          0x1</span>
<span class="cm"> *  66        110          0x0</span>
<span class="cm"> *  67        104          0x0</span>
<span class="cm"> *  68         98          0x0</span>
<span class="cm"> *  69         97            0</span>
<span class="cm"> *  70         96            0</span>
<span class="cm"> *  71         95            0</span>
<span class="cm"> *  72         94            0</span>
<span class="cm"> *  73         93            0</span>
<span class="cm"> *  74         92            0</span>
<span class="cm"> *  75         91            0</span>
<span class="cm"> *  76         90            0</span>
<span class="cm"> *  77         89            0</span>
<span class="cm"> *  78         88            0</span>
<span class="cm"> *  79         87            0</span>
<span class="cm"> *  80         86            0</span>
<span class="cm"> *  81         85            0</span>
<span class="cm"> *  82         84            0</span>
<span class="cm"> *  83         83            0</span>
<span class="cm"> *  84         82            0</span>
<span class="cm"> *  85         81            0</span>
<span class="cm"> *  86         80            0</span>
<span class="cm"> *  87         79            0</span>
<span class="cm"> *  88         78            0</span>
<span class="cm"> *  89         77            0</span>
<span class="cm"> *  90         76            0</span>
<span class="cm"> *  91         75            0</span>
<span class="cm"> *  92         74            0</span>
<span class="cm"> *  93         73            0</span>
<span class="cm"> *  94         72            0</span>
<span class="cm"> *  95         71            0</span>
<span class="cm"> *  96         70            0</span>
<span class="cm"> *  97         69            0</span>
<span class="cm"> *  98         68            0</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * 5 GHz gain table</span>
<span class="cm"> *</span>
<span class="cm"> * Index    Dsp gain   Radio gain</span>
<span class="cm"> *  -9 	      123         0x3F      (highest gain)</span>
<span class="cm"> *  -8 	      117         0x3F</span>
<span class="cm"> *  -7        110         0x3F</span>
<span class="cm"> *  -6        104         0x3F</span>
<span class="cm"> *  -5         98         0x3F</span>
<span class="cm"> *  -4        110         0x3E</span>
<span class="cm"> *  -3        104         0x3E</span>
<span class="cm"> *  -2         98         0x3E</span>
<span class="cm"> *  -1        110         0x3D</span>
<span class="cm"> *   0        104         0x3D</span>
<span class="cm"> *   1         98         0x3D</span>
<span class="cm"> *   2        110         0x3C</span>
<span class="cm"> *   3        104         0x3C</span>
<span class="cm"> *   4         98         0x3C</span>
<span class="cm"> *   5        110         0x3B</span>
<span class="cm"> *   6        104         0x3B</span>
<span class="cm"> *   7         98         0x3B</span>
<span class="cm"> *   8        110         0x3A</span>
<span class="cm"> *   9        104         0x3A</span>
<span class="cm"> *  10         98         0x3A</span>
<span class="cm"> *  11        110         0x39</span>
<span class="cm"> *  12        104         0x39</span>
<span class="cm"> *  13         98         0x39</span>
<span class="cm"> *  14        110         0x38</span>
<span class="cm"> *  15        104         0x38</span>
<span class="cm"> *  16         98         0x38</span>
<span class="cm"> *  17        110         0x37</span>
<span class="cm"> *  18        104         0x37</span>
<span class="cm"> *  19         98         0x37</span>
<span class="cm"> *  20        110         0x36</span>
<span class="cm"> *  21        104         0x36</span>
<span class="cm"> *  22         98         0x36</span>
<span class="cm"> *  23        110         0x35</span>
<span class="cm"> *  24        104         0x35</span>
<span class="cm"> *  25         98         0x35</span>
<span class="cm"> *  26        110         0x34</span>
<span class="cm"> *  27        104         0x34</span>
<span class="cm"> *  28         98         0x34</span>
<span class="cm"> *  29        110         0x33</span>
<span class="cm"> *  30        104         0x33</span>
<span class="cm"> *  31         98         0x33</span>
<span class="cm"> *  32        110         0x32</span>
<span class="cm"> *  33        104         0x32</span>
<span class="cm"> *  34         98         0x32</span>
<span class="cm"> *  35        110         0x31</span>
<span class="cm"> *  36        104         0x31</span>
<span class="cm"> *  37         98         0x31</span>
<span class="cm"> *  38        110         0x30</span>
<span class="cm"> *  39        104         0x30</span>
<span class="cm"> *  40         98         0x30</span>
<span class="cm"> *  41        110         0x25</span>
<span class="cm"> *  42        104         0x25</span>
<span class="cm"> *  43         98         0x25</span>
<span class="cm"> *  44        110         0x24</span>
<span class="cm"> *  45        104         0x24</span>
<span class="cm"> *  46         98         0x24</span>
<span class="cm"> *  47        110         0x23</span>
<span class="cm"> *  48        104         0x23</span>
<span class="cm"> *  49         98         0x23</span>
<span class="cm"> *  50        110         0x22</span>
<span class="cm"> *  51        104         0x18</span>
<span class="cm"> *  52         98         0x18</span>
<span class="cm"> *  53        110         0x17</span>
<span class="cm"> *  54        104         0x17</span>
<span class="cm"> *  55         98         0x17</span>
<span class="cm"> *  56        110         0x16</span>
<span class="cm"> *  57        104         0x16</span>
<span class="cm"> *  58         98         0x16</span>
<span class="cm"> *  59        110         0x15</span>
<span class="cm"> *  60        104         0x15</span>
<span class="cm"> *  61         98         0x15</span>
<span class="cm"> *  62        110         0x14</span>
<span class="cm"> *  63        104         0x14</span>
<span class="cm"> *  64         98         0x14</span>
<span class="cm"> *  65        110         0x13</span>
<span class="cm"> *  66        104         0x13</span>
<span class="cm"> *  67         98         0x13</span>
<span class="cm"> *  68        110         0x12</span>
<span class="cm"> *  69        104         0x08</span>
<span class="cm"> *  70         98         0x08</span>
<span class="cm"> *  71        110         0x07</span>
<span class="cm"> *  72        104         0x07</span>
<span class="cm"> *  73         98         0x07</span>
<span class="cm"> *  74        110         0x06</span>
<span class="cm"> *  75        104         0x06</span>
<span class="cm"> *  76         98         0x06</span>
<span class="cm"> *  77        110         0x05</span>
<span class="cm"> *  78        104         0x05</span>
<span class="cm"> *  79         98         0x05</span>
<span class="cm"> *  80        110         0x04</span>
<span class="cm"> *  81        104         0x04</span>
<span class="cm"> *  82         98         0x04</span>
<span class="cm"> *  83        110         0x03</span>
<span class="cm"> *  84        104         0x03</span>
<span class="cm"> *  85         98         0x03</span>
<span class="cm"> *  86        110         0x02</span>
<span class="cm"> *  87        104         0x02</span>
<span class="cm"> *  88         98         0x02</span>
<span class="cm"> *  89        110         0x01</span>
<span class="cm"> *  90        104         0x01</span>
<span class="cm"> *  91         98         0x01</span>
<span class="cm"> *  92        110         0x00</span>
<span class="cm"> *  93        104         0x00</span>
<span class="cm"> *  94         98         0x00</span>
<span class="cm"> *  95         93         0x00</span>
<span class="cm"> *  96         88         0x00</span>
<span class="cm"> *  97         83         0x00</span>
<span class="cm"> *  98         78         0x00</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * Sanity checks and default values for EEPROM regulatory levels.</span>
<span class="cm"> * If EEPROM values fall outside MIN/MAX range, use default values.</span>
<span class="cm"> *</span>
<span class="cm"> * Regulatory limits refer to the maximum average txpower allowed by</span>
<span class="cm"> * regulatory agencies in the geographies in which the device is meant</span>
<span class="cm"> * to be operated.  These limits are SKU-specific (i.e. geography-specific),</span>
<span class="cm"> * and channel-specific; each channel has an individual regulatory limit</span>
<span class="cm"> * listed in the EEPROM.</span>
<span class="cm"> *</span>
<span class="cm"> * Units are in half-dBm (i.e. &quot;34&quot; means 17 dBm).</span>
<span class="cm"> */</span>
<span class="cp">#define IL_TX_POWER_DEFAULT_REGULATORY_24   (34)</span>
<span class="cp">#define IL_TX_POWER_DEFAULT_REGULATORY_52   (34)</span>
<span class="cp">#define IL_TX_POWER_REGULATORY_MIN          (0)</span>
<span class="cp">#define IL_TX_POWER_REGULATORY_MAX          (34)</span>

<span class="cm">/**</span>
<span class="cm"> * Sanity checks and default values for EEPROM saturation levels.</span>
<span class="cm"> * If EEPROM values fall outside MIN/MAX range, use default values.</span>
<span class="cm"> *</span>
<span class="cm"> * Saturation is the highest level that the output power amplifier can produce</span>
<span class="cm"> * without significant clipping distortion.  This is a &quot;peak&quot; power level.</span>
<span class="cm"> * Different types of modulation (i.e. various &quot;rates&quot;, and OFDM vs. CCK)</span>
<span class="cm"> * require differing amounts of backoff, relative to their average power output,</span>
<span class="cm"> * in order to avoid clipping distortion.</span>
<span class="cm"> *</span>
<span class="cm"> * Driver must make sure that it is violating neither the saturation limit,</span>
<span class="cm"> * nor the regulatory limit, when calculating Tx power settings for various</span>
<span class="cm"> * rates.</span>
<span class="cm"> *</span>
<span class="cm"> * Units are in half-dBm (i.e. &quot;38&quot; means 19 dBm).</span>
<span class="cm"> */</span>
<span class="cp">#define IL_TX_POWER_DEFAULT_SATURATION_24   (38)</span>
<span class="cp">#define IL_TX_POWER_DEFAULT_SATURATION_52   (38)</span>
<span class="cp">#define IL_TX_POWER_SATURATION_MIN          (20)</span>
<span class="cp">#define IL_TX_POWER_SATURATION_MAX          (50)</span>

<span class="cm">/**</span>
<span class="cm"> * Channel groups used for Tx Attenuation calibration (MIMO tx channel balance)</span>
<span class="cm"> * and thermal Txpower calibration.</span>
<span class="cm"> *</span>
<span class="cm"> * When calculating txpower, driver must compensate for current device</span>
<span class="cm"> * temperature; higher temperature requires higher gain.  Driver must calculate</span>
<span class="cm"> * current temperature (see &quot;4965 temperature calculation&quot;), then compare vs.</span>
<span class="cm"> * factory calibration temperature in EEPROM; if current temperature is higher</span>
<span class="cm"> * than factory temperature, driver must *increase* gain by proportions shown</span>
<span class="cm"> * in table below.  If current temperature is lower than factory, driver must</span>
<span class="cm"> * *decrease* gain.</span>
<span class="cm"> *</span>
<span class="cm"> * Different frequency ranges require different compensation, as shown below.</span>
<span class="cm"> */</span>
<span class="cm">/* Group 0, 5.2 GHz ch 34-43:  4.5 degrees per 1/2 dB. */</span>
<span class="cp">#define CALIB_IL_TX_ATTEN_GR1_FCH 34</span>
<span class="cp">#define CALIB_IL_TX_ATTEN_GR1_LCH 43</span>

<span class="cm">/* Group 1, 5.3 GHz ch 44-70:  4.0 degrees per 1/2 dB. */</span>
<span class="cp">#define CALIB_IL_TX_ATTEN_GR2_FCH 44</span>
<span class="cp">#define CALIB_IL_TX_ATTEN_GR2_LCH 70</span>

<span class="cm">/* Group 2, 5.5 GHz ch 71-124:  4.0 degrees per 1/2 dB. */</span>
<span class="cp">#define CALIB_IL_TX_ATTEN_GR3_FCH 71</span>
<span class="cp">#define CALIB_IL_TX_ATTEN_GR3_LCH 124</span>

<span class="cm">/* Group 3, 5.7 GHz ch 125-200:  4.0 degrees per 1/2 dB. */</span>
<span class="cp">#define CALIB_IL_TX_ATTEN_GR4_FCH 125</span>
<span class="cp">#define CALIB_IL_TX_ATTEN_GR4_LCH 200</span>

<span class="cm">/* Group 4, 2.4 GHz all channels:  3.5 degrees per 1/2 dB. */</span>
<span class="cp">#define CALIB_IL_TX_ATTEN_GR5_FCH 1</span>
<span class="cp">#define CALIB_IL_TX_ATTEN_GR5_LCH 20</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">CALIB_CH_GROUP_1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">CALIB_CH_GROUP_2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">CALIB_CH_GROUP_3</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">CALIB_CH_GROUP_4</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">CALIB_CH_GROUP_5</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">CALIB_CH_GROUP_MAX</span>
<span class="p">};</span>

<span class="cm">/********************* END TXPOWER *****************************************/</span>

<span class="cm">/**</span>
<span class="cm"> * Tx/Rx Queues</span>
<span class="cm"> *</span>
<span class="cm"> * Most communication between driver and 4965 is via queues of data buffers.</span>
<span class="cm"> * For example, all commands that the driver issues to device&#39;s embedded</span>
<span class="cm"> * controller (uCode) are via the command queue (one of the Tx queues).  All</span>
<span class="cm"> * uCode command responses/replies/notifications, including Rx frames, are</span>
<span class="cm"> * conveyed from uCode to driver via the Rx queue.</span>
<span class="cm"> *</span>
<span class="cm"> * Most support for these queues, including handshake support, resides in</span>
<span class="cm"> * structures in host DRAM, shared between the driver and the device.  When</span>
<span class="cm"> * allocating this memory, the driver must make sure that data written by</span>
<span class="cm"> * the host CPU updates DRAM immediately (and does not get &quot;stuck&quot; in CPU&#39;s</span>
<span class="cm"> * cache memory), so DRAM and cache are consistent, and the device can</span>
<span class="cm"> * immediately see changes made by the driver.</span>
<span class="cm"> *</span>
<span class="cm"> * 4965 supports up to 16 DRAM-based Tx queues, and services these queues via</span>
<span class="cm"> * up to 7 DMA channels (FIFOs).  Each Tx queue is supported by a circular array</span>
<span class="cm"> * in DRAM containing 256 Transmit Frame Descriptors (TFDs).</span>
<span class="cm"> */</span>
<span class="cp">#define IL49_NUM_FIFOS	7</span>
<span class="cp">#define IL49_CMD_FIFO_NUM	4</span>
<span class="cp">#define IL49_NUM_QUEUES	16</span>
<span class="cp">#define IL49_NUM_AMPDU_QUEUES	8</span>

<span class="cm">/**</span>
<span class="cm"> * struct il4965_schedq_bc_tbl</span>
<span class="cm"> *</span>
<span class="cm"> * Byte Count table</span>
<span class="cm"> *</span>
<span class="cm"> * Each Tx queue uses a byte-count table containing 320 entries:</span>
<span class="cm"> * one 16-bit entry for each of 256 TFDs, plus an additional 64 entries that</span>
<span class="cm"> * duplicate the first 64 entries (to avoid wrap-around within a Tx win;</span>
<span class="cm"> * max Tx win is 64 TFDs).</span>
<span class="cm"> *</span>
<span class="cm"> * When driver sets up a new TFD, it must also enter the total byte count</span>
<span class="cm"> * of the frame to be transmitted into the corresponding entry in the byte</span>
<span class="cm"> * count table for the chosen Tx queue.  If the TFD idx is 0-63, the driver</span>
<span class="cm"> * must duplicate the byte count entry in corresponding idx 256-319.</span>
<span class="cm"> *</span>
<span class="cm"> * padding puts each byte count table on a 1024-byte boundary;</span>
<span class="cm"> * 4965 assumes tables are separated by 1024 bytes.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">il4965_scd_bc_tbl</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">tfd_offset</span><span class="p">[</span><span class="n">TFD_QUEUE_BC_SIZE</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">pad</span><span class="p">[</span><span class="mi">1024</span> <span class="o">-</span> <span class="p">(</span><span class="n">TFD_QUEUE_BC_SIZE</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__le16</span><span class="p">)];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cp">#define IL4965_RTC_INST_LOWER_BOUND		(0x000000)</span>

<span class="cm">/* RSSI to dBm */</span>
<span class="cp">#define IL4965_RSSI_OFFSET	44</span>

<span class="cm">/* PCI registers */</span>
<span class="cp">#define PCI_CFG_RETRY_TIMEOUT	0x041</span>

<span class="cm">/* PCI register values */</span>
<span class="cp">#define PCI_CFG_LINK_CTRL_VAL_L0S_EN	0x01</span>
<span class="cp">#define PCI_CFG_LINK_CTRL_VAL_L1_EN	0x02</span>

<span class="cp">#define IL4965_DEFAULT_TX_RETRY  15</span>

<span class="cm">/* EEPROM */</span>
<span class="cp">#define IL4965_FIRST_AMPDU_QUEUE	10</span>

<span class="cm">/* Calibration */</span>
<span class="kt">void</span> <span class="n">il4965_chain_noise_calibration</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">stat_resp</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il4965_sensitivity_calibration</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">resp</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il4965_init_sensitivity</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il4965_reset_run_time_calib</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>

<span class="cm">/* Debug */</span>
<span class="cp">#ifdef CONFIG_IWLEGACY_DEBUGFS</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">il_debugfs_ops</span> <span class="n">il4965_debugfs_ops</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/****************************/</span>
<span class="cm">/* Flow Handler Definitions */</span>
<span class="cm">/****************************/</span>

<span class="cm">/**</span>
<span class="cm"> * This I/O area is directly read/writable by driver (e.g. Linux uses writel())</span>
<span class="cm"> * Addresses are offsets from device&#39;s PCI hardware base address.</span>
<span class="cm"> */</span>
<span class="cp">#define FH49_MEM_LOWER_BOUND                   (0x1000)</span>
<span class="cp">#define FH49_MEM_UPPER_BOUND                   (0x2000)</span>

<span class="cm">/**</span>
<span class="cm"> * Keep-Warm (KW) buffer base address.</span>
<span class="cm"> *</span>
<span class="cm"> * Driver must allocate a 4KByte buffer that is used by 4965 for keeping the</span>
<span class="cm"> * host DRAM powered on (via dummy accesses to DRAM) to maintain low-latency</span>
<span class="cm"> * DRAM access when 4965 is Txing or Rxing.  The dummy accesses prevent host</span>
<span class="cm"> * from going into a power-savings mode that would cause higher DRAM latency,</span>
<span class="cm"> * and possible data over/under-runs, before all Tx/Rx is complete.</span>
<span class="cm"> *</span>
<span class="cm"> * Driver loads FH49_KW_MEM_ADDR_REG with the physical address (bits 35:4)</span>
<span class="cm"> * of the buffer, which must be 4K aligned.  Once this is set up, the 4965</span>
<span class="cm"> * automatically invokes keep-warm accesses when normal accesses might not</span>
<span class="cm"> * be sufficient to maintain fast DRAM response.</span>
<span class="cm"> *</span>
<span class="cm"> * Bit fields:</span>
<span class="cm"> *  31-0:  Keep-warm buffer physical base address [35:4], must be 4K aligned</span>
<span class="cm"> */</span>
<span class="cp">#define FH49_KW_MEM_ADDR_REG		     (FH49_MEM_LOWER_BOUND + 0x97C)</span>

<span class="cm">/**</span>
<span class="cm"> * TFD Circular Buffers Base (CBBC) addresses</span>
<span class="cm"> *</span>
<span class="cm"> * 4965 has 16 base pointer registers, one for each of 16 host-DRAM-resident</span>
<span class="cm"> * circular buffers (CBs/queues) containing Transmit Frame Descriptors (TFDs)</span>
<span class="cm"> * (see struct il_tfd_frame).  These 16 pointer registers are offset by 0x04</span>
<span class="cm"> * bytes from one another.  Each TFD circular buffer in DRAM must be 256-byte</span>
<span class="cm"> * aligned (address bits 0-7 must be 0).</span>
<span class="cm"> *</span>
<span class="cm"> * Bit fields in each pointer register:</span>
<span class="cm"> *  27-0: TFD CB physical base address [35:8], must be 256-byte aligned</span>
<span class="cm"> */</span>
<span class="cp">#define FH49_MEM_CBBC_LOWER_BOUND          (FH49_MEM_LOWER_BOUND + 0x9D0)</span>
<span class="cp">#define FH49_MEM_CBBC_UPPER_BOUND          (FH49_MEM_LOWER_BOUND + 0xA10)</span>

<span class="cm">/* Find TFD CB base pointer for given queue (range 0-15). */</span>
<span class="cp">#define FH49_MEM_CBBC_QUEUE(x)  (FH49_MEM_CBBC_LOWER_BOUND + (x) * 0x4)</span>

<span class="cm">/**</span>
<span class="cm"> * Rx SRAM Control and Status Registers (RSCSR)</span>
<span class="cm"> *</span>
<span class="cm"> * These registers provide handshake between driver and 4965 for the Rx queue</span>
<span class="cm"> * (this queue handles *all* command responses, notifications, Rx data, etc.</span>
<span class="cm"> * sent from 4965 uCode to host driver).  Unlike Tx, there is only one Rx</span>
<span class="cm"> * queue, and only one Rx DMA/FIFO channel.  Also unlike Tx, which can</span>
<span class="cm"> * concatenate up to 20 DRAM buffers to form a Tx frame, each Receive Buffer</span>
<span class="cm"> * Descriptor (RBD) points to only one Rx Buffer (RB); there is a 1:1</span>
<span class="cm"> * mapping between RBDs and RBs.</span>
<span class="cm"> *</span>
<span class="cm"> * Driver must allocate host DRAM memory for the following, and set the</span>
<span class="cm"> * physical address of each into 4965 registers:</span>
<span class="cm"> *</span>
<span class="cm"> * 1)  Receive Buffer Descriptor (RBD) circular buffer (CB), typically with 256</span>
<span class="cm"> *     entries (although any power of 2, up to 4096, is selectable by driver).</span>
<span class="cm"> *     Each entry (1 dword) points to a receive buffer (RB) of consistent size</span>
<span class="cm"> *     (typically 4K, although 8K or 16K are also selectable by driver).</span>
<span class="cm"> *     Driver sets up RB size and number of RBDs in the CB via Rx config</span>
<span class="cm"> *     register FH49_MEM_RCSR_CHNL0_CONFIG_REG.</span>
<span class="cm"> *</span>
<span class="cm"> *     Bit fields within one RBD:</span>
<span class="cm"> *     27-0:  Receive Buffer physical address bits [35:8], 256-byte aligned</span>
<span class="cm"> *</span>
<span class="cm"> *     Driver sets physical address [35:8] of base of RBD circular buffer</span>
<span class="cm"> *     into FH49_RSCSR_CHNL0_RBDCB_BASE_REG [27:0].</span>
<span class="cm"> *</span>
<span class="cm"> * 2)  Rx status buffer, 8 bytes, in which 4965 indicates which Rx Buffers</span>
<span class="cm"> *     (RBs) have been filled, via a &quot;write pointer&quot;, actually the idx of</span>
<span class="cm"> *     the RB&#39;s corresponding RBD within the circular buffer.  Driver sets</span>
<span class="cm"> *     physical address [35:4] into FH49_RSCSR_CHNL0_STTS_WPTR_REG [31:0].</span>
<span class="cm"> *</span>
<span class="cm"> *     Bit fields in lower dword of Rx status buffer (upper dword not used</span>
<span class="cm"> *     by driver; see struct il4965_shared, val0):</span>
<span class="cm"> *     31-12:  Not used by driver</span>
<span class="cm"> *     11- 0:  Index of last filled Rx buffer descriptor</span>
<span class="cm"> *             (4965 writes, driver reads this value)</span>
<span class="cm"> *</span>
<span class="cm"> * As the driver prepares Receive Buffers (RBs) for 4965 to fill, driver must</span>
<span class="cm"> * enter pointers to these RBs into contiguous RBD circular buffer entries,</span>
<span class="cm"> * and update the 4965&#39;s &quot;write&quot; idx register,</span>
<span class="cm"> * FH49_RSCSR_CHNL0_RBDCB_WPTR_REG.</span>
<span class="cm"> *</span>
<span class="cm"> * This &quot;write&quot; idx corresponds to the *next* RBD that the driver will make</span>
<span class="cm"> * available, i.e. one RBD past the tail of the ready-to-fill RBDs within</span>
<span class="cm"> * the circular buffer.  This value should initially be 0 (before preparing any</span>
<span class="cm"> * RBs), should be 8 after preparing the first 8 RBs (for example), and must</span>
<span class="cm"> * wrap back to 0 at the end of the circular buffer (but don&#39;t wrap before</span>
<span class="cm"> * &quot;read&quot; idx has advanced past 1!  See below).</span>
<span class="cm"> * NOTE:  4965 EXPECTS THE WRITE IDX TO BE INCREMENTED IN MULTIPLES OF 8.</span>
<span class="cm"> *</span>
<span class="cm"> * As the 4965 fills RBs (referenced from contiguous RBDs within the circular</span>
<span class="cm"> * buffer), it updates the Rx status buffer in host DRAM, 2) described above,</span>
<span class="cm"> * to tell the driver the idx of the latest filled RBD.  The driver must</span>
<span class="cm"> * read this &quot;read&quot; idx from DRAM after receiving an Rx interrupt from 4965.</span>
<span class="cm"> *</span>
<span class="cm"> * The driver must also internally keep track of a third idx, which is the</span>
<span class="cm"> * next RBD to process.  When receiving an Rx interrupt, driver should process</span>
<span class="cm"> * all filled but unprocessed RBs up to, but not including, the RB</span>
<span class="cm"> * corresponding to the &quot;read&quot; idx.  For example, if &quot;read&quot; idx becomes &quot;1&quot;,</span>
<span class="cm"> * driver may process the RB pointed to by RBD 0.  Depending on volume of</span>
<span class="cm"> * traffic, there may be many RBs to process.</span>
<span class="cm"> *</span>
<span class="cm"> * If read idx == write idx, 4965 thinks there is no room to put new data.</span>
<span class="cm"> * Due to this, the maximum number of filled RBs is 255, instead of 256.  To</span>
<span class="cm"> * be safe, make sure that there is a gap of at least 2 RBDs between &quot;write&quot;</span>
<span class="cm"> * and &quot;read&quot; idxes; that is, make sure that there are no more than 254</span>
<span class="cm"> * buffers waiting to be filled.</span>
<span class="cm"> */</span>
<span class="cp">#define FH49_MEM_RSCSR_LOWER_BOUND	(FH49_MEM_LOWER_BOUND + 0xBC0)</span>
<span class="cp">#define FH49_MEM_RSCSR_UPPER_BOUND	(FH49_MEM_LOWER_BOUND + 0xC00)</span>
<span class="cp">#define FH49_MEM_RSCSR_CHNL0		(FH49_MEM_RSCSR_LOWER_BOUND)</span>

<span class="cm">/**</span>
<span class="cm"> * Physical base address of 8-byte Rx Status buffer.</span>
<span class="cm"> * Bit fields:</span>
<span class="cm"> *  31-0: Rx status buffer physical base address [35:4], must 16-byte aligned.</span>
<span class="cm"> */</span>
<span class="cp">#define FH49_RSCSR_CHNL0_STTS_WPTR_REG	(FH49_MEM_RSCSR_CHNL0)</span>

<span class="cm">/**</span>
<span class="cm"> * Physical base address of Rx Buffer Descriptor Circular Buffer.</span>
<span class="cm"> * Bit fields:</span>
<span class="cm"> *  27-0:  RBD CD physical base address [35:8], must be 256-byte aligned.</span>
<span class="cm"> */</span>
<span class="cp">#define FH49_RSCSR_CHNL0_RBDCB_BASE_REG	(FH49_MEM_RSCSR_CHNL0 + 0x004)</span>

<span class="cm">/**</span>
<span class="cm"> * Rx write pointer (idx, really!).</span>
<span class="cm"> * Bit fields:</span>
<span class="cm"> *  11-0:  Index of driver&#39;s most recent prepared-to-be-filled RBD, + 1.</span>
<span class="cm"> *         NOTE:  For 256-entry circular buffer, use only bits [7:0].</span>
<span class="cm"> */</span>
<span class="cp">#define FH49_RSCSR_CHNL0_RBDCB_WPTR_REG	(FH49_MEM_RSCSR_CHNL0 + 0x008)</span>
<span class="cp">#define FH49_RSCSR_CHNL0_WPTR        (FH49_RSCSR_CHNL0_RBDCB_WPTR_REG)</span>

<span class="cm">/**</span>
<span class="cm"> * Rx Config/Status Registers (RCSR)</span>
<span class="cm"> * Rx Config Reg for channel 0 (only channel used)</span>
<span class="cm"> *</span>
<span class="cm"> * Driver must initialize FH49_MEM_RCSR_CHNL0_CONFIG_REG as follows for</span>
<span class="cm"> * normal operation (see bit fields).</span>
<span class="cm"> *</span>
<span class="cm"> * Clearing FH49_MEM_RCSR_CHNL0_CONFIG_REG to 0 turns off Rx DMA.</span>
<span class="cm"> * Driver should poll FH49_MEM_RSSR_RX_STATUS_REG	for</span>
<span class="cm"> * FH49_RSSR_CHNL0_RX_STATUS_CHNL_IDLE (bit 24) before continuing.</span>
<span class="cm"> *</span>
<span class="cm"> * Bit fields:</span>
<span class="cm"> * 31-30: Rx DMA channel enable: &#39;00&#39; off/pause, &#39;01&#39; pause at end of frame,</span>
<span class="cm"> *        &#39;10&#39; operate normally</span>
<span class="cm"> * 29-24: reserved</span>
<span class="cm"> * 23-20: # RBDs in circular buffer = 2^value; use &quot;8&quot; for 256 RBDs (normal),</span>
<span class="cm"> *        min &quot;5&quot; for 32 RBDs, max &quot;12&quot; for 4096 RBDs.</span>
<span class="cm"> * 19-18: reserved</span>
<span class="cm"> * 17-16: size of each receive buffer; &#39;00&#39; 4K (normal), &#39;01&#39; 8K,</span>
<span class="cm"> *        &#39;10&#39; 12K, &#39;11&#39; 16K.</span>
<span class="cm"> * 15-14: reserved</span>
<span class="cm"> * 13-12: IRQ destination; &#39;00&#39; none, &#39;01&#39; host driver (normal operation)</span>
<span class="cm"> * 11- 4: timeout for closing Rx buffer and interrupting host (units 32 usec)</span>
<span class="cm"> *        typical value 0x10 (about 1/2 msec)</span>
<span class="cm"> *  3- 0: reserved</span>
<span class="cm"> */</span>
<span class="cp">#define FH49_MEM_RCSR_LOWER_BOUND      (FH49_MEM_LOWER_BOUND + 0xC00)</span>
<span class="cp">#define FH49_MEM_RCSR_UPPER_BOUND      (FH49_MEM_LOWER_BOUND + 0xCC0)</span>
<span class="cp">#define FH49_MEM_RCSR_CHNL0            (FH49_MEM_RCSR_LOWER_BOUND)</span>

<span class="cp">#define FH49_MEM_RCSR_CHNL0_CONFIG_REG	(FH49_MEM_RCSR_CHNL0)</span>

<span class="cp">#define FH49_RCSR_CHNL0_RX_CONFIG_RB_TIMEOUT_MSK (0x00000FF0)	</span><span class="cm">/* bits 4-11 */</span><span class="cp"></span>
<span class="cp">#define FH49_RCSR_CHNL0_RX_CONFIG_IRQ_DEST_MSK   (0x00001000)	</span><span class="cm">/* bits 12 */</span><span class="cp"></span>
<span class="cp">#define FH49_RCSR_CHNL0_RX_CONFIG_SINGLE_FRAME_MSK (0x00008000)	</span><span class="cm">/* bit 15 */</span><span class="cp"></span>
<span class="cp">#define FH49_RCSR_CHNL0_RX_CONFIG_RB_SIZE_MSK   (0x00030000)	</span><span class="cm">/* bits 16-17 */</span><span class="cp"></span>
<span class="cp">#define FH49_RCSR_CHNL0_RX_CONFIG_RBDBC_SIZE_MSK (0x00F00000)	</span><span class="cm">/* bits 20-23 */</span><span class="cp"></span>
<span class="cp">#define FH49_RCSR_CHNL0_RX_CONFIG_DMA_CHNL_EN_MSK (0xC0000000)	</span><span class="cm">/* bits 30-31 */</span><span class="cp"></span>

<span class="cp">#define FH49_RCSR_RX_CONFIG_RBDCB_SIZE_POS	(20)</span>
<span class="cp">#define FH49_RCSR_RX_CONFIG_REG_IRQ_RBTH_POS	(4)</span>
<span class="cp">#define RX_RB_TIMEOUT	(0x10)</span>

<span class="cp">#define FH49_RCSR_RX_CONFIG_CHNL_EN_PAUSE_VAL         (0x00000000)</span>
<span class="cp">#define FH49_RCSR_RX_CONFIG_CHNL_EN_PAUSE_EOF_VAL     (0x40000000)</span>
<span class="cp">#define FH49_RCSR_RX_CONFIG_CHNL_EN_ENABLE_VAL        (0x80000000)</span>

<span class="cp">#define FH49_RCSR_RX_CONFIG_REG_VAL_RB_SIZE_4K    (0x00000000)</span>
<span class="cp">#define FH49_RCSR_RX_CONFIG_REG_VAL_RB_SIZE_8K    (0x00010000)</span>
<span class="cp">#define FH49_RCSR_RX_CONFIG_REG_VAL_RB_SIZE_12K   (0x00020000)</span>
<span class="cp">#define FH49_RCSR_RX_CONFIG_REG_VAL_RB_SIZE_16K   (0x00030000)</span>

<span class="cp">#define FH49_RCSR_CHNL0_RX_IGNORE_RXF_EMPTY              (0x00000004)</span>
<span class="cp">#define FH49_RCSR_CHNL0_RX_CONFIG_IRQ_DEST_NO_INT_VAL    (0x00000000)</span>
<span class="cp">#define FH49_RCSR_CHNL0_RX_CONFIG_IRQ_DEST_INT_HOST_VAL  (0x00001000)</span>

<span class="cm">/**</span>
<span class="cm"> * Rx Shared Status Registers (RSSR)</span>
<span class="cm"> *</span>
<span class="cm"> * After stopping Rx DMA channel (writing 0 to</span>
<span class="cm"> * FH49_MEM_RCSR_CHNL0_CONFIG_REG), driver must poll</span>
<span class="cm"> * FH49_MEM_RSSR_RX_STATUS_REG until Rx channel is idle.</span>
<span class="cm"> *</span>
<span class="cm"> * Bit fields:</span>
<span class="cm"> *  24:  1 = Channel 0 is idle</span>
<span class="cm"> *</span>
<span class="cm"> * FH49_MEM_RSSR_SHARED_CTRL_REG and FH49_MEM_RSSR_RX_ENABLE_ERR_IRQ2DRV</span>
<span class="cm"> * contain default values that should not be altered by the driver.</span>
<span class="cm"> */</span>
<span class="cp">#define FH49_MEM_RSSR_LOWER_BOUND           (FH49_MEM_LOWER_BOUND + 0xC40)</span>
<span class="cp">#define FH49_MEM_RSSR_UPPER_BOUND           (FH49_MEM_LOWER_BOUND + 0xD00)</span>

<span class="cp">#define FH49_MEM_RSSR_SHARED_CTRL_REG       (FH49_MEM_RSSR_LOWER_BOUND)</span>
<span class="cp">#define FH49_MEM_RSSR_RX_STATUS_REG	(FH49_MEM_RSSR_LOWER_BOUND + 0x004)</span>
<span class="cp">#define FH49_MEM_RSSR_RX_ENABLE_ERR_IRQ2DRV\</span>
<span class="cp">					(FH49_MEM_RSSR_LOWER_BOUND + 0x008)</span>

<span class="cp">#define FH49_RSSR_CHNL0_RX_STATUS_CHNL_IDLE	(0x01000000)</span>

<span class="cp">#define FH49_MEM_TFDIB_REG1_ADDR_BITSHIFT	28</span>

<span class="cm">/* TFDB  Area - TFDs buffer table */</span>
<span class="cp">#define FH49_MEM_TFDIB_DRAM_ADDR_LSB_MSK      (0xFFFFFFFF)</span>
<span class="cp">#define FH49_TFDIB_LOWER_BOUND       (FH49_MEM_LOWER_BOUND + 0x900)</span>
<span class="cp">#define FH49_TFDIB_UPPER_BOUND       (FH49_MEM_LOWER_BOUND + 0x958)</span>
<span class="cp">#define FH49_TFDIB_CTRL0_REG(_chnl)  (FH49_TFDIB_LOWER_BOUND + 0x8 * (_chnl))</span>
<span class="cp">#define FH49_TFDIB_CTRL1_REG(_chnl)  (FH49_TFDIB_LOWER_BOUND + 0x8 * (_chnl) + 0x4)</span>

<span class="cm">/**</span>
<span class="cm"> * Transmit DMA Channel Control/Status Registers (TCSR)</span>
<span class="cm"> *</span>
<span class="cm"> * 4965 has one configuration register for each of 8 Tx DMA/FIFO channels</span>
<span class="cm"> * supported in hardware (don&#39;t confuse these with the 16 Tx queues in DRAM,</span>
<span class="cm"> * which feed the DMA/FIFO channels); config regs are separated by 0x20 bytes.</span>
<span class="cm"> *</span>
<span class="cm"> * To use a Tx DMA channel, driver must initialize its</span>
<span class="cm"> * FH49_TCSR_CHNL_TX_CONFIG_REG(chnl) with:</span>
<span class="cm"> *</span>
<span class="cm"> * FH49_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_ENABLE |</span>
<span class="cm"> * FH49_TCSR_TX_CONFIG_REG_VAL_DMA_CREDIT_ENABLE_VAL</span>
<span class="cm"> *</span>
<span class="cm"> * All other bits should be 0.</span>
<span class="cm"> *</span>
<span class="cm"> * Bit fields:</span>
<span class="cm"> * 31-30: Tx DMA channel enable: &#39;00&#39; off/pause, &#39;01&#39; pause at end of frame,</span>
<span class="cm"> *        &#39;10&#39; operate normally</span>
<span class="cm"> * 29- 4: Reserved, set to &quot;0&quot;</span>
<span class="cm"> *     3: Enable internal DMA requests (1, normal operation), disable (0)</span>
<span class="cm"> *  2- 0: Reserved, set to &quot;0&quot;</span>
<span class="cm"> */</span>
<span class="cp">#define FH49_TCSR_LOWER_BOUND  (FH49_MEM_LOWER_BOUND + 0xD00)</span>
<span class="cp">#define FH49_TCSR_UPPER_BOUND  (FH49_MEM_LOWER_BOUND + 0xE60)</span>

<span class="cm">/* Find Control/Status reg for given Tx DMA/FIFO channel */</span>
<span class="cp">#define FH49_TCSR_CHNL_NUM                            (7)</span>
<span class="cp">#define FH50_TCSR_CHNL_NUM                            (8)</span>

<span class="cm">/* TCSR: tx_config register values */</span>
<span class="cp">#define FH49_TCSR_CHNL_TX_CONFIG_REG(_chnl)	\</span>
<span class="cp">		(FH49_TCSR_LOWER_BOUND + 0x20 * (_chnl))</span>
<span class="cp">#define FH49_TCSR_CHNL_TX_CREDIT_REG(_chnl)	\</span>
<span class="cp">		(FH49_TCSR_LOWER_BOUND + 0x20 * (_chnl) + 0x4)</span>
<span class="cp">#define FH49_TCSR_CHNL_TX_BUF_STS_REG(_chnl)	\</span>
<span class="cp">		(FH49_TCSR_LOWER_BOUND + 0x20 * (_chnl) + 0x8)</span>

<span class="cp">#define FH49_TCSR_TX_CONFIG_REG_VAL_MSG_MODE_TXF		(0x00000000)</span>
<span class="cp">#define FH49_TCSR_TX_CONFIG_REG_VAL_MSG_MODE_DRV		(0x00000001)</span>

<span class="cp">#define FH49_TCSR_TX_CONFIG_REG_VAL_DMA_CREDIT_DISABLE	(0x00000000)</span>
<span class="cp">#define FH49_TCSR_TX_CONFIG_REG_VAL_DMA_CREDIT_ENABLE	(0x00000008)</span>

<span class="cp">#define FH49_TCSR_TX_CONFIG_REG_VAL_CIRQ_HOST_NOINT	(0x00000000)</span>
<span class="cp">#define FH49_TCSR_TX_CONFIG_REG_VAL_CIRQ_HOST_ENDTFD	(0x00100000)</span>
<span class="cp">#define FH49_TCSR_TX_CONFIG_REG_VAL_CIRQ_HOST_IFTFD	(0x00200000)</span>

<span class="cp">#define FH49_TCSR_TX_CONFIG_REG_VAL_CIRQ_RTC_NOINT	(0x00000000)</span>
<span class="cp">#define FH49_TCSR_TX_CONFIG_REG_VAL_CIRQ_RTC_ENDTFD	(0x00400000)</span>
<span class="cp">#define FH49_TCSR_TX_CONFIG_REG_VAL_CIRQ_RTC_IFTFD	(0x00800000)</span>

<span class="cp">#define FH49_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_PAUSE	(0x00000000)</span>
<span class="cp">#define FH49_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_PAUSE_EOF	(0x40000000)</span>
<span class="cp">#define FH49_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_ENABLE	(0x80000000)</span>

<span class="cp">#define FH49_TCSR_CHNL_TX_BUF_STS_REG_VAL_TFDB_EMPTY	(0x00000000)</span>
<span class="cp">#define FH49_TCSR_CHNL_TX_BUF_STS_REG_VAL_TFDB_WAIT	(0x00002000)</span>
<span class="cp">#define FH49_TCSR_CHNL_TX_BUF_STS_REG_VAL_TFDB_VALID	(0x00000003)</span>

<span class="cp">#define FH49_TCSR_CHNL_TX_BUF_STS_REG_POS_TB_NUM		(20)</span>
<span class="cp">#define FH49_TCSR_CHNL_TX_BUF_STS_REG_POS_TB_IDX		(12)</span>

<span class="cm">/**</span>
<span class="cm"> * Tx Shared Status Registers (TSSR)</span>
<span class="cm"> *</span>
<span class="cm"> * After stopping Tx DMA channel (writing 0 to</span>
<span class="cm"> * FH49_TCSR_CHNL_TX_CONFIG_REG(chnl)), driver must poll</span>
<span class="cm"> * FH49_TSSR_TX_STATUS_REG until selected Tx channel is idle</span>
<span class="cm"> * (channel&#39;s buffers empty | no pending requests).</span>
<span class="cm"> *</span>
<span class="cm"> * Bit fields:</span>
<span class="cm"> * 31-24:  1 = Channel buffers empty (channel 7:0)</span>
<span class="cm"> * 23-16:  1 = No pending requests (channel 7:0)</span>
<span class="cm"> */</span>
<span class="cp">#define FH49_TSSR_LOWER_BOUND		(FH49_MEM_LOWER_BOUND + 0xEA0)</span>
<span class="cp">#define FH49_TSSR_UPPER_BOUND		(FH49_MEM_LOWER_BOUND + 0xEC0)</span>

<span class="cp">#define FH49_TSSR_TX_STATUS_REG		(FH49_TSSR_LOWER_BOUND + 0x010)</span>

<span class="cm">/**</span>
<span class="cm"> * Bit fields for TSSR(Tx Shared Status &amp; Control) error status register:</span>
<span class="cm"> * 31:  Indicates an address error when accessed to internal memory</span>
<span class="cm"> *	uCode/driver must write &quot;1&quot; in order to clear this flag</span>
<span class="cm"> * 30:  Indicates that Host did not send the expected number of dwords to FH</span>
<span class="cm"> *	uCode/driver must write &quot;1&quot; in order to clear this flag</span>
<span class="cm"> * 16-9:Each status bit is for one channel. Indicates that an (Error) ActDMA</span>
<span class="cm"> *	command was received from the scheduler while the TRB was already full</span>
<span class="cm"> *	with previous command</span>
<span class="cm"> *	uCode/driver must write &quot;1&quot; in order to clear this flag</span>
<span class="cm"> * 7-0: Each status bit indicates a channel&#39;s TxCredit error. When an error</span>
<span class="cm"> *	bit is set, it indicates that the FH has received a full indication</span>
<span class="cm"> *	from the RTC TxFIFO and the current value of the TxCredit counter was</span>
<span class="cm"> *	not equal to zero. This mean that the credit mechanism was not</span>
<span class="cm"> *	synchronized to the TxFIFO status</span>
<span class="cm"> *	uCode/driver must write &quot;1&quot; in order to clear this flag</span>
<span class="cm"> */</span>
<span class="cp">#define FH49_TSSR_TX_ERROR_REG		(FH49_TSSR_LOWER_BOUND + 0x018)</span>

<span class="cp">#define FH49_TSSR_TX_STATUS_REG_MSK_CHNL_IDLE(_chnl) ((1 &lt;&lt; (_chnl)) &lt;&lt; 16)</span>

<span class="cm">/* Tx service channels */</span>
<span class="cp">#define FH49_SRVC_CHNL		(9)</span>
<span class="cp">#define FH49_SRVC_LOWER_BOUND	(FH49_MEM_LOWER_BOUND + 0x9C8)</span>
<span class="cp">#define FH49_SRVC_UPPER_BOUND	(FH49_MEM_LOWER_BOUND + 0x9D0)</span>
<span class="cp">#define FH49_SRVC_CHNL_SRAM_ADDR_REG(_chnl) \</span>
<span class="cp">		(FH49_SRVC_LOWER_BOUND + ((_chnl) - 9) * 0x4)</span>

<span class="cp">#define FH49_TX_CHICKEN_BITS_REG	(FH49_MEM_LOWER_BOUND + 0xE98)</span>
<span class="cm">/* Instruct FH to increment the retry count of a packet when</span>
<span class="cm"> * it is brought from the memory to TX-FIFO</span>
<span class="cm"> */</span>
<span class="cp">#define FH49_TX_CHICKEN_BITS_SCD_AUTO_RETRY_EN	(0x00000002)</span>

<span class="cm">/* Keep Warm Size */</span>
<span class="cp">#define IL_KW_SIZE 0x1000	</span><span class="cm">/* 4k */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* __il_4965_h__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
