<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › iwlegacy › prph.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>prph.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * This file is provided under a dual BSD/GPLv2 license.  When using or</span>
<span class="cm"> * redistributing this file, you may do so under either license.</span>
<span class="cm"> *</span>
<span class="cm"> * GPL LICENSE SUMMARY</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2005 - 2011 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of version 2 of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,</span>
<span class="cm"> * USA</span>
<span class="cm"> *</span>
<span class="cm"> * The full GNU General Public License is included in this distribution</span>
<span class="cm"> * in the file called LICENSE.GPL.</span>
<span class="cm"> *</span>
<span class="cm"> * Contact Information:</span>
<span class="cm"> *  Intel Linux Wireless &lt;ilw@linux.intel.com&gt;</span>
<span class="cm"> * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>
<span class="cm"> *</span>
<span class="cm"> * BSD LICENSE</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2005 - 2011 Intel Corporation. All rights reserved.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> *</span>
<span class="cm"> *  * Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *  * Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer in</span>
<span class="cm"> *    the documentation and/or other materials provided with the</span>
<span class="cm"> *    distribution.</span>
<span class="cm"> *  * Neither the name Intel Corporation nor the names of its</span>
<span class="cm"> *    contributors may be used to endorse or promote products derived</span>
<span class="cm"> *    from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="cm"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="cm"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="cm"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="cm"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cp">#ifndef	__il_prph_h__</span>
<span class="cp">#define __il_prph_h__</span>

<span class="cm">/*</span>
<span class="cm"> * Registers in this file are internal, not PCI bus memory mapped.</span>
<span class="cm"> * Driver accesses these via HBUS_TARG_PRPH_* registers.</span>
<span class="cm"> */</span>
<span class="cp">#define PRPH_BASE	(0x00000)</span>
<span class="cp">#define PRPH_END	(0xFFFFF)</span>

<span class="cm">/* APMG (power management) constants */</span>
<span class="cp">#define APMG_BASE			(PRPH_BASE + 0x3000)</span>
<span class="cp">#define APMG_CLK_CTRL_REG		(APMG_BASE + 0x0000)</span>
<span class="cp">#define APMG_CLK_EN_REG			(APMG_BASE + 0x0004)</span>
<span class="cp">#define APMG_CLK_DIS_REG		(APMG_BASE + 0x0008)</span>
<span class="cp">#define APMG_PS_CTRL_REG		(APMG_BASE + 0x000c)</span>
<span class="cp">#define APMG_PCIDEV_STT_REG		(APMG_BASE + 0x0010)</span>
<span class="cp">#define APMG_RFKILL_REG			(APMG_BASE + 0x0014)</span>
<span class="cp">#define APMG_RTC_INT_STT_REG		(APMG_BASE + 0x001c)</span>
<span class="cp">#define APMG_RTC_INT_MSK_REG		(APMG_BASE + 0x0020)</span>
<span class="cp">#define APMG_DIGITAL_SVR_REG		(APMG_BASE + 0x0058)</span>
<span class="cp">#define APMG_ANALOG_SVR_REG		(APMG_BASE + 0x006C)</span>

<span class="cp">#define APMS_CLK_VAL_MRB_FUNC_MODE	(0x00000001)</span>
<span class="cp">#define APMG_CLK_VAL_DMA_CLK_RQT	(0x00000200)</span>
<span class="cp">#define APMG_CLK_VAL_BSM_CLK_RQT	(0x00000800)</span>

<span class="cp">#define APMG_PS_CTRL_EARLY_PWR_OFF_RESET_DIS	(0x00400000)</span>
<span class="cp">#define APMG_PS_CTRL_VAL_RESET_REQ		(0x04000000)</span>
<span class="cp">#define APMG_PS_CTRL_MSK_PWR_SRC		(0x03000000)</span>
<span class="cp">#define APMG_PS_CTRL_VAL_PWR_SRC_VMAIN		(0x00000000)</span>
<span class="cp">#define APMG_PS_CTRL_VAL_PWR_SRC_MAX		(0x01000000)	</span><span class="cm">/* 3945 only */</span><span class="cp"></span>
<span class="cp">#define APMG_PS_CTRL_VAL_PWR_SRC_VAUX		(0x02000000)</span>
<span class="cp">#define APMG_SVR_VOLTAGE_CONFIG_BIT_MSK	(0x000001E0)	</span><span class="cm">/* bit 8:5 */</span><span class="cp"></span>
<span class="cp">#define APMG_SVR_DIGITAL_VOLTAGE_1_32		(0x00000060)</span>

<span class="cp">#define APMG_PCIDEV_STT_VAL_L1_ACT_DIS		(0x00000800)</span>

<span class="cm">/**</span>
<span class="cm"> * BSM (Bootstrap State Machine)</span>
<span class="cm"> *</span>
<span class="cm"> * The Bootstrap State Machine (BSM) stores a short bootstrap uCode program</span>
<span class="cm"> * in special SRAM that does not power down when the embedded control</span>
<span class="cm"> * processor is sleeping (e.g. for periodic power-saving shutdowns of radio).</span>
<span class="cm"> *</span>
<span class="cm"> * When powering back up after sleeps (or during initial uCode load), the BSM</span>
<span class="cm"> * internally loads the short bootstrap program from the special SRAM into the</span>
<span class="cm"> * embedded processor&#39;s instruction SRAM, and starts the processor so it runs</span>
<span class="cm"> * the bootstrap program.</span>
<span class="cm"> *</span>
<span class="cm"> * This bootstrap program loads (via PCI busmaster DMA) instructions and data</span>
<span class="cm"> * images for a uCode program from host DRAM locations.  The host driver</span>
<span class="cm"> * indicates DRAM locations and sizes for instruction and data images via the</span>
<span class="cm"> * four BSM_DRAM_* registers.  Once the bootstrap program loads the new program,</span>
<span class="cm"> * the new program starts automatically.</span>
<span class="cm"> *</span>
<span class="cm"> * The uCode used for open-source drivers includes two programs:</span>
<span class="cm"> *</span>
<span class="cm"> * 1)  Initialization -- performs hardware calibration and sets up some</span>
<span class="cm"> *     internal data, then notifies host via &quot;initialize alive&quot; notification</span>
<span class="cm"> *     (struct il_init_alive_resp) that it has completed all of its work.</span>
<span class="cm"> *     After signal from host, it then loads and starts the runtime program.</span>
<span class="cm"> *     The initialization program must be used when initially setting up the</span>
<span class="cm"> *     NIC after loading the driver.</span>
<span class="cm"> *</span>
<span class="cm"> * 2)  Runtime/Protocol -- performs all normal runtime operations.  This</span>
<span class="cm"> *     notifies host via &quot;alive&quot; notification (struct il_alive_resp) that it</span>
<span class="cm"> *     is ready to be used.</span>
<span class="cm"> *</span>
<span class="cm"> * When initializing the NIC, the host driver does the following procedure:</span>
<span class="cm"> *</span>
<span class="cm"> * 1)  Load bootstrap program (instructions only, no data image for bootstrap)</span>
<span class="cm"> *     into bootstrap memory.  Use dword writes starting at BSM_SRAM_LOWER_BOUND</span>
<span class="cm"> *</span>
<span class="cm"> * 2)  Point (via BSM_DRAM_*) to the &quot;initialize&quot; uCode data and instruction</span>
<span class="cm"> *     images in host DRAM.</span>
<span class="cm"> *</span>
<span class="cm"> * 3)  Set up BSM to copy from BSM SRAM into uCode instruction SRAM when asked:</span>
<span class="cm"> *     BSM_WR_MEM_SRC_REG = 0</span>
<span class="cm"> *     BSM_WR_MEM_DST_REG = RTC_INST_LOWER_BOUND</span>
<span class="cm"> *     BSM_WR_MEM_DWCOUNT_REG = # dwords in bootstrap instruction image</span>
<span class="cm"> *</span>
<span class="cm"> * 4)  Load bootstrap into instruction SRAM:</span>
<span class="cm"> *     BSM_WR_CTRL_REG = BSM_WR_CTRL_REG_BIT_START</span>
<span class="cm"> *</span>
<span class="cm"> * 5)  Wait for load completion:</span>
<span class="cm"> *     Poll BSM_WR_CTRL_REG for BSM_WR_CTRL_REG_BIT_START = 0</span>
<span class="cm"> *</span>
<span class="cm"> * 6)  Enable future boot loads whenever NIC&#39;s power management triggers it:</span>
<span class="cm"> *     BSM_WR_CTRL_REG = BSM_WR_CTRL_REG_BIT_START_EN</span>
<span class="cm"> *</span>
<span class="cm"> * 7)  Start the NIC by removing all reset bits:</span>
<span class="cm"> *     CSR_RESET = 0</span>
<span class="cm"> *</span>
<span class="cm"> *     The bootstrap uCode (already in instruction SRAM) loads initialization</span>
<span class="cm"> *     uCode.  Initialization uCode performs data initialization, sends</span>
<span class="cm"> *     &quot;initialize alive&quot; notification to host, and waits for a signal from</span>
<span class="cm"> *     host to load runtime code.</span>
<span class="cm"> *</span>
<span class="cm"> * 4)  Point (via BSM_DRAM_*) to the &quot;runtime&quot; uCode data and instruction</span>
<span class="cm"> *     images in host DRAM.  The last register loaded must be the instruction</span>
<span class="cm"> *     byte count register (&quot;1&quot; in MSbit tells initialization uCode to load</span>
<span class="cm"> *     the runtime uCode):</span>
<span class="cm"> *     BSM_DRAM_INST_BYTECOUNT_REG = byte count | BSM_DRAM_INST_LOAD</span>
<span class="cm"> *</span>
<span class="cm"> * 5)  Wait for &quot;alive&quot; notification, then issue normal runtime commands.</span>
<span class="cm"> *</span>
<span class="cm"> * Data caching during power-downs:</span>
<span class="cm"> *</span>
<span class="cm"> * Just before the embedded controller powers down (e.g for automatic</span>
<span class="cm"> * power-saving modes, or for RFKILL), uCode stores (via PCI busmaster DMA)</span>
<span class="cm"> * a current snapshot of the embedded processor&#39;s data SRAM into host DRAM.</span>
<span class="cm"> * This caches the data while the embedded processor&#39;s memory is powered down.</span>
<span class="cm"> * Location and size are controlled by BSM_DRAM_DATA_* registers.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  Instruction SRAM does not need to be saved, since that doesn&#39;t</span>
<span class="cm"> *        change during operation; the original image (from uCode distribution</span>
<span class="cm"> *        file) can be used for reload.</span>
<span class="cm"> *</span>
<span class="cm"> * When powering back up, the BSM loads the bootstrap program.  Bootstrap looks</span>
<span class="cm"> * at the BSM_DRAM_* registers, which now point to the runtime instruction</span>
<span class="cm"> * image and the cached (modified) runtime data (*not* the initialization</span>
<span class="cm"> * uCode).  Bootstrap reloads these runtime images into SRAM, and restarts the</span>
<span class="cm"> * uCode from where it left off before the power-down.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  Initialization uCode does *not* run as part of the save/restore</span>
<span class="cm"> *        procedure.</span>
<span class="cm"> *</span>
<span class="cm"> * This save/restore method is mostly for autonomous power management during</span>
<span class="cm"> * normal operation (result of C_POWER_TBL).  Platform suspend/resume and</span>
<span class="cm"> * RFKILL should use complete restarts (with total re-initialization) of uCode,</span>
<span class="cm"> * allowing total shutdown (including BSM memory).</span>
<span class="cm"> *</span>
<span class="cm"> * Note that, during normal operation, the host DRAM that held the initial</span>
<span class="cm"> * startup data for the runtime code is now being used as a backup data cache</span>
<span class="cm"> * for modified data!  If you need to completely re-initialize the NIC, make</span>
<span class="cm"> * sure that you use the runtime data image from the uCode distribution file,</span>
<span class="cm"> * not the modified/saved runtime data.  You may want to store a separate</span>
<span class="cm"> * &quot;clean&quot; runtime data image in DRAM to avoid disk reads of distribution file.</span>
<span class="cm"> */</span>

<span class="cm">/* BSM bit fields */</span>
<span class="cp">#define BSM_WR_CTRL_REG_BIT_START     (0x80000000)	</span><span class="cm">/* start boot load now */</span><span class="cp"></span>
<span class="cp">#define BSM_WR_CTRL_REG_BIT_START_EN  (0x40000000)	</span><span class="cm">/* enable boot after pwrup */</span><span class="cp"></span>
<span class="cp">#define BSM_DRAM_INST_LOAD            (0x80000000)	</span><span class="cm">/* start program load now */</span><span class="cp"></span>

<span class="cm">/* BSM addresses */</span>
<span class="cp">#define BSM_BASE                     (PRPH_BASE + 0x3400)</span>
<span class="cp">#define BSM_END                      (PRPH_BASE + 0x3800)</span>

<span class="cp">#define BSM_WR_CTRL_REG              (BSM_BASE + 0x000)	</span><span class="cm">/* ctl and status */</span><span class="cp"></span>
<span class="cp">#define BSM_WR_MEM_SRC_REG           (BSM_BASE + 0x004)	</span><span class="cm">/* source in BSM mem */</span><span class="cp"></span>
<span class="cp">#define BSM_WR_MEM_DST_REG           (BSM_BASE + 0x008)	</span><span class="cm">/* dest in SRAM mem */</span><span class="cp"></span>
<span class="cp">#define BSM_WR_DWCOUNT_REG           (BSM_BASE + 0x00C)	</span><span class="cm">/* bytes */</span><span class="cp"></span>
<span class="cp">#define BSM_WR_STATUS_REG            (BSM_BASE + 0x010)	</span><span class="cm">/* bit 0:  1 == done */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Pointers and size regs for bootstrap load and data SRAM save/restore.</span>
<span class="cm"> * NOTE:  3945 pointers use bits 31:0 of DRAM address.</span>
<span class="cm"> *        4965 pointers use bits 35:4 of DRAM address.</span>
<span class="cm"> */</span>
<span class="cp">#define BSM_DRAM_INST_PTR_REG        (BSM_BASE + 0x090)</span>
<span class="cp">#define BSM_DRAM_INST_BYTECOUNT_REG  (BSM_BASE + 0x094)</span>
<span class="cp">#define BSM_DRAM_DATA_PTR_REG        (BSM_BASE + 0x098)</span>
<span class="cp">#define BSM_DRAM_DATA_BYTECOUNT_REG  (BSM_BASE + 0x09C)</span>

<span class="cm">/*</span>
<span class="cm"> * BSM special memory, stays powered on during power-save sleeps.</span>
<span class="cm"> * Read/write, address range from LOWER_BOUND to (LOWER_BOUND + SIZE -1)</span>
<span class="cm"> */</span>
<span class="cp">#define BSM_SRAM_LOWER_BOUND         (PRPH_BASE + 0x3800)</span>
<span class="cp">#define BSM_SRAM_SIZE			(1024)	</span><span class="cm">/* bytes */</span><span class="cp"></span>

<span class="cm">/* 3945 Tx scheduler registers */</span>
<span class="cp">#define ALM_SCD_BASE                        (PRPH_BASE + 0x2E00)</span>
<span class="cp">#define ALM_SCD_MODE_REG                    (ALM_SCD_BASE + 0x000)</span>
<span class="cp">#define ALM_SCD_ARASTAT_REG                 (ALM_SCD_BASE + 0x004)</span>
<span class="cp">#define ALM_SCD_TXFACT_REG                  (ALM_SCD_BASE + 0x010)</span>
<span class="cp">#define ALM_SCD_TXF4MF_REG                  (ALM_SCD_BASE + 0x014)</span>
<span class="cp">#define ALM_SCD_TXF5MF_REG                  (ALM_SCD_BASE + 0x020)</span>
<span class="cp">#define ALM_SCD_SBYP_MODE_1_REG             (ALM_SCD_BASE + 0x02C)</span>
<span class="cp">#define ALM_SCD_SBYP_MODE_2_REG             (ALM_SCD_BASE + 0x030)</span>

<span class="cm">/**</span>
<span class="cm"> * Tx Scheduler</span>
<span class="cm"> *</span>
<span class="cm"> * The Tx Scheduler selects the next frame to be transmitted, choosing TFDs</span>
<span class="cm"> * (Transmit Frame Descriptors) from up to 16 circular Tx queues resident in</span>
<span class="cm"> * host DRAM.  It steers each frame&#39;s Tx command (which contains the frame</span>
<span class="cm"> * data) into one of up to 7 prioritized Tx DMA FIFO channels within the</span>
<span class="cm"> * device.  A queue maps to only one (selectable by driver) Tx DMA channel,</span>
<span class="cm"> * but one DMA channel may take input from several queues.</span>
<span class="cm"> *</span>
<span class="cm"> * Tx DMA FIFOs have dedicated purposes.  For 4965, they are used as follows</span>
<span class="cm"> * (cf. default_queue_to_tx_fifo in 4965.c):</span>
<span class="cm"> *</span>
<span class="cm"> * 0 -- EDCA BK (background) frames, lowest priority</span>
<span class="cm"> * 1 -- EDCA BE (best effort) frames, normal priority</span>
<span class="cm"> * 2 -- EDCA VI (video) frames, higher priority</span>
<span class="cm"> * 3 -- EDCA VO (voice) and management frames, highest priority</span>
<span class="cm"> * 4 -- Commands (e.g. RXON, etc.)</span>
<span class="cm"> * 5 -- unused (HCCA)</span>
<span class="cm"> * 6 -- unused (HCCA)</span>
<span class="cm"> * 7 -- not used by driver (device-internal only)</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Driver should normally map queues 0-6 to Tx DMA/FIFO channels 0-6.</span>
<span class="cm"> * In addition, driver can map the remaining queues to Tx DMA/FIFO</span>
<span class="cm"> * channels 0-3 to support 11n aggregation via EDCA DMA channels.</span>
<span class="cm"> *</span>
<span class="cm"> * The driver sets up each queue to work in one of two modes:</span>
<span class="cm"> *</span>
<span class="cm"> * 1)  Scheduler-Ack, in which the scheduler automatically supports a</span>
<span class="cm"> *     block-ack (BA) win of up to 64 TFDs.  In this mode, each queue</span>
<span class="cm"> *     contains TFDs for a unique combination of Recipient Address (RA)</span>
<span class="cm"> *     and Traffic Identifier (TID), that is, traffic of a given</span>
<span class="cm"> *     Quality-Of-Service (QOS) priority, destined for a single station.</span>
<span class="cm"> *</span>
<span class="cm"> *     In scheduler-ack mode, the scheduler keeps track of the Tx status of</span>
<span class="cm"> *     each frame within the BA win, including whether it&#39;s been transmitted,</span>
<span class="cm"> *     and whether it&#39;s been acknowledged by the receiving station.  The device</span>
<span class="cm"> *     automatically processes block-acks received from the receiving STA,</span>
<span class="cm"> *     and reschedules un-acked frames to be retransmitted (successful</span>
<span class="cm"> *     Tx completion may end up being out-of-order).</span>
<span class="cm"> *</span>
<span class="cm"> *     The driver must maintain the queue&#39;s Byte Count table in host DRAM</span>
<span class="cm"> *     (struct il4965_sched_queue_byte_cnt_tbl) for this mode.</span>
<span class="cm"> *     This mode does not support fragmentation.</span>
<span class="cm"> *</span>
<span class="cm"> * 2)  FIFO (a.k.a. non-Scheduler-ACK), in which each TFD is processed in order.</span>
<span class="cm"> *     The device may automatically retry Tx, but will retry only one frame</span>
<span class="cm"> *     at a time, until receiving ACK from receiving station, or reaching</span>
<span class="cm"> *     retry limit and giving up.</span>
<span class="cm"> *</span>
<span class="cm"> *     The command queue (#4/#9) must use this mode!</span>
<span class="cm"> *     This mode does not require use of the Byte Count table in host DRAM.</span>
<span class="cm"> *</span>
<span class="cm"> * Driver controls scheduler operation via 3 means:</span>
<span class="cm"> * 1)  Scheduler registers</span>
<span class="cm"> * 2)  Shared scheduler data base in internal 4956 SRAM</span>
<span class="cm"> * 3)  Shared data in host DRAM</span>
<span class="cm"> *</span>
<span class="cm"> * Initialization:</span>
<span class="cm"> *</span>
<span class="cm"> * When loading, driver should allocate memory for:</span>
<span class="cm"> * 1)  16 TFD circular buffers, each with space for (typically) 256 TFDs.</span>
<span class="cm"> * 2)  16 Byte Count circular buffers in 16 KBytes contiguous memory</span>
<span class="cm"> *     (1024 bytes for each queue).</span>
<span class="cm"> *</span>
<span class="cm"> * After receiving &quot;Alive&quot; response from uCode, driver must initialize</span>
<span class="cm"> * the scheduler (especially for queue #4/#9, the command queue, otherwise</span>
<span class="cm"> * the driver can&#39;t issue commands!):</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * Max Tx win size is the max number of contiguous TFDs that the scheduler</span>
<span class="cm"> * can keep track of at one time when creating block-ack chains of frames.</span>
<span class="cm"> * Note that &quot;64&quot; matches the number of ack bits in a block-ack packet.</span>
<span class="cm"> * Driver should use SCD_WIN_SIZE and SCD_FRAME_LIMIT values to initialize</span>
<span class="cm"> * IL49_SCD_CONTEXT_QUEUE_OFFSET(x) values.</span>
<span class="cm"> */</span>
<span class="cp">#define SCD_WIN_SIZE				64</span>
<span class="cp">#define SCD_FRAME_LIMIT				64</span>

<span class="cm">/* SCD registers are internal, must be accessed via HBUS_TARG_PRPH regs */</span>
<span class="cp">#define IL49_SCD_START_OFFSET		0xa02c00</span>

<span class="cm">/*</span>
<span class="cm"> * 4965 tells driver SRAM address for internal scheduler structs via this reg.</span>
<span class="cm"> * Value is valid only after &quot;Alive&quot; response from uCode.</span>
<span class="cm"> */</span>
<span class="cp">#define IL49_SCD_SRAM_BASE_ADDR           (IL49_SCD_START_OFFSET + 0x0)</span>

<span class="cm">/*</span>
<span class="cm"> * Driver may need to update queue-empty bits after changing queue&#39;s</span>
<span class="cm"> * write and read pointers (idxes) during (re-)initialization (i.e. when</span>
<span class="cm"> * scheduler is not tracking what&#39;s happening).</span>
<span class="cm"> * Bit fields:</span>
<span class="cm"> * 31-16:  Write mask -- 1: update empty bit, 0: don&#39;t change empty bit</span>
<span class="cm"> * 15-00:  Empty state, one for each queue -- 1: empty, 0: non-empty</span>
<span class="cm"> * NOTE:  This register is not used by Linux driver.</span>
<span class="cm"> */</span>
<span class="cp">#define IL49_SCD_EMPTY_BITS               (IL49_SCD_START_OFFSET + 0x4)</span>

<span class="cm">/*</span>
<span class="cm"> * Physical base address of array of byte count (BC) circular buffers (CBs).</span>
<span class="cm"> * Each Tx queue has a BC CB in host DRAM to support Scheduler-ACK mode.</span>
<span class="cm"> * This register points to BC CB for queue 0, must be on 1024-byte boundary.</span>
<span class="cm"> * Others are spaced by 1024 bytes.</span>
<span class="cm"> * Each BC CB is 2 bytes * (256 + 64) = 740 bytes, followed by 384 bytes pad.</span>
<span class="cm"> * (Index into a queue&#39;s BC CB) = (idx into queue&#39;s TFD CB) = (SSN &amp; 0xff).</span>
<span class="cm"> * Bit fields:</span>
<span class="cm"> * 25-00:  Byte Count CB physical address [35:10], must be 1024-byte aligned.</span>
<span class="cm"> */</span>
<span class="cp">#define IL49_SCD_DRAM_BASE_ADDR           (IL49_SCD_START_OFFSET + 0x10)</span>

<span class="cm">/*</span>
<span class="cm"> * Enables any/all Tx DMA/FIFO channels.</span>
<span class="cm"> * Scheduler generates requests for only the active channels.</span>
<span class="cm"> * Set this to 0xff to enable all 8 channels (normal usage).</span>
<span class="cm"> * Bit fields:</span>
<span class="cm"> *  7- 0:  Enable (1), disable (0), one bit for each channel 0-7</span>
<span class="cm"> */</span>
<span class="cp">#define IL49_SCD_TXFACT                   (IL49_SCD_START_OFFSET + 0x1c)</span>
<span class="cm">/*</span>
<span class="cm"> * Queue (x) Write Pointers (idxes, really!), one for each Tx queue.</span>
<span class="cm"> * Initialized and updated by driver as new TFDs are added to queue.</span>
<span class="cm"> * NOTE:  If using Block Ack, idx must correspond to frame&#39;s</span>
<span class="cm"> *        Start Sequence Number; idx = (SSN &amp; 0xff)</span>
<span class="cm"> * NOTE:  Alternative to HBUS_TARG_WRPTR, which is what Linux driver uses?</span>
<span class="cm"> */</span>
<span class="cp">#define IL49_SCD_QUEUE_WRPTR(x)  (IL49_SCD_START_OFFSET + 0x24 + (x) * 4)</span>

<span class="cm">/*</span>
<span class="cm"> * Queue (x) Read Pointers (idxes, really!), one for each Tx queue.</span>
<span class="cm"> * For FIFO mode, idx indicates next frame to transmit.</span>
<span class="cm"> * For Scheduler-ACK mode, idx indicates first frame in Tx win.</span>
<span class="cm"> * Initialized by driver, updated by scheduler.</span>
<span class="cm"> */</span>
<span class="cp">#define IL49_SCD_QUEUE_RDPTR(x)  (IL49_SCD_START_OFFSET + 0x64 + (x) * 4)</span>

<span class="cm">/*</span>
<span class="cm"> * Select which queues work in chain mode (1) vs. not (0).</span>
<span class="cm"> * Use chain mode to build chains of aggregated frames.</span>
<span class="cm"> * Bit fields:</span>
<span class="cm"> * 31-16:  Reserved</span>
<span class="cm"> * 15-00:  Mode, one bit for each queue -- 1: Chain mode, 0: one-at-a-time</span>
<span class="cm"> * NOTE:  If driver sets up queue for chain mode, it should be also set up</span>
<span class="cm"> *        Scheduler-ACK mode as well, via SCD_QUEUE_STATUS_BITS(x).</span>
<span class="cm"> */</span>
<span class="cp">#define IL49_SCD_QUEUECHAIN_SEL  (IL49_SCD_START_OFFSET + 0xd0)</span>

<span class="cm">/*</span>
<span class="cm"> * Select which queues interrupt driver when scheduler increments</span>
<span class="cm"> * a queue&#39;s read pointer (idx).</span>
<span class="cm"> * Bit fields:</span>
<span class="cm"> * 31-16:  Reserved</span>
<span class="cm"> * 15-00:  Interrupt enable, one bit for each queue -- 1: enabled, 0: disabled</span>
<span class="cm"> * NOTE:  This functionality is apparently a no-op; driver relies on interrupts</span>
<span class="cm"> *        from Rx queue to read Tx command responses and update Tx queues.</span>
<span class="cm"> */</span>
<span class="cp">#define IL49_SCD_INTERRUPT_MASK  (IL49_SCD_START_OFFSET + 0xe4)</span>

<span class="cm">/*</span>
<span class="cm"> * Queue search status registers.  One for each queue.</span>
<span class="cm"> * Sets up queue mode and assigns queue to Tx DMA channel.</span>
<span class="cm"> * Bit fields:</span>
<span class="cm"> * 19-10: Write mask/enable bits for bits 0-9</span>
<span class="cm"> *     9: Driver should init to &quot;0&quot;</span>
<span class="cm"> *     8: Scheduler-ACK mode (1), non-Scheduler-ACK (i.e. FIFO) mode (0).</span>
<span class="cm"> *        Driver should init to &quot;1&quot; for aggregation mode, or &quot;0&quot; otherwise.</span>
<span class="cm"> *   7-6: Driver should init to &quot;0&quot;</span>
<span class="cm"> *     5: Window Size Left; indicates whether scheduler can request</span>
<span class="cm"> *        another TFD, based on win size, etc.  Driver should init</span>
<span class="cm"> *        this bit to &quot;1&quot; for aggregation mode, or &quot;0&quot; for non-agg.</span>
<span class="cm"> *   4-1: Tx FIFO to use (range 0-7).</span>
<span class="cm"> *     0: Queue is active (1), not active (0).</span>
<span class="cm"> * Other bits should be written as &quot;0&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  If enabling Scheduler-ACK mode, chain mode should also be enabled</span>
<span class="cm"> *        via SCD_QUEUECHAIN_SEL.</span>
<span class="cm"> */</span>
<span class="cp">#define IL49_SCD_QUEUE_STATUS_BITS(x)\</span>
<span class="cp">	(IL49_SCD_START_OFFSET + 0x104 + (x) * 4)</span>

<span class="cm">/* Bit field positions */</span>
<span class="cp">#define IL49_SCD_QUEUE_STTS_REG_POS_ACTIVE	(0)</span>
<span class="cp">#define IL49_SCD_QUEUE_STTS_REG_POS_TXF	(1)</span>
<span class="cp">#define IL49_SCD_QUEUE_STTS_REG_POS_WSL	(5)</span>
<span class="cp">#define IL49_SCD_QUEUE_STTS_REG_POS_SCD_ACK	(8)</span>

<span class="cm">/* Write masks */</span>
<span class="cp">#define IL49_SCD_QUEUE_STTS_REG_POS_SCD_ACT_EN	(10)</span>
<span class="cp">#define IL49_SCD_QUEUE_STTS_REG_MSK		(0x0007FC00)</span>

<span class="cm">/**</span>
<span class="cm"> * 4965 internal SRAM structures for scheduler, shared with driver ...</span>
<span class="cm"> *</span>
<span class="cm"> * Driver should clear and initialize the following areas after receiving</span>
<span class="cm"> * &quot;Alive&quot; response from 4965 uCode, i.e. after initial</span>
<span class="cm"> * uCode load, or after a uCode load done for error recovery:</span>
<span class="cm"> *</span>
<span class="cm"> * SCD_CONTEXT_DATA_OFFSET (size 128 bytes)</span>
<span class="cm"> * SCD_TX_STTS_BITMAP_OFFSET (size 256 bytes)</span>
<span class="cm"> * SCD_TRANSLATE_TBL_OFFSET (size 32 bytes)</span>
<span class="cm"> *</span>
<span class="cm"> * Driver accesses SRAM via HBUS_TARG_MEM_* registers.</span>
<span class="cm"> * Driver reads base address of this scheduler area from SCD_SRAM_BASE_ADDR.</span>
<span class="cm"> * All OFFSET values must be added to this base address.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Queue context.  One 8-byte entry for each of 16 queues.</span>
<span class="cm"> *</span>
<span class="cm"> * Driver should clear this entire area (size 0x80) to 0 after receiving</span>
<span class="cm"> * &quot;Alive&quot; notification from uCode.  Additionally, driver should init</span>
<span class="cm"> * each queue&#39;s entry as follows:</span>
<span class="cm"> *</span>
<span class="cm"> * LS Dword bit fields:</span>
<span class="cm"> *  0-06:  Max Tx win size for Scheduler-ACK.  Driver should init to 64.</span>
<span class="cm"> *</span>
<span class="cm"> * MS Dword bit fields:</span>
<span class="cm"> * 16-22:  Frame limit.  Driver should init to 10 (0xa).</span>
<span class="cm"> *</span>
<span class="cm"> * Driver should init all other bits to 0.</span>
<span class="cm"> *</span>
<span class="cm"> * Init must be done after driver receives &quot;Alive&quot; response from 4965 uCode,</span>
<span class="cm"> * and when setting up queue for aggregation.</span>
<span class="cm"> */</span>
<span class="cp">#define IL49_SCD_CONTEXT_DATA_OFFSET			0x380</span>
<span class="cp">#define IL49_SCD_CONTEXT_QUEUE_OFFSET(x) \</span>
<span class="cp">			(IL49_SCD_CONTEXT_DATA_OFFSET + ((x) * 8))</span>

<span class="cp">#define IL49_SCD_QUEUE_CTX_REG1_WIN_SIZE_POS		(0)</span>
<span class="cp">#define IL49_SCD_QUEUE_CTX_REG1_WIN_SIZE_MSK		(0x0000007F)</span>
<span class="cp">#define IL49_SCD_QUEUE_CTX_REG2_FRAME_LIMIT_POS	(16)</span>
<span class="cp">#define IL49_SCD_QUEUE_CTX_REG2_FRAME_LIMIT_MSK	(0x007F0000)</span>

<span class="cm">/*</span>
<span class="cm"> * Tx Status Bitmap</span>
<span class="cm"> *</span>
<span class="cm"> * Driver should clear this entire area (size 0x100) to 0 after receiving</span>
<span class="cm"> * &quot;Alive&quot; notification from uCode.  Area is used only by device itself;</span>
<span class="cm"> * no other support (besides clearing) is required from driver.</span>
<span class="cm"> */</span>
<span class="cp">#define IL49_SCD_TX_STTS_BITMAP_OFFSET		0x400</span>

<span class="cm">/*</span>
<span class="cm"> * RAxTID to queue translation mapping.</span>
<span class="cm"> *</span>
<span class="cm"> * When queue is in Scheduler-ACK mode, frames placed in a that queue must be</span>
<span class="cm"> * for only one combination of receiver address (RA) and traffic ID (TID), i.e.</span>
<span class="cm"> * one QOS priority level destined for one station (for this wireless link,</span>
<span class="cm"> * not final destination).  The SCD_TRANSLATE_TBL area provides 16 16-bit</span>
<span class="cm"> * mappings, one for each of the 16 queues.  If queue is not in Scheduler-ACK</span>
<span class="cm"> * mode, the device ignores the mapping value.</span>
<span class="cm"> *</span>
<span class="cm"> * Bit fields, for each 16-bit map:</span>
<span class="cm"> * 15-9:  Reserved, set to 0</span>
<span class="cm"> *  8-4:  Index into device&#39;s station table for recipient station</span>
<span class="cm"> *  3-0:  Traffic ID (tid), range 0-15</span>
<span class="cm"> *</span>
<span class="cm"> * Driver should clear this entire area (size 32 bytes) to 0 after receiving</span>
<span class="cm"> * &quot;Alive&quot; notification from uCode.  To update a 16-bit map value, driver</span>
<span class="cm"> * must read a dword-aligned value from device SRAM, replace the 16-bit map</span>
<span class="cm"> * value of interest, and write the dword value back into device SRAM.</span>
<span class="cm"> */</span>
<span class="cp">#define IL49_SCD_TRANSLATE_TBL_OFFSET		0x500</span>

<span class="cm">/* Find translation table dword to read/write for given queue */</span>
<span class="cp">#define IL49_SCD_TRANSLATE_TBL_OFFSET_QUEUE(x) \</span>
<span class="cp">	((IL49_SCD_TRANSLATE_TBL_OFFSET + ((x) * 2)) &amp; 0xfffffffc)</span>

<span class="cp">#define IL_SCD_TXFIFO_POS_TID			(0)</span>
<span class="cp">#define IL_SCD_TXFIFO_POS_RA			(4)</span>
<span class="cp">#define IL_SCD_QUEUE_RA_TID_MAP_RATID_MSK	(0x01FF)</span>

<span class="cm">/*********************** END TX SCHEDULER *************************************/</span>

<span class="cp">#endif </span><span class="cm">/* __il_prph_h__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
