<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › iwlegacy › common.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>common.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2003 - 2011 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of version 2 of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA</span>
<span class="cm"> *</span>
<span class="cm"> * The full GNU General Public License is included in this distribution in the</span>
<span class="cm"> * file called LICENSE.</span>
<span class="cm"> *</span>
<span class="cm"> * Contact Information:</span>
<span class="cm"> *  Intel Linux Wireless &lt;ilw@linux.intel.com&gt;</span>
<span class="cm"> * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>
<span class="cp">#ifndef __il_core_h__</span>
<span class="cp">#define __il_core_h__</span>

<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;		</span><span class="cm">/* for struct pci_device_id */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/leds.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;net/mac80211.h&gt;</span>
<span class="cp">#include &lt;net/ieee80211_radiotap.h&gt;</span>

<span class="cp">#include &quot;commands.h&quot;</span>
<span class="cp">#include &quot;csr.h&quot;</span>
<span class="cp">#include &quot;prph.h&quot;</span>

<span class="k">struct</span> <span class="n">il_host_cmd</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">il_cmd</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">il_tx_queue</span><span class="p">;</span>

<span class="cp">#define IL_ERR(f, a...) dev_err(&amp;il-&gt;pci_dev-&gt;dev, f, ## a)</span>
<span class="cp">#define IL_WARN(f, a...) dev_warn(&amp;il-&gt;pci_dev-&gt;dev, f, ## a)</span>
<span class="cp">#define IL_INFO(f, a...) dev_info(&amp;il-&gt;pci_dev-&gt;dev, f, ## a)</span>

<span class="cp">#define RX_QUEUE_SIZE                         256</span>
<span class="cp">#define RX_QUEUE_MASK                         255</span>
<span class="cp">#define RX_QUEUE_SIZE_LOG                     8</span>

<span class="cm">/*</span>
<span class="cm"> * RX related structures and functions</span>
<span class="cm"> */</span>
<span class="cp">#define RX_FREE_BUFFERS 64</span>
<span class="cp">#define RX_LOW_WATERMARK 8</span>

<span class="cp">#define U32_PAD(n)		((4-(n))&amp;0x3)</span>

<span class="cm">/* CT-KILL constants */</span>
<span class="cp">#define CT_KILL_THRESHOLD_LEGACY   110	</span><span class="cm">/* in Celsius */</span><span class="cp"></span>

<span class="cm">/* Default noise level to report when noise measurement is not available.</span>
<span class="cm"> *   This may be because we&#39;re:</span>
<span class="cm"> *   1)  Not associated (4965, no beacon stats being sent to driver)</span>
<span class="cm"> *   2)  Scanning (noise measurement does not apply to associated channel)</span>
<span class="cm"> *   3)  Receiving CCK (3945 delivers noise info only for OFDM frames)</span>
<span class="cm"> * Use default noise value of -127 ... this is below the range of measurable</span>
<span class="cm"> *   Rx dBm for either 3945 or 4965, so it can indicate &quot;unmeasurable&quot; to user.</span>
<span class="cm"> *   Also, -127 works better than 0 when averaging frames with/without</span>
<span class="cm"> *   noise info (e.g. averaging might be done in app); measured dBm values are</span>
<span class="cm"> *   always negative ... using a negative value as the default keeps all</span>
<span class="cm"> *   averages within an s8&#39;s (used in some apps) range of negative values. */</span>
<span class="cp">#define IL_NOISE_MEAS_NOT_AVAILABLE (-127)</span>

<span class="cm">/*</span>
<span class="cm"> * RTS threshold here is total size [2347] minus 4 FCS bytes</span>
<span class="cm"> * Per spec:</span>
<span class="cm"> *   a value of 0 means RTS on all data/management packets</span>
<span class="cm"> *   a value &gt; max MSDU size means no RTS</span>
<span class="cm"> * else RTS for data/management frames where MPDU is larger</span>
<span class="cm"> *   than RTS value.</span>
<span class="cm"> */</span>
<span class="cp">#define DEFAULT_RTS_THRESHOLD     2347U</span>
<span class="cp">#define MIN_RTS_THRESHOLD         0U</span>
<span class="cp">#define MAX_RTS_THRESHOLD         2347U</span>
<span class="cp">#define MAX_MSDU_SIZE		  2304U</span>
<span class="cp">#define MAX_MPDU_SIZE		  2346U</span>
<span class="cp">#define DEFAULT_BEACON_INTERVAL   100U</span>
<span class="cp">#define	DEFAULT_SHORT_RETRY_LIMIT 7U</span>
<span class="cp">#define	DEFAULT_LONG_RETRY_LIMIT  4U</span>

<span class="k">struct</span> <span class="n">il_rx_buf</span> <span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">page_dma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define rxb_addr(r) page_address(r-&gt;page)</span>

<span class="cm">/* defined below */</span>
<span class="k">struct</span> <span class="n">il_device_cmd</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">il_cmd_meta</span> <span class="p">{</span>
	<span class="cm">/* only for SYNC commands, iff the reply skb is wanted */</span>
	<span class="k">struct</span> <span class="n">il_host_cmd</span> <span class="o">*</span><span class="n">source</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * only for ASYNC commands</span>
<span class="cm">	 * (which is somewhat stupid -- look at common.c for instance</span>
<span class="cm">	 * which duplicates a bunch of code because the callback isn&#39;t</span>
<span class="cm">	 * invoked for SYNC commands, if it were and its result passed</span>
<span class="cm">	 * through it would be simpler...)</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_device_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">il_rx_pkt</span> <span class="o">*</span><span class="n">pkt</span><span class="p">);</span>

	<span class="cm">/* The CMD_SIZE_HUGE flag bit indicates that the command</span>
<span class="cm">	 * structure is stored at the end of the shared queue memory. */</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>

	 <span class="n">DEFINE_DMA_UNMAP_ADDR</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
	 <span class="n">DEFINE_DMA_UNMAP_LEN</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Generic queue structure</span>
<span class="cm"> *</span>
<span class="cm"> * Contains common data for Rx and Tx queues</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">il_queue</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">n_bd</span><span class="p">;</span>		<span class="cm">/* number of BDs in this queue */</span>
	<span class="kt">int</span> <span class="n">write_ptr</span><span class="p">;</span>		<span class="cm">/* 1-st empty entry (idx) host_w */</span>
	<span class="kt">int</span> <span class="n">read_ptr</span><span class="p">;</span>		<span class="cm">/* last used entry (idx) host_r */</span>
	<span class="cm">/* use for monitoring and recovering the stuck queue */</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">;</span>	<span class="cm">/* physical addr for BD&#39;s */</span>
	<span class="kt">int</span> <span class="n">n_win</span><span class="p">;</span>		<span class="cm">/* safe queue win */</span>
	<span class="n">u32</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">low_mark</span><span class="p">;</span>		<span class="cm">/* low watermark, resume queue if free</span>
<span class="cm">				 * space more than this */</span>
	<span class="kt">int</span> <span class="n">high_mark</span><span class="p">;</span>		<span class="cm">/* high watermark, stop queue if free</span>
<span class="cm">				 * space less than this */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct il_tx_queue - Tx Queue for DMA</span>
<span class="cm"> * @q: generic Rx/Tx queue descriptor</span>
<span class="cm"> * @bd: base of circular buffer of TFDs</span>
<span class="cm"> * @cmd: array of command/TX buffer pointers</span>
<span class="cm"> * @meta: array of meta data for each command/tx buffer</span>
<span class="cm"> * @dma_addr_cmd: physical address of cmd/tx buffer array</span>
<span class="cm"> * @skbs: array of per-TFD socket buffer pointers</span>
<span class="cm"> * @time_stamp: time (in jiffies) of last read_ptr change</span>
<span class="cm"> * @need_update: indicates need to update read/write idx</span>
<span class="cm"> * @sched_retry: indicates queue is high-throughput aggregation (HT AGG) enabled</span>
<span class="cm"> *</span>
<span class="cm"> * A Tx queue consists of circular buffer of BDs (a.k.a. TFDs, transmit frame</span>
<span class="cm"> * descriptors) and required locking structures.</span>
<span class="cm"> */</span>
<span class="cp">#define TFD_TX_CMD_SLOTS 256</span>
<span class="cp">#define TFD_CMD_SLOTS 32</span>

<span class="k">struct</span> <span class="n">il_tx_queue</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">il_queue</span> <span class="n">q</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">tfds</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_device_cmd</span> <span class="o">**</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_cmd_meta</span> <span class="o">*</span><span class="n">meta</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">skbs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">time_stamp</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">need_update</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">sched_retry</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">active</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">swq_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * EEPROM access time values:</span>
<span class="cm"> *</span>
<span class="cm"> * Driver initiates EEPROM read by writing byte address &lt;&lt; 1 to CSR_EEPROM_REG.</span>
<span class="cm"> * Driver then polls CSR_EEPROM_REG for CSR_EEPROM_REG_READ_VALID_MSK (0x1).</span>
<span class="cm"> * When polling, wait 10 uSec between polling loops, up to a maximum 5000 uSec.</span>
<span class="cm"> * Driver reads 16-bit value from bits 31-16 of CSR_EEPROM_REG.</span>
<span class="cm"> */</span>
<span class="cp">#define IL_EEPROM_ACCESS_TIMEOUT	5000	</span><span class="cm">/* uSec */</span><span class="cp"></span>

<span class="cp">#define IL_EEPROM_SEM_TIMEOUT		10	</span><span class="cm">/* microseconds */</span><span class="cp"></span>
<span class="cp">#define IL_EEPROM_SEM_RETRY_LIMIT	1000	</span><span class="cm">/* number of attempts (not time) */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Regulatory channel usage flags in EEPROM struct il4965_eeprom_channel.flags.</span>
<span class="cm"> *</span>
<span class="cm"> * IBSS and/or AP operation is allowed *only* on those channels with</span>
<span class="cm"> * (VALID &amp;&amp; IBSS &amp;&amp; ACTIVE &amp;&amp; !RADAR).  This restriction is in place because</span>
<span class="cm"> * RADAR detection is not supported by the 4965 driver, but is a</span>
<span class="cm"> * requirement for establishing a new network for legal operation on channels</span>
<span class="cm"> * requiring RADAR detection or restricting ACTIVE scanning.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  &quot;WIDE&quot; flag does not indicate anything about &quot;HT40&quot; 40 MHz channels.</span>
<span class="cm"> *        It only indicates that 20 MHz channel use is supported; HT40 channel</span>
<span class="cm"> *        usage is indicated by a separate set of regulatory flags for each</span>
<span class="cm"> *        HT40 channel pair.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  Using a channel inappropriately will result in a uCode error!</span>
<span class="cm"> */</span>
<span class="cp">#define IL_NUM_TX_CALIB_GROUPS 5</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">EEPROM_CHANNEL_VALID</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>	<span class="cm">/* usable for this SKU/geo */</span>
	<span class="n">EEPROM_CHANNEL_IBSS</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>	<span class="cm">/* usable as an IBSS channel */</span>
	<span class="cm">/* Bit 2 Reserved */</span>
	<span class="n">EEPROM_CHANNEL_ACTIVE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>	<span class="cm">/* active scanning allowed */</span>
	<span class="n">EEPROM_CHANNEL_RADAR</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span>	<span class="cm">/* radar detection required */</span>
	<span class="n">EEPROM_CHANNEL_WIDE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span>	<span class="cm">/* 20 MHz channel okay */</span>
	<span class="cm">/* Bit 6 Reserved (was Narrow Channel) */</span>
	<span class="n">EEPROM_CHANNEL_DFS</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span>	<span class="cm">/* dynamic freq selection candidate */</span>
<span class="p">};</span>

<span class="cm">/* SKU Capabilities */</span>
<span class="cm">/* 3945 only */</span>
<span class="cp">#define EEPROM_SKU_CAP_SW_RF_KILL_ENABLE                (1 &lt;&lt; 0)</span>
<span class="cp">#define EEPROM_SKU_CAP_HW_RF_KILL_ENABLE                (1 &lt;&lt; 1)</span>

<span class="cm">/* *regulatory* channel data format in eeprom, one for each channel.</span>
<span class="cm"> * There are separate entries for HT40 (40 MHz) vs. normal (20 MHz) channels. */</span>
<span class="k">struct</span> <span class="n">il_eeprom_channel</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* EEPROM_CHANNEL_* flags copied from EEPROM */</span>
	<span class="n">s8</span> <span class="n">max_power_avg</span><span class="p">;</span>	<span class="cm">/* max power (dBm) on this chnl, limit 31 */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* 3945 Specific */</span>
<span class="cp">#define EEPROM_3945_EEPROM_VERSION	(0x2f)</span>

<span class="cm">/* 4965 has two radio transmitters (and 3 radio receivers) */</span>
<span class="cp">#define EEPROM_TX_POWER_TX_CHAINS      (2)</span>

<span class="cm">/* 4965 has room for up to 8 sets of txpower calibration data */</span>
<span class="cp">#define EEPROM_TX_POWER_BANDS          (8)</span>

<span class="cm">/* 4965 factory calibration measures txpower gain settings for</span>
<span class="cm"> * each of 3 target output levels */</span>
<span class="cp">#define EEPROM_TX_POWER_MEASUREMENTS   (3)</span>

<span class="cm">/* 4965 Specific */</span>
<span class="cm">/* 4965 driver does not work with txpower calibration version &lt; 5 */</span>
<span class="cp">#define EEPROM_4965_TX_POWER_VERSION    (5)</span>
<span class="cp">#define EEPROM_4965_EEPROM_VERSION	(0x2f)</span>
<span class="cp">#define EEPROM_4965_CALIB_VERSION_OFFSET       (2*0xB6)	</span><span class="cm">/* 2 bytes */</span><span class="cp"></span>
<span class="cp">#define EEPROM_4965_CALIB_TXPOWER_OFFSET       (2*0xE8)	</span><span class="cm">/* 48  bytes */</span><span class="cp"></span>
<span class="cp">#define EEPROM_4965_BOARD_REVISION             (2*0x4F)	</span><span class="cm">/* 2 bytes */</span><span class="cp"></span>
<span class="cp">#define EEPROM_4965_BOARD_PBA                  (2*0x56+1)	</span><span class="cm">/* 9 bytes */</span><span class="cp"></span>

<span class="cm">/* 2.4 GHz */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">il_eeprom_band_1</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * factory calibration data for one txpower level, on one channel,</span>
<span class="cm"> * measured on one of the 2 tx chains (radio transmitter and associated</span>
<span class="cm"> * antenna).  EEPROM contains:</span>
<span class="cm"> *</span>
<span class="cm"> * 1)  Temperature (degrees Celsius) of device when measurement was made.</span>
<span class="cm"> *</span>
<span class="cm"> * 2)  Gain table idx used to achieve the target measurement power.</span>
<span class="cm"> *     This refers to the &quot;well-known&quot; gain tables (see 4965.h).</span>
<span class="cm"> *</span>
<span class="cm"> * 3)  Actual measured output power, in half-dBm (&quot;34&quot; = 17 dBm).</span>
<span class="cm"> *</span>
<span class="cm"> * 4)  RF power amplifier detector level measurement (not used).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">il_eeprom_calib_measure</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">temperature</span><span class="p">;</span>		<span class="cm">/* Device temperature (Celsius) */</span>
	<span class="n">u8</span> <span class="n">gain_idx</span><span class="p">;</span>		<span class="cm">/* Index into gain table */</span>
	<span class="n">u8</span> <span class="n">actual_pow</span><span class="p">;</span>		<span class="cm">/* Measured RF output power, half-dBm */</span>
	<span class="n">s8</span> <span class="n">pa_det</span><span class="p">;</span>		<span class="cm">/* Power amp detector level (not used) */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * measurement set for one channel.  EEPROM contains:</span>
<span class="cm"> *</span>
<span class="cm"> * 1)  Channel number measured</span>
<span class="cm"> *</span>
<span class="cm"> * 2)  Measurements for each of 3 power levels for each of 2 radio transmitters</span>
<span class="cm"> *     (a.k.a. &quot;tx chains&quot;) (6 measurements altogether)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">il_eeprom_calib_ch_info</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">ch_num</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_eeprom_calib_measure</span>
	    <span class="n">measurements</span><span class="p">[</span><span class="n">EEPROM_TX_POWER_TX_CHAINS</span><span class="p">]</span>
	    <span class="p">[</span><span class="n">EEPROM_TX_POWER_MEASUREMENTS</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * txpower subband info.</span>
<span class="cm"> *</span>
<span class="cm"> * For each frequency subband, EEPROM contains the following:</span>
<span class="cm"> *</span>
<span class="cm"> * 1)  First and last channels within range of the subband.  &quot;0&quot; values</span>
<span class="cm"> *     indicate that this sample set is not being used.</span>
<span class="cm"> *</span>
<span class="cm"> * 2)  Sample measurement sets for 2 channels close to the range endpoints.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">il_eeprom_calib_subband_info</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">ch_from</span><span class="p">;</span>		<span class="cm">/* channel number of lowest channel in subband */</span>
	<span class="n">u8</span> <span class="n">ch_to</span><span class="p">;</span>		<span class="cm">/* channel number of highest channel in subband */</span>
	<span class="k">struct</span> <span class="n">il_eeprom_calib_ch_info</span> <span class="n">ch1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_eeprom_calib_ch_info</span> <span class="n">ch2</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * txpower calibration info.  EEPROM contains:</span>
<span class="cm"> *</span>
<span class="cm"> * 1)  Factory-measured saturation power levels (maximum levels at which</span>
<span class="cm"> *     tx power amplifier can output a signal without too much distortion).</span>
<span class="cm"> *     There is one level for 2.4 GHz band and one for 5 GHz band.  These</span>
<span class="cm"> *     values apply to all channels within each of the bands.</span>
<span class="cm"> *</span>
<span class="cm"> * 2)  Factory-measured power supply voltage level.  This is assumed to be</span>
<span class="cm"> *     constant (i.e. same value applies to all channels/bands) while the</span>
<span class="cm"> *     factory measurements are being made.</span>
<span class="cm"> *</span>
<span class="cm"> * 3)  Up to 8 sets of factory-measured txpower calibration values.</span>
<span class="cm"> *     These are for different frequency ranges, since txpower gain</span>
<span class="cm"> *     characteristics of the analog radio circuitry vary with frequency.</span>
<span class="cm"> *</span>
<span class="cm"> *     Not all sets need to be filled with data;</span>
<span class="cm"> *     struct il_eeprom_calib_subband_info contains range of channels</span>
<span class="cm"> *     (0 if unused) for each set of data.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">il_eeprom_calib_info</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">saturation_power24</span><span class="p">;</span>	<span class="cm">/* half-dBm (e.g. &quot;34&quot; = 17 dBm) */</span>
	<span class="n">u8</span> <span class="n">saturation_power52</span><span class="p">;</span>	<span class="cm">/* half-dBm */</span>
	<span class="n">__le16</span> <span class="n">voltage</span><span class="p">;</span>		<span class="cm">/* signed */</span>
	<span class="k">struct</span> <span class="n">il_eeprom_calib_subband_info</span> <span class="n">band_info</span><span class="p">[</span><span class="n">EEPROM_TX_POWER_BANDS</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* General */</span>
<span class="cp">#define EEPROM_DEVICE_ID                    (2*0x08)	</span><span class="cm">/* 2 bytes */</span><span class="cp"></span>
<span class="cp">#define EEPROM_MAC_ADDRESS                  (2*0x15)	</span><span class="cm">/* 6  bytes */</span><span class="cp"></span>
<span class="cp">#define EEPROM_BOARD_REVISION               (2*0x35)	</span><span class="cm">/* 2  bytes */</span><span class="cp"></span>
<span class="cp">#define EEPROM_BOARD_PBA_NUMBER             (2*0x3B+1)	</span><span class="cm">/* 9  bytes */</span><span class="cp"></span>
<span class="cp">#define EEPROM_VERSION                      (2*0x44)	</span><span class="cm">/* 2  bytes */</span><span class="cp"></span>
<span class="cp">#define EEPROM_SKU_CAP                      (2*0x45)	</span><span class="cm">/* 2  bytes */</span><span class="cp"></span>
<span class="cp">#define EEPROM_OEM_MODE                     (2*0x46)	</span><span class="cm">/* 2  bytes */</span><span class="cp"></span>
<span class="cp">#define EEPROM_WOWLAN_MODE                  (2*0x47)	</span><span class="cm">/* 2  bytes */</span><span class="cp"></span>
<span class="cp">#define EEPROM_RADIO_CONFIG                 (2*0x48)	</span><span class="cm">/* 2  bytes */</span><span class="cp"></span>
<span class="cp">#define EEPROM_NUM_MAC_ADDRESS              (2*0x4C)	</span><span class="cm">/* 2  bytes */</span><span class="cp"></span>

<span class="cm">/* The following masks are to be applied on EEPROM_RADIO_CONFIG */</span>
<span class="cp">#define EEPROM_RF_CFG_TYPE_MSK(x)   (x &amp; 0x3)	</span><span class="cm">/* bits 0-1   */</span><span class="cp"></span>
<span class="cp">#define EEPROM_RF_CFG_STEP_MSK(x)   ((x &gt;&gt; 2)  &amp; 0x3)	</span><span class="cm">/* bits 2-3   */</span><span class="cp"></span>
<span class="cp">#define EEPROM_RF_CFG_DASH_MSK(x)   ((x &gt;&gt; 4)  &amp; 0x3)	</span><span class="cm">/* bits 4-5   */</span><span class="cp"></span>
<span class="cp">#define EEPROM_RF_CFG_PNUM_MSK(x)   ((x &gt;&gt; 6)  &amp; 0x3)	</span><span class="cm">/* bits 6-7   */</span><span class="cp"></span>
<span class="cp">#define EEPROM_RF_CFG_TX_ANT_MSK(x) ((x &gt;&gt; 8)  &amp; 0xF)	</span><span class="cm">/* bits 8-11  */</span><span class="cp"></span>
<span class="cp">#define EEPROM_RF_CFG_RX_ANT_MSK(x) ((x &gt;&gt; 12) &amp; 0xF)	</span><span class="cm">/* bits 12-15 */</span><span class="cp"></span>

<span class="cp">#define EEPROM_3945_RF_CFG_TYPE_MAX  0x0</span>
<span class="cp">#define EEPROM_4965_RF_CFG_TYPE_MAX  0x1</span>

<span class="cm">/*</span>
<span class="cm"> * Per-channel regulatory data.</span>
<span class="cm"> *</span>
<span class="cm"> * Each channel that *might* be supported by iwl has a fixed location</span>
<span class="cm"> * in EEPROM containing EEPROM_CHANNEL_* usage flags (LSB) and max regulatory</span>
<span class="cm"> * txpower (MSB).</span>
<span class="cm"> *</span>
<span class="cm"> * Entries immediately below are for 20 MHz channel width.  HT40 (40 MHz)</span>
<span class="cm"> * channels (only for 4965, not supported by 3945) appear later in the EEPROM.</span>
<span class="cm"> *</span>
<span class="cm"> * 2.4 GHz channels 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14</span>
<span class="cm"> */</span>
<span class="cp">#define EEPROM_REGULATORY_SKU_ID            (2*0x60)	</span><span class="cm">/* 4  bytes */</span><span class="cp"></span>
<span class="cp">#define EEPROM_REGULATORY_BAND_1            (2*0x62)	</span><span class="cm">/* 2  bytes */</span><span class="cp"></span>
<span class="cp">#define EEPROM_REGULATORY_BAND_1_CHANNELS   (2*0x63)	</span><span class="cm">/* 28 bytes */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * 4.9 GHz channels 183, 184, 185, 187, 188, 189, 192, 196,</span>
<span class="cm"> * 5.0 GHz channels 7, 8, 11, 12, 16</span>
<span class="cm"> * (4915-5080MHz) (none of these is ever supported)</span>
<span class="cm"> */</span>
<span class="cp">#define EEPROM_REGULATORY_BAND_2            (2*0x71)	</span><span class="cm">/* 2  bytes */</span><span class="cp"></span>
<span class="cp">#define EEPROM_REGULATORY_BAND_2_CHANNELS   (2*0x72)	</span><span class="cm">/* 26 bytes */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * 5.2 GHz channels 34, 36, 38, 40, 42, 44, 46, 48, 52, 56, 60, 64</span>
<span class="cm"> * (5170-5320MHz)</span>
<span class="cm"> */</span>
<span class="cp">#define EEPROM_REGULATORY_BAND_3            (2*0x7F)	</span><span class="cm">/* 2  bytes */</span><span class="cp"></span>
<span class="cp">#define EEPROM_REGULATORY_BAND_3_CHANNELS   (2*0x80)	</span><span class="cm">/* 24 bytes */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * 5.5 GHz channels 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140</span>
<span class="cm"> * (5500-5700MHz)</span>
<span class="cm"> */</span>
<span class="cp">#define EEPROM_REGULATORY_BAND_4            (2*0x8C)	</span><span class="cm">/* 2  bytes */</span><span class="cp"></span>
<span class="cp">#define EEPROM_REGULATORY_BAND_4_CHANNELS   (2*0x8D)	</span><span class="cm">/* 22 bytes */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * 5.7 GHz channels 145, 149, 153, 157, 161, 165</span>
<span class="cm"> * (5725-5825MHz)</span>
<span class="cm"> */</span>
<span class="cp">#define EEPROM_REGULATORY_BAND_5            (2*0x98)	</span><span class="cm">/* 2  bytes */</span><span class="cp"></span>
<span class="cp">#define EEPROM_REGULATORY_BAND_5_CHANNELS   (2*0x99)	</span><span class="cm">/* 12 bytes */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * 2.4 GHz HT40 channels 1 (5), 2 (6), 3 (7), 4 (8), 5 (9), 6 (10), 7 (11)</span>
<span class="cm"> *</span>
<span class="cm"> * The channel listed is the center of the lower 20 MHz half of the channel.</span>
<span class="cm"> * The overall center frequency is actually 2 channels (10 MHz) above that,</span>
<span class="cm"> * and the upper half of each HT40 channel is centered 4 channels (20 MHz) away</span>
<span class="cm"> * from the lower half; e.g. the upper half of HT40 channel 1 is channel 5,</span>
<span class="cm"> * and the overall HT40 channel width centers on channel 3.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  The RXON command uses 20 MHz channel numbers to specify the</span>
<span class="cm"> *        control channel to which to tune.  RXON also specifies whether the</span>
<span class="cm"> *        control channel is the upper or lower half of a HT40 channel.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  4965 does not support HT40 channels on 2.4 GHz.</span>
<span class="cm"> */</span>
<span class="cp">#define EEPROM_4965_REGULATORY_BAND_24_HT40_CHANNELS (2*0xA0)	</span><span class="cm">/* 14 bytes */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * 5.2 GHz HT40 channels 36 (40), 44 (48), 52 (56), 60 (64),</span>
<span class="cm"> * 100 (104), 108 (112), 116 (120), 124 (128), 132 (136), 149 (153), 157 (161)</span>
<span class="cm"> */</span>
<span class="cp">#define EEPROM_4965_REGULATORY_BAND_52_HT40_CHANNELS (2*0xA8)	</span><span class="cm">/* 22 bytes */</span><span class="cp"></span>

<span class="cp">#define EEPROM_REGULATORY_BAND_NO_HT40			(0)</span>

<span class="kt">int</span> <span class="n">il_eeprom_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_eeprom_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">il_eeprom_query_addr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">offset</span><span class="p">);</span>
<span class="n">u16</span> <span class="n">il_eeprom_query16</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">offset</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il_init_channel_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_free_channel_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">il_channel_info</span> <span class="o">*</span><span class="n">il_get_channel_info</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span>
						  <span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">,</span>
						  <span class="n">u16</span> <span class="n">channel</span><span class="p">);</span>

<span class="cp">#define IL_NUM_SCAN_RATES         (2)</span>

<span class="k">struct</span> <span class="n">il4965_channel_tgd_info</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">s8</span> <span class="n">max_power</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">il4965_channel_tgh_info</span> <span class="p">{</span>
	<span class="n">s64</span> <span class="n">last_radar_time</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define IL4965_MAX_RATE (33)</span>

<span class="k">struct</span> <span class="n">il3945_clip_group</span> <span class="p">{</span>
	<span class="cm">/* maximum power level to prevent clipping for each rate, derived by</span>
<span class="cm">	 *   us from this band&#39;s saturation power in EEPROM */</span>
	<span class="k">const</span> <span class="n">s8</span> <span class="n">clip_powers</span><span class="p">[</span><span class="n">IL_MAX_RATES</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* current Tx power values to use, one for each rate for each channel.</span>
<span class="cm"> * requested power is limited by:</span>
<span class="cm"> * -- regulatory EEPROM limits for this channel</span>
<span class="cm"> * -- hardware capabilities (clip-powers)</span>
<span class="cm"> * -- spectrum management</span>
<span class="cm"> * -- user preference (e.g. iwconfig)</span>
<span class="cm"> * when requested power is set, base power idx must also be set. */</span>
<span class="k">struct</span> <span class="n">il3945_channel_power_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">il3945_tx_power</span> <span class="n">tpc</span><span class="p">;</span>	<span class="cm">/* actual radio and DSP gain settings */</span>
	<span class="n">s8</span> <span class="n">power_table_idx</span><span class="p">;</span>	<span class="cm">/* actual (compenst&#39;d) idx into gain table */</span>
	<span class="n">s8</span> <span class="n">base_power_idx</span><span class="p">;</span>	<span class="cm">/* gain idx for power at factory temp. */</span>
	<span class="n">s8</span> <span class="n">requested_power</span><span class="p">;</span>	<span class="cm">/* power (dBm) requested for this chnl/rate */</span>
<span class="p">};</span>

<span class="cm">/* current scan Tx power values to use, one for each scan rate for each</span>
<span class="cm"> * channel. */</span>
<span class="k">struct</span> <span class="n">il3945_scan_power_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">il3945_tx_power</span> <span class="n">tpc</span><span class="p">;</span>	<span class="cm">/* actual radio and DSP gain settings */</span>
	<span class="n">s8</span> <span class="n">power_table_idx</span><span class="p">;</span>	<span class="cm">/* actual (compenst&#39;d) idx into gain table */</span>
	<span class="n">s8</span> <span class="n">requested_power</span><span class="p">;</span>	<span class="cm">/* scan pwr (dBm) requested for chnl/rate */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * One for each channel, holds all channel setup data</span>
<span class="cm"> * Some of the fields (e.g. eeprom and flags/max_power_avg) are redundant</span>
<span class="cm"> *     with one another!</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">il_channel_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">il4965_channel_tgd_info</span> <span class="n">tgd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il4965_channel_tgh_info</span> <span class="n">tgh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_eeprom_channel</span> <span class="n">eeprom</span><span class="p">;</span>	<span class="cm">/* EEPROM regulatory limit */</span>
	<span class="k">struct</span> <span class="n">il_eeprom_channel</span> <span class="n">ht40_eeprom</span><span class="p">;</span>	<span class="cm">/* EEPROM regulatory limit for</span>
<span class="cm">						 * HT40 channel */</span>

	<span class="n">u8</span> <span class="n">channel</span><span class="p">;</span>		<span class="cm">/* channel number */</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* flags copied from EEPROM */</span>
	<span class="n">s8</span> <span class="n">max_power_avg</span><span class="p">;</span>	<span class="cm">/* (dBm) regul. eeprom, normal Tx, any rate */</span>
	<span class="n">s8</span> <span class="n">curr_txpow</span><span class="p">;</span>		<span class="cm">/* (dBm) regulatory/spectrum/user (not h/w) limit */</span>
	<span class="n">s8</span> <span class="n">min_power</span><span class="p">;</span>		<span class="cm">/* always 0 */</span>
	<span class="n">s8</span> <span class="n">scan_power</span><span class="p">;</span>		<span class="cm">/* (dBm) regul. eeprom, direct scans, any rate */</span>

	<span class="n">u8</span> <span class="n">group_idx</span><span class="p">;</span>		<span class="cm">/* 0-4, maps channel to group1/2/3/4/5 */</span>
	<span class="n">u8</span> <span class="n">band_idx</span><span class="p">;</span>		<span class="cm">/* 0-4, maps channel to band1/2/3/4/5 */</span>
	<span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">;</span>

	<span class="cm">/* HT40 channel info */</span>
	<span class="n">s8</span> <span class="n">ht40_max_power_avg</span><span class="p">;</span>	<span class="cm">/* (dBm) regul. eeprom, normal Tx, any rate */</span>
	<span class="n">u8</span> <span class="n">ht40_flags</span><span class="p">;</span>		<span class="cm">/* flags copied from EEPROM */</span>
	<span class="n">u8</span> <span class="n">ht40_extension_channel</span><span class="p">;</span>	<span class="cm">/* HT_IE_EXT_CHANNEL_* */</span>

	<span class="cm">/* Radio/DSP gain settings for each &quot;normal&quot; data Tx rate.</span>
<span class="cm">	 * These include, in addition to RF and DSP gain, a few fields for</span>
<span class="cm">	 *   remembering/modifying gain settings (idxes). */</span>
	<span class="k">struct</span> <span class="n">il3945_channel_power_info</span> <span class="n">power_info</span><span class="p">[</span><span class="n">IL4965_MAX_RATE</span><span class="p">];</span>

	<span class="cm">/* Radio/DSP gain settings for each scan rate, for directed scans. */</span>
	<span class="k">struct</span> <span class="n">il3945_scan_power_info</span> <span class="n">scan_pwr_info</span><span class="p">[</span><span class="n">IL_NUM_SCAN_RATES</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define IL_TX_FIFO_BK		0	</span><span class="cm">/* shared */</span><span class="cp"></span>
<span class="cp">#define IL_TX_FIFO_BE		1</span>
<span class="cp">#define IL_TX_FIFO_VI		2	</span><span class="cm">/* shared */</span><span class="cp"></span>
<span class="cp">#define IL_TX_FIFO_VO		3</span>
<span class="cp">#define IL_TX_FIFO_UNUSED	-1</span>

<span class="cm">/* Minimum number of queues. MAX_NUM is defined in hw specific files.</span>
<span class="cm"> * Set the minimum to accommodate the 4 standard TX queues, 1 command</span>
<span class="cm"> * queue, 2 (unused) HCCA queues, and 4 HT queues (one for each AC) */</span>
<span class="cp">#define IL_MIN_NUM_QUEUES	10</span>

<span class="cp">#define IL_DEFAULT_CMD_QUEUE_NUM	4</span>

<span class="cp">#define IEEE80211_DATA_LEN              2304</span>
<span class="cp">#define IEEE80211_4ADDR_LEN             30</span>
<span class="cp">#define IEEE80211_HLEN                  (IEEE80211_4ADDR_LEN)</span>
<span class="cp">#define IEEE80211_FRAME_LEN             (IEEE80211_DATA_LEN + IEEE80211_HLEN)</span>

<span class="k">struct</span> <span class="n">il_frame</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ieee80211_hdr</span> <span class="n">frame</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">il_tx_beacon_cmd</span> <span class="n">beacon</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">raw</span><span class="p">[</span><span class="n">IEEE80211_FRAME_LEN</span><span class="p">];</span>
		<span class="n">u8</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">360</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define SEQ_TO_SN(seq) (((seq) &amp; IEEE80211_SCTL_SEQ) &gt;&gt; 4)</span>
<span class="cp">#define SN_TO_SEQ(ssn) (((ssn) &lt;&lt; 4) &amp; IEEE80211_SCTL_SEQ)</span>
<span class="cp">#define MAX_SN ((IEEE80211_SCTL_SEQ) &gt;&gt; 4)</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">CMD_SYNC</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">CMD_SIZE_NORMAL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">CMD_NO_SKB</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">CMD_SIZE_HUGE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">CMD_ASYNC</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">CMD_WANT_SKB</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
	<span class="n">CMD_MAPPED</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
<span class="p">};</span>

<span class="cp">#define DEF_CMD_PAYLOAD_SIZE 320</span>

<span class="cm">/**</span>
<span class="cm"> * struct il_device_cmd</span>
<span class="cm"> *</span>
<span class="cm"> * For allocation of the command and tx queues, this establishes the overall</span>
<span class="cm"> * size of the largest command we send to uCode, except for a scan command</span>
<span class="cm"> * (which is relatively huge; space is allocated separately).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">il_device_cmd</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">il_cmd_header</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* uCode API */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">val8</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">val16</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">val32</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">il_tx_cmd</span> <span class="n">tx</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">payload</span><span class="p">[</span><span class="n">DEF_CMD_PAYLOAD_SIZE</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">__packed</span> <span class="n">cmd</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cp">#define TFD_MAX_PAYLOAD_SIZE (sizeof(struct il_device_cmd))</span>

<span class="k">struct</span> <span class="n">il_host_cmd</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reply_page</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_device_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">il_rx_pkt</span> <span class="o">*</span><span class="n">pkt</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">id</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define SUP_RATE_11A_MAX_NUM_CHANNELS  8</span>
<span class="cp">#define SUP_RATE_11B_MAX_NUM_CHANNELS  4</span>
<span class="cp">#define SUP_RATE_11G_MAX_NUM_CHANNELS  12</span>

<span class="cm">/**</span>
<span class="cm"> * struct il_rx_queue - Rx queue</span>
<span class="cm"> * @bd: driver&#39;s pointer to buffer of receive buffer descriptors (rbd)</span>
<span class="cm"> * @bd_dma: bus address of buffer of receive buffer descriptors (rbd)</span>
<span class="cm"> * @read: Shared idx to newest available Rx buffer</span>
<span class="cm"> * @write: Shared idx to oldest written Rx packet</span>
<span class="cm"> * @free_count: Number of pre-allocated buffers in rx_free</span>
<span class="cm"> * @rx_free: list of free SKBs for use</span>
<span class="cm"> * @rx_used: List of Rx buffers with no SKB</span>
<span class="cm"> * @need_update: flag to indicate we need to update read/write idx</span>
<span class="cm"> * @rb_stts: driver&#39;s pointer to receive buffer status</span>
<span class="cm"> * @rb_stts_dma: bus address of receive buffer status</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  rx_free and rx_used are used as a FIFO for il_rx_bufs</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">il_rx_queue</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">bd</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">bd_dma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_rx_buf</span> <span class="n">pool</span><span class="p">[</span><span class="n">RX_QUEUE_SIZE</span> <span class="o">+</span> <span class="n">RX_FREE_BUFFERS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">il_rx_buf</span> <span class="o">*</span><span class="n">queue</span><span class="p">[</span><span class="n">RX_QUEUE_SIZE</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">read</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">write</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">free_count</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">write_actual</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rx_free</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rx_used</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">need_update</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_rb_status</span> <span class="o">*</span><span class="n">rb_stts</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">rb_stts_dma</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define IL_SUPPORTED_RATES_IE_LEN         8</span>

<span class="cp">#define MAX_TID_COUNT        9</span>

<span class="cp">#define IL_INVALID_RATE     0xFF</span>
<span class="cp">#define IL_INVALID_VALUE    -1</span>

<span class="cm">/**</span>
<span class="cm"> * struct il_ht_agg -- aggregation status while waiting for block-ack</span>
<span class="cm"> * @txq_id: Tx queue used for Tx attempt</span>
<span class="cm"> * @frame_count: # frames attempted by Tx command</span>
<span class="cm"> * @wait_for_ba: Expect block-ack before next Tx reply</span>
<span class="cm"> * @start_idx: Index of 1st Transmit Frame Descriptor (TFD) in Tx win</span>
<span class="cm"> * @bitmap0: Low order bitmap, one bit for each frame pending ACK in Tx win</span>
<span class="cm"> * @bitmap1: High order, one bit for each frame pending ACK in Tx win</span>
<span class="cm"> * @rate_n_flags: Rate at which Tx was attempted</span>
<span class="cm"> *</span>
<span class="cm"> * If C_TX indicates that aggregation was attempted, driver must wait</span>
<span class="cm"> * for block ack (N_COMPRESSED_BA).  This struct stores tx reply info</span>
<span class="cm"> * until block ack arrives.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">il_ht_agg</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">txq_id</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">frame_count</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">wait_for_ba</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">start_idx</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">bitmap</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rate_n_flags</span><span class="p">;</span>
<span class="cp">#define IL_AGG_OFF 0</span>
<span class="cp">#define IL_AGG_ON 1</span>
<span class="cp">#define IL_EMPTYING_HW_QUEUE_ADDBA 2</span>
<span class="cp">#define IL_EMPTYING_HW_QUEUE_DELBA 3</span>
	<span class="n">u8</span> <span class="n">state</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">il_tid_data</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">seq_number</span><span class="p">;</span>		<span class="cm">/* 4965 only */</span>
	<span class="n">u16</span> <span class="n">tfds_in_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_ht_agg</span> <span class="n">agg</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">il_hw_key</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">cipher</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">keylen</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">keyidx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">key</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">union</span> <span class="n">il_ht_rate_supp</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">rates</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">siso_rate</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">mimo_rate</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="cp">#define CFG_HT_RX_AMPDU_FACTOR_8K   (0x0)</span>
<span class="cp">#define CFG_HT_RX_AMPDU_FACTOR_16K  (0x1)</span>
<span class="cp">#define CFG_HT_RX_AMPDU_FACTOR_32K  (0x2)</span>
<span class="cp">#define CFG_HT_RX_AMPDU_FACTOR_64K  (0x3)</span>
<span class="cp">#define CFG_HT_RX_AMPDU_FACTOR_DEF  CFG_HT_RX_AMPDU_FACTOR_64K</span>
<span class="cp">#define CFG_HT_RX_AMPDU_FACTOR_MAX  CFG_HT_RX_AMPDU_FACTOR_64K</span>
<span class="cp">#define CFG_HT_RX_AMPDU_FACTOR_MIN  CFG_HT_RX_AMPDU_FACTOR_8K</span>

<span class="cm">/*</span>
<span class="cm"> * Maximal MPDU density for TX aggregation</span>
<span class="cm"> * 4 - 2us density</span>
<span class="cm"> * 5 - 4us density</span>
<span class="cm"> * 6 - 8us density</span>
<span class="cm"> * 7 - 16us density</span>
<span class="cm"> */</span>
<span class="cp">#define CFG_HT_MPDU_DENSITY_2USEC   (0x4)</span>
<span class="cp">#define CFG_HT_MPDU_DENSITY_4USEC   (0x5)</span>
<span class="cp">#define CFG_HT_MPDU_DENSITY_8USEC   (0x6)</span>
<span class="cp">#define CFG_HT_MPDU_DENSITY_16USEC  (0x7)</span>
<span class="cp">#define CFG_HT_MPDU_DENSITY_DEF CFG_HT_MPDU_DENSITY_4USEC</span>
<span class="cp">#define CFG_HT_MPDU_DENSITY_MAX CFG_HT_MPDU_DENSITY_16USEC</span>
<span class="cp">#define CFG_HT_MPDU_DENSITY_MIN     (0x1)</span>

<span class="k">struct</span> <span class="n">il_ht_config</span> <span class="p">{</span>
	<span class="n">bool</span> <span class="n">single_chain_sufficient</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ieee80211_smps_mode</span> <span class="n">smps</span><span class="p">;</span>	<span class="cm">/* current smps mode */</span>
<span class="p">};</span>

<span class="cm">/* QoS structures */</span>
<span class="k">struct</span> <span class="n">il_qos_info</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">qos_active</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_qosparam_cmd</span> <span class="n">def_qos_parm</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Structure should be accessed with sta_lock held. When station addition</span>
<span class="cm"> * is in progress (IL_STA_UCODE_INPROGRESS) it is possible to access only</span>
<span class="cm"> * the commands (il_addsta_cmd and il_link_quality_cmd) without</span>
<span class="cm"> * sta_lock held.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">il_station_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">il_addsta_cmd</span> <span class="n">sta</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_tid_data</span> <span class="n">tid</span><span class="p">[</span><span class="n">MAX_TID_COUNT</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">used</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_hw_key</span> <span class="n">keyinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_link_quality_cmd</span> <span class="o">*</span><span class="n">lq</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">il_station_priv_common</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">sta_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct il_vif_priv - driver&#39;s ilate per-interface information</span>
<span class="cm"> *</span>
<span class="cm"> * When mac80211 allocates a virtual interface, it can allocate</span>
<span class="cm"> * space for us to put data into.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">il_vif_priv</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">ibss_bssid_sta_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* one for each uCode image (inst/data, boot/init/runtime) */</span>
<span class="k">struct</span> <span class="n">fw_desc</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">v_addr</span><span class="p">;</span>		<span class="cm">/* access by driver */</span>
	<span class="n">dma_addr_t</span> <span class="n">p_addr</span><span class="p">;</span>	<span class="cm">/* access by card&#39;s busmaster DMA */</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>		<span class="cm">/* bytes */</span>
<span class="p">};</span>

<span class="cm">/* uCode file layout */</span>
<span class="k">struct</span> <span class="n">il_ucode_header</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">ver</span><span class="p">;</span>		<span class="cm">/* major/minor/API/serial */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">__le32</span> <span class="n">inst_size</span><span class="p">;</span>	<span class="cm">/* bytes of runtime code */</span>
		<span class="n">__le32</span> <span class="n">data_size</span><span class="p">;</span>	<span class="cm">/* bytes of runtime data */</span>
		<span class="n">__le32</span> <span class="n">init_size</span><span class="p">;</span>	<span class="cm">/* bytes of init code */</span>
		<span class="n">__le32</span> <span class="n">init_data_size</span><span class="p">;</span>	<span class="cm">/* bytes of init data */</span>
		<span class="n">__le32</span> <span class="n">boot_size</span><span class="p">;</span>	<span class="cm">/* bytes of bootstrap code */</span>
		<span class="n">u8</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* in same order as sizes */</span>
	<span class="p">}</span> <span class="n">v1</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">il4965_ibss_seq</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">mac</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">u16</span> <span class="n">seq_num</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">frag_num</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">packet_time</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">il_sensitivity_ranges</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">min_nrg_cck</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">max_nrg_cck</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">nrg_th_cck</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">nrg_th_ofdm</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">auto_corr_min_ofdm</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">auto_corr_min_ofdm_mrc</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">auto_corr_min_ofdm_x1</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">auto_corr_min_ofdm_mrc_x1</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">auto_corr_max_ofdm</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">auto_corr_max_ofdm_mrc</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">auto_corr_max_ofdm_x1</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">auto_corr_max_ofdm_mrc_x1</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">auto_corr_max_cck</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">auto_corr_max_cck_mrc</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">auto_corr_min_cck</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">auto_corr_min_cck_mrc</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">barker_corr_th_min</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">barker_corr_th_min_mrc</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">nrg_th_cca</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define KELVIN_TO_CELSIUS(x) ((x)-273)</span>
<span class="cp">#define CELSIUS_TO_KELVIN(x) ((x)+273)</span>

<span class="cm">/**</span>
<span class="cm"> * struct il_hw_params</span>
<span class="cm"> * @bcast_id: f/w broadcast station ID</span>
<span class="cm"> * @max_txq_num: Max # Tx queues supported</span>
<span class="cm"> * @dma_chnl_num: Number of Tx DMA/FIFO channels</span>
<span class="cm"> * @scd_bc_tbls_size: size of scheduler byte count tables</span>
<span class="cm"> * @tfd_size: TFD size</span>
<span class="cm"> * @tx/rx_chains_num: Number of TX/RX chains</span>
<span class="cm"> * @valid_tx/rx_ant: usable antennas</span>
<span class="cm"> * @max_rxq_size: Max # Rx frames in Rx queue (must be power-of-2)</span>
<span class="cm"> * @max_rxq_log: Log-base-2 of max_rxq_size</span>
<span class="cm"> * @rx_page_order: Rx buffer page order</span>
<span class="cm"> * @rx_wrt_ptr_reg: FH{39}_RSCSR_CHNL0_WPTR</span>
<span class="cm"> * @max_stations:</span>
<span class="cm"> * @ht40_channel: is 40MHz width possible in band 2.4</span>
<span class="cm"> * BIT(IEEE80211_BAND_5GHZ) BIT(IEEE80211_BAND_5GHZ)</span>
<span class="cm"> * @sw_crypto: 0 for hw, 1 for sw</span>
<span class="cm"> * @max_xxx_size: for ucode uses</span>
<span class="cm"> * @ct_kill_threshold: temperature threshold</span>
<span class="cm"> * @beacon_time_tsf_bits: number of valid tsf bits for beacon time</span>
<span class="cm"> * @struct il_sensitivity_ranges: range of sensitivity values</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">il_hw_params</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">bcast_id</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">max_txq_num</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">dma_chnl_num</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">scd_bc_tbls_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tfd_size</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tx_chains_num</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">rx_chains_num</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">valid_tx_ant</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">valid_rx_ant</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">max_rxq_size</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">max_rxq_log</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rx_page_order</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rx_wrt_ptr_reg</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">max_stations</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ht40_channel</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">max_beacon_itrvl</span><span class="p">;</span>	<span class="cm">/* in 1024 ms */</span>
	<span class="n">u32</span> <span class="n">max_inst_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">max_data_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">max_bsm_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ct_kill_threshold</span><span class="p">;</span>	<span class="cm">/* value in hw-dependent units */</span>
	<span class="n">u16</span> <span class="n">beacon_time_tsf_bits</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">il_sensitivity_ranges</span> <span class="o">*</span><span class="n">sens</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Functions implemented in core module which are forward declared here</span>
<span class="cm"> * for use by iwl-[4-5].c</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  The implementation of these functions are not hardware specific</span>
<span class="cm"> * which is why they are in the core module files.</span>
<span class="cm"> *</span>
<span class="cm"> * Naming convention --</span>
<span class="cm"> * il_         &lt;-- Is part of iwlwifi</span>
<span class="cm"> * iwlXXXX_     &lt;-- Hardware specific (implemented in iwl-XXXX.c for XXXX)</span>
<span class="cm"> * il4965_bg_      &lt;-- Called from work queue context</span>
<span class="cm"> * il4965_mac_     &lt;-- mac80211 callback</span>
<span class="cm"> *</span>
<span class="cm"> ****************************************************************************/</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">il4965_update_chain_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">il_bcast_addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">il_queue_space</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">il_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">il_queue_used</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">il_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">read_ptr</span> <span class="o">?</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">read_ptr</span> <span class="o">&amp;&amp;</span>
					      <span class="n">i</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span><span class="p">)</span> <span class="o">:</span> <span class="o">!</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span>
								    <span class="n">q</span><span class="o">-&gt;</span><span class="n">read_ptr</span>
								    <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;=</span>
								    <span class="n">q</span><span class="o">-&gt;</span>
								    <span class="n">write_ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span>
<span class="nf">il_get_cmd_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">u32</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_huge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * This is for init calibration result and scan command which</span>
<span class="cm">	 * required buffer &gt; TFD_MAX_PAYLOAD_SIZE,</span>
<span class="cm">	 * the big buffer at end of command array</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_huge</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">n_win</span><span class="p">;</span>	<span class="cm">/* must be power of 2 */</span>

	<span class="cm">/* Otherwise, use normal size buffers */</span>
	<span class="k">return</span> <span class="n">idx</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">n_win</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">il_dma_ptr</span> <span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">dma</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define IL_OPERATION_MODE_AUTO     0</span>
<span class="cp">#define IL_OPERATION_MODE_HT_ONLY  1</span>
<span class="cp">#define IL_OPERATION_MODE_MIXED    2</span>
<span class="cp">#define IL_OPERATION_MODE_20MHZ    3</span>

<span class="cp">#define IL_TX_CRC_SIZE 4</span>
<span class="cp">#define IL_TX_DELIMITER_SIZE 4</span>

<span class="cp">#define TX_POWER_IL_ILLEGAL_VOLTAGE -10000</span>

<span class="cm">/* Sensitivity and chain noise calibration */</span>
<span class="cp">#define INITIALIZATION_VALUE		0xFFFF</span>
<span class="cp">#define IL4965_CAL_NUM_BEACONS		20</span>
<span class="cp">#define IL_CAL_NUM_BEACONS		16</span>
<span class="cp">#define MAXIMUM_ALLOWED_PATHLOSS	15</span>

<span class="cp">#define CHAIN_NOISE_MAX_DELTA_GAIN_CODE 3</span>

<span class="cp">#define MAX_FA_OFDM  50</span>
<span class="cp">#define MIN_FA_OFDM  5</span>
<span class="cp">#define MAX_FA_CCK   50</span>
<span class="cp">#define MIN_FA_CCK   5</span>

<span class="cp">#define AUTO_CORR_STEP_OFDM       1</span>

<span class="cp">#define AUTO_CORR_STEP_CCK     3</span>
<span class="cp">#define AUTO_CORR_MAX_TH_CCK   160</span>

<span class="cp">#define NRG_DIFF               2</span>
<span class="cp">#define NRG_STEP_CCK           2</span>
<span class="cp">#define NRG_MARGIN             8</span>
<span class="cp">#define MAX_NUMBER_CCK_NO_FA 100</span>

<span class="cp">#define AUTO_CORR_CCK_MIN_VAL_DEF    (125)</span>

<span class="cp">#define CHAIN_A             0</span>
<span class="cp">#define CHAIN_B             1</span>
<span class="cp">#define CHAIN_C             2</span>
<span class="cp">#define CHAIN_NOISE_DELTA_GAIN_INIT_VAL 4</span>
<span class="cp">#define ALL_BAND_FILTER			0xFF00</span>
<span class="cp">#define IN_BAND_FILTER			0xFF</span>
<span class="cp">#define MIN_AVERAGE_NOISE_MAX_VALUE	0xFFFFFFFF</span>

<span class="cp">#define NRG_NUM_PREV_STAT_L     20</span>
<span class="cp">#define NUM_RX_CHAINS           3</span>

<span class="k">enum</span> <span class="n">il4965_false_alarm_state</span> <span class="p">{</span>
	<span class="n">IL_FA_TOO_MANY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IL_FA_TOO_FEW</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IL_FA_GOOD_RANGE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">il4965_chain_noise_state</span> <span class="p">{</span>
	<span class="n">IL_CHAIN_NOISE_ALIVE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* must be 0 */</span>
	<span class="n">IL_CHAIN_NOISE_ACCUMULATE</span><span class="p">,</span>
	<span class="n">IL_CHAIN_NOISE_CALIBRATED</span><span class="p">,</span>
	<span class="n">IL_CHAIN_NOISE_DONE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ucode_type</span> <span class="p">{</span>
	<span class="n">UCODE_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">UCODE_INIT</span><span class="p">,</span>
	<span class="n">UCODE_RT</span>
<span class="p">};</span>

<span class="cm">/* Sensitivity calib data */</span>
<span class="k">struct</span> <span class="n">il_sensitivity_data</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">auto_corr_ofdm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">auto_corr_ofdm_mrc</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">auto_corr_ofdm_x1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">auto_corr_ofdm_mrc_x1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">auto_corr_cck</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">auto_corr_cck_mrc</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">last_bad_plcp_cnt_ofdm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">last_fa_cnt_ofdm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">last_bad_plcp_cnt_cck</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">last_fa_cnt_cck</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">nrg_curr_state</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nrg_prev_state</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nrg_value</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">nrg_silence_rssi</span><span class="p">[</span><span class="n">NRG_NUM_PREV_STAT_L</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">nrg_silence_ref</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nrg_energy_idx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nrg_silence_idx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nrg_th_cck</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">nrg_auto_corr_silence_diff</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num_in_cck_no_fa</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nrg_th_ofdm</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">barker_corr_th_min</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">barker_corr_th_min_mrc</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">nrg_th_cca</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Chain noise (differential Rx gain) calib data */</span>
<span class="k">struct</span> <span class="n">il_chain_noise_data</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">active_chains</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chain_noise_a</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chain_noise_b</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chain_noise_c</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chain_signal_a</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chain_signal_b</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chain_signal_c</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">beacon_count</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">disconn_array</span><span class="p">[</span><span class="n">NUM_RX_CHAINS</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">delta_gain_code</span><span class="p">[</span><span class="n">NUM_RX_CHAINS</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">radio_write</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">state</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define	EEPROM_SEM_TIMEOUT 10	</span><span class="cm">/* milliseconds */</span><span class="cp"></span>
<span class="cp">#define EEPROM_SEM_RETRY_LIMIT 1000	</span><span class="cm">/* number of attempts (not time) */</span><span class="cp"></span>

<span class="cp">#define IL_TRAFFIC_ENTRIES	(256)</span>
<span class="cp">#define IL_TRAFFIC_ENTRY_SIZE  (64)</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">MEASUREMENT_READY</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">MEASUREMENT_ACTIVE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/* interrupt stats */</span>
<span class="k">struct</span> <span class="n">isr_stats</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">err_code</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sch</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">alive</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rfkill</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctkill</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">wakeup</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">handlers</span><span class="p">[</span><span class="n">IL_CN_MAX</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">tx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">unhandled</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* management stats */</span>
<span class="k">enum</span> <span class="n">il_mgmt_stats</span> <span class="p">{</span>
	<span class="n">MANAGEMENT_ASSOC_REQ</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">MANAGEMENT_ASSOC_RESP</span><span class="p">,</span>
	<span class="n">MANAGEMENT_REASSOC_REQ</span><span class="p">,</span>
	<span class="n">MANAGEMENT_REASSOC_RESP</span><span class="p">,</span>
	<span class="n">MANAGEMENT_PROBE_REQ</span><span class="p">,</span>
	<span class="n">MANAGEMENT_PROBE_RESP</span><span class="p">,</span>
	<span class="n">MANAGEMENT_BEACON</span><span class="p">,</span>
	<span class="n">MANAGEMENT_ATIM</span><span class="p">,</span>
	<span class="n">MANAGEMENT_DISASSOC</span><span class="p">,</span>
	<span class="n">MANAGEMENT_AUTH</span><span class="p">,</span>
	<span class="n">MANAGEMENT_DEAUTH</span><span class="p">,</span>
	<span class="n">MANAGEMENT_ACTION</span><span class="p">,</span>
	<span class="n">MANAGEMENT_MAX</span><span class="p">,</span>
<span class="p">};</span>
<span class="cm">/* control stats */</span>
<span class="k">enum</span> <span class="n">il_ctrl_stats</span> <span class="p">{</span>
	<span class="n">CONTROL_BACK_REQ</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">CONTROL_BACK</span><span class="p">,</span>
	<span class="n">CONTROL_PSPOLL</span><span class="p">,</span>
	<span class="n">CONTROL_RTS</span><span class="p">,</span>
	<span class="n">CONTROL_CTS</span><span class="p">,</span>
	<span class="n">CONTROL_ACK</span><span class="p">,</span>
	<span class="n">CONTROL_CFEND</span><span class="p">,</span>
	<span class="n">CONTROL_CFENDACK</span><span class="p">,</span>
	<span class="n">CONTROL_MAX</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">traffic_stats</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_IWLEGACY_DEBUGFS</span>
	<span class="n">u32</span> <span class="n">mgmt</span><span class="p">[</span><span class="n">MANAGEMENT_MAX</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">[</span><span class="n">CONTROL_MAX</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">data_cnt</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">data_bytes</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * host interrupt timeout value</span>
<span class="cm"> * used with setting interrupt coalescing timer</span>
<span class="cm"> * the CSR_INT_COALESCING is an 8 bit register in 32-usec unit</span>
<span class="cm"> *</span>
<span class="cm"> * default interrupt coalescing timer is 64 x 32 = 2048 usecs</span>
<span class="cm"> * default interrupt coalescing calibration timer is 16 x 32 = 512 usecs</span>
<span class="cm"> */</span>
<span class="cp">#define IL_HOST_INT_TIMEOUT_MAX	(0xFF)</span>
<span class="cp">#define IL_HOST_INT_TIMEOUT_DEF	(0x40)</span>
<span class="cp">#define IL_HOST_INT_TIMEOUT_MIN	(0x0)</span>
<span class="cp">#define IL_HOST_INT_CALIB_TIMEOUT_MAX	(0xFF)</span>
<span class="cp">#define IL_HOST_INT_CALIB_TIMEOUT_DEF	(0x10)</span>
<span class="cp">#define IL_HOST_INT_CALIB_TIMEOUT_MIN	(0x0)</span>

<span class="cp">#define IL_DELAY_NEXT_FORCE_FW_RELOAD (HZ*5)</span>

<span class="cm">/* TX queue watchdog timeouts in mSecs */</span>
<span class="cp">#define IL_DEF_WD_TIMEOUT	(2000)</span>
<span class="cp">#define IL_LONG_WD_TIMEOUT	(10000)</span>
<span class="cp">#define IL_MAX_WD_TIMEOUT	(120000)</span>

<span class="k">struct</span> <span class="n">il_force_reset</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">reset_request_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reset_success_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reset_reject_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reset_duration</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_force_reset_jiffies</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* extend beacon time format bit shifting  */</span>
<span class="cm">/*</span>
<span class="cm"> * for _3945 devices</span>
<span class="cm"> * bits 31:24 - extended</span>
<span class="cm"> * bits 23:0  - interval</span>
<span class="cm"> */</span>
<span class="cp">#define IL3945_EXT_BEACON_TIME_POS	24</span>
<span class="cm">/*</span>
<span class="cm"> * for _4965 devices</span>
<span class="cm"> * bits 31:22 - extended</span>
<span class="cm"> * bits 21:0  - interval</span>
<span class="cm"> */</span>
<span class="cp">#define IL4965_EXT_BEACON_TIME_POS	22</span>

<span class="k">struct</span> <span class="n">il_rxon_context</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">il_power_mgr</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">il_powertable_cmd</span> <span class="n">sleep_cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_powertable_cmd</span> <span class="n">sleep_cmd_next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">debug_sleep_level_override</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">pci_pm</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">il_priv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">ieee_channels</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_rate</span> <span class="o">*</span><span class="n">ieee_rates</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">il_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">il_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_IWLEGACY_DEBUGFS</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">il_debugfs_ops</span> <span class="o">*</span><span class="n">debugfs_ops</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* temporary frame storage list */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">free_frames</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">frames_count</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">alloc_rxb_page</span><span class="p">;</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handlers</span><span class="p">[</span><span class="n">IL_CN_MAX</span><span class="p">])</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">il_rx_buf</span> <span class="o">*</span><span class="n">rxb</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">ieee80211_supported_band</span> <span class="n">bands</span><span class="p">[</span><span class="n">IEEE80211_NUM_BANDS</span><span class="p">];</span>

	<span class="cm">/* spectrum measurement report caching */</span>
	<span class="k">struct</span> <span class="n">il_spectrum_notification</span> <span class="n">measure_report</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">measurement_status</span><span class="p">;</span>

	<span class="cm">/* ucode beacon time */</span>
	<span class="n">u32</span> <span class="n">ucode_beacon_time</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">missed_beacon_threshold</span><span class="p">;</span>

	<span class="cm">/* track IBSS manager (last beacon) status */</span>
	<span class="n">u32</span> <span class="n">ibss_manager</span><span class="p">;</span>

	<span class="cm">/* force reset */</span>
	<span class="k">struct</span> <span class="n">il_force_reset</span> <span class="n">force_reset</span><span class="p">;</span>

	<span class="cm">/* we allocate array of il_channel_info for NIC&#39;s valid channels.</span>
<span class="cm">	 *    Access via channel # using indirect idx array */</span>
	<span class="k">struct</span> <span class="n">il_channel_info</span> <span class="o">*</span><span class="n">channel_info</span><span class="p">;</span>	<span class="cm">/* channel info array */</span>
	<span class="n">u8</span> <span class="n">channel_count</span><span class="p">;</span>	<span class="cm">/* # of channels */</span>

	<span class="cm">/* thermal calibration */</span>
	<span class="n">s32</span> <span class="n">temperature</span><span class="p">;</span>	<span class="cm">/* degrees Kelvin */</span>
	<span class="n">s32</span> <span class="n">last_temperature</span><span class="p">;</span>

	<span class="cm">/* Scan related variables */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">scan_start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">scan_start_tsf</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">scan_cmd</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">scan_band</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfg80211_scan_request</span> <span class="o">*</span><span class="n">scan_request</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">scan_vif</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">scan_tx_ant</span><span class="p">[</span><span class="n">IEEE80211_NUM_BANDS</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">mgmt_tx_ant</span><span class="p">;</span>

	<span class="cm">/* spinlock */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>	<span class="cm">/* protect general shared data */</span>
	<span class="n">spinlock_t</span> <span class="n">hcmd_lock</span><span class="p">;</span>	<span class="cm">/* protect hcmd */</span>
	<span class="n">spinlock_t</span> <span class="n">reg_lock</span><span class="p">;</span>	<span class="cm">/* protect hw register access */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>

	<span class="cm">/* basic pci-network driver stuff */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">;</span>

	<span class="cm">/* pci hardware address support */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">hw_base</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hw_rev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hw_wa_rev</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">rev_id</span><span class="p">;</span>

	<span class="cm">/* command queue number */</span>
	<span class="n">u8</span> <span class="n">cmd_queue</span><span class="p">;</span>

	<span class="cm">/* max number of station keys */</span>
	<span class="n">u8</span> <span class="n">sta_key_max_num</span><span class="p">;</span>

	<span class="cm">/* EEPROM MAC addresses */</span>
	<span class="k">struct</span> <span class="n">mac_address</span> <span class="n">addresses</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="cm">/* uCode images, save to reload in case of failure */</span>
	<span class="kt">int</span> <span class="n">fw_idx</span><span class="p">;</span>		<span class="cm">/* firmware we&#39;re trying to load */</span>
	<span class="n">u32</span> <span class="n">ucode_ver</span><span class="p">;</span>		<span class="cm">/* version of ucode, copy of</span>
<span class="cm">				   il_ucode.ver */</span>
	<span class="k">struct</span> <span class="n">fw_desc</span> <span class="n">ucode_code</span><span class="p">;</span>	<span class="cm">/* runtime inst */</span>
	<span class="k">struct</span> <span class="n">fw_desc</span> <span class="n">ucode_data</span><span class="p">;</span>	<span class="cm">/* runtime data original */</span>
	<span class="k">struct</span> <span class="n">fw_desc</span> <span class="n">ucode_data_backup</span><span class="p">;</span>	<span class="cm">/* runtime data save/restore */</span>
	<span class="k">struct</span> <span class="n">fw_desc</span> <span class="n">ucode_init</span><span class="p">;</span>	<span class="cm">/* initialization inst */</span>
	<span class="k">struct</span> <span class="n">fw_desc</span> <span class="n">ucode_init_data</span><span class="p">;</span>	<span class="cm">/* initialization data */</span>
	<span class="k">struct</span> <span class="n">fw_desc</span> <span class="n">ucode_boot</span><span class="p">;</span>	<span class="cm">/* bootstrap inst */</span>
	<span class="k">enum</span> <span class="n">ucode_type</span> <span class="n">ucode_type</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ucode_write_complete</span><span class="p">;</span>	<span class="cm">/* the image write is complete */</span>
	<span class="kt">char</span> <span class="n">firmware_name</span><span class="p">[</span><span class="mi">25</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">il_qos_info</span> <span class="n">qos_data</span><span class="p">;</span>

	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">bool</span> <span class="n">enabled</span><span class="p">;</span>
		<span class="n">bool</span> <span class="n">is_40mhz</span><span class="p">;</span>
		<span class="n">bool</span> <span class="n">non_gf_sta_present</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">protection</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">extension_chan_offset</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ht</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We declare this const so it can only be</span>
<span class="cm">	 * changed via explicit cast within the</span>
<span class="cm">	 * routines that actually update the physical</span>
<span class="cm">	 * hardware.</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">il_rxon_cmd</span> <span class="n">active</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_rxon_cmd</span> <span class="n">staging</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">il_rxon_time_cmd</span> <span class="n">timing</span><span class="p">;</span>

	<span class="n">__le16</span> <span class="n">switch_channel</span><span class="p">;</span>

	<span class="cm">/* 1st responses from initialize and runtime uCode images.</span>
<span class="cm">	 * _4965&#39;s initialize alive response contains some calibration data. */</span>
	<span class="k">struct</span> <span class="n">il_init_alive_resp</span> <span class="n">card_alive_init</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_alive_resp</span> <span class="n">card_alive</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">active_rate</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">start_calib</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_sensitivity_data</span> <span class="n">sensitivity_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_chain_noise_data</span> <span class="n">chain_noise_data</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">sensitivity_tbl</span><span class="p">[</span><span class="n">HD_TBL_SIZE</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">il_ht_config</span> <span class="n">current_ht_config</span><span class="p">;</span>

	<span class="cm">/* Rate scaling data */</span>
	<span class="n">u8</span> <span class="n">retry_rate</span><span class="p">;</span>

	<span class="n">wait_queue_head_t</span> <span class="n">wait_command_queue</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">activity_timer_active</span><span class="p">;</span>

	<span class="cm">/* Rx and Tx DMA processing queues */</span>
	<span class="k">struct</span> <span class="n">il_rx_queue</span> <span class="n">rxq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">txq_ctx_active_msk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_dma_ptr</span> <span class="n">kw</span><span class="p">;</span>	<span class="cm">/* keep warm address */</span>
	<span class="k">struct</span> <span class="n">il_dma_ptr</span> <span class="n">scd_bc_tbls</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">scd_base_addr</span><span class="p">;</span>	<span class="cm">/* scheduler sram base address */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* counts mgmt, ctl, and data packets */</span>
	<span class="k">struct</span> <span class="n">traffic_stats</span> <span class="n">tx_stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">traffic_stats</span> <span class="n">rx_stats</span><span class="p">;</span>

	<span class="cm">/* counts interrupts */</span>
	<span class="k">struct</span> <span class="n">isr_stats</span> <span class="n">isr_stats</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">il_power_mgr</span> <span class="n">power_data</span><span class="p">;</span>

	<span class="cm">/* context information */</span>
	<span class="n">u8</span> <span class="n">bssid</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>	<span class="cm">/* used only on 3945 but filled by core */</span>

	<span class="cm">/* station table variables */</span>

	<span class="cm">/* Note: if lock and sta_lock are needed, lock must be acquired first */</span>
	<span class="n">spinlock_t</span> <span class="n">sta_lock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_stations</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_station_entry</span> <span class="n">stations</span><span class="p">[</span><span class="n">IL_STATION_COUNT</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ucode_key_table</span><span class="p">;</span>

	<span class="cm">/* queue refcounts */</span>
<span class="cp">#define IL_MAX_HW_QUEUES	32</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">queue_stopped</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">IL_MAX_HW_QUEUES</span><span class="p">)];</span>
	<span class="cm">/* for each AC */</span>
	<span class="n">atomic_t</span> <span class="n">queue_stop_count</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="cm">/* Indication if ieee80211_ops-&gt;open has been called */</span>
	<span class="n">u8</span> <span class="n">is_open</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">mac80211_registered</span><span class="p">;</span>

	<span class="cm">/* eeprom -- this is in the card&#39;s little endian byte order */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">eeprom</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_eeprom_calib_info</span> <span class="o">*</span><span class="n">calib_info</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">nl80211_iftype</span> <span class="n">iw_mode</span><span class="p">;</span>

	<span class="cm">/* Last Rx&#39;d beacon timestamp */</span>
	<span class="n">u64</span> <span class="n">timestamp</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>
<span class="cp">#if defined(CONFIG_IWL3945) || defined(CONFIG_IWL3945_MODULE)</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">shared_virt</span><span class="p">;</span>
			<span class="n">dma_addr_t</span> <span class="n">shared_phys</span><span class="p">;</span>

			<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">thermal_periodic</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">rfkill_poll</span><span class="p">;</span>

			<span class="k">struct</span> <span class="n">il3945_notif_stats</span> <span class="n">stats</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_IWLEGACY_DEBUGFS</span>
			<span class="k">struct</span> <span class="n">il3945_notif_stats</span> <span class="n">accum_stats</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">il3945_notif_stats</span> <span class="n">delta_stats</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">il3945_notif_stats</span> <span class="n">max_delta</span><span class="p">;</span>
<span class="cp">#endif</span>

			<span class="n">u32</span> <span class="n">sta_supp_rates</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">last_rx_rssi</span><span class="p">;</span>	<span class="cm">/* From Rx packet stats */</span>

			<span class="cm">/* Rx&#39;d packet timing information */</span>
			<span class="n">u32</span> <span class="n">last_beacon_time</span><span class="p">;</span>
			<span class="n">u64</span> <span class="n">last_tsf</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * each calibration channel group in the</span>
<span class="cm">			 * EEPROM has a derived clip setting for</span>
<span class="cm">			 * each rate.</span>
<span class="cm">			 */</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">il3945_clip_group</span> <span class="n">clip_groups</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

		<span class="p">}</span> <span class="n">_3945</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#if defined(CONFIG_IWL4965) || defined(CONFIG_IWL4965_MODULE)</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">il_rx_phy_res</span> <span class="n">last_phy_res</span><span class="p">;</span>
			<span class="n">bool</span> <span class="n">last_phy_res_valid</span><span class="p">;</span>

			<span class="k">struct</span> <span class="n">completion</span> <span class="n">firmware_loading_complete</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * chain noise reset and gain commands are the</span>
<span class="cm">			 * two extra calibration commands follows the standard</span>
<span class="cm">			 * phy calibration commands</span>
<span class="cm">			 */</span>
			<span class="n">u8</span> <span class="n">phy_calib_chain_noise_reset_cmd</span><span class="p">;</span>
			<span class="n">u8</span> <span class="n">phy_calib_chain_noise_gain_cmd</span><span class="p">;</span>

			<span class="n">u8</span> <span class="n">key_mapping_keys</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">il_wep_key</span> <span class="n">wep_keys</span><span class="p">[</span><span class="n">WEP_KEYS_MAX</span><span class="p">];</span>

			<span class="k">struct</span> <span class="n">il_notif_stats</span> <span class="n">stats</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_IWLEGACY_DEBUGFS</span>
			<span class="k">struct</span> <span class="n">il_notif_stats</span> <span class="n">accum_stats</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">il_notif_stats</span> <span class="n">delta_stats</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">il_notif_stats</span> <span class="n">max_delta</span><span class="p">;</span>
<span class="cp">#endif</span>

		<span class="p">}</span> <span class="n">_4965</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">};</span>

	<span class="k">struct</span> <span class="n">il_hw_params</span> <span class="n">hw_params</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">inta_mask</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">workqueue</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">restart</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">scan_completed</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">rx_replenish</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">abort_scan</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">beacon_enabled</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">beacon_skb</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">tx_flush</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">irq_tasklet</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">init_alive_start</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">alive_start</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">scan_check</span><span class="p">;</span>

	<span class="cm">/* TX Power */</span>
	<span class="n">s8</span> <span class="n">tx_power_user_lmt</span><span class="p">;</span>
	<span class="n">s8</span> <span class="n">tx_power_device_lmt</span><span class="p">;</span>
	<span class="n">s8</span> <span class="n">tx_power_next</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_IWLEGACY_DEBUG</span>
	<span class="cm">/* debugging info */</span>
	<span class="n">u32</span> <span class="n">debug_level</span><span class="p">;</span>	<span class="cm">/* per device debugging will override global</span>
<span class="cm">				   il_debug_level if set */</span>
<span class="cp">#endif				</span><span class="cm">/* CONFIG_IWLEGACY_DEBUG */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_IWLEGACY_DEBUGFS</span>
	<span class="cm">/* debugfs */</span>
	<span class="n">u16</span> <span class="n">tx_traffic_idx</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">rx_traffic_idx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">tx_traffic</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">rx_traffic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfs_dir</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dbgfs_sram_offset</span><span class="p">,</span> <span class="n">dbgfs_sram_len</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">disable_ht40</span><span class="p">;</span>
<span class="cp">#endif				</span><span class="cm">/* CONFIG_IWLEGACY_DEBUGFS */</span><span class="cp"></span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">txpower_work</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">disable_sens_cal</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">disable_chain_noise_cal</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">disable_tx_power_cal</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">run_time_calib_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">stats_periodic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">watchdog</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">hw_ready</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">led_classdev</span> <span class="n">led</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">blink_on</span><span class="p">,</span> <span class="n">blink_off</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">led_registered</span><span class="p">;</span>
<span class="p">};</span>				<span class="cm">/*il_priv */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">il_txq_ctx_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="kt">int</span> <span class="n">txq_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">txq_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">txq_ctx_active_msk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">il_txq_ctx_deactivate</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="kt">int</span> <span class="n">txq_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">txq_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">txq_ctx_active_msk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">il_is_associated</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">.</span><span class="n">filter_flags</span> <span class="o">&amp;</span> <span class="n">RXON_FILTER_ASSOC_MSK</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">il_is_any_associated</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">il_is_associated</span><span class="p">(</span><span class="n">il</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">il_is_channel_valid</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">il_channel_info</span> <span class="o">*</span><span class="n">ch_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ch_info</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ch_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EEPROM_CHANNEL_VALID</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">il_is_channel_radar</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">il_channel_info</span> <span class="o">*</span><span class="n">ch_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ch_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EEPROM_CHANNEL_RADAR</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span>
<span class="nf">il_is_channel_a_band</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">il_channel_info</span> <span class="o">*</span><span class="n">ch_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ch_info</span><span class="o">-&gt;</span><span class="n">band</span> <span class="o">==</span> <span class="n">IEEE80211_BAND_5GHZ</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">il_is_channel_passive</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">il_channel_info</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EEPROM_CHANNEL_ACTIVE</span><span class="p">))</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">il_is_channel_ibss</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">il_channel_info</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EEPROM_CHANNEL_IBSS</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">__il_free_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__free_pages</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">il</span><span class="o">-&gt;</span><span class="n">hw_params</span><span class="p">.</span><span class="n">rx_page_order</span><span class="p">);</span>
	<span class="n">il</span><span class="o">-&gt;</span><span class="n">alloc_rxb_page</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">il_free_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_pages</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">il</span><span class="o">-&gt;</span><span class="n">hw_params</span><span class="p">.</span><span class="n">rx_page_order</span><span class="p">);</span>
	<span class="n">il</span><span class="o">-&gt;</span><span class="n">alloc_rxb_page</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define IWLWIFI_VERSION &quot;in-tree:&quot;</span>
<span class="cp">#define DRV_COPYRIGHT	&quot;Copyright(c) 2003-2011 Intel Corporation&quot;</span>
<span class="cp">#define DRV_AUTHOR     &quot;&lt;ilw@linux.intel.com&gt;&quot;</span>

<span class="cp">#define IL_PCI_DEVICE(dev, subdev, cfg) \</span>
<span class="cp">	.vendor = PCI_VENDOR_ID_INTEL,  .device = (dev), \</span>
<span class="cp">	.subvendor = PCI_ANY_ID, .subdevice = (subdev), \</span>
<span class="cp">	.driver_data = (kernel_ulong_t)&amp;(cfg)</span>

<span class="cp">#define TIME_UNIT		1024</span>

<span class="cp">#define IL_SKU_G       0x1</span>
<span class="cp">#define IL_SKU_A       0x2</span>
<span class="cp">#define IL_SKU_N       0x8</span>

<span class="cp">#define IL_CMD(x) case x: return #x</span>

<span class="cm">/* Size of one Rx buffer in host DRAM */</span>
<span class="cp">#define IL_RX_BUF_SIZE_3K (3 * 1000)	</span><span class="cm">/* 3945 only */</span><span class="cp"></span>
<span class="cp">#define IL_RX_BUF_SIZE_4K (4 * 1024)</span>
<span class="cp">#define IL_RX_BUF_SIZE_8K (8 * 1024)</span>

<span class="cp">#ifdef CONFIG_IWLEGACY_DEBUGFS</span>
<span class="k">struct</span> <span class="n">il_debugfs_ops</span> <span class="p">{</span>
	<span class="kt">ssize_t</span><span class="p">(</span><span class="o">*</span><span class="n">rx_stats_read</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_buf</span><span class="p">,</span>
				 <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">);</span>
	<span class="kt">ssize_t</span><span class="p">(</span><span class="o">*</span><span class="n">tx_stats_read</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_buf</span><span class="p">,</span>
				 <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">);</span>
	<span class="kt">ssize_t</span><span class="p">(</span><span class="o">*</span><span class="n">general_stats_read</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				      <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
				      <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">);</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">il_ops</span> <span class="p">{</span>
	<span class="cm">/* Handling TX */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">txq_update_byte_cnt_tbl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">il_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">,</span>
					 <span class="n">u16</span> <span class="n">byte_cnt</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">txq_attach_buf_to_tfd</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">il_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">,</span>
				      <span class="n">u16</span> <span class="n">len</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reset</span><span class="p">,</span> <span class="n">u8</span> <span class="n">pad</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">txq_free_tfd</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">txq_init</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">);</span>
	<span class="cm">/* alive notification after init uCode load */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">init_alive_start</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
	<span class="cm">/* check validity of rtc data address */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">is_valid_rtc_data_addr</span><span class="p">)</span> <span class="p">(</span><span class="n">u32</span> <span class="n">addr</span><span class="p">);</span>
	<span class="cm">/* 1st ucode load */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">load_ucode</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dump_nic_error_log</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">dump_fh</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">buf</span><span class="p">,</span> <span class="n">bool</span> <span class="n">display</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_channel_switch</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">ieee80211_channel_switch</span> <span class="o">*</span><span class="n">ch_switch</span><span class="p">);</span>
	<span class="cm">/* power management */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">apm_init</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>

	<span class="cm">/* tx power */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">send_tx_power</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">update_chain_flags</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>

	<span class="cm">/* eeprom operations */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">eeprom_acquire_semaphore</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">eeprom_release_semaphore</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rxon_assoc</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">commit_rxon</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_rxon_chain</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>

	<span class="n">u16</span><span class="p">(</span><span class="o">*</span><span class="n">get_hcmd_size</span><span class="p">)</span> <span class="p">(</span><span class="n">u8</span> <span class="n">cmd_id</span><span class="p">,</span> <span class="n">u16</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">u16</span><span class="p">(</span><span class="o">*</span><span class="n">build_addsta_hcmd</span><span class="p">)</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">il_addsta_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">request_scan</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">post_scan</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">post_associate</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">config_ap</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
	<span class="cm">/* station management */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">update_bcast_stations</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">manage_ibss_station</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span> <span class="n">bool</span> <span class="n">add</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">send_led_cmd</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_led_cmd</span> <span class="o">*</span><span class="n">led_cmd</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">il_mod_params</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">sw_crypto</span><span class="p">;</span>		<span class="cm">/* def: 0 = using hardware encryption */</span>
	<span class="kt">int</span> <span class="n">disable_hw_scan</span><span class="p">;</span>	<span class="cm">/* def: 0 = use h/w scan */</span>
	<span class="kt">int</span> <span class="n">num_of_queues</span><span class="p">;</span>	<span class="cm">/* def: HW dependent */</span>
	<span class="kt">int</span> <span class="n">disable_11n</span><span class="p">;</span>	<span class="cm">/* def: 0 = 11n capabilities enabled */</span>
	<span class="kt">int</span> <span class="n">amsdu_size_8K</span><span class="p">;</span>	<span class="cm">/* def: 1 = enable 8K amsdu size */</span>
	<span class="kt">int</span> <span class="n">antenna</span><span class="p">;</span>		<span class="cm">/* def: 0 = both antennas (use diversity) */</span>
	<span class="kt">int</span> <span class="n">restart_fw</span><span class="p">;</span>		<span class="cm">/* def: 1 = restart firmware */</span>
<span class="p">};</span>

<span class="cp">#define IL_LED_SOLID 11</span>
<span class="cp">#define IL_DEF_LED_INTRVL cpu_to_le32(1000)</span>

<span class="cp">#define IL_LED_ACTIVITY       (0&lt;&lt;1)</span>
<span class="cp">#define IL_LED_LINK           (1&lt;&lt;1)</span>

<span class="cm">/*</span>
<span class="cm"> * LED mode</span>
<span class="cm"> *    IL_LED_DEFAULT:  use device default</span>
<span class="cm"> *    IL_LED_RF_STATE: turn LED on/off based on RF state</span>
<span class="cm"> *			LED ON  = RF ON</span>
<span class="cm"> *			LED OFF = RF OFF</span>
<span class="cm"> *    IL_LED_BLINK:    adjust led blink rate based on blink table</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">il_led_mode</span> <span class="p">{</span>
	<span class="n">IL_LED_DEFAULT</span><span class="p">,</span>
	<span class="n">IL_LED_RF_STATE</span><span class="p">,</span>
	<span class="n">IL_LED_BLINK</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">il_leds_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_leds_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct il_cfg</span>
<span class="cm"> * @fw_name_pre: Firmware filename prefix. The api version and extension</span>
<span class="cm"> *	(.ucode) will be added to filename before loading from disk. The</span>
<span class="cm"> *	filename is constructed as fw_name_pre&lt;api&gt;.ucode.</span>
<span class="cm"> * @ucode_api_max: Highest version of uCode API supported by driver.</span>
<span class="cm"> * @ucode_api_min: Lowest version of uCode API supported by driver.</span>
<span class="cm"> * @scan_antennas: available antenna for scan operation</span>
<span class="cm"> * @led_mode: 0=blinking, 1=On(RF On)/Off(RF Off)</span>
<span class="cm"> *</span>
<span class="cm"> * We enable the driver to be backward compatible wrt API version. The</span>
<span class="cm"> * driver specifies which APIs it supports (with @ucode_api_max being the</span>
<span class="cm"> * highest and @ucode_api_min the lowest). Firmware will only be loaded if</span>
<span class="cm"> * it has a supported API version. The firmware&#39;s API version will be</span>
<span class="cm"> * stored in @il_priv, enabling the driver to make runtime changes based</span>
<span class="cm"> * on firmware version used.</span>
<span class="cm"> *</span>
<span class="cm"> * For example,</span>
<span class="cm"> * if (IL_UCODE_API(il-&gt;ucode_ver) &gt;= 2) {</span>
<span class="cm"> *	Driver interacts with Firmware API version &gt;= 2.</span>
<span class="cm"> * } else {</span>
<span class="cm"> *	Driver interacts with Firmware API version 1.</span>
<span class="cm"> * }</span>
<span class="cm"> *</span>
<span class="cm"> * The ideal usage of this infrastructure is to treat a new ucode API</span>
<span class="cm"> * release as a new hardware revision. That is, through utilizing the</span>
<span class="cm"> * il_hcmd_utils_ops etc. we accommodate different command structures</span>
<span class="cm"> * and flows between hardware versions as well as their API</span>
<span class="cm"> * versions.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">il_cfg</span> <span class="p">{</span>
	<span class="cm">/* params specific to an individual device within a device family */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fw_name_pre</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ucode_api_max</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ucode_api_min</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">valid_tx_ant</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">valid_rx_ant</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sku</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">eeprom_ver</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">eeprom_calib_ver</span><span class="p">;</span>
	<span class="cm">/* module based parameters which can be set from modprobe cmd */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">il_mod_params</span> <span class="o">*</span><span class="n">mod_params</span><span class="p">;</span>
	<span class="cm">/* params not likely to change within a device family */</span>
	<span class="k">struct</span> <span class="n">il_base_params</span> <span class="o">*</span><span class="n">base_params</span><span class="p">;</span>
	<span class="cm">/* params likely to change within a device family */</span>
	<span class="n">u8</span> <span class="n">scan_rx_antennas</span><span class="p">[</span><span class="n">IEEE80211_NUM_BANDS</span><span class="p">];</span>
	<span class="k">enum</span> <span class="n">il_led_mode</span> <span class="n">led_mode</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">eeprom_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_of_queues</span><span class="p">;</span>		<span class="cm">/* def: HW dependent */</span>
	<span class="kt">int</span> <span class="n">num_of_ampdu_queues</span><span class="p">;</span>	<span class="cm">/* def: HW dependent */</span>
	<span class="cm">/* for il_apm_init() */</span>
	<span class="n">u32</span> <span class="n">pll_cfg_val</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">set_l0s</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">use_bsm</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">led_compensation</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chain_noise_num_beacons</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wd_timeout</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">temperature_kelvin</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">bool</span> <span class="n">ucode_tracing</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">bool</span> <span class="n">sensitivity_calib_by_driver</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">bool</span> <span class="n">chain_noise_calib_by_driver</span><span class="p">;</span>

	<span class="k">const</span> <span class="n">u32</span> <span class="n">regulatory_bands</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/***************************</span>
<span class="cm"> *   L i b                 *</span>
<span class="cm"> ***************************/</span>

<span class="kt">int</span> <span class="n">il_mac_conf_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
		   <span class="n">u16</span> <span class="n">queue</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_tx_queue_params</span> <span class="o">*</span><span class="n">params</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il_mac_tx_last_beacon</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">il_set_rxon_hwcrypto</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hw_decrypt</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il_check_rxon_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il_full_rxon_required</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il_set_rxon_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_set_flags_for_band</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>
<span class="n">u8</span> <span class="n">il_get_single_channel_number</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_set_rxon_ht</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_ht_config</span> <span class="o">*</span><span class="n">ht_conf</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">il_is_ht40_tx_allowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">ieee80211_sta_ht_cap</span> <span class="o">*</span><span class="n">ht_cap</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_connection_init_rx_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_set_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il_set_decrypted_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span>
			  <span class="n">u32</span> <span class="n">decrypt_res</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_rx_status</span> <span class="o">*</span><span class="n">stats</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_irq_handle_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il_mac_add_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_mac_remove_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il_mac_change_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
			    <span class="k">enum</span> <span class="n">nl80211_iftype</span> <span class="n">newtype</span><span class="p">,</span> <span class="n">bool</span> <span class="n">newp2p</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il_alloc_txq_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_free_txq_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_IWLEGACY_DEBUGFS</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">il_update_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">bool</span> <span class="n">is_tx</span><span class="p">,</span> <span class="n">__le16</span> <span class="n">fc</span><span class="p">,</span> <span class="n">u16</span> <span class="n">len</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">il_update_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">bool</span> <span class="n">is_tx</span><span class="p">,</span> <span class="n">__le16</span> <span class="n">fc</span><span class="p">,</span> <span class="n">u16</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*****************************************************</span>
<span class="cm"> * Handlers</span>
<span class="cm"> ***************************************************/</span>
<span class="kt">void</span> <span class="n">il_hdl_pm_sleep</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_rx_buf</span> <span class="o">*</span><span class="n">rxb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_hdl_pm_debug_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_rx_buf</span> <span class="o">*</span><span class="n">rxb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_hdl_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_rx_buf</span> <span class="o">*</span><span class="n">rxb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_hdl_csa</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_rx_buf</span> <span class="o">*</span><span class="n">rxb</span><span class="p">);</span>

<span class="cm">/*****************************************************</span>
<span class="cm">* RX</span>
<span class="cm">******************************************************/</span>
<span class="kt">void</span> <span class="n">il_cmd_queue_unmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_cmd_queue_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il_rx_queue_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_rx_queue_update_write_ptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_rx_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il_rx_queue_space</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">il_rx_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_tx_cmd_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_rx_buf</span> <span class="o">*</span><span class="n">rxb</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">il_hdl_spectrum_measurement</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_rx_buf</span> <span class="o">*</span><span class="n">rxb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_recover_from_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_rx_pkt</span> <span class="o">*</span><span class="n">pkt</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_chswitch_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">bool</span> <span class="n">is_success</span><span class="p">);</span>

<span class="cm">/*****************************************************</span>
<span class="cm">* TX</span>
<span class="cm">******************************************************/</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">il_txq_update_write_ptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">il_tx_queue_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="n">txq_id</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">il_tx_queue_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="n">txq_id</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">il_tx_queue_unmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="kt">int</span> <span class="n">txq_id</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">il_tx_queue_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="kt">int</span> <span class="n">txq_id</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">il_setup_watchdog</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="cm">/*****************************************************</span>
<span class="cm"> * TX power</span>
<span class="cm"> ****************************************************/</span>
<span class="kt">int</span> <span class="n">il_set_tx_power</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">s8</span> <span class="n">tx_power</span><span class="p">,</span> <span class="n">bool</span> <span class="n">force</span><span class="p">);</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> * Rate</span>
<span class="cm"> ******************************************************************************/</span>

<span class="n">u8</span> <span class="n">il_get_lowest_plcp</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> * Scanning</span>
<span class="cm"> ******************************************************************************/</span>
<span class="kt">void</span> <span class="n">il_init_scan_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il_scan_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il_scan_cancel_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ms</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_force_scan_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il_mac_hw_scan</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">cfg80211_scan_request</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_internal_short_hw_scan</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il_force_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">bool</span> <span class="n">external</span><span class="p">);</span>
<span class="n">u16</span> <span class="n">il_fill_probe_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_mgmt</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
		      <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ta</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ie</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ie_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_setup_rx_scan_handlers</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="n">u16</span> <span class="n">il_get_active_dwell_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">,</span>
			     <span class="n">u8</span> <span class="n">n_probes</span><span class="p">);</span>
<span class="n">u16</span> <span class="n">il_get_passive_dwell_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_setup_scan_deferred_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_cancel_scan_deferred_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>

<span class="cm">/* For faster active scanning, scan will move to the next channel if fewer than</span>
<span class="cm"> * PLCP_QUIET_THRESH packets are heard on this channel within</span>
<span class="cm"> * ACTIVE_QUIET_TIME after sending probe request.  This shortens the dwell</span>
<span class="cm"> * time if it&#39;s a quiet channel (nothing responded to our probe, and there&#39;s</span>
<span class="cm"> * no other traffic).</span>
<span class="cm"> * Disable &quot;quiet&quot; feature by setting PLCP_QUIET_THRESH to 0. */</span>
<span class="cp">#define IL_ACTIVE_QUIET_TIME       cpu_to_le16(10)	</span><span class="cm">/* msec */</span><span class="cp"></span>
<span class="cp">#define IL_PLCP_QUIET_THRESH       cpu_to_le16(1)	</span><span class="cm">/* packets */</span><span class="cp"></span>

<span class="cp">#define IL_SCAN_CHECK_WATCHDOG		(HZ * 7)</span>

<span class="cm">/*****************************************************</span>
<span class="cm"> *   S e n d i n g     H o s t     C o m m a n d s   *</span>
<span class="cm"> *****************************************************/</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">il_get_cmd_string</span><span class="p">(</span><span class="n">u8</span> <span class="n">cmd</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">il_send_cmd_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_host_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il_send_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_host_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">il_send_cmd_pdu</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u8</span> <span class="n">id</span><span class="p">,</span> <span class="n">u16</span> <span class="n">len</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il_send_cmd_pdu_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u8</span> <span class="n">id</span><span class="p">,</span> <span class="n">u16</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">il_device_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">il_rx_pkt</span> <span class="o">*</span><span class="n">pkt</span><span class="p">));</span>

<span class="kt">int</span> <span class="n">il_enqueue_hcmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_host_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>

<span class="cm">/*****************************************************</span>
<span class="cm"> * PCI						     *</span>
<span class="cm"> *****************************************************/</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span>
<span class="nf">il_pcie_link_ctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pci_lnk_ctl</span><span class="p">;</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_pcie_cap</span><span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_LNKCTL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_lnk_ctl</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pci_lnk_ctl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">il_bg_watchdog</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">il_usecs_to_beacons</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="n">usec</span><span class="p">,</span> <span class="n">u32</span> <span class="n">beacon_interval</span><span class="p">);</span>
<span class="n">__le32</span> <span class="n">il_add_beacon_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="n">base</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addon</span><span class="p">,</span>
			  <span class="n">u32</span> <span class="n">beacon_interval</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="kt">int</span> <span class="n">il_pci_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">device</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il_pci_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">device</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">il_pm_ops</span><span class="p">;</span>

<span class="cp">#define IL_LEGACY_PM_OPS	(&amp;il_pm_ops)</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_PM */</span><span class="cp"></span>

<span class="cp">#define IL_LEGACY_PM_OPS	NULL</span>

<span class="cp">#endif </span><span class="cm">/* !CONFIG_PM */</span><span class="cp"></span>

<span class="cm">/*****************************************************</span>
<span class="cm">*  Error Handling Debugging</span>
<span class="cm">******************************************************/</span>
<span class="kt">void</span> <span class="n">il4965_dump_nic_error_log</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_IWLEGACY_DEBUG</span>
<span class="kt">void</span> <span class="n">il_print_rx_config_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">il_print_rx_config_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="n">il_clear_isr_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>

<span class="cm">/*****************************************************</span>
<span class="cm">*  GEOS</span>
<span class="cm">******************************************************/</span>
<span class="kt">int</span> <span class="n">il_init_geos</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_free_geos</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>

<span class="cm">/*************** DRIVER STATUS FUNCTIONS   *****/</span>

<span class="cp">#define S_HCMD_ACTIVE	0	</span><span class="cm">/* host command in progress */</span><span class="cp"></span>
<span class="cm">/* 1 is unused (used to be S_HCMD_SYNC_ACTIVE) */</span>
<span class="cp">#define S_INT_ENABLED	2</span>
<span class="cp">#define S_RFKILL	3</span>
<span class="cp">#define S_CT_KILL		4</span>
<span class="cp">#define S_INIT		5</span>
<span class="cp">#define S_ALIVE		6</span>
<span class="cp">#define S_READY		7</span>
<span class="cp">#define S_TEMPERATURE	8</span>
<span class="cp">#define S_GEO_CONFIGURED	9</span>
<span class="cp">#define S_EXIT_PENDING	10</span>
<span class="cp">#define S_STATS		12</span>
<span class="cp">#define S_SCANNING		13</span>
<span class="cp">#define S_SCAN_ABORTING	14</span>
<span class="cp">#define S_SCAN_HW		15</span>
<span class="cp">#define S_POWER_PMI	16</span>
<span class="cp">#define S_FW_ERROR		17</span>
<span class="cp">#define S_CHANNEL_SWITCH_PENDING 18</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">il_is_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* The adapter is &#39;ready&#39; if READY and GEO_CONFIGURED bits are</span>
<span class="cm">	 * set but EXIT_PENDING is not */</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">S_READY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">test_bit</span><span class="p">(</span><span class="n">S_GEO_CONFIGURED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">S_EXIT_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">il_is_alive</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">S_ALIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">il_is_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">S_INIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">il_is_rfkill</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">S_RFKILL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">il_is_ctkill</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">S_CT_KILL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">il_is_ready_rf</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">il_is_rfkill</span><span class="p">(</span><span class="n">il</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">il_is_ready</span><span class="p">(</span><span class="n">il</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">il_send_bt_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">il_send_stats_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u8</span> <span class="n">flags</span><span class="p">,</span> <span class="n">bool</span> <span class="n">clear</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">il_apm_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">_il_apm_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">il_apm_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">il_send_rxon_timing</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">il_send_rxon_assoc</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">il</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">rxon_assoc</span><span class="p">(</span><span class="n">il</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">il_commit_rxon</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">il</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">commit_rxon</span><span class="p">(</span><span class="n">il</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_supported_band</span> <span class="o">*</span>
<span class="nf">il_get_hw_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">il</span><span class="o">-&gt;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">bands</span><span class="p">[</span><span class="n">band</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/* mac80211 handlers */</span>
<span class="kt">int</span> <span class="n">il_mac_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">changed</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_mac_reset_tsf</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_mac_bss_info_changed</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ieee80211_bss_conf</span> <span class="o">*</span><span class="n">bss_conf</span><span class="p">,</span> <span class="n">u32</span> <span class="n">changes</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_tx_cmd_protection</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_tx_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			  <span class="n">__le16</span> <span class="n">fc</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">tx_flags</span><span class="p">);</span>

<span class="n">irqreturn_t</span> <span class="n">il_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">il_set_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">u32</span> <span class="n">r</span><span class="p">,</span> <span class="n">u32</span> <span class="n">m</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">il_clear_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">u32</span> <span class="n">r</span><span class="p">,</span> <span class="n">u32</span> <span class="n">m</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">_il_grab_nic_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">_il_poll_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bits</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">il_poll_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">il_rd_prph</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">il_wr_prph</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">il_read_targ_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">il_write_targ_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">_il_write8</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">u8</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">il</span><span class="o">-&gt;</span><span class="n">hw_base</span> <span class="o">+</span> <span class="n">ofs</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#define il_write8(il, ofs, val) _il_write8(il, ofs, val)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">_il_wr</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">il</span><span class="o">-&gt;</span><span class="n">hw_base</span> <span class="o">+</span> <span class="n">ofs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span>
<span class="nf">_il_rd</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ofs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">hw_base</span> <span class="o">+</span> <span class="n">ofs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">_il_clear_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">_il_wr</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">_il_rd</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">_il_set_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">_il_wr</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">_il_rd</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="o">|</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">_il_release_nic_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">_il_clear_bit</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">CSR_GP_CNTRL</span><span class="p">,</span> <span class="n">CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * In above we are reading CSR_GP_CNTRL register, what will flush any</span>
<span class="cm">	 * previous writes, but still want write, which clear MAC_ACCESS_REQ</span>
<span class="cm">	 * bit, be performed on PCI bus before any other writes scheduled on</span>
<span class="cm">	 * different CPUs (after we drop reg_lock).</span>
<span class="cm">	 */</span>
	<span class="n">mmiowb</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span>
<span class="nf">il_rd</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">value</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg_flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">reg_flags</span><span class="p">);</span>
	<span class="n">_il_grab_nic_access</span><span class="p">(</span><span class="n">il</span><span class="p">);</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">_il_rd</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="n">_il_release_nic_access</span><span class="p">(</span><span class="n">il</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">reg_flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">il_wr</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg_flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">reg_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">_il_grab_nic_access</span><span class="p">(</span><span class="n">il</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">_il_wr</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
		<span class="n">_il_release_nic_access</span><span class="p">(</span><span class="n">il</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">reg_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span>
<span class="nf">_il_rd_prph</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">_il_wr</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">HBUS_TARG_PRPH_RADDR</span><span class="p">,</span> <span class="n">reg</span> <span class="o">|</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">_il_rd</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">HBUS_TARG_PRPH_RDAT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">_il_wr_prph</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">_il_wr</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">HBUS_TARG_PRPH_WADDR</span><span class="p">,</span> <span class="p">((</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0x0000FFFF</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)));</span>
	<span class="n">_il_wr</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">HBUS_TARG_PRPH_WDAT</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">il_set_bits_prph</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg_flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">reg_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">_il_grab_nic_access</span><span class="p">(</span><span class="n">il</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">_il_wr_prph</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="p">(</span><span class="n">_il_rd_prph</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="o">|</span> <span class="n">mask</span><span class="p">));</span>
		<span class="n">_il_release_nic_access</span><span class="p">(</span><span class="n">il</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">reg_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">il_set_bits_mask_prph</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bits</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg_flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">reg_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">_il_grab_nic_access</span><span class="p">(</span><span class="n">il</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">_il_wr_prph</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="p">((</span><span class="n">_il_rd_prph</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="n">bits</span><span class="p">));</span>
		<span class="n">_il_release_nic_access</span><span class="p">(</span><span class="n">il</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">reg_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">il_clear_bits_prph</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg_flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">reg_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">_il_grab_nic_access</span><span class="p">(</span><span class="n">il</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">_il_rd_prph</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="n">_il_wr_prph</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">));</span>
		<span class="n">_il_release_nic_access</span><span class="p">(</span><span class="n">il</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">reg_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define HW_KEY_DYNAMIC 0</span>
<span class="cp">#define HW_KEY_DEFAULT 1</span>

<span class="cp">#define IL_STA_DRIVER_ACTIVE BIT(0)	</span><span class="cm">/* driver entry is active */</span><span class="cp"></span>
<span class="cp">#define IL_STA_UCODE_ACTIVE  BIT(1)	</span><span class="cm">/* ucode entry is active */</span><span class="cp"></span>
<span class="cp">#define IL_STA_UCODE_INPROGRESS  BIT(2)	</span><span class="cm">/* ucode entry is in process of</span>
<span class="cm">					   being activated */</span><span class="cp"></span>
<span class="cp">#define IL_STA_LOCAL BIT(3)	</span><span class="cm">/* station state not directed by mac80211;</span>
<span class="cm">				   (this is for the IBSS BSSID stations) */</span><span class="cp"></span>
<span class="cp">#define IL_STA_BCAST BIT(4)	</span><span class="cm">/* this station is the special bcast station */</span><span class="cp"></span>

<span class="kt">void</span> <span class="n">il_restore_stations</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_clear_ucode_stations</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_dealloc_bcast_stations</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il_get_free_ucode_key_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il_send_add_sta</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_addsta_cmd</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="n">u8</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il_add_station_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">bool</span> <span class="n">is_ap</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">sta_id_r</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il_remove_station</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">sta_id</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span> <span class="n">addr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">il_mac_sta_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">);</span>

<span class="n">u8</span> <span class="n">il_prep_station</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">bool</span> <span class="n">is_ap</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">il_send_lq_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_link_quality_cmd</span> <span class="o">*</span><span class="n">lq</span><span class="p">,</span>
		   <span class="n">u8</span> <span class="n">flags</span><span class="p">,</span> <span class="n">bool</span> <span class="n">init</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * il_clear_driver_stations - clear knowledge of all stations from driver</span>
<span class="cm"> * @il: iwl il struct</span>
<span class="cm"> *</span>
<span class="cm"> * This is called during il_down() to make sure that in the case</span>
<span class="cm"> * we&#39;re coming there from a hardware restart mac80211 will be</span>
<span class="cm"> * able to reconfigure stations -- if we&#39;re getting there in the</span>
<span class="cm"> * normal down flow then the stations will already be cleared.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">il_clear_driver_stations</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">sta_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">stations</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">stations</span><span class="p">));</span>
	<span class="n">il</span><span class="o">-&gt;</span><span class="n">num_stations</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">il</span><span class="o">-&gt;</span><span class="n">ucode_key_table</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">sta_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">il_sta_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sta</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IL_INVALID_STATION</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">((</span><span class="k">struct</span> <span class="n">il_station_priv_common</span> <span class="o">*</span><span class="p">)</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">drv_priv</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sta_id</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * il_sta_id_or_broadcast - return sta_id or broadcast sta</span>
<span class="cm"> * @il: iwl il</span>
<span class="cm"> * @context: the current context</span>
<span class="cm"> * @sta: mac80211 station</span>
<span class="cm"> *</span>
<span class="cm"> * In certain circumstances mac80211 passes a station pointer</span>
<span class="cm"> * that may be %NULL, for example during TX or key setup. In</span>
<span class="cm"> * that case, we need to use the broadcast station, so this</span>
<span class="cm"> * inline wraps that pattern.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">il_sta_id_or_broadcast</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sta_id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sta</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">il</span><span class="o">-&gt;</span><span class="n">hw_params</span><span class="p">.</span><span class="n">bcast_id</span><span class="p">;</span>

	<span class="n">sta_id</span> <span class="o">=</span> <span class="n">il_sta_id</span><span class="p">(</span><span class="n">sta</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * mac80211 should not be passing a partially</span>
<span class="cm">	 * initialised station!</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">sta_id</span> <span class="o">==</span> <span class="n">IL_INVALID_STATION</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sta_id</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * il_queue_inc_wrap - increment queue idx, wrap back to beginning</span>
<span class="cm"> * @idx -- current idx</span>
<span class="cm"> * @n_bd -- total number of entries in queue (must be power of 2)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">il_queue_inc_wrap</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n_bd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">++</span><span class="n">idx</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n_bd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * il_queue_dec_wrap - decrement queue idx, wrap back to end</span>
<span class="cm"> * @idx -- current idx</span>
<span class="cm"> * @n_bd -- total number of entries in queue (must be power of 2)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">il_queue_dec_wrap</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n_bd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">--</span><span class="n">idx</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n_bd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* TODO: Move fw_desc functions to iwl-pci.ko */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">il_free_fw_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fw_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">v_addr</span><span class="p">)</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">v_addr</span><span class="p">,</span>
				  <span class="n">desc</span><span class="o">-&gt;</span><span class="n">p_addr</span><span class="p">);</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">v_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">il_alloc_fw_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fw_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">v_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">v_addr</span> <span class="o">=</span>
	    <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">p_addr</span><span class="p">,</span>
			       <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">v_addr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * we have 8 bits used like this:</span>
<span class="cm"> *</span>
<span class="cm"> * 7 6 5 4 3 2 1 0</span>
<span class="cm"> * | | | | | | | |</span>
<span class="cm"> * | | | | | | +-+-------- AC queue (0-3)</span>
<span class="cm"> * | | | | | |</span>
<span class="cm"> * | +-+-+-+-+------------ HW queue ID</span>
<span class="cm"> * |</span>
<span class="cm"> * +---------------------- unused</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">il_set_swq_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ac</span><span class="p">,</span> <span class="n">u8</span> <span class="n">hwq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ac</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">);</span>		<span class="cm">/* only have 2 bits */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">hwq</span> <span class="o">&gt;</span> <span class="mi">31</span><span class="p">);</span>	<span class="cm">/* only use 5 bits */</span>

	<span class="n">txq</span><span class="o">-&gt;</span><span class="n">swq_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">hwq</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="n">ac</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">il_wake_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">swq_id</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ac</span> <span class="o">=</span> <span class="n">queue</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">hwq</span> <span class="o">=</span> <span class="p">(</span><span class="n">queue</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">hwq</span><span class="p">,</span> <span class="n">il</span><span class="o">-&gt;</span><span class="n">queue_stopped</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">queue_stop_count</span><span class="p">[</span><span class="n">ac</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ieee80211_wake_queue</span><span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">ac</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">il_stop_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">il_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">swq_id</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ac</span> <span class="o">=</span> <span class="n">queue</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">hwq</span> <span class="o">=</span> <span class="p">(</span><span class="n">queue</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">hwq</span><span class="p">,</span> <span class="n">il</span><span class="o">-&gt;</span><span class="n">queue_stopped</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">queue_stop_count</span><span class="p">[</span><span class="n">ac</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ieee80211_stop_queue</span><span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">ac</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef ieee80211_stop_queue</span>
<span class="cp">#undef ieee80211_stop_queue</span>
<span class="cp">#endif</span>

<span class="cp">#define ieee80211_stop_queue DO_NOT_USE_ieee80211_stop_queue</span>

<span class="cp">#ifdef ieee80211_wake_queue</span>
<span class="cp">#undef ieee80211_wake_queue</span>
<span class="cp">#endif</span>

<span class="cp">#define ieee80211_wake_queue DO_NOT_USE_ieee80211_wake_queue</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">il_disable_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">S_INT_ENABLED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>

	<span class="cm">/* disable interrupts from uCode/NIC to host */</span>
	<span class="n">_il_wr</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">CSR_INT_MASK</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">);</span>

	<span class="cm">/* acknowledge/clear/reset any interrupts still pending</span>
<span class="cm">	 * from uCode or flow handler (Rx/Tx DMA) */</span>
	<span class="n">_il_wr</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">CSR_INT</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
	<span class="n">_il_wr</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">CSR_FH_INT_STATUS</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">il_enable_rfkill_int</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">_il_wr</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">CSR_INT_MASK</span><span class="p">,</span> <span class="n">CSR_INT_BIT_RF_KILL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">il_enable_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">S_INT_ENABLED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="n">_il_wr</span><span class="p">(</span><span class="n">il</span><span class="p">,</span> <span class="n">CSR_INT_MASK</span><span class="p">,</span> <span class="n">il</span><span class="o">-&gt;</span><span class="n">inta_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * il_beacon_time_mask_low - mask of lower 32 bit of beacon time</span>
<span class="cm"> * @il -- pointer to il_priv data structure</span>
<span class="cm"> * @tsf_bits -- number of bits need to shift for masking)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span>
<span class="nf">il_beacon_time_mask_low</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u16</span> <span class="n">tsf_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">tsf_bits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * il_beacon_time_mask_high - mask of higher 32 bit of beacon time</span>
<span class="cm"> * @il -- pointer to il_priv data structure</span>
<span class="cm"> * @tsf_bits -- number of bits need to shift for masking)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span>
<span class="nf">il_beacon_time_mask_high</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">u16</span> <span class="n">tsf_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">tsf_bits</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">tsf_bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * struct il_rb_status - reseve buffer status host memory mapped FH registers</span>
<span class="cm"> *</span>
<span class="cm"> * @closed_rb_num [0:11] - Indicates the idx of the RB which was closed</span>
<span class="cm"> * @closed_fr_num [0:11] - Indicates the idx of the RX Frame which was closed</span>
<span class="cm"> * @finished_rb_num [0:11] - Indicates the idx of the current RB</span>
<span class="cm"> *			     in which the last frame was written to</span>
<span class="cm"> * @finished_fr_num [0:11] - Indicates the idx of the RX Frame</span>
<span class="cm"> *			     which was transferred</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">il_rb_status</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">closed_rb_num</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">closed_fr_num</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">finished_rb_num</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">finished_fr_nam</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">__unused</span><span class="p">;</span>	<span class="cm">/* 3945 only */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cp">#define TFD_QUEUE_SIZE_MAX      256</span>
<span class="cp">#define TFD_QUEUE_SIZE_BC_DUP	64</span>
<span class="cp">#define TFD_QUEUE_BC_SIZE	(TFD_QUEUE_SIZE_MAX + TFD_QUEUE_SIZE_BC_DUP)</span>
<span class="cp">#define IL_TX_DMA_MASK		DMA_BIT_MASK(36)</span>
<span class="cp">#define IL_NUM_OF_TBS		20</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span>
<span class="nf">il_get_dma_hi_addr</span><span class="p">(</span><span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * struct il_tfd_tb transmit buffer descriptor within transmit frame descriptor</span>
<span class="cm"> *</span>
<span class="cm"> * This structure contains dma address and length of transmission address</span>
<span class="cm"> *</span>
<span class="cm"> * @lo: low [31:0] portion of the dma address of TX buffer every even is</span>
<span class="cm"> *	unaligned on 16 bit boundary</span>
<span class="cm"> * @hi_n_len: 0-3 [35:32] portion of dma</span>
<span class="cm"> *	      4-15 length of the tx buffer</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">il_tfd_tb</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">lo</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">hi_n_len</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct il_tfd</span>
<span class="cm"> *</span>
<span class="cm"> * Transmit Frame Descriptor (TFD)</span>
<span class="cm"> *</span>
<span class="cm"> * @ __reserved1[3] reserved</span>
<span class="cm"> * @ num_tbs 0-4 number of active tbs</span>
<span class="cm"> *	     5   reserved</span>
<span class="cm"> * 	     6-7 padding (not used)</span>
<span class="cm"> * @ tbs[20]	transmit frame buffer descriptors</span>
<span class="cm"> * @ __pad	padding</span>
<span class="cm"> *</span>
<span class="cm"> * Each Tx queue uses a circular buffer of 256 TFDs stored in host DRAM.</span>
<span class="cm"> * Both driver and device share these circular buffers, each of which must be</span>
<span class="cm"> * contiguous 256 TFDs x 128 bytes-per-TFD = 32 KBytes</span>
<span class="cm"> *</span>
<span class="cm"> * Driver must indicate the physical address of the base of each</span>
<span class="cm"> * circular buffer via the FH49_MEM_CBBC_QUEUE registers.</span>
<span class="cm"> *</span>
<span class="cm"> * Each TFD contains pointer/size information for up to 20 data buffers</span>
<span class="cm"> * in host DRAM.  These buffers collectively contain the (one) frame described</span>
<span class="cm"> * by the TFD.  Each buffer must be a single contiguous block of memory within</span>
<span class="cm"> * itself, but buffers may be scattered in host DRAM.  Each buffer has max size</span>
<span class="cm"> * of (4K - 4).  The concatenates all of a TFD&#39;s buffers into a single</span>
<span class="cm"> * Tx frame, up to 8 KBytes in size.</span>
<span class="cm"> *</span>
<span class="cm"> * A maximum of 255 (not 256!) TFDs may be on a queue waiting for Tx.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">il_tfd</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">__reserved1</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">num_tbs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_tfd_tb</span> <span class="n">tbs</span><span class="p">[</span><span class="n">IL_NUM_OF_TBS</span><span class="p">];</span>
	<span class="n">__le32</span> <span class="n">__pad</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>
<span class="cm">/* PCI registers */</span>
<span class="cp">#define PCI_CFG_RETRY_TIMEOUT	0x041</span>

<span class="cm">/* PCI register values */</span>
<span class="cp">#define PCI_CFG_LINK_CTRL_VAL_L0S_EN	0x01</span>
<span class="cp">#define PCI_CFG_LINK_CTRL_VAL_L1_EN	0x02</span>

<span class="k">struct</span> <span class="n">il_rate_info</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">plcp</span><span class="p">;</span>		<span class="cm">/* uCode API:  RATE_6M_PLCP, etc. */</span>
	<span class="n">u8</span> <span class="n">plcp_siso</span><span class="p">;</span>		<span class="cm">/* uCode API:  RATE_SISO_6M_PLCP, etc. */</span>
	<span class="n">u8</span> <span class="n">plcp_mimo2</span><span class="p">;</span>		<span class="cm">/* uCode API:  RATE_MIMO2_6M_PLCP, etc. */</span>
	<span class="n">u8</span> <span class="n">ieee</span><span class="p">;</span>		<span class="cm">/* MAC header:  RATE_6M_IEEE, etc. */</span>
	<span class="n">u8</span> <span class="n">prev_ieee</span><span class="p">;</span>		<span class="cm">/* previous rate in IEEE speeds */</span>
	<span class="n">u8</span> <span class="n">next_ieee</span><span class="p">;</span>		<span class="cm">/* next rate in IEEE speeds */</span>
	<span class="n">u8</span> <span class="n">prev_rs</span><span class="p">;</span>		<span class="cm">/* previous rate used in rs algo */</span>
	<span class="n">u8</span> <span class="n">next_rs</span><span class="p">;</span>		<span class="cm">/* next rate used in rs algo */</span>
	<span class="n">u8</span> <span class="n">prev_rs_tgg</span><span class="p">;</span>		<span class="cm">/* previous rate used in TGG rs algo */</span>
	<span class="n">u8</span> <span class="n">next_rs_tgg</span><span class="p">;</span>		<span class="cm">/* next rate used in TGG rs algo */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">il3945_rate_info</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">plcp</span><span class="p">;</span>		<span class="cm">/* uCode API:  RATE_6M_PLCP, etc. */</span>
	<span class="n">u8</span> <span class="n">ieee</span><span class="p">;</span>		<span class="cm">/* MAC header:  RATE_6M_IEEE, etc. */</span>
	<span class="n">u8</span> <span class="n">prev_ieee</span><span class="p">;</span>		<span class="cm">/* previous rate in IEEE speeds */</span>
	<span class="n">u8</span> <span class="n">next_ieee</span><span class="p">;</span>		<span class="cm">/* next rate in IEEE speeds */</span>
	<span class="n">u8</span> <span class="n">prev_rs</span><span class="p">;</span>		<span class="cm">/* previous rate used in rs algo */</span>
	<span class="n">u8</span> <span class="n">next_rs</span><span class="p">;</span>		<span class="cm">/* next rate used in rs algo */</span>
	<span class="n">u8</span> <span class="n">prev_rs_tgg</span><span class="p">;</span>		<span class="cm">/* previous rate used in TGG rs algo */</span>
	<span class="n">u8</span> <span class="n">next_rs_tgg</span><span class="p">;</span>		<span class="cm">/* next rate used in TGG rs algo */</span>
	<span class="n">u8</span> <span class="n">table_rs_idx</span><span class="p">;</span>	<span class="cm">/* idx in rate scale table cmd */</span>
	<span class="n">u8</span> <span class="n">prev_table_rs</span><span class="p">;</span>	<span class="cm">/* prev in rate table cmd */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * These serve as idxes into</span>
<span class="cm"> * struct il_rate_info il_rates[RATE_COUNT];</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">RATE_1M_IDX</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">RATE_2M_IDX</span><span class="p">,</span>
	<span class="n">RATE_5M_IDX</span><span class="p">,</span>
	<span class="n">RATE_11M_IDX</span><span class="p">,</span>
	<span class="n">RATE_6M_IDX</span><span class="p">,</span>
	<span class="n">RATE_9M_IDX</span><span class="p">,</span>
	<span class="n">RATE_12M_IDX</span><span class="p">,</span>
	<span class="n">RATE_18M_IDX</span><span class="p">,</span>
	<span class="n">RATE_24M_IDX</span><span class="p">,</span>
	<span class="n">RATE_36M_IDX</span><span class="p">,</span>
	<span class="n">RATE_48M_IDX</span><span class="p">,</span>
	<span class="n">RATE_54M_IDX</span><span class="p">,</span>
	<span class="n">RATE_60M_IDX</span><span class="p">,</span>
	<span class="n">RATE_COUNT</span><span class="p">,</span>
	<span class="n">RATE_COUNT_LEGACY</span> <span class="o">=</span> <span class="n">RATE_COUNT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* Excluding 60M */</span>
	<span class="n">RATE_COUNT_3945</span> <span class="o">=</span> <span class="n">RATE_COUNT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">RATE_INVM_IDX</span> <span class="o">=</span> <span class="n">RATE_COUNT</span><span class="p">,</span>
	<span class="n">RATE_INVALID</span> <span class="o">=</span> <span class="n">RATE_COUNT</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">RATE_6M_IDX_TBL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">RATE_9M_IDX_TBL</span><span class="p">,</span>
	<span class="n">RATE_12M_IDX_TBL</span><span class="p">,</span>
	<span class="n">RATE_18M_IDX_TBL</span><span class="p">,</span>
	<span class="n">RATE_24M_IDX_TBL</span><span class="p">,</span>
	<span class="n">RATE_36M_IDX_TBL</span><span class="p">,</span>
	<span class="n">RATE_48M_IDX_TBL</span><span class="p">,</span>
	<span class="n">RATE_54M_IDX_TBL</span><span class="p">,</span>
	<span class="n">RATE_1M_IDX_TBL</span><span class="p">,</span>
	<span class="n">RATE_2M_IDX_TBL</span><span class="p">,</span>
	<span class="n">RATE_5M_IDX_TBL</span><span class="p">,</span>
	<span class="n">RATE_11M_IDX_TBL</span><span class="p">,</span>
	<span class="n">RATE_INVM_IDX_TBL</span> <span class="o">=</span> <span class="n">RATE_INVM_IDX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IL_FIRST_OFDM_RATE</span> <span class="o">=</span> <span class="n">RATE_6M_IDX</span><span class="p">,</span>
	<span class="n">IL39_LAST_OFDM_RATE</span> <span class="o">=</span> <span class="n">RATE_54M_IDX</span><span class="p">,</span>
	<span class="n">IL_LAST_OFDM_RATE</span> <span class="o">=</span> <span class="n">RATE_60M_IDX</span><span class="p">,</span>
	<span class="n">IL_FIRST_CCK_RATE</span> <span class="o">=</span> <span class="n">RATE_1M_IDX</span><span class="p">,</span>
	<span class="n">IL_LAST_CCK_RATE</span> <span class="o">=</span> <span class="n">RATE_11M_IDX</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* #define vs. enum to keep from defaulting to &#39;large integer&#39; */</span>
<span class="cp">#define	RATE_6M_MASK   (1 &lt;&lt; RATE_6M_IDX)</span>
<span class="cp">#define	RATE_9M_MASK   (1 &lt;&lt; RATE_9M_IDX)</span>
<span class="cp">#define	RATE_12M_MASK  (1 &lt;&lt; RATE_12M_IDX)</span>
<span class="cp">#define	RATE_18M_MASK  (1 &lt;&lt; RATE_18M_IDX)</span>
<span class="cp">#define	RATE_24M_MASK  (1 &lt;&lt; RATE_24M_IDX)</span>
<span class="cp">#define	RATE_36M_MASK  (1 &lt;&lt; RATE_36M_IDX)</span>
<span class="cp">#define	RATE_48M_MASK  (1 &lt;&lt; RATE_48M_IDX)</span>
<span class="cp">#define	RATE_54M_MASK  (1 &lt;&lt; RATE_54M_IDX)</span>
<span class="cp">#define RATE_60M_MASK  (1 &lt;&lt; RATE_60M_IDX)</span>
<span class="cp">#define	RATE_1M_MASK   (1 &lt;&lt; RATE_1M_IDX)</span>
<span class="cp">#define	RATE_2M_MASK   (1 &lt;&lt; RATE_2M_IDX)</span>
<span class="cp">#define	RATE_5M_MASK   (1 &lt;&lt; RATE_5M_IDX)</span>
<span class="cp">#define	RATE_11M_MASK  (1 &lt;&lt; RATE_11M_IDX)</span>

<span class="cm">/* uCode API values for legacy bit rates, both OFDM and CCK */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">RATE_6M_PLCP</span> <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>
	<span class="n">RATE_9M_PLCP</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
	<span class="n">RATE_12M_PLCP</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">RATE_18M_PLCP</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
	<span class="n">RATE_24M_PLCP</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
	<span class="n">RATE_36M_PLCP</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
	<span class="n">RATE_48M_PLCP</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">RATE_54M_PLCP</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">RATE_60M_PLCP</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>	<span class="cm">/*FIXME:RS:should be removed */</span>
	<span class="n">RATE_1M_PLCP</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
	<span class="n">RATE_2M_PLCP</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
	<span class="n">RATE_5M_PLCP</span> <span class="o">=</span> <span class="mi">55</span><span class="p">,</span>
	<span class="n">RATE_11M_PLCP</span> <span class="o">=</span> <span class="mi">110</span><span class="p">,</span>
	<span class="cm">/*FIXME:RS:add RATE_LEGACY_INVM_PLCP = 0, */</span>
<span class="p">};</span>

<span class="cm">/* uCode API values for OFDM high-throughput (HT) bit rates */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">RATE_SISO_6M_PLCP</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">RATE_SISO_12M_PLCP</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">RATE_SISO_18M_PLCP</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">RATE_SISO_24M_PLCP</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">RATE_SISO_36M_PLCP</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">RATE_SISO_48M_PLCP</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">RATE_SISO_54M_PLCP</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">RATE_SISO_60M_PLCP</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
	<span class="n">RATE_MIMO2_6M_PLCP</span> <span class="o">=</span> <span class="mh">0x8</span><span class="p">,</span>
	<span class="n">RATE_MIMO2_12M_PLCP</span> <span class="o">=</span> <span class="mh">0x9</span><span class="p">,</span>
	<span class="n">RATE_MIMO2_18M_PLCP</span> <span class="o">=</span> <span class="mh">0xa</span><span class="p">,</span>
	<span class="n">RATE_MIMO2_24M_PLCP</span> <span class="o">=</span> <span class="mh">0xb</span><span class="p">,</span>
	<span class="n">RATE_MIMO2_36M_PLCP</span> <span class="o">=</span> <span class="mh">0xc</span><span class="p">,</span>
	<span class="n">RATE_MIMO2_48M_PLCP</span> <span class="o">=</span> <span class="mh">0xd</span><span class="p">,</span>
	<span class="n">RATE_MIMO2_54M_PLCP</span> <span class="o">=</span> <span class="mh">0xe</span><span class="p">,</span>
	<span class="n">RATE_MIMO2_60M_PLCP</span> <span class="o">=</span> <span class="mh">0xf</span><span class="p">,</span>
	<span class="n">RATE_SISO_INVM_PLCP</span><span class="p">,</span>
	<span class="n">RATE_MIMO2_INVM_PLCP</span> <span class="o">=</span> <span class="n">RATE_SISO_INVM_PLCP</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* MAC header values for bit rates */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">RATE_6M_IEEE</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
	<span class="n">RATE_9M_IEEE</span> <span class="o">=</span> <span class="mi">18</span><span class="p">,</span>
	<span class="n">RATE_12M_IEEE</span> <span class="o">=</span> <span class="mi">24</span><span class="p">,</span>
	<span class="n">RATE_18M_IEEE</span> <span class="o">=</span> <span class="mi">36</span><span class="p">,</span>
	<span class="n">RATE_24M_IEEE</span> <span class="o">=</span> <span class="mi">48</span><span class="p">,</span>
	<span class="n">RATE_36M_IEEE</span> <span class="o">=</span> <span class="mi">72</span><span class="p">,</span>
	<span class="n">RATE_48M_IEEE</span> <span class="o">=</span> <span class="mi">96</span><span class="p">,</span>
	<span class="n">RATE_54M_IEEE</span> <span class="o">=</span> <span class="mi">108</span><span class="p">,</span>
	<span class="n">RATE_60M_IEEE</span> <span class="o">=</span> <span class="mi">120</span><span class="p">,</span>
	<span class="n">RATE_1M_IEEE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">RATE_2M_IEEE</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">RATE_5M_IEEE</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
	<span class="n">RATE_11M_IEEE</span> <span class="o">=</span> <span class="mi">22</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define IL_CCK_BASIC_RATES_MASK    \</span>
<span class="cp">	(RATE_1M_MASK          | \</span>
<span class="cp">	RATE_2M_MASK)</span>

<span class="cp">#define IL_CCK_RATES_MASK          \</span>
<span class="cp">	(IL_CCK_BASIC_RATES_MASK  | \</span>
<span class="cp">	RATE_5M_MASK          | \</span>
<span class="cp">	RATE_11M_MASK)</span>

<span class="cp">#define IL_OFDM_BASIC_RATES_MASK   \</span>
<span class="cp">	(RATE_6M_MASK         | \</span>
<span class="cp">	RATE_12M_MASK         | \</span>
<span class="cp">	RATE_24M_MASK)</span>

<span class="cp">#define IL_OFDM_RATES_MASK         \</span>
<span class="cp">	(IL_OFDM_BASIC_RATES_MASK | \</span>
<span class="cp">	RATE_9M_MASK          | \</span>
<span class="cp">	RATE_18M_MASK         | \</span>
<span class="cp">	RATE_36M_MASK         | \</span>
<span class="cp">	RATE_48M_MASK         | \</span>
<span class="cp">	RATE_54M_MASK)</span>

<span class="cp">#define IL_BASIC_RATES_MASK         \</span>
<span class="cp">	(IL_OFDM_BASIC_RATES_MASK | \</span>
<span class="cp">	 IL_CCK_BASIC_RATES_MASK)</span>

<span class="cp">#define RATES_MASK ((1 &lt;&lt; RATE_COUNT) - 1)</span>
<span class="cp">#define RATES_MASK_3945 ((1 &lt;&lt; RATE_COUNT_3945) - 1)</span>

<span class="cp">#define IL_INVALID_VALUE    -1</span>

<span class="cp">#define IL_MIN_RSSI_VAL                 -100</span>
<span class="cp">#define IL_MAX_RSSI_VAL                    0</span>

<span class="cm">/* These values specify how many Tx frame attempts before</span>
<span class="cm"> * searching for a new modulation mode */</span>
<span class="cp">#define IL_LEGACY_FAILURE_LIMIT	160</span>
<span class="cp">#define IL_LEGACY_SUCCESS_LIMIT	480</span>
<span class="cp">#define IL_LEGACY_TBL_COUNT		160</span>

<span class="cp">#define IL_NONE_LEGACY_FAILURE_LIMIT	400</span>
<span class="cp">#define IL_NONE_LEGACY_SUCCESS_LIMIT	4500</span>
<span class="cp">#define IL_NONE_LEGACY_TBL_COUNT	1500</span>

<span class="cm">/* Success ratio (ACKed / attempted tx frames) values (perfect is 128 * 100) */</span>
<span class="cp">#define IL_RS_GOOD_RATIO		12800	</span><span class="cm">/* 100% */</span><span class="cp"></span>
<span class="cp">#define RATE_SCALE_SWITCH		10880	</span><span class="cm">/*  85% */</span><span class="cp"></span>
<span class="cp">#define RATE_HIGH_TH		10880	</span><span class="cm">/*  85% */</span><span class="cp"></span>
<span class="cp">#define RATE_INCREASE_TH		6400	</span><span class="cm">/*  50% */</span><span class="cp"></span>
<span class="cp">#define RATE_DECREASE_TH		1920	</span><span class="cm">/*  15% */</span><span class="cp"></span>

<span class="cm">/* possible actions when in legacy mode */</span>
<span class="cp">#define IL_LEGACY_SWITCH_ANTENNA1      0</span>
<span class="cp">#define IL_LEGACY_SWITCH_ANTENNA2      1</span>
<span class="cp">#define IL_LEGACY_SWITCH_SISO          2</span>
<span class="cp">#define IL_LEGACY_SWITCH_MIMO2_AB      3</span>
<span class="cp">#define IL_LEGACY_SWITCH_MIMO2_AC      4</span>
<span class="cp">#define IL_LEGACY_SWITCH_MIMO2_BC      5</span>

<span class="cm">/* possible actions when in siso mode */</span>
<span class="cp">#define IL_SISO_SWITCH_ANTENNA1        0</span>
<span class="cp">#define IL_SISO_SWITCH_ANTENNA2        1</span>
<span class="cp">#define IL_SISO_SWITCH_MIMO2_AB        2</span>
<span class="cp">#define IL_SISO_SWITCH_MIMO2_AC        3</span>
<span class="cp">#define IL_SISO_SWITCH_MIMO2_BC        4</span>
<span class="cp">#define IL_SISO_SWITCH_GI              5</span>

<span class="cm">/* possible actions when in mimo mode */</span>
<span class="cp">#define IL_MIMO2_SWITCH_ANTENNA1       0</span>
<span class="cp">#define IL_MIMO2_SWITCH_ANTENNA2       1</span>
<span class="cp">#define IL_MIMO2_SWITCH_SISO_A         2</span>
<span class="cp">#define IL_MIMO2_SWITCH_SISO_B         3</span>
<span class="cp">#define IL_MIMO2_SWITCH_SISO_C         4</span>
<span class="cp">#define IL_MIMO2_SWITCH_GI             5</span>

<span class="cp">#define IL_MAX_SEARCH IL_MIMO2_SWITCH_GI</span>

<span class="cp">#define IL_ACTION_LIMIT		3	</span><span class="cm">/* # possible actions */</span><span class="cp"></span>

<span class="cp">#define LQ_SIZE		2	</span><span class="cm">/* 2 mode tables:  &quot;Active&quot; and &quot;Search&quot; */</span><span class="cp"></span>

<span class="cm">/* load per tid defines for A-MPDU activation */</span>
<span class="cp">#define IL_AGG_TPT_THREHOLD	0</span>
<span class="cp">#define IL_AGG_LOAD_THRESHOLD	10</span>
<span class="cp">#define IL_AGG_ALL_TID		0xff</span>
<span class="cp">#define TID_QUEUE_CELL_SPACING	50	</span><span class="cm">/*mS */</span><span class="cp"></span>
<span class="cp">#define TID_QUEUE_MAX_SIZE	20</span>
<span class="cp">#define TID_ROUND_VALUE		5	</span><span class="cm">/* mS */</span><span class="cp"></span>
<span class="cp">#define TID_MAX_LOAD_COUNT	8</span>

<span class="cp">#define TID_MAX_TIME_DIFF ((TID_QUEUE_MAX_SIZE - 1) * TID_QUEUE_CELL_SPACING)</span>
<span class="cp">#define TIME_WRAP_AROUND(x, y) (((y) &gt; (x)) ? (y) - (x) : (0-(x)) + (y))</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">il_rate_info</span> <span class="n">il_rates</span><span class="p">[</span><span class="n">RATE_COUNT</span><span class="p">];</span>

<span class="k">enum</span> <span class="n">il_table_type</span> <span class="p">{</span>
	<span class="n">LQ_NONE</span><span class="p">,</span>
	<span class="n">LQ_G</span><span class="p">,</span>			<span class="cm">/* legacy types */</span>
	<span class="n">LQ_A</span><span class="p">,</span>
	<span class="n">LQ_SISO</span><span class="p">,</span>		<span class="cm">/* high-throughput types */</span>
	<span class="n">LQ_MIMO2</span><span class="p">,</span>
	<span class="n">LQ_MAX</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define is_legacy(tbl) ((tbl) == LQ_G || (tbl) == LQ_A)</span>
<span class="cp">#define is_siso(tbl) ((tbl) == LQ_SISO)</span>
<span class="cp">#define is_mimo2(tbl) ((tbl) == LQ_MIMO2)</span>
<span class="cp">#define is_mimo(tbl) (is_mimo2(tbl))</span>
<span class="cp">#define is_Ht(tbl) (is_siso(tbl) || is_mimo(tbl))</span>
<span class="cp">#define is_a_band(tbl) ((tbl) == LQ_A)</span>
<span class="cp">#define is_g_and(tbl) ((tbl) == LQ_G)</span>

<span class="cp">#define	ANT_NONE	0x0</span>
<span class="cp">#define	ANT_A		BIT(0)</span>
<span class="cp">#define	ANT_B		BIT(1)</span>
<span class="cp">#define	ANT_AB		(ANT_A | ANT_B)</span>
<span class="cp">#define ANT_C		BIT(2)</span>
<span class="cp">#define	ANT_AC		(ANT_A | ANT_C)</span>
<span class="cp">#define ANT_BC		(ANT_B | ANT_C)</span>
<span class="cp">#define ANT_ABC		(ANT_AB | ANT_C)</span>

<span class="cp">#define IL_MAX_MCS_DISPLAY_SIZE	12</span>

<span class="k">struct</span> <span class="n">il_rate_mcs_info</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">mbps</span><span class="p">[</span><span class="n">IL_MAX_MCS_DISPLAY_SIZE</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">mcs</span><span class="p">[</span><span class="n">IL_MAX_MCS_DISPLAY_SIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct il_rate_scale_data -- tx success history for one rate</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">il_rate_scale_data</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">data</span><span class="p">;</span>		<span class="cm">/* bitmap of successful frames */</span>
	<span class="n">s32</span> <span class="n">success_counter</span><span class="p">;</span>	<span class="cm">/* number of frames successful */</span>
	<span class="n">s32</span> <span class="n">success_ratio</span><span class="p">;</span>	<span class="cm">/* per-cent * 128  */</span>
	<span class="n">s32</span> <span class="n">counter</span><span class="p">;</span>		<span class="cm">/* number of frames attempted */</span>
	<span class="n">s32</span> <span class="n">average_tpt</span><span class="p">;</span>	<span class="cm">/* success ratio * expected throughput */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stamp</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct il_scale_tbl_info -- tx params and success history for all rates</span>
<span class="cm"> *</span>
<span class="cm"> * There are two of these in struct il_lq_sta,</span>
<span class="cm"> * one for &quot;active&quot;, and one for &quot;search&quot;.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">il_scale_tbl_info</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">il_table_type</span> <span class="n">lq_type</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ant_type</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">is_SGI</span><span class="p">;</span>		<span class="cm">/* 1 = short guard interval */</span>
	<span class="n">u8</span> <span class="n">is_ht40</span><span class="p">;</span>		<span class="cm">/* 1 = 40 MHz channel width */</span>
	<span class="n">u8</span> <span class="n">is_dup</span><span class="p">;</span>		<span class="cm">/* 1 = duplicated data streams */</span>
	<span class="n">u8</span> <span class="n">action</span><span class="p">;</span>		<span class="cm">/* change modulation; IL_[LEGACY/SISO/MIMO]_SWITCH_* */</span>
	<span class="n">u8</span> <span class="n">max_search</span><span class="p">;</span>		<span class="cm">/* maximun number of tables we can search */</span>
	<span class="n">s32</span> <span class="o">*</span><span class="n">expected_tpt</span><span class="p">;</span>	<span class="cm">/* throughput metrics; expected_tpt_G, etc. */</span>
	<span class="n">u32</span> <span class="n">current_rate</span><span class="p">;</span>	<span class="cm">/* rate_n_flags, uCode API format */</span>
	<span class="k">struct</span> <span class="n">il_rate_scale_data</span> <span class="n">win</span><span class="p">[</span><span class="n">RATE_COUNT</span><span class="p">];</span>	<span class="cm">/* rate histories */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">il_traffic_load</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">time_stamp</span><span class="p">;</span>	<span class="cm">/* age of the oldest stats */</span>
	<span class="n">u32</span> <span class="n">packet_count</span><span class="p">[</span><span class="n">TID_QUEUE_MAX_SIZE</span><span class="p">];</span>	<span class="cm">/* packet count in this time</span>
<span class="cm">						 * slice */</span>
	<span class="n">u32</span> <span class="n">total</span><span class="p">;</span>		<span class="cm">/* total num of packets during the</span>
<span class="cm">				 * last TID_MAX_TIME_DIFF */</span>
	<span class="n">u8</span> <span class="n">queue_count</span><span class="p">;</span>		<span class="cm">/* number of queues that has</span>
<span class="cm">				 * been used since the last cleanup */</span>
	<span class="n">u8</span> <span class="n">head</span><span class="p">;</span>		<span class="cm">/* start of the circular buffer */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct il_lq_sta -- driver&#39;s rate scaling ilate structure</span>
<span class="cm"> *</span>
<span class="cm"> * Pointer to this gets passed back and forth between driver and mac80211.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">il_lq_sta</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">active_tbl</span><span class="p">;</span>		<span class="cm">/* idx of active table, range 0-1 */</span>
	<span class="n">u8</span> <span class="n">enable_counter</span><span class="p">;</span>	<span class="cm">/* indicates HT mode */</span>
	<span class="n">u8</span> <span class="n">stay_in_tbl</span><span class="p">;</span>		<span class="cm">/* 1: disallow, 0: allow search for new mode */</span>
	<span class="n">u8</span> <span class="n">search_better_tbl</span><span class="p">;</span>	<span class="cm">/* 1: currently trying alternate mode */</span>
	<span class="n">s32</span> <span class="n">last_tpt</span><span class="p">;</span>

	<span class="cm">/* The following determine when to search for a new mode */</span>
	<span class="n">u32</span> <span class="n">table_count_limit</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">max_failure_limit</span><span class="p">;</span>	<span class="cm">/* # failed frames before new search */</span>
	<span class="n">u32</span> <span class="n">max_success_limit</span><span class="p">;</span>	<span class="cm">/* # successful frames before new search */</span>
	<span class="n">u32</span> <span class="n">table_count</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">total_failed</span><span class="p">;</span>	<span class="cm">/* total failed frames, any/all rates */</span>
	<span class="n">u32</span> <span class="n">total_success</span><span class="p">;</span>	<span class="cm">/* total successful frames, any/all rates */</span>
	<span class="n">u64</span> <span class="n">flush_timer</span><span class="p">;</span>	<span class="cm">/* time staying in mode before new search */</span>

	<span class="n">u8</span> <span class="n">action_counter</span><span class="p">;</span>	<span class="cm">/* # mode-switch actions tried */</span>
	<span class="n">u8</span> <span class="n">is_green</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">is_dup</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">;</span>

	<span class="cm">/* The following are bitmaps of rates; RATE_6M_MASK, etc. */</span>
	<span class="n">u32</span> <span class="n">supp_rates</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">active_legacy_rate</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">active_siso_rate</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">active_mimo2_rate</span><span class="p">;</span>
	<span class="n">s8</span> <span class="n">max_rate_idx</span><span class="p">;</span>	<span class="cm">/* Max rate set by user */</span>
	<span class="n">u8</span> <span class="n">missed_rate_counter</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">il_link_quality_cmd</span> <span class="n">lq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_scale_tbl_info</span> <span class="n">lq_info</span><span class="p">[</span><span class="n">LQ_SIZE</span><span class="p">];</span>	<span class="cm">/* &quot;active&quot;, &quot;search&quot; */</span>
	<span class="k">struct</span> <span class="n">il_traffic_load</span> <span class="n">load</span><span class="p">[</span><span class="n">TID_MAX_LOAD_COUNT</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">tx_agg_tid_en</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_MAC80211_DEBUGFS</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">rs_sta_dbgfs_scale_table_file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">rs_sta_dbgfs_stats_table_file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">rs_sta_dbgfs_rate_scale_data_file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">rs_sta_dbgfs_tx_agg_tid_en_file</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dbg_fixed_rate</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">drv</span><span class="p">;</span>

	<span class="cm">/* used to be in sta_info */</span>
	<span class="kt">int</span> <span class="n">last_txrate_idx</span><span class="p">;</span>
	<span class="cm">/* last tx rate_n_flags */</span>
	<span class="n">u32</span> <span class="n">last_rate_n_flags</span><span class="p">;</span>
	<span class="cm">/* packets destined for this STA are aggregated */</span>
	<span class="n">u8</span> <span class="n">is_agg</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * il_station_priv: Driver&#39;s ilate station information</span>
<span class="cm"> *</span>
<span class="cm"> * When mac80211 creates a station it reserves some space (hw-&gt;sta_data_size)</span>
<span class="cm"> * in the structure for use by driver. This structure is places in that</span>
<span class="cm"> * space.</span>
<span class="cm"> *</span>
<span class="cm"> * The common struct MUST be first because it is shared between</span>
<span class="cm"> * 3945 and 4965!</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">il_station_priv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">il_station_priv_common</span> <span class="n">common</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">il_lq_sta</span> <span class="n">lq_sta</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">pending_frames</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">client</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">asleep</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span>
<span class="nf">il4965_num_of_ant</span><span class="p">(</span><span class="n">u8</span> <span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!!</span><span class="p">(</span><span class="n">m</span> <span class="o">&amp;</span> <span class="n">ANT_A</span><span class="p">)</span> <span class="o">+</span> <span class="o">!!</span><span class="p">(</span><span class="n">m</span> <span class="o">&amp;</span> <span class="n">ANT_B</span><span class="p">)</span> <span class="o">+</span> <span class="o">!!</span><span class="p">(</span><span class="n">m</span> <span class="o">&amp;</span> <span class="n">ANT_C</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span>
<span class="nf">il4965_first_antenna</span><span class="p">(</span><span class="n">u8</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">ANT_A</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ANT_A</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">ANT_B</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ANT_B</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ANT_C</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * il3945_rate_scale_init - Initialize the rate scale table based on assoc info</span>
<span class="cm"> *</span>
<span class="cm"> * The specific throughput table used is based on the type of network</span>
<span class="cm"> * the associated with, including A, B, G, and G w/ TGG protection</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">il3945_rate_scale_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">s32</span> <span class="n">sta_id</span><span class="p">);</span>

<span class="cm">/* Initialize station&#39;s rate scaling information after adding station */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">il4965_rs_rate_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span>
				<span class="n">u8</span> <span class="n">sta_id</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">il3945_rs_rate_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span>
				<span class="n">u8</span> <span class="n">sta_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * il_rate_control_register - Register the rate control algorithm callbacks</span>
<span class="cm"> *</span>
<span class="cm"> * Since the rate control algorithm is hardware specific, there is no need</span>
<span class="cm"> * or reason to place it as a stand alone module.  The driver can call</span>
<span class="cm"> * il_rate_control_register in order to register the rate control callbacks</span>
<span class="cm"> * with the mac80211 subsystem.  This should be performed prior to calling</span>
<span class="cm"> * ieee80211_register_hw</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">il4965_rate_control_register</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">il3945_rate_control_register</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * il_rate_control_unregister - Unregister the rate control callbacks</span>
<span class="cm"> *</span>
<span class="cm"> * This should be called after calling ieee80211_unregister_hw, but before</span>
<span class="cm"> * the driver is unloaded.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">il4965_rate_control_unregister</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">il3945_rate_control_unregister</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">il_power_update_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="n">bool</span> <span class="n">force</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">il_power_initialize</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">u32</span> <span class="n">il_debug_level</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_IWLEGACY_DEBUG</span>
<span class="cm">/*</span>
<span class="cm"> * il_get_debug_level: Return active debug level for device</span>
<span class="cm"> *</span>
<span class="cm"> * Using sysfs it is possible to set per device debug level. This debug</span>
<span class="cm"> * level will be used if set, otherwise the global debug level which can be</span>
<span class="cm"> * set via module parameter is used.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span>
<span class="nf">il_get_debug_level</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">il</span><span class="o">-&gt;</span><span class="n">debug_level</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">il</span><span class="o">-&gt;</span><span class="n">debug_level</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">il_debug_level</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span>
<span class="nf">il_get_debug_level</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">il_debug_level</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#define il_print_hex_error(il, p, len)					\</span>
<span class="cp">do {									\</span>
<span class="cp">	print_hex_dump(KERN_ERR, &quot;iwl data: &quot;,				\</span>
<span class="cp">		       DUMP_PREFIX_OFFSET, 16, 1, p, len, 1);		\</span>
<span class="cp">} while (0)</span>

<span class="cp">#ifdef CONFIG_IWLEGACY_DEBUG</span>
<span class="cp">#define IL_DBG(level, fmt, args...)					\</span>
<span class="cp">do {									\</span>
<span class="cp">	if (il_get_debug_level(il) &amp; level)				\</span>
<span class="cp">		dev_printk(KERN_ERR, &amp;il-&gt;hw-&gt;wiphy-&gt;dev,		\</span>
<span class="cp">			 &quot;%c %s &quot; fmt, in_interrupt() ? &#39;I&#39; : &#39;U&#39;,	\</span>
<span class="cp">			__func__ , ## args);				\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define il_print_hex_dump(il, level, p, len)				\</span>
<span class="cp">do {									\</span>
<span class="cp">	if (il_get_debug_level(il) &amp; level)				\</span>
<span class="cp">		print_hex_dump(KERN_DEBUG, &quot;iwl data: &quot;,		\</span>
<span class="cp">			       DUMP_PREFIX_OFFSET, 16, 1, p, len, 1);	\</span>
<span class="cp">} while (0)</span>

<span class="cp">#else</span>
<span class="cp">#define IL_DBG(level, fmt, args...)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">il_print_hex_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IWLEGACY_DEBUG */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_IWLEGACY_DEBUGFS</span>
<span class="kt">int</span> <span class="n">il_dbgfs_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">il_dbgfs_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">il_dbgfs_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">il_dbgfs_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">il_priv</span> <span class="o">*</span><span class="n">il</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IWLEGACY_DEBUGFS */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * To use the debug system:</span>
<span class="cm"> *</span>
<span class="cm"> * If you are defining a new debug classification, simply add it to the #define</span>
<span class="cm"> * list here in the form of</span>
<span class="cm"> *</span>
<span class="cm"> * #define IL_DL_xxxx VALUE</span>
<span class="cm"> *</span>
<span class="cm"> * where xxxx should be the name of the classification (for example, WEP).</span>
<span class="cm"> *</span>
<span class="cm"> * You then need to either add a IL_xxxx_DEBUG() macro definition for your</span>
<span class="cm"> * classification, or use IL_DBG(IL_DL_xxxx, ...) whenever you want</span>
<span class="cm"> * to send output to that classification.</span>
<span class="cm"> *</span>
<span class="cm"> * The active debug levels can be accessed via files</span>
<span class="cm"> *</span>
<span class="cm"> *	/sys/module/iwl4965/parameters/debug</span>
<span class="cm"> *	/sys/module/iwl3945/parameters/debug</span>
<span class="cm"> *	/sys/class/net/wlan0/device/debug_level</span>
<span class="cm"> *</span>
<span class="cm"> * when CONFIG_IWLEGACY_DEBUG=y.</span>
<span class="cm"> */</span>

<span class="cm">/* 0x0000000F - 0x00000001 */</span>
<span class="cp">#define IL_DL_INFO		(1 &lt;&lt; 0)</span>
<span class="cp">#define IL_DL_MAC80211		(1 &lt;&lt; 1)</span>
<span class="cp">#define IL_DL_HCMD		(1 &lt;&lt; 2)</span>
<span class="cp">#define IL_DL_STATE		(1 &lt;&lt; 3)</span>
<span class="cm">/* 0x000000F0 - 0x00000010 */</span>
<span class="cp">#define IL_DL_MACDUMP		(1 &lt;&lt; 4)</span>
<span class="cp">#define IL_DL_HCMD_DUMP		(1 &lt;&lt; 5)</span>
<span class="cp">#define IL_DL_EEPROM		(1 &lt;&lt; 6)</span>
<span class="cp">#define IL_DL_RADIO		(1 &lt;&lt; 7)</span>
<span class="cm">/* 0x00000F00 - 0x00000100 */</span>
<span class="cp">#define IL_DL_POWER		(1 &lt;&lt; 8)</span>
<span class="cp">#define IL_DL_TEMP		(1 &lt;&lt; 9)</span>
<span class="cp">#define IL_DL_NOTIF		(1 &lt;&lt; 10)</span>
<span class="cp">#define IL_DL_SCAN		(1 &lt;&lt; 11)</span>
<span class="cm">/* 0x0000F000 - 0x00001000 */</span>
<span class="cp">#define IL_DL_ASSOC		(1 &lt;&lt; 12)</span>
<span class="cp">#define IL_DL_DROP		(1 &lt;&lt; 13)</span>
<span class="cp">#define IL_DL_TXPOWER		(1 &lt;&lt; 14)</span>
<span class="cp">#define IL_DL_AP		(1 &lt;&lt; 15)</span>
<span class="cm">/* 0x000F0000 - 0x00010000 */</span>
<span class="cp">#define IL_DL_FW		(1 &lt;&lt; 16)</span>
<span class="cp">#define IL_DL_RF_KILL		(1 &lt;&lt; 17)</span>
<span class="cp">#define IL_DL_FW_ERRORS		(1 &lt;&lt; 18)</span>
<span class="cp">#define IL_DL_LED		(1 &lt;&lt; 19)</span>
<span class="cm">/* 0x00F00000 - 0x00100000 */</span>
<span class="cp">#define IL_DL_RATE		(1 &lt;&lt; 20)</span>
<span class="cp">#define IL_DL_CALIB		(1 &lt;&lt; 21)</span>
<span class="cp">#define IL_DL_WEP		(1 &lt;&lt; 22)</span>
<span class="cp">#define IL_DL_TX		(1 &lt;&lt; 23)</span>
<span class="cm">/* 0x0F000000 - 0x01000000 */</span>
<span class="cp">#define IL_DL_RX		(1 &lt;&lt; 24)</span>
<span class="cp">#define IL_DL_ISR		(1 &lt;&lt; 25)</span>
<span class="cp">#define IL_DL_HT		(1 &lt;&lt; 26)</span>
<span class="cm">/* 0xF0000000 - 0x10000000 */</span>
<span class="cp">#define IL_DL_11H		(1 &lt;&lt; 28)</span>
<span class="cp">#define IL_DL_STATS		(1 &lt;&lt; 29)</span>
<span class="cp">#define IL_DL_TX_REPLY		(1 &lt;&lt; 30)</span>
<span class="cp">#define IL_DL_QOS		(1 &lt;&lt; 31)</span>

<span class="cp">#define D_INFO(f, a...)		IL_DBG(IL_DL_INFO, f, ## a)</span>
<span class="cp">#define D_MAC80211(f, a...)	IL_DBG(IL_DL_MAC80211, f, ## a)</span>
<span class="cp">#define D_MACDUMP(f, a...)	IL_DBG(IL_DL_MACDUMP, f, ## a)</span>
<span class="cp">#define D_TEMP(f, a...)		IL_DBG(IL_DL_TEMP, f, ## a)</span>
<span class="cp">#define D_SCAN(f, a...)		IL_DBG(IL_DL_SCAN, f, ## a)</span>
<span class="cp">#define D_RX(f, a...)		IL_DBG(IL_DL_RX, f, ## a)</span>
<span class="cp">#define D_TX(f, a...)		IL_DBG(IL_DL_TX, f, ## a)</span>
<span class="cp">#define D_ISR(f, a...)		IL_DBG(IL_DL_ISR, f, ## a)</span>
<span class="cp">#define D_LED(f, a...)		IL_DBG(IL_DL_LED, f, ## a)</span>
<span class="cp">#define D_WEP(f, a...)		IL_DBG(IL_DL_WEP, f, ## a)</span>
<span class="cp">#define D_HC(f, a...)		IL_DBG(IL_DL_HCMD, f, ## a)</span>
<span class="cp">#define D_HC_DUMP(f, a...)	IL_DBG(IL_DL_HCMD_DUMP, f, ## a)</span>
<span class="cp">#define D_EEPROM(f, a...)	IL_DBG(IL_DL_EEPROM, f, ## a)</span>
<span class="cp">#define D_CALIB(f, a...)	IL_DBG(IL_DL_CALIB, f, ## a)</span>
<span class="cp">#define D_FW(f, a...)		IL_DBG(IL_DL_FW, f, ## a)</span>
<span class="cp">#define D_RF_KILL(f, a...)	IL_DBG(IL_DL_RF_KILL, f, ## a)</span>
<span class="cp">#define D_DROP(f, a...)		IL_DBG(IL_DL_DROP, f, ## a)</span>
<span class="cp">#define D_AP(f, a...)		IL_DBG(IL_DL_AP, f, ## a)</span>
<span class="cp">#define D_TXPOWER(f, a...)	IL_DBG(IL_DL_TXPOWER, f, ## a)</span>
<span class="cp">#define D_RATE(f, a...)		IL_DBG(IL_DL_RATE, f, ## a)</span>
<span class="cp">#define D_NOTIF(f, a...)	IL_DBG(IL_DL_NOTIF, f, ## a)</span>
<span class="cp">#define D_ASSOC(f, a...)	IL_DBG(IL_DL_ASSOC, f, ## a)</span>
<span class="cp">#define D_HT(f, a...)		IL_DBG(IL_DL_HT, f, ## a)</span>
<span class="cp">#define D_STATS(f, a...)	IL_DBG(IL_DL_STATS, f, ## a)</span>
<span class="cp">#define D_TX_REPLY(f, a...)	IL_DBG(IL_DL_TX_REPLY, f, ## a)</span>
<span class="cp">#define D_QOS(f, a...)		IL_DBG(IL_DL_QOS, f, ## a)</span>
<span class="cp">#define D_RADIO(f, a...)	IL_DBG(IL_DL_RADIO, f, ## a)</span>
<span class="cp">#define D_POWER(f, a...)	IL_DBG(IL_DL_POWER, f, ## a)</span>
<span class="cp">#define D_11H(f, a...)		IL_DBG(IL_DL_11H, f, ## a)</span>

<span class="cp">#endif </span><span class="cm">/* __il_core_h__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
