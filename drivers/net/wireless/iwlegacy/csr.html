<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › iwlegacy › csr.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>csr.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * This file is provided under a dual BSD/GPLv2 license.  When using or</span>
<span class="cm"> * redistributing this file, you may do so under either license.</span>
<span class="cm"> *</span>
<span class="cm"> * GPL LICENSE SUMMARY</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2005 - 2011 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of version 2 of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,</span>
<span class="cm"> * USA</span>
<span class="cm"> *</span>
<span class="cm"> * The full GNU General Public License is included in this distribution</span>
<span class="cm"> * in the file called LICENSE.GPL.</span>
<span class="cm"> *</span>
<span class="cm"> * Contact Information:</span>
<span class="cm"> *  Intel Linux Wireless &lt;ilw@linux.intel.com&gt;</span>
<span class="cm"> * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>
<span class="cm"> *</span>
<span class="cm"> * BSD LICENSE</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2005 - 2011 Intel Corporation. All rights reserved.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> *</span>
<span class="cm"> *  * Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *  * Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer in</span>
<span class="cm"> *    the documentation and/or other materials provided with the</span>
<span class="cm"> *    distribution.</span>
<span class="cm"> *  * Neither the name Intel Corporation nor the names of its</span>
<span class="cm"> *    contributors may be used to endorse or promote products derived</span>
<span class="cm"> *    from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="cm"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="cm"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="cm"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="cm"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>
<span class="cp">#ifndef __il_csr_h__</span>
<span class="cp">#define __il_csr_h__</span>
<span class="cm">/*</span>
<span class="cm"> * CSR (control and status registers)</span>
<span class="cm"> *</span>
<span class="cm"> * CSR registers are mapped directly into PCI bus space, and are accessible</span>
<span class="cm"> * whenever platform supplies power to device, even when device is in</span>
<span class="cm"> * low power states due to driver-invoked device resets</span>
<span class="cm"> * (e.g. CSR_RESET_REG_FLAG_SW_RESET) or uCode-driven power-saving modes.</span>
<span class="cm"> *</span>
<span class="cm"> * Use _il_wr() and _il_rd() family to access these registers;</span>
<span class="cm"> * these provide simple PCI bus access, without waking up the MAC.</span>
<span class="cm"> * Do not use il_wr() family for these registers;</span>
<span class="cm"> * no need to &quot;grab nic access&quot; via CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ.</span>
<span class="cm"> * The MAC (uCode processor, etc.) does not need to be powered up for accessing</span>
<span class="cm"> * the CSR registers.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  Device does need to be awake in order to read this memory</span>
<span class="cm"> *        via CSR_EEPROM register</span>
<span class="cm"> */</span>
<span class="cp">#define CSR_BASE    (0x000)</span>

<span class="cp">#define CSR_HW_IF_CONFIG_REG    (CSR_BASE+0x000)	</span><span class="cm">/* hardware interface config */</span><span class="cp"></span>
<span class="cp">#define CSR_INT_COALESCING      (CSR_BASE+0x004)	</span><span class="cm">/* accum ints, 32-usec units */</span><span class="cp"></span>
<span class="cp">#define CSR_INT                 (CSR_BASE+0x008)	</span><span class="cm">/* host interrupt status/ack */</span><span class="cp"></span>
<span class="cp">#define CSR_INT_MASK            (CSR_BASE+0x00c)	</span><span class="cm">/* host interrupt enable */</span><span class="cp"></span>
<span class="cp">#define CSR_FH_INT_STATUS       (CSR_BASE+0x010)	</span><span class="cm">/* busmaster int status/ack */</span><span class="cp"></span>
<span class="cp">#define CSR_GPIO_IN             (CSR_BASE+0x018)	</span><span class="cm">/* read external chip pins */</span><span class="cp"></span>
<span class="cp">#define CSR_RESET               (CSR_BASE+0x020)	</span><span class="cm">/* busmaster enable, NMI, etc */</span><span class="cp"></span>
<span class="cp">#define CSR_GP_CNTRL            (CSR_BASE+0x024)</span>

<span class="cm">/* 2nd byte of CSR_INT_COALESCING, not accessible via _il_wr()! */</span>
<span class="cp">#define CSR_INT_PERIODIC_REG	(CSR_BASE+0x005)</span>

<span class="cm">/*</span>
<span class="cm"> * Hardware revision info</span>
<span class="cm"> * Bit fields:</span>
<span class="cm"> * 31-8:  Reserved</span>
<span class="cm"> *  7-4:  Type of device:  see CSR_HW_REV_TYPE_xxx definitions</span>
<span class="cm"> *  3-2:  Revision step:  0 = A, 1 = B, 2 = C, 3 = D</span>
<span class="cm"> *  1-0:  &quot;Dash&quot; (-) value, as in A-1, etc.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  Revision step affects calculation of CCK txpower for 4965.</span>
<span class="cm"> * NOTE:  See also CSR_HW_REV_WA_REG (work-around for bug in 4965).</span>
<span class="cm"> */</span>
<span class="cp">#define CSR_HW_REV              (CSR_BASE+0x028)</span>

<span class="cm">/*</span>
<span class="cm"> * EEPROM memory reads</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  Device must be awake, initialized via apm_ops.init(),</span>
<span class="cm"> *        in order to read.</span>
<span class="cm"> */</span>
<span class="cp">#define CSR_EEPROM_REG          (CSR_BASE+0x02c)</span>
<span class="cp">#define CSR_EEPROM_GP           (CSR_BASE+0x030)</span>

<span class="cp">#define CSR_GIO_REG		(CSR_BASE+0x03C)</span>
<span class="cp">#define CSR_GP_UCODE_REG	(CSR_BASE+0x048)</span>
<span class="cp">#define CSR_GP_DRIVER_REG	(CSR_BASE+0x050)</span>

<span class="cm">/*</span>
<span class="cm"> * UCODE-DRIVER GP (general purpose) mailbox registers.</span>
<span class="cm"> * SET/CLR registers set/clear bit(s) if &quot;1&quot; is written.</span>
<span class="cm"> */</span>
<span class="cp">#define CSR_UCODE_DRV_GP1       (CSR_BASE+0x054)</span>
<span class="cp">#define CSR_UCODE_DRV_GP1_SET   (CSR_BASE+0x058)</span>
<span class="cp">#define CSR_UCODE_DRV_GP1_CLR   (CSR_BASE+0x05c)</span>
<span class="cp">#define CSR_UCODE_DRV_GP2       (CSR_BASE+0x060)</span>

<span class="cp">#define CSR_LED_REG             (CSR_BASE+0x094)</span>
<span class="cp">#define CSR_DRAM_INT_TBL_REG	(CSR_BASE+0x0A0)</span>

<span class="cm">/* GIO Chicken Bits (PCI Express bus link power management) */</span>
<span class="cp">#define CSR_GIO_CHICKEN_BITS    (CSR_BASE+0x100)</span>

<span class="cm">/* Analog phase-lock-loop configuration  */</span>
<span class="cp">#define CSR_ANA_PLL_CFG         (CSR_BASE+0x20c)</span>

<span class="cm">/*</span>
<span class="cm"> * CSR Hardware Revision Workaround Register.  Indicates hardware rev;</span>
<span class="cm"> * &quot;step&quot; determines CCK backoff for txpower calculation.  Used for 4965 only.</span>
<span class="cm"> * See also CSR_HW_REV register.</span>
<span class="cm"> * Bit fields:</span>
<span class="cm"> *  3-2:  0 = A, 1 = B, 2 = C, 3 = D step</span>
<span class="cm"> *  1-0:  &quot;Dash&quot; (-) value, as in C-1, etc.</span>
<span class="cm"> */</span>
<span class="cp">#define CSR_HW_REV_WA_REG		(CSR_BASE+0x22C)</span>

<span class="cp">#define CSR_DBG_HPET_MEM_REG		(CSR_BASE+0x240)</span>
<span class="cp">#define CSR_DBG_LINK_PWR_MGMT_REG	(CSR_BASE+0x250)</span>

<span class="cm">/* Bits for CSR_HW_IF_CONFIG_REG */</span>
<span class="cp">#define CSR49_HW_IF_CONFIG_REG_BIT_4965_R	(0x00000010)</span>
<span class="cp">#define CSR_HW_IF_CONFIG_REG_MSK_BOARD_VER	(0x00000C00)</span>
<span class="cp">#define CSR_HW_IF_CONFIG_REG_BIT_MAC_SI 	(0x00000100)</span>
<span class="cp">#define CSR_HW_IF_CONFIG_REG_BIT_RADIO_SI	(0x00000200)</span>

<span class="cp">#define CSR39_HW_IF_CONFIG_REG_BIT_3945_MB         (0x00000100)</span>
<span class="cp">#define CSR39_HW_IF_CONFIG_REG_BIT_3945_MM         (0x00000200)</span>
<span class="cp">#define CSR39_HW_IF_CONFIG_REG_BIT_SKU_MRC            (0x00000400)</span>
<span class="cp">#define CSR39_HW_IF_CONFIG_REG_BIT_BOARD_TYPE         (0x00000800)</span>
<span class="cp">#define CSR39_HW_IF_CONFIG_REG_BITS_SILICON_TYPE_A    (0x00000000)</span>
<span class="cp">#define CSR39_HW_IF_CONFIG_REG_BITS_SILICON_TYPE_B    (0x00001000)</span>

<span class="cp">#define CSR_HW_IF_CONFIG_REG_BIT_HAP_WAKE_L1A	(0x00080000)</span>
<span class="cp">#define CSR_HW_IF_CONFIG_REG_BIT_EEPROM_OWN_SEM	(0x00200000)</span>
<span class="cp">#define CSR_HW_IF_CONFIG_REG_BIT_NIC_READY	(0x00400000)	</span><span class="cm">/* PCI_OWN_SEM */</span><span class="cp"></span>
<span class="cp">#define CSR_HW_IF_CONFIG_REG_BIT_NIC_PREPARE_DONE (0x02000000)	</span><span class="cm">/* ME_OWN */</span><span class="cp"></span>
<span class="cp">#define CSR_HW_IF_CONFIG_REG_PREPARE		  (0x08000000)	</span><span class="cm">/* WAKE_ME */</span><span class="cp"></span>

<span class="cp">#define CSR_INT_PERIODIC_DIS			(0x00)	</span><span class="cm">/* disable periodic int */</span><span class="cp"></span>
<span class="cp">#define CSR_INT_PERIODIC_ENA			(0xFF)	</span><span class="cm">/* 255*32 usec ~ 8 msec */</span><span class="cp"></span>

<span class="cm">/* interrupt flags in INTA, set by uCode or hardware (e.g. dma),</span>
<span class="cm"> * acknowledged (reset) by host writing &quot;1&quot; to flagged bits. */</span>
<span class="cp">#define CSR_INT_BIT_FH_RX        (1 &lt;&lt; 31)	</span><span class="cm">/* Rx DMA, cmd responses, FH_INT[17:16] */</span><span class="cp"></span>
<span class="cp">#define CSR_INT_BIT_HW_ERR       (1 &lt;&lt; 29)	</span><span class="cm">/* DMA hardware error FH_INT[31] */</span><span class="cp"></span>
<span class="cp">#define CSR_INT_BIT_RX_PERIODIC	 (1 &lt;&lt; 28)	</span><span class="cm">/* Rx periodic */</span><span class="cp"></span>
<span class="cp">#define CSR_INT_BIT_FH_TX        (1 &lt;&lt; 27)	</span><span class="cm">/* Tx DMA FH_INT[1:0] */</span><span class="cp"></span>
<span class="cp">#define CSR_INT_BIT_SCD          (1 &lt;&lt; 26)	</span><span class="cm">/* TXQ pointer advanced */</span><span class="cp"></span>
<span class="cp">#define CSR_INT_BIT_SW_ERR       (1 &lt;&lt; 25)	</span><span class="cm">/* uCode error */</span><span class="cp"></span>
<span class="cp">#define CSR_INT_BIT_RF_KILL      (1 &lt;&lt; 7)	</span><span class="cm">/* HW RFKILL switch GP_CNTRL[27] toggled */</span><span class="cp"></span>
<span class="cp">#define CSR_INT_BIT_CT_KILL      (1 &lt;&lt; 6)	</span><span class="cm">/* Critical temp (chip too hot) rfkill */</span><span class="cp"></span>
<span class="cp">#define CSR_INT_BIT_SW_RX        (1 &lt;&lt; 3)	</span><span class="cm">/* Rx, command responses, 3945 */</span><span class="cp"></span>
<span class="cp">#define CSR_INT_BIT_WAKEUP       (1 &lt;&lt; 1)	</span><span class="cm">/* NIC controller waking up (pwr mgmt) */</span><span class="cp"></span>
<span class="cp">#define CSR_INT_BIT_ALIVE        (1 &lt;&lt; 0)	</span><span class="cm">/* uCode interrupts once it initializes */</span><span class="cp"></span>

<span class="cp">#define CSR_INI_SET_MASK	(CSR_INT_BIT_FH_RX   | \</span>
<span class="cp">				 CSR_INT_BIT_HW_ERR  | \</span>
<span class="cp">				 CSR_INT_BIT_FH_TX   | \</span>
<span class="cp">				 CSR_INT_BIT_SW_ERR  | \</span>
<span class="cp">				 CSR_INT_BIT_RF_KILL | \</span>
<span class="cp">				 CSR_INT_BIT_SW_RX   | \</span>
<span class="cp">				 CSR_INT_BIT_WAKEUP  | \</span>
<span class="cp">				 CSR_INT_BIT_ALIVE)</span>

<span class="cm">/* interrupt flags in FH (flow handler) (PCI busmaster DMA) */</span>
<span class="cp">#define CSR_FH_INT_BIT_ERR       (1 &lt;&lt; 31)	</span><span class="cm">/* Error */</span><span class="cp"></span>
<span class="cp">#define CSR_FH_INT_BIT_HI_PRIOR  (1 &lt;&lt; 30)	</span><span class="cm">/* High priority Rx, bypass coalescing */</span><span class="cp"></span>
<span class="cp">#define CSR39_FH_INT_BIT_RX_CHNL2  (1 &lt;&lt; 18)	</span><span class="cm">/* Rx channel 2 (3945 only) */</span><span class="cp"></span>
<span class="cp">#define CSR_FH_INT_BIT_RX_CHNL1  (1 &lt;&lt; 17)	</span><span class="cm">/* Rx channel 1 */</span><span class="cp"></span>
<span class="cp">#define CSR_FH_INT_BIT_RX_CHNL0  (1 &lt;&lt; 16)	</span><span class="cm">/* Rx channel 0 */</span><span class="cp"></span>
<span class="cp">#define CSR39_FH_INT_BIT_TX_CHNL6  (1 &lt;&lt; 6)	</span><span class="cm">/* Tx channel 6 (3945 only) */</span><span class="cp"></span>
<span class="cp">#define CSR_FH_INT_BIT_TX_CHNL1  (1 &lt;&lt; 1)	</span><span class="cm">/* Tx channel 1 */</span><span class="cp"></span>
<span class="cp">#define CSR_FH_INT_BIT_TX_CHNL0  (1 &lt;&lt; 0)	</span><span class="cm">/* Tx channel 0 */</span><span class="cp"></span>

<span class="cp">#define CSR39_FH_INT_RX_MASK	(CSR_FH_INT_BIT_HI_PRIOR | \</span>
<span class="cp">				 CSR39_FH_INT_BIT_RX_CHNL2 | \</span>
<span class="cp">				 CSR_FH_INT_BIT_RX_CHNL1 | \</span>
<span class="cp">				 CSR_FH_INT_BIT_RX_CHNL0)</span>

<span class="cp">#define CSR39_FH_INT_TX_MASK	(CSR39_FH_INT_BIT_TX_CHNL6 | \</span>
<span class="cp">				 CSR_FH_INT_BIT_TX_CHNL1 | \</span>
<span class="cp">				 CSR_FH_INT_BIT_TX_CHNL0)</span>

<span class="cp">#define CSR49_FH_INT_RX_MASK	(CSR_FH_INT_BIT_HI_PRIOR | \</span>
<span class="cp">				 CSR_FH_INT_BIT_RX_CHNL1 | \</span>
<span class="cp">				 CSR_FH_INT_BIT_RX_CHNL0)</span>

<span class="cp">#define CSR49_FH_INT_TX_MASK	(CSR_FH_INT_BIT_TX_CHNL1 | \</span>
<span class="cp">				 CSR_FH_INT_BIT_TX_CHNL0)</span>

<span class="cm">/* GPIO */</span>
<span class="cp">#define CSR_GPIO_IN_BIT_AUX_POWER                   (0x00000200)</span>
<span class="cp">#define CSR_GPIO_IN_VAL_VAUX_PWR_SRC                (0x00000000)</span>
<span class="cp">#define CSR_GPIO_IN_VAL_VMAIN_PWR_SRC               (0x00000200)</span>

<span class="cm">/* RESET */</span>
<span class="cp">#define CSR_RESET_REG_FLAG_NEVO_RESET                (0x00000001)</span>
<span class="cp">#define CSR_RESET_REG_FLAG_FORCE_NMI                 (0x00000002)</span>
<span class="cp">#define CSR_RESET_REG_FLAG_SW_RESET                  (0x00000080)</span>
<span class="cp">#define CSR_RESET_REG_FLAG_MASTER_DISABLED           (0x00000100)</span>
<span class="cp">#define CSR_RESET_REG_FLAG_STOP_MASTER               (0x00000200)</span>
<span class="cp">#define CSR_RESET_LINK_PWR_MGMT_DISABLED             (0x80000000)</span>

<span class="cm">/*</span>
<span class="cm"> * GP (general purpose) CONTROL REGISTER</span>
<span class="cm"> * Bit fields:</span>
<span class="cm"> *    27:  HW_RF_KILL_SW</span>
<span class="cm"> *         Indicates state of (platform&#39;s) hardware RF-Kill switch</span>
<span class="cm"> * 26-24:  POWER_SAVE_TYPE</span>
<span class="cm"> *         Indicates current power-saving mode:</span>
<span class="cm"> *         000 -- No power saving</span>
<span class="cm"> *         001 -- MAC power-down</span>
<span class="cm"> *         010 -- PHY (radio) power-down</span>
<span class="cm"> *         011 -- Error</span>
<span class="cm"> *   9-6:  SYS_CONFIG</span>
<span class="cm"> *         Indicates current system configuration, reflecting pins on chip</span>
<span class="cm"> *         as forced high/low by device circuit board.</span>
<span class="cm"> *     4:  GOING_TO_SLEEP</span>
<span class="cm"> *         Indicates MAC is entering a power-saving sleep power-down.</span>
<span class="cm"> *         Not a good time to access device-internal resources.</span>
<span class="cm"> *     3:  MAC_ACCESS_REQ</span>
<span class="cm"> *         Host sets this to request and maintain MAC wakeup, to allow host</span>
<span class="cm"> *         access to device-internal resources.  Host must wait for</span>
<span class="cm"> *         MAC_CLOCK_READY (and !GOING_TO_SLEEP) before accessing non-CSR</span>
<span class="cm"> *         device registers.</span>
<span class="cm"> *     2:  INIT_DONE</span>
<span class="cm"> *         Host sets this to put device into fully operational D0 power mode.</span>
<span class="cm"> *         Host resets this after SW_RESET to put device into low power mode.</span>
<span class="cm"> *     0:  MAC_CLOCK_READY</span>
<span class="cm"> *         Indicates MAC (ucode processor, etc.) is powered up and can run.</span>
<span class="cm"> *         Internal resources are accessible.</span>
<span class="cm"> *         NOTE:  This does not indicate that the processor is actually running.</span>
<span class="cm"> *         NOTE:  This does not indicate that 4965 or 3945 has completed</span>
<span class="cm"> *                init or post-power-down restore of internal SRAM memory.</span>
<span class="cm"> *                Use CSR_UCODE_DRV_GP1_BIT_MAC_SLEEP as indication that</span>
<span class="cm"> *                SRAM is restored and uCode is in normal operation mode.</span>
<span class="cm"> *                Later devices (5xxx/6xxx/1xxx) use non-volatile SRAM, and</span>
<span class="cm"> *                do not need to save/restore it.</span>
<span class="cm"> *         NOTE:  After device reset, this bit remains &quot;0&quot; until host sets</span>
<span class="cm"> *                INIT_DONE</span>
<span class="cm"> */</span>
<span class="cp">#define CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY        (0x00000001)</span>
<span class="cp">#define CSR_GP_CNTRL_REG_FLAG_INIT_DONE              (0x00000004)</span>
<span class="cp">#define CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ         (0x00000008)</span>
<span class="cp">#define CSR_GP_CNTRL_REG_FLAG_GOING_TO_SLEEP         (0x00000010)</span>

<span class="cp">#define CSR_GP_CNTRL_REG_VAL_MAC_ACCESS_EN           (0x00000001)</span>

<span class="cp">#define CSR_GP_CNTRL_REG_MSK_POWER_SAVE_TYPE         (0x07000000)</span>
<span class="cp">#define CSR_GP_CNTRL_REG_FLAG_MAC_POWER_SAVE         (0x04000000)</span>
<span class="cp">#define CSR_GP_CNTRL_REG_FLAG_HW_RF_KILL_SW          (0x08000000)</span>

<span class="cm">/* EEPROM REG */</span>
<span class="cp">#define CSR_EEPROM_REG_READ_VALID_MSK	(0x00000001)</span>
<span class="cp">#define CSR_EEPROM_REG_BIT_CMD		(0x00000002)</span>
<span class="cp">#define CSR_EEPROM_REG_MSK_ADDR		(0x0000FFFC)</span>
<span class="cp">#define CSR_EEPROM_REG_MSK_DATA		(0xFFFF0000)</span>

<span class="cm">/* EEPROM GP */</span>
<span class="cp">#define CSR_EEPROM_GP_VALID_MSK		(0x00000007)	</span><span class="cm">/* signature */</span><span class="cp"></span>
<span class="cp">#define CSR_EEPROM_GP_IF_OWNER_MSK	(0x00000180)</span>
<span class="cp">#define CSR_EEPROM_GP_GOOD_SIG_EEP_LESS_THAN_4K		(0x00000002)</span>
<span class="cp">#define CSR_EEPROM_GP_GOOD_SIG_EEP_MORE_THAN_4K		(0x00000004)</span>

<span class="cm">/* GP REG */</span>
<span class="cp">#define CSR_GP_REG_POWER_SAVE_STATUS_MSK            (0x03000000)	</span><span class="cm">/* bit 24/25 */</span><span class="cp"></span>
<span class="cp">#define CSR_GP_REG_NO_POWER_SAVE            (0x00000000)</span>
<span class="cp">#define CSR_GP_REG_MAC_POWER_SAVE           (0x01000000)</span>
<span class="cp">#define CSR_GP_REG_PHY_POWER_SAVE           (0x02000000)</span>
<span class="cp">#define CSR_GP_REG_POWER_SAVE_ERROR         (0x03000000)</span>

<span class="cm">/* CSR GIO */</span>
<span class="cp">#define CSR_GIO_REG_VAL_L0S_ENABLED	(0x00000002)</span>

<span class="cm">/*</span>
<span class="cm"> * UCODE-DRIVER GP (general purpose) mailbox register 1</span>
<span class="cm"> * Host driver and uCode write and/or read this register to communicate with</span>
<span class="cm"> * each other.</span>
<span class="cm"> * Bit fields:</span>
<span class="cm"> *     4:  UCODE_DISABLE</span>
<span class="cm"> *         Host sets this to request permanent halt of uCode, same as</span>
<span class="cm"> *         sending CARD_STATE command with &quot;halt&quot; bit set.</span>
<span class="cm"> *     3:  CT_KILL_EXIT</span>
<span class="cm"> *         Host sets this to request exit from CT_KILL state, i.e. host thinks</span>
<span class="cm"> *         device temperature is low enough to continue normal operation.</span>
<span class="cm"> *     2:  CMD_BLOCKED</span>
<span class="cm"> *         Host sets this during RF KILL power-down sequence (HW, SW, CT KILL)</span>
<span class="cm"> *         to release uCode to clear all Tx and command queues, enter</span>
<span class="cm"> *         unassociated mode, and power down.</span>
<span class="cm"> *         NOTE:  Some devices also use HBUS_TARG_MBX_C register for this bit.</span>
<span class="cm"> *     1:  SW_BIT_RFKILL</span>
<span class="cm"> *         Host sets this when issuing CARD_STATE command to request</span>
<span class="cm"> *         device sleep.</span>
<span class="cm"> *     0:  MAC_SLEEP</span>
<span class="cm"> *         uCode sets this when preparing a power-saving power-down.</span>
<span class="cm"> *         uCode resets this when power-up is complete and SRAM is sane.</span>
<span class="cm"> *         NOTE:  3945/4965 saves internal SRAM data to host when powering down,</span>
<span class="cm"> *                and must restore this data after powering back up.</span>
<span class="cm"> *                MAC_SLEEP is the best indication that restore is complete.</span>
<span class="cm"> *                Later devices (5xxx/6xxx/1xxx) use non-volatile SRAM, and</span>
<span class="cm"> *                do not need to save/restore it.</span>
<span class="cm"> */</span>
<span class="cp">#define CSR_UCODE_DRV_GP1_BIT_MAC_SLEEP             (0x00000001)</span>
<span class="cp">#define CSR_UCODE_SW_BIT_RFKILL                     (0x00000002)</span>
<span class="cp">#define CSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED           (0x00000004)</span>
<span class="cp">#define CSR_UCODE_DRV_GP1_REG_BIT_CT_KILL_EXIT      (0x00000008)</span>

<span class="cm">/* GIO Chicken Bits (PCI Express bus link power management) */</span>
<span class="cp">#define CSR_GIO_CHICKEN_BITS_REG_BIT_L1A_NO_L0S_RX  (0x00800000)</span>
<span class="cp">#define CSR_GIO_CHICKEN_BITS_REG_BIT_DIS_L0S_EXIT_TIMER  (0x20000000)</span>

<span class="cm">/* LED */</span>
<span class="cp">#define CSR_LED_BSM_CTRL_MSK (0xFFFFFFDF)</span>
<span class="cp">#define CSR_LED_REG_TRUN_ON (0x78)</span>
<span class="cp">#define CSR_LED_REG_TRUN_OFF (0x38)</span>

<span class="cm">/* ANA_PLL */</span>
<span class="cp">#define CSR39_ANA_PLL_CFG_VAL        (0x01000000)</span>

<span class="cm">/* HPET MEM debug */</span>
<span class="cp">#define CSR_DBG_HPET_MEM_REG_VAL	(0xFFFF0000)</span>

<span class="cm">/* DRAM INT TBL */</span>
<span class="cp">#define CSR_DRAM_INT_TBL_ENABLE		(1 &lt;&lt; 31)</span>
<span class="cp">#define CSR_DRAM_INIT_TBL_WRAP_CHECK	(1 &lt;&lt; 27)</span>

<span class="cm">/*</span>
<span class="cm"> * HBUS (Host-side Bus)</span>
<span class="cm"> *</span>
<span class="cm"> * HBUS registers are mapped directly into PCI bus space, but are used</span>
<span class="cm"> * to indirectly access device&#39;s internal memory or registers that</span>
<span class="cm"> * may be powered-down.</span>
<span class="cm"> *</span>
<span class="cm"> * Use il_wr()/il_rd() family</span>
<span class="cm"> * for these registers;</span>
<span class="cm"> * host must &quot;grab nic access&quot; via CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ</span>
<span class="cm"> * to make sure the MAC (uCode processor, etc.) is powered up for accessing</span>
<span class="cm"> * internal resources.</span>
<span class="cm"> *</span>
<span class="cm"> * Do not use _il_wr()/_il_rd() family to access these registers;</span>
<span class="cm"> * these provide only simple PCI bus access, without waking up the MAC.</span>
<span class="cm"> */</span>
<span class="cp">#define HBUS_BASE	(0x400)</span>

<span class="cm">/*</span>
<span class="cm"> * Registers for accessing device&#39;s internal SRAM memory (e.g. SCD SRAM</span>
<span class="cm"> * structures, error log, event log, verifying uCode load).</span>
<span class="cm"> * First write to address register, then read from or write to data register</span>
<span class="cm"> * to complete the job.  Once the address register is set up, accesses to</span>
<span class="cm"> * data registers auto-increment the address by one dword.</span>
<span class="cm"> * Bit usage for address registers (read or write):</span>
<span class="cm"> *  0-31:  memory address within device</span>
<span class="cm"> */</span>
<span class="cp">#define HBUS_TARG_MEM_RADDR     (HBUS_BASE+0x00c)</span>
<span class="cp">#define HBUS_TARG_MEM_WADDR     (HBUS_BASE+0x010)</span>
<span class="cp">#define HBUS_TARG_MEM_WDAT      (HBUS_BASE+0x018)</span>
<span class="cp">#define HBUS_TARG_MEM_RDAT      (HBUS_BASE+0x01c)</span>

<span class="cm">/* Mailbox C, used as workaround alternative to CSR_UCODE_DRV_GP1 mailbox */</span>
<span class="cp">#define HBUS_TARG_MBX_C         (HBUS_BASE+0x030)</span>
<span class="cp">#define HBUS_TARG_MBX_C_REG_BIT_CMD_BLOCKED         (0x00000004)</span>

<span class="cm">/*</span>
<span class="cm"> * Registers for accessing device&#39;s internal peripheral registers</span>
<span class="cm"> * (e.g. SCD, BSM, etc.).  First write to address register,</span>
<span class="cm"> * then read from or write to data register to complete the job.</span>
<span class="cm"> * Bit usage for address registers (read or write):</span>
<span class="cm"> *  0-15:  register address (offset) within device</span>
<span class="cm"> * 24-25:  (# bytes - 1) to read or write (e.g. 3 for dword)</span>
<span class="cm"> */</span>
<span class="cp">#define HBUS_TARG_PRPH_WADDR    (HBUS_BASE+0x044)</span>
<span class="cp">#define HBUS_TARG_PRPH_RADDR    (HBUS_BASE+0x048)</span>
<span class="cp">#define HBUS_TARG_PRPH_WDAT     (HBUS_BASE+0x04c)</span>
<span class="cp">#define HBUS_TARG_PRPH_RDAT     (HBUS_BASE+0x050)</span>

<span class="cm">/*</span>
<span class="cm"> * Per-Tx-queue write pointer (idx, really!)</span>
<span class="cm"> * Indicates idx to next TFD that driver will fill (1 past latest filled).</span>
<span class="cm"> * Bit usage:</span>
<span class="cm"> *  0-7:  queue write idx</span>
<span class="cm"> * 11-8:  queue selector</span>
<span class="cm"> */</span>
<span class="cp">#define HBUS_TARG_WRPTR         (HBUS_BASE+0x060)</span>

<span class="cp">#endif </span><span class="cm">/* !__il_csr_h__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
