<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › zd1211rw › zd_chip.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>zd_chip.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* ZD1211 USB-WLAN driver for Linux</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2007 Ulrich Kunitz &lt;kune@deine-taler.de&gt;</span>
<span class="cm"> * Copyright (C) 2006-2007 Daniel Drake &lt;dsd@gentoo.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _ZD_CHIP_H</span>
<span class="cp">#define _ZD_CHIP_H</span>

<span class="cp">#include &lt;net/mac80211.h&gt;</span>

<span class="cp">#include &quot;zd_rf.h&quot;</span>
<span class="cp">#include &quot;zd_usb.h&quot;</span>

<span class="cm">/* Header for the Media Access Controller (MAC) and the Baseband Processor</span>
<span class="cm"> * (BBP). It appears that the ZD1211 wraps the old ZD1205 with USB glue and</span>
<span class="cm"> * adds a processor for handling the USB protocol.</span>
<span class="cm"> */</span>

<span class="cm">/* Address space */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* CONTROL REGISTERS */</span>
	<span class="n">CR_START</span>			<span class="o">=</span> <span class="mh">0x9000</span><span class="p">,</span>


	<span class="cm">/* FIRMWARE */</span>
	<span class="n">FW_START</span>			<span class="o">=</span> <span class="mh">0xee00</span><span class="p">,</span>


	<span class="cm">/* EEPROM */</span>
	<span class="n">E2P_START</span>			<span class="o">=</span> <span class="mh">0xf800</span><span class="p">,</span>
	<span class="n">E2P_LEN</span>				<span class="o">=</span> <span class="mh">0x800</span><span class="p">,</span>

	<span class="cm">/* EEPROM layout */</span>
	<span class="n">E2P_LOAD_CODE_LEN</span>		<span class="o">=</span> <span class="mh">0xe</span><span class="p">,</span>		<span class="cm">/* base 0xf800 */</span>
	<span class="n">E2P_LOAD_VECT_LEN</span>		<span class="o">=</span> <span class="mh">0x9</span><span class="p">,</span>		<span class="cm">/* base 0xf80e */</span>
	<span class="cm">/* E2P_DATA indexes into this */</span>
	<span class="n">E2P_DATA_LEN</span>			<span class="o">=</span> <span class="mh">0x7e</span><span class="p">,</span>		<span class="cm">/* base 0xf817 */</span>
	<span class="n">E2P_BOOT_CODE_LEN</span>		<span class="o">=</span> <span class="mh">0x760</span><span class="p">,</span>	<span class="cm">/* base 0xf895 */</span>
	<span class="n">E2P_INTR_VECT_LEN</span>		<span class="o">=</span> <span class="mh">0xb</span><span class="p">,</span>		<span class="cm">/* base 0xfff5 */</span>

	<span class="cm">/* Some precomputed offsets into the EEPROM */</span>
	<span class="n">E2P_DATA_OFFSET</span>			<span class="o">=</span> <span class="n">E2P_LOAD_CODE_LEN</span> <span class="o">+</span> <span class="n">E2P_LOAD_VECT_LEN</span><span class="p">,</span>
	<span class="n">E2P_BOOT_CODE_OFFSET</span>		<span class="o">=</span> <span class="n">E2P_DATA_OFFSET</span> <span class="o">+</span> <span class="n">E2P_DATA_LEN</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define CTL_REG(offset) ((zd_addr_t)(CR_START + (offset)))</span>
<span class="cp">#define E2P_DATA(offset) ((zd_addr_t)(E2P_START + E2P_DATA_OFFSET + (offset)))</span>
<span class="cp">#define FWRAW_DATA(offset) ((zd_addr_t)(FW_START + (offset)))</span>

<span class="cm">/* 8-bit hardware registers */</span>
<span class="cp">#define ZD_CR0   CTL_REG(0x0000)</span>
<span class="cp">#define ZD_CR1   CTL_REG(0x0004)</span>
<span class="cp">#define ZD_CR2   CTL_REG(0x0008)</span>
<span class="cp">#define ZD_CR3   CTL_REG(0x000C)</span>

<span class="cp">#define ZD_CR5   CTL_REG(0x0010)</span>
<span class="cm">/*	bit 5: if set short preamble used</span>
<span class="cm"> *	bit 6: filter band - Japan channel 14 on, else off</span>
<span class="cm"> */</span>
<span class="cp">#define ZD_CR6   CTL_REG(0x0014)</span>
<span class="cp">#define ZD_CR7   CTL_REG(0x0018)</span>
<span class="cp">#define ZD_CR8   CTL_REG(0x001C)</span>

<span class="cp">#define ZD_CR4   CTL_REG(0x0020)</span>

<span class="cp">#define ZD_CR9   CTL_REG(0x0024)</span>
<span class="cm">/*	bit 2: antenna switch (together with ZD_CR10) */</span>
<span class="cp">#define ZD_CR10  CTL_REG(0x0028)</span>
<span class="cm">/*	bit 1: antenna switch (together with ZD_CR9)</span>
<span class="cm"> *	RF2959 controls with ZD_CR11 radion on and off</span>
<span class="cm"> */</span>
<span class="cp">#define ZD_CR11  CTL_REG(0x002C)</span>
<span class="cm">/*	bit 6:  TX power control for OFDM</span>
<span class="cm"> *	RF2959 controls with ZD_CR10 radio on and off</span>
<span class="cm"> */</span>
<span class="cp">#define ZD_CR12  CTL_REG(0x0030)</span>
<span class="cp">#define ZD_CR13  CTL_REG(0x0034)</span>
<span class="cp">#define ZD_CR14  CTL_REG(0x0038)</span>
<span class="cp">#define ZD_CR15  CTL_REG(0x003C)</span>
<span class="cp">#define ZD_CR16  CTL_REG(0x0040)</span>
<span class="cp">#define ZD_CR17  CTL_REG(0x0044)</span>
<span class="cp">#define ZD_CR18  CTL_REG(0x0048)</span>
<span class="cp">#define ZD_CR19  CTL_REG(0x004C)</span>
<span class="cp">#define ZD_CR20  CTL_REG(0x0050)</span>
<span class="cp">#define ZD_CR21  CTL_REG(0x0054)</span>
<span class="cp">#define ZD_CR22  CTL_REG(0x0058)</span>
<span class="cp">#define ZD_CR23  CTL_REG(0x005C)</span>
<span class="cp">#define ZD_CR24  CTL_REG(0x0060)	</span><span class="cm">/* CCA threshold */</span><span class="cp"></span>
<span class="cp">#define ZD_CR25  CTL_REG(0x0064)</span>
<span class="cp">#define ZD_CR26  CTL_REG(0x0068)</span>
<span class="cp">#define ZD_CR27  CTL_REG(0x006C)</span>
<span class="cp">#define ZD_CR28  CTL_REG(0x0070)</span>
<span class="cp">#define ZD_CR29  CTL_REG(0x0074)</span>
<span class="cp">#define ZD_CR30  CTL_REG(0x0078)</span>
<span class="cp">#define ZD_CR31  CTL_REG(0x007C)	</span><span class="cm">/* TX power control for RF in</span>
<span class="cm">					 * CCK mode</span>
<span class="cm">					 */</span><span class="cp"></span>
<span class="cp">#define ZD_CR32  CTL_REG(0x0080)</span>
<span class="cp">#define ZD_CR33  CTL_REG(0x0084)</span>
<span class="cp">#define ZD_CR34  CTL_REG(0x0088)</span>
<span class="cp">#define ZD_CR35  CTL_REG(0x008C)</span>
<span class="cp">#define ZD_CR36  CTL_REG(0x0090)</span>
<span class="cp">#define ZD_CR37  CTL_REG(0x0094)</span>
<span class="cp">#define ZD_CR38  CTL_REG(0x0098)</span>
<span class="cp">#define ZD_CR39  CTL_REG(0x009C)</span>
<span class="cp">#define ZD_CR40  CTL_REG(0x00A0)</span>
<span class="cp">#define ZD_CR41  CTL_REG(0x00A4)</span>
<span class="cp">#define ZD_CR42  CTL_REG(0x00A8)</span>
<span class="cp">#define ZD_CR43  CTL_REG(0x00AC)</span>
<span class="cp">#define ZD_CR44  CTL_REG(0x00B0)</span>
<span class="cp">#define ZD_CR45  CTL_REG(0x00B4)</span>
<span class="cp">#define ZD_CR46  CTL_REG(0x00B8)</span>
<span class="cp">#define ZD_CR47  CTL_REG(0x00BC)	</span><span class="cm">/* CCK baseband gain</span>
<span class="cm">					 * (patch value might be in EEPROM)</span>
<span class="cm">					 */</span><span class="cp"></span>
<span class="cp">#define ZD_CR48  CTL_REG(0x00C0)</span>
<span class="cp">#define ZD_CR49  CTL_REG(0x00C4)</span>
<span class="cp">#define ZD_CR50  CTL_REG(0x00C8)</span>
<span class="cp">#define ZD_CR51  CTL_REG(0x00CC)	</span><span class="cm">/* TX power control for RF in</span>
<span class="cm">					 * 6-36M modes</span>
<span class="cm">					 */</span><span class="cp"></span>
<span class="cp">#define ZD_CR52  CTL_REG(0x00D0)	</span><span class="cm">/* TX power control for RF in</span>
<span class="cm">					 * 48M mode</span>
<span class="cm">					 */</span><span class="cp"></span>
<span class="cp">#define ZD_CR53  CTL_REG(0x00D4)	</span><span class="cm">/* TX power control for RF in</span>
<span class="cm">					 * 54M mode</span>
<span class="cm">					 */</span><span class="cp"></span>
<span class="cp">#define ZD_CR54  CTL_REG(0x00D8)</span>
<span class="cp">#define ZD_CR55  CTL_REG(0x00DC)</span>
<span class="cp">#define ZD_CR56  CTL_REG(0x00E0)</span>
<span class="cp">#define ZD_CR57  CTL_REG(0x00E4)</span>
<span class="cp">#define ZD_CR58  CTL_REG(0x00E8)</span>
<span class="cp">#define ZD_CR59  CTL_REG(0x00EC)</span>
<span class="cp">#define ZD_CR60  CTL_REG(0x00F0)</span>
<span class="cp">#define ZD_CR61  CTL_REG(0x00F4)</span>
<span class="cp">#define ZD_CR62  CTL_REG(0x00F8)</span>
<span class="cp">#define ZD_CR63  CTL_REG(0x00FC)</span>
<span class="cp">#define ZD_CR64  CTL_REG(0x0100)</span>
<span class="cp">#define ZD_CR65  CTL_REG(0x0104) </span><span class="cm">/* OFDM 54M calibration */</span><span class="cp"></span>
<span class="cp">#define ZD_CR66  CTL_REG(0x0108) </span><span class="cm">/* OFDM 48M calibration */</span><span class="cp"></span>
<span class="cp">#define ZD_CR67  CTL_REG(0x010C) </span><span class="cm">/* OFDM 36M calibration */</span><span class="cp"></span>
<span class="cp">#define ZD_CR68  CTL_REG(0x0110) </span><span class="cm">/* CCK calibration */</span><span class="cp"></span>
<span class="cp">#define ZD_CR69  CTL_REG(0x0114)</span>
<span class="cp">#define ZD_CR70  CTL_REG(0x0118)</span>
<span class="cp">#define ZD_CR71  CTL_REG(0x011C)</span>
<span class="cp">#define ZD_CR72  CTL_REG(0x0120)</span>
<span class="cp">#define ZD_CR73  CTL_REG(0x0124)</span>
<span class="cp">#define ZD_CR74  CTL_REG(0x0128)</span>
<span class="cp">#define ZD_CR75  CTL_REG(0x012C)</span>
<span class="cp">#define ZD_CR76  CTL_REG(0x0130)</span>
<span class="cp">#define ZD_CR77  CTL_REG(0x0134)</span>
<span class="cp">#define ZD_CR78  CTL_REG(0x0138)</span>
<span class="cp">#define ZD_CR79  CTL_REG(0x013C)</span>
<span class="cp">#define ZD_CR80  CTL_REG(0x0140)</span>
<span class="cp">#define ZD_CR81  CTL_REG(0x0144)</span>
<span class="cp">#define ZD_CR82  CTL_REG(0x0148)</span>
<span class="cp">#define ZD_CR83  CTL_REG(0x014C)</span>
<span class="cp">#define ZD_CR84  CTL_REG(0x0150)</span>
<span class="cp">#define ZD_CR85  CTL_REG(0x0154)</span>
<span class="cp">#define ZD_CR86  CTL_REG(0x0158)</span>
<span class="cp">#define ZD_CR87  CTL_REG(0x015C)</span>
<span class="cp">#define ZD_CR88  CTL_REG(0x0160)</span>
<span class="cp">#define ZD_CR89  CTL_REG(0x0164)</span>
<span class="cp">#define ZD_CR90  CTL_REG(0x0168)</span>
<span class="cp">#define ZD_CR91  CTL_REG(0x016C)</span>
<span class="cp">#define ZD_CR92  CTL_REG(0x0170)</span>
<span class="cp">#define ZD_CR93  CTL_REG(0x0174)</span>
<span class="cp">#define ZD_CR94  CTL_REG(0x0178)</span>
<span class="cp">#define ZD_CR95  CTL_REG(0x017C)</span>
<span class="cp">#define ZD_CR96  CTL_REG(0x0180)</span>
<span class="cp">#define ZD_CR97  CTL_REG(0x0184)</span>
<span class="cp">#define ZD_CR98  CTL_REG(0x0188)</span>
<span class="cp">#define ZD_CR99  CTL_REG(0x018C)</span>
<span class="cp">#define ZD_CR100 CTL_REG(0x0190)</span>
<span class="cp">#define ZD_CR101 CTL_REG(0x0194)</span>
<span class="cp">#define ZD_CR102 CTL_REG(0x0198)</span>
<span class="cp">#define ZD_CR103 CTL_REG(0x019C)</span>
<span class="cp">#define ZD_CR104 CTL_REG(0x01A0)</span>
<span class="cp">#define ZD_CR105 CTL_REG(0x01A4)</span>
<span class="cp">#define ZD_CR106 CTL_REG(0x01A8)</span>
<span class="cp">#define ZD_CR107 CTL_REG(0x01AC)</span>
<span class="cp">#define ZD_CR108 CTL_REG(0x01B0)</span>
<span class="cp">#define ZD_CR109 CTL_REG(0x01B4)</span>
<span class="cp">#define ZD_CR110 CTL_REG(0x01B8)</span>
<span class="cp">#define ZD_CR111 CTL_REG(0x01BC)</span>
<span class="cp">#define ZD_CR112 CTL_REG(0x01C0)</span>
<span class="cp">#define ZD_CR113 CTL_REG(0x01C4)</span>
<span class="cp">#define ZD_CR114 CTL_REG(0x01C8)</span>
<span class="cp">#define ZD_CR115 CTL_REG(0x01CC)</span>
<span class="cp">#define ZD_CR116 CTL_REG(0x01D0)</span>
<span class="cp">#define ZD_CR117 CTL_REG(0x01D4)</span>
<span class="cp">#define ZD_CR118 CTL_REG(0x01D8)</span>
<span class="cp">#define ZD_CR119 CTL_REG(0x01DC)</span>
<span class="cp">#define ZD_CR120 CTL_REG(0x01E0)</span>
<span class="cp">#define ZD_CR121 CTL_REG(0x01E4)</span>
<span class="cp">#define ZD_CR122 CTL_REG(0x01E8)</span>
<span class="cp">#define ZD_CR123 CTL_REG(0x01EC)</span>
<span class="cp">#define ZD_CR124 CTL_REG(0x01F0)</span>
<span class="cp">#define ZD_CR125 CTL_REG(0x01F4)</span>
<span class="cp">#define ZD_CR126 CTL_REG(0x01F8)</span>
<span class="cp">#define ZD_CR127 CTL_REG(0x01FC)</span>
<span class="cp">#define ZD_CR128 CTL_REG(0x0200)</span>
<span class="cp">#define ZD_CR129 CTL_REG(0x0204)</span>
<span class="cp">#define ZD_CR130 CTL_REG(0x0208)</span>
<span class="cp">#define ZD_CR131 CTL_REG(0x020C)</span>
<span class="cp">#define ZD_CR132 CTL_REG(0x0210)</span>
<span class="cp">#define ZD_CR133 CTL_REG(0x0214)</span>
<span class="cp">#define ZD_CR134 CTL_REG(0x0218)</span>
<span class="cp">#define ZD_CR135 CTL_REG(0x021C)</span>
<span class="cp">#define ZD_CR136 CTL_REG(0x0220)</span>
<span class="cp">#define ZD_CR137 CTL_REG(0x0224)</span>
<span class="cp">#define ZD_CR138 CTL_REG(0x0228)</span>
<span class="cp">#define ZD_CR139 CTL_REG(0x022C)</span>
<span class="cp">#define ZD_CR140 CTL_REG(0x0230)</span>
<span class="cp">#define ZD_CR141 CTL_REG(0x0234)</span>
<span class="cp">#define ZD_CR142 CTL_REG(0x0238)</span>
<span class="cp">#define ZD_CR143 CTL_REG(0x023C)</span>
<span class="cp">#define ZD_CR144 CTL_REG(0x0240)</span>
<span class="cp">#define ZD_CR145 CTL_REG(0x0244)</span>
<span class="cp">#define ZD_CR146 CTL_REG(0x0248)</span>
<span class="cp">#define ZD_CR147 CTL_REG(0x024C)</span>
<span class="cp">#define ZD_CR148 CTL_REG(0x0250)</span>
<span class="cp">#define ZD_CR149 CTL_REG(0x0254)</span>
<span class="cp">#define ZD_CR150 CTL_REG(0x0258)</span>
<span class="cp">#define ZD_CR151 CTL_REG(0x025C)</span>
<span class="cp">#define ZD_CR152 CTL_REG(0x0260)</span>
<span class="cp">#define ZD_CR153 CTL_REG(0x0264)</span>
<span class="cp">#define ZD_CR154 CTL_REG(0x0268)</span>
<span class="cp">#define ZD_CR155 CTL_REG(0x026C)</span>
<span class="cp">#define ZD_CR156 CTL_REG(0x0270)</span>
<span class="cp">#define ZD_CR157 CTL_REG(0x0274)</span>
<span class="cp">#define ZD_CR158 CTL_REG(0x0278)</span>
<span class="cp">#define ZD_CR159 CTL_REG(0x027C)</span>
<span class="cp">#define ZD_CR160 CTL_REG(0x0280)</span>
<span class="cp">#define ZD_CR161 CTL_REG(0x0284)</span>
<span class="cp">#define ZD_CR162 CTL_REG(0x0288)</span>
<span class="cp">#define ZD_CR163 CTL_REG(0x028C)</span>
<span class="cp">#define ZD_CR164 CTL_REG(0x0290)</span>
<span class="cp">#define ZD_CR165 CTL_REG(0x0294)</span>
<span class="cp">#define ZD_CR166 CTL_REG(0x0298)</span>
<span class="cp">#define ZD_CR167 CTL_REG(0x029C)</span>
<span class="cp">#define ZD_CR168 CTL_REG(0x02A0)</span>
<span class="cp">#define ZD_CR169 CTL_REG(0x02A4)</span>
<span class="cp">#define ZD_CR170 CTL_REG(0x02A8)</span>
<span class="cp">#define ZD_CR171 CTL_REG(0x02AC)</span>
<span class="cp">#define ZD_CR172 CTL_REG(0x02B0)</span>
<span class="cp">#define ZD_CR173 CTL_REG(0x02B4)</span>
<span class="cp">#define ZD_CR174 CTL_REG(0x02B8)</span>
<span class="cp">#define ZD_CR175 CTL_REG(0x02BC)</span>
<span class="cp">#define ZD_CR176 CTL_REG(0x02C0)</span>
<span class="cp">#define ZD_CR177 CTL_REG(0x02C4)</span>
<span class="cp">#define ZD_CR178 CTL_REG(0x02C8)</span>
<span class="cp">#define ZD_CR179 CTL_REG(0x02CC)</span>
<span class="cp">#define ZD_CR180 CTL_REG(0x02D0)</span>
<span class="cp">#define ZD_CR181 CTL_REG(0x02D4)</span>
<span class="cp">#define ZD_CR182 CTL_REG(0x02D8)</span>
<span class="cp">#define ZD_CR183 CTL_REG(0x02DC)</span>
<span class="cp">#define ZD_CR184 CTL_REG(0x02E0)</span>
<span class="cp">#define ZD_CR185 CTL_REG(0x02E4)</span>
<span class="cp">#define ZD_CR186 CTL_REG(0x02E8)</span>
<span class="cp">#define ZD_CR187 CTL_REG(0x02EC)</span>
<span class="cp">#define ZD_CR188 CTL_REG(0x02F0)</span>
<span class="cp">#define ZD_CR189 CTL_REG(0x02F4)</span>
<span class="cp">#define ZD_CR190 CTL_REG(0x02F8)</span>
<span class="cp">#define ZD_CR191 CTL_REG(0x02FC)</span>
<span class="cp">#define ZD_CR192 CTL_REG(0x0300)</span>
<span class="cp">#define ZD_CR193 CTL_REG(0x0304)</span>
<span class="cp">#define ZD_CR194 CTL_REG(0x0308)</span>
<span class="cp">#define ZD_CR195 CTL_REG(0x030C)</span>
<span class="cp">#define ZD_CR196 CTL_REG(0x0310)</span>
<span class="cp">#define ZD_CR197 CTL_REG(0x0314)</span>
<span class="cp">#define ZD_CR198 CTL_REG(0x0318)</span>
<span class="cp">#define ZD_CR199 CTL_REG(0x031C)</span>
<span class="cp">#define ZD_CR200 CTL_REG(0x0320)</span>
<span class="cp">#define ZD_CR201 CTL_REG(0x0324)</span>
<span class="cp">#define ZD_CR202 CTL_REG(0x0328)</span>
<span class="cp">#define ZD_CR203 CTL_REG(0x032C)	</span><span class="cm">/* I2C bus template value &amp; flash</span>
<span class="cm">					 * control</span>
<span class="cm">					 */</span><span class="cp"></span>
<span class="cp">#define ZD_CR204 CTL_REG(0x0330)</span>
<span class="cp">#define ZD_CR205 CTL_REG(0x0334)</span>
<span class="cp">#define ZD_CR206 CTL_REG(0x0338)</span>
<span class="cp">#define ZD_CR207 CTL_REG(0x033C)</span>
<span class="cp">#define ZD_CR208 CTL_REG(0x0340)</span>
<span class="cp">#define ZD_CR209 CTL_REG(0x0344)</span>
<span class="cp">#define ZD_CR210 CTL_REG(0x0348)</span>
<span class="cp">#define ZD_CR211 CTL_REG(0x034C)</span>
<span class="cp">#define ZD_CR212 CTL_REG(0x0350)</span>
<span class="cp">#define ZD_CR213 CTL_REG(0x0354)</span>
<span class="cp">#define ZD_CR214 CTL_REG(0x0358)</span>
<span class="cp">#define ZD_CR215 CTL_REG(0x035C)</span>
<span class="cp">#define ZD_CR216 CTL_REG(0x0360)</span>
<span class="cp">#define ZD_CR217 CTL_REG(0x0364)</span>
<span class="cp">#define ZD_CR218 CTL_REG(0x0368)</span>
<span class="cp">#define ZD_CR219 CTL_REG(0x036C)</span>
<span class="cp">#define ZD_CR220 CTL_REG(0x0370)</span>
<span class="cp">#define ZD_CR221 CTL_REG(0x0374)</span>
<span class="cp">#define ZD_CR222 CTL_REG(0x0378)</span>
<span class="cp">#define ZD_CR223 CTL_REG(0x037C)</span>
<span class="cp">#define ZD_CR224 CTL_REG(0x0380)</span>
<span class="cp">#define ZD_CR225 CTL_REG(0x0384)</span>
<span class="cp">#define ZD_CR226 CTL_REG(0x0388)</span>
<span class="cp">#define ZD_CR227 CTL_REG(0x038C)</span>
<span class="cp">#define ZD_CR228 CTL_REG(0x0390)</span>
<span class="cp">#define ZD_CR229 CTL_REG(0x0394)</span>
<span class="cp">#define ZD_CR230 CTL_REG(0x0398)</span>
<span class="cp">#define ZD_CR231 CTL_REG(0x039C)</span>
<span class="cp">#define ZD_CR232 CTL_REG(0x03A0)</span>
<span class="cp">#define ZD_CR233 CTL_REG(0x03A4)</span>
<span class="cp">#define ZD_CR234 CTL_REG(0x03A8)</span>
<span class="cp">#define ZD_CR235 CTL_REG(0x03AC)</span>
<span class="cp">#define ZD_CR236 CTL_REG(0x03B0)</span>

<span class="cp">#define ZD_CR240 CTL_REG(0x03C0)</span>
<span class="cm">/*             bit 7: host-controlled RF register writes</span>
<span class="cm"> * ZD_CR241-ZD_CR245: for hardware controlled writing of RF bits, not needed for</span>
<span class="cm"> *                    USB</span>
<span class="cm"> */</span>
<span class="cp">#define ZD_CR241 CTL_REG(0x03C4)</span>
<span class="cp">#define ZD_CR242 CTL_REG(0x03C8)</span>
<span class="cp">#define ZD_CR243 CTL_REG(0x03CC)</span>
<span class="cp">#define ZD_CR244 CTL_REG(0x03D0)</span>
<span class="cp">#define ZD_CR245 CTL_REG(0x03D4)</span>

<span class="cp">#define ZD_CR251 CTL_REG(0x03EC)	</span><span class="cm">/* only used for activation and</span>
<span class="cm">					 * deactivation of Airoha RFs AL2230</span>
<span class="cm">					 * and AL7230B</span>
<span class="cm">					 */</span><span class="cp"></span>
<span class="cp">#define ZD_CR252 CTL_REG(0x03F0)</span>
<span class="cp">#define ZD_CR253 CTL_REG(0x03F4)</span>
<span class="cp">#define ZD_CR254 CTL_REG(0x03F8)</span>
<span class="cp">#define ZD_CR255 CTL_REG(0x03FC)</span>

<span class="cp">#define CR_MAX_PHY_REG 255</span>

<span class="cm">/* Taken from the ZYDAS driver, not all of them are relevant for the ZD1211</span>
<span class="cm"> * driver.</span>
<span class="cm"> */</span>

<span class="cp">#define CR_RF_IF_CLK			CTL_REG(0x0400)</span>
<span class="cp">#define CR_RF_IF_DATA			CTL_REG(0x0404)</span>
<span class="cp">#define CR_PE1_PE2			CTL_REG(0x0408)</span>
<span class="cp">#define CR_PE2_DLY			CTL_REG(0x040C)</span>
<span class="cp">#define CR_LE1				CTL_REG(0x0410)</span>
<span class="cp">#define CR_LE2				CTL_REG(0x0414)</span>
<span class="cm">/* Seems to enable/disable GPI (General Purpose IO?) */</span>
<span class="cp">#define CR_GPI_EN			CTL_REG(0x0418)</span>
<span class="cp">#define CR_RADIO_PD			CTL_REG(0x042C)</span>
<span class="cp">#define CR_RF2948_PD			CTL_REG(0x042C)</span>
<span class="cp">#define CR_ENABLE_PS_MANUAL_AGC		CTL_REG(0x043C)</span>
<span class="cp">#define CR_CONFIG_PHILIPS		CTL_REG(0x0440)</span>
<span class="cp">#define CR_SA2400_SER_AP		CTL_REG(0x0444)</span>
<span class="cp">#define CR_I2C_WRITE			CTL_REG(0x0444)</span>
<span class="cp">#define CR_SA2400_SER_RP		CTL_REG(0x0448)</span>
<span class="cp">#define CR_RADIO_PE			CTL_REG(0x0458)</span>
<span class="cp">#define CR_RST_BUS_MASTER		CTL_REG(0x045C)</span>
<span class="cp">#define CR_RFCFG			CTL_REG(0x0464)</span>
<span class="cp">#define CR_HSTSCHG			CTL_REG(0x046C)</span>
<span class="cp">#define CR_PHY_ON			CTL_REG(0x0474)</span>
<span class="cp">#define CR_RX_DELAY			CTL_REG(0x0478)</span>
<span class="cp">#define CR_RX_PE_DELAY			CTL_REG(0x047C)</span>
<span class="cp">#define CR_GPIO_1			CTL_REG(0x0490)</span>
<span class="cp">#define CR_GPIO_2			CTL_REG(0x0494)</span>
<span class="cp">#define CR_EncryBufMux			CTL_REG(0x04A8)</span>
<span class="cp">#define CR_PS_CTRL			CTL_REG(0x0500)</span>
<span class="cp">#define CR_ADDA_PWR_DWN			CTL_REG(0x0504)</span>
<span class="cp">#define CR_ADDA_MBIAS_WARMTIME		CTL_REG(0x0508)</span>
<span class="cp">#define CR_MAC_PS_STATE			CTL_REG(0x050C)</span>

<span class="cp">#define CR_INTERRUPT			CTL_REG(0x0510)</span>
<span class="cp">#define INT_TX_COMPLETE			(1 &lt;&lt;  0)</span>
<span class="cp">#define INT_RX_COMPLETE			(1 &lt;&lt;  1)</span>
<span class="cp">#define INT_RETRY_FAIL			(1 &lt;&lt;  2)</span>
<span class="cp">#define INT_WAKEUP			(1 &lt;&lt;  3)</span>
<span class="cp">#define INT_DTIM_NOTIFY			(1 &lt;&lt;  5)</span>
<span class="cp">#define INT_CFG_NEXT_BCN		(1 &lt;&lt;  6)</span>
<span class="cp">#define INT_BUS_ABORT			(1 &lt;&lt;  7)</span>
<span class="cp">#define INT_TX_FIFO_READY		(1 &lt;&lt;  8)</span>
<span class="cp">#define INT_UART			(1 &lt;&lt;  9)</span>
<span class="cp">#define INT_TX_COMPLETE_EN		(1 &lt;&lt; 16)</span>
<span class="cp">#define INT_RX_COMPLETE_EN		(1 &lt;&lt; 17)</span>
<span class="cp">#define INT_RETRY_FAIL_EN		(1 &lt;&lt; 18)</span>
<span class="cp">#define INT_WAKEUP_EN			(1 &lt;&lt; 19)</span>
<span class="cp">#define INT_DTIM_NOTIFY_EN		(1 &lt;&lt; 21)</span>
<span class="cp">#define INT_CFG_NEXT_BCN_EN		(1 &lt;&lt; 22)</span>
<span class="cp">#define INT_BUS_ABORT_EN		(1 &lt;&lt; 23)</span>
<span class="cp">#define INT_TX_FIFO_READY_EN		(1 &lt;&lt; 24)</span>
<span class="cp">#define INT_UART_EN			(1 &lt;&lt; 25)</span>

<span class="cp">#define CR_TSF_LOW_PART			CTL_REG(0x0514)</span>
<span class="cp">#define CR_TSF_HIGH_PART		CTL_REG(0x0518)</span>

<span class="cm">/* Following three values are in time units (1024us)</span>
<span class="cm"> * Following condition must be met:</span>
<span class="cm"> * atim &lt; tbtt &lt; bcn</span>
<span class="cm"> */</span>
<span class="cp">#define CR_ATIM_WND_PERIOD		CTL_REG(0x051C)</span>
<span class="cp">#define CR_BCN_INTERVAL			CTL_REG(0x0520)</span>
<span class="cp">#define CR_PRE_TBTT			CTL_REG(0x0524)</span>
<span class="cm">/* in units of TU(1024us) */</span>

<span class="cm">/* for UART support */</span>
<span class="cp">#define CR_UART_RBR_THR_DLL		CTL_REG(0x0540)</span>
<span class="cp">#define CR_UART_DLM_IER			CTL_REG(0x0544)</span>
<span class="cp">#define CR_UART_IIR_FCR			CTL_REG(0x0548)</span>
<span class="cp">#define CR_UART_LCR			CTL_REG(0x054c)</span>
<span class="cp">#define CR_UART_MCR			CTL_REG(0x0550)</span>
<span class="cp">#define CR_UART_LSR			CTL_REG(0x0554)</span>
<span class="cp">#define CR_UART_MSR			CTL_REG(0x0558)</span>
<span class="cp">#define CR_UART_ECR			CTL_REG(0x055c)</span>
<span class="cp">#define CR_UART_STATUS			CTL_REG(0x0560)</span>

<span class="cp">#define CR_PCI_TX_ADDR_P1		CTL_REG(0x0600)</span>
<span class="cp">#define CR_PCI_TX_AddR_P2		CTL_REG(0x0604)</span>
<span class="cp">#define CR_PCI_RX_AddR_P1		CTL_REG(0x0608)</span>
<span class="cp">#define CR_PCI_RX_AddR_P2		CTL_REG(0x060C)</span>

<span class="cm">/* must be overwritten if custom MAC address will be used */</span>
<span class="cp">#define CR_MAC_ADDR_P1			CTL_REG(0x0610)</span>
<span class="cp">#define CR_MAC_ADDR_P2			CTL_REG(0x0614)</span>
<span class="cp">#define CR_BSSID_P1			CTL_REG(0x0618)</span>
<span class="cp">#define CR_BSSID_P2			CTL_REG(0x061C)</span>
<span class="cp">#define CR_BCN_PLCP_CFG			CTL_REG(0x0620)</span>

<span class="cm">/* Group hash table for filtering incoming packets.</span>
<span class="cm"> *</span>
<span class="cm"> * The group hash table is 64 bit large and split over two parts. The first</span>
<span class="cm"> * part is the lower part. The upper 6 bits of the last byte of the target</span>
<span class="cm"> * address are used as index. Packets are received if the hash table bit is</span>
<span class="cm"> * set. This is used for multicast handling, but for broadcasts (address</span>
<span class="cm"> * ff:ff:ff:ff:ff:ff) the highest bit in the second table must also be set.</span>
<span class="cm"> */</span>
<span class="cp">#define CR_GROUP_HASH_P1		CTL_REG(0x0624)</span>
<span class="cp">#define CR_GROUP_HASH_P2		CTL_REG(0x0628)</span>

<span class="cp">#define CR_RX_TIMEOUT			CTL_REG(0x062C)</span>

<span class="cm">/* Basic rates supported by the BSS. When producing ACK or CTS messages, the</span>
<span class="cm"> * device will use a rate in this table that is less than or equal to the rate</span>
<span class="cm"> * of the incoming frame which prompted the response. */</span>
<span class="cp">#define CR_BASIC_RATE_TBL		CTL_REG(0x0630)</span>
<span class="cp">#define CR_RATE_1M	(1 &lt;&lt;  0)	</span><span class="cm">/* 802.11b */</span><span class="cp"></span>
<span class="cp">#define CR_RATE_2M	(1 &lt;&lt;  1)	</span><span class="cm">/* 802.11b */</span><span class="cp"></span>
<span class="cp">#define CR_RATE_5_5M	(1 &lt;&lt;  2)	</span><span class="cm">/* 802.11b */</span><span class="cp"></span>
<span class="cp">#define CR_RATE_11M	(1 &lt;&lt;  3)	</span><span class="cm">/* 802.11b */</span><span class="cp"></span>
<span class="cp">#define CR_RATE_6M      (1 &lt;&lt;  8)	</span><span class="cm">/* 802.11g */</span><span class="cp"></span>
<span class="cp">#define CR_RATE_9M      (1 &lt;&lt;  9)	</span><span class="cm">/* 802.11g */</span><span class="cp"></span>
<span class="cp">#define CR_RATE_12M	(1 &lt;&lt; 10)	</span><span class="cm">/* 802.11g */</span><span class="cp"></span>
<span class="cp">#define CR_RATE_18M	(1 &lt;&lt; 11)	</span><span class="cm">/* 802.11g */</span><span class="cp"></span>
<span class="cp">#define CR_RATE_24M     (1 &lt;&lt; 12)	</span><span class="cm">/* 802.11g */</span><span class="cp"></span>
<span class="cp">#define CR_RATE_36M     (1 &lt;&lt; 13)	</span><span class="cm">/* 802.11g */</span><span class="cp"></span>
<span class="cp">#define CR_RATE_48M     (1 &lt;&lt; 14)	</span><span class="cm">/* 802.11g */</span><span class="cp"></span>
<span class="cp">#define CR_RATE_54M     (1 &lt;&lt; 15)	</span><span class="cm">/* 802.11g */</span><span class="cp"></span>
<span class="cp">#define CR_RATES_80211G	0xff00</span>
<span class="cp">#define CR_RATES_80211B	0x000f</span>

<span class="cm">/* Mandatory rates required in the BSS. When producing ACK or CTS messages, if</span>
<span class="cm"> * the device could not find an appropriate rate in CR_BASIC_RATE_TBL, it will</span>
<span class="cm"> * look for a rate in this table that is less than or equal to the rate of</span>
<span class="cm"> * the incoming frame. */</span>
<span class="cp">#define CR_MANDATORY_RATE_TBL		CTL_REG(0x0634)</span>
<span class="cp">#define CR_RTS_CTS_RATE			CTL_REG(0x0638)</span>

<span class="cm">/* These are all bit indexes in CR_RTS_CTS_RATE, so remember to shift. */</span>
<span class="cp">#define RTSCTS_SH_RTS_RATE		0</span>
<span class="cp">#define RTSCTS_SH_EXP_CTS_RATE		4</span>
<span class="cp">#define RTSCTS_SH_RTS_MOD_TYPE		8</span>
<span class="cp">#define RTSCTS_SH_RTS_PMB_TYPE		9</span>
<span class="cp">#define RTSCTS_SH_CTS_RATE		16</span>
<span class="cp">#define RTSCTS_SH_CTS_MOD_TYPE		24</span>
<span class="cp">#define RTSCTS_SH_CTS_PMB_TYPE		25</span>

<span class="cp">#define CR_WEP_PROTECT			CTL_REG(0x063C)</span>
<span class="cp">#define CR_RX_THRESHOLD			CTL_REG(0x0640)</span>

<span class="cm">/* register for controlling the LEDS */</span>
<span class="cp">#define CR_LED				CTL_REG(0x0644)</span>
<span class="cm">/* masks for controlling LEDs */</span>
<span class="cp">#define LED1				(1 &lt;&lt;  8)</span>
<span class="cp">#define LED2				(1 &lt;&lt;  9)</span>
<span class="cp">#define LED_SW				(1 &lt;&lt; 10)</span>

<span class="cm">/* Seems to indicate that the configuration is over.</span>
<span class="cm"> */</span>
<span class="cp">#define CR_AFTER_PNP			CTL_REG(0x0648)</span>
<span class="cp">#define CR_ACK_TIME_80211		CTL_REG(0x0658)</span>

<span class="cp">#define CR_RX_OFFSET			CTL_REG(0x065c)</span>

<span class="cp">#define CR_BCN_LENGTH			CTL_REG(0x0664)</span>
<span class="cp">#define CR_PHY_DELAY			CTL_REG(0x066C)</span>
<span class="cp">#define CR_BCN_FIFO			CTL_REG(0x0670)</span>
<span class="cp">#define CR_SNIFFER_ON			CTL_REG(0x0674)</span>

<span class="cp">#define CR_ENCRYPTION_TYPE		CTL_REG(0x0678)</span>
<span class="cp">#define NO_WEP				0</span>
<span class="cp">#define WEP64				1</span>
<span class="cp">#define WEP128				5</span>
<span class="cp">#define WEP256				6</span>
<span class="cp">#define ENC_SNIFFER			8</span>

<span class="cp">#define CR_ZD1211_RETRY_MAX		CTL_REG(0x067C)</span>

<span class="cp">#define CR_REG1				CTL_REG(0x0680)</span>
<span class="cm">/* Setting the bit UNLOCK_PHY_REGS disallows the write access to physical</span>
<span class="cm"> * registers, so one could argue it is a LOCK bit. But calling it</span>
<span class="cm"> * LOCK_PHY_REGS makes it confusing.</span>
<span class="cm"> */</span>
<span class="cp">#define UNLOCK_PHY_REGS			(1 &lt;&lt; 7)</span>

<span class="cp">#define CR_DEVICE_STATE			CTL_REG(0x0684)</span>
<span class="cp">#define CR_UNDERRUN_CNT			CTL_REG(0x0688)</span>

<span class="cp">#define CR_RX_FILTER			CTL_REG(0x068c)</span>
<span class="cp">#define RX_FILTER_ASSOC_REQUEST		(1 &lt;&lt;  0)</span>
<span class="cp">#define RX_FILTER_ASSOC_RESPONSE	(1 &lt;&lt;  1)</span>
<span class="cp">#define RX_FILTER_REASSOC_REQUEST	(1 &lt;&lt;  2)</span>
<span class="cp">#define RX_FILTER_REASSOC_RESPONSE	(1 &lt;&lt;  3)</span>
<span class="cp">#define RX_FILTER_PROBE_REQUEST		(1 &lt;&lt;  4)</span>
<span class="cp">#define RX_FILTER_PROBE_RESPONSE	(1 &lt;&lt;  5)</span>
<span class="cm">/* bits 6 and 7 reserved */</span>
<span class="cp">#define RX_FILTER_BEACON		(1 &lt;&lt;  8)</span>
<span class="cp">#define RX_FILTER_ATIM			(1 &lt;&lt;  9)</span>
<span class="cp">#define RX_FILTER_DISASSOC		(1 &lt;&lt; 10)</span>
<span class="cp">#define RX_FILTER_AUTH			(1 &lt;&lt; 11)</span>
<span class="cp">#define RX_FILTER_DEAUTH		(1 &lt;&lt; 12)</span>
<span class="cp">#define RX_FILTER_PSPOLL		(1 &lt;&lt; 26)</span>
<span class="cp">#define RX_FILTER_RTS			(1 &lt;&lt; 27)</span>
<span class="cp">#define RX_FILTER_CTS			(1 &lt;&lt; 28)</span>
<span class="cp">#define RX_FILTER_ACK			(1 &lt;&lt; 29)</span>
<span class="cp">#define RX_FILTER_CFEND			(1 &lt;&lt; 30)</span>
<span class="cp">#define RX_FILTER_CFACK			(1 &lt;&lt; 31)</span>

<span class="cm">/* Enable bits for all frames you are interested in. */</span>
<span class="cp">#define STA_RX_FILTER	(RX_FILTER_ASSOC_REQUEST | RX_FILTER_ASSOC_RESPONSE | \</span>
<span class="cp">	RX_FILTER_REASSOC_REQUEST | RX_FILTER_REASSOC_RESPONSE | \</span>
<span class="cp">	RX_FILTER_PROBE_REQUEST | RX_FILTER_PROBE_RESPONSE | \</span>
<span class="cp">	(0x3 &lt;&lt; 6) </span><span class="cm">/* vendor driver sets these reserved bits */</span><span class="cp"> | \</span>
<span class="cp">	RX_FILTER_BEACON | RX_FILTER_ATIM | RX_FILTER_DISASSOC | \</span>
<span class="cp">	RX_FILTER_AUTH | RX_FILTER_DEAUTH | \</span>
<span class="cp">	(0x7 &lt;&lt; 13) </span><span class="cm">/* vendor driver sets these reserved bits */</span><span class="cp"> | \</span>
<span class="cp">	RX_FILTER_PSPOLL | RX_FILTER_ACK) </span><span class="cm">/* 0x2400ffff */</span><span class="cp"></span>

<span class="cp">#define RX_FILTER_CTRL (RX_FILTER_RTS | RX_FILTER_CTS | \</span>
<span class="cp">	RX_FILTER_CFEND | RX_FILTER_CFACK)</span>

<span class="cp">#define BCN_MODE_AP			0x1000000</span>
<span class="cp">#define BCN_MODE_IBSS			0x2000000</span>

<span class="cm">/* Monitor mode sets filter to 0xfffff */</span>

<span class="cp">#define CR_ACK_TIMEOUT_EXT		CTL_REG(0x0690)</span>
<span class="cp">#define CR_BCN_FIFO_SEMAPHORE		CTL_REG(0x0694)</span>

<span class="cp">#define CR_IFS_VALUE			CTL_REG(0x0698)</span>
<span class="cp">#define IFS_VALUE_DIFS_SH		0</span>
<span class="cp">#define IFS_VALUE_EIFS_SH		12</span>
<span class="cp">#define IFS_VALUE_SIFS_SH		24</span>
<span class="cp">#define IFS_VALUE_DEFAULT		((  50 &lt;&lt; IFS_VALUE_DIFS_SH) | \</span>
<span class="cp">					 (1148 &lt;&lt; IFS_VALUE_EIFS_SH) | \</span>
<span class="cp">					 (  10 &lt;&lt; IFS_VALUE_SIFS_SH))</span>

<span class="cp">#define CR_RX_TIME_OUT			CTL_REG(0x069C)</span>
<span class="cp">#define CR_TOTAL_RX_FRM			CTL_REG(0x06A0)</span>
<span class="cp">#define CR_CRC32_CNT			CTL_REG(0x06A4)</span>
<span class="cp">#define CR_CRC16_CNT			CTL_REG(0x06A8)</span>
<span class="cp">#define CR_DECRYPTION_ERR_UNI		CTL_REG(0x06AC)</span>
<span class="cp">#define CR_RX_FIFO_OVERRUN		CTL_REG(0x06B0)</span>

<span class="cp">#define CR_DECRYPTION_ERR_MUL		CTL_REG(0x06BC)</span>

<span class="cp">#define CR_NAV_CNT			CTL_REG(0x06C4)</span>
<span class="cp">#define CR_NAV_CCA			CTL_REG(0x06C8)</span>
<span class="cp">#define CR_RETRY_CNT			CTL_REG(0x06CC)</span>

<span class="cp">#define CR_READ_TCB_ADDR		CTL_REG(0x06E8)</span>
<span class="cp">#define CR_READ_RFD_ADDR		CTL_REG(0x06EC)</span>
<span class="cp">#define CR_CWMIN_CWMAX			CTL_REG(0x06F0)</span>
<span class="cp">#define CR_TOTAL_TX_FRM			CTL_REG(0x06F4)</span>

<span class="cm">/* CAM: Continuous Access Mode (power management) */</span>
<span class="cp">#define CR_CAM_MODE			CTL_REG(0x0700)</span>
<span class="cp">#define MODE_IBSS			0x0</span>
<span class="cp">#define MODE_AP				0x1</span>
<span class="cp">#define MODE_STA			0x2</span>
<span class="cp">#define MODE_AP_WDS			0x3</span>

<span class="cp">#define CR_CAM_ROLL_TB_LOW		CTL_REG(0x0704)</span>
<span class="cp">#define CR_CAM_ROLL_TB_HIGH		CTL_REG(0x0708)</span>
<span class="cp">#define CR_CAM_ADDRESS			CTL_REG(0x070C)</span>
<span class="cp">#define CR_CAM_DATA			CTL_REG(0x0710)</span>

<span class="cp">#define CR_ROMDIR			CTL_REG(0x0714)</span>

<span class="cp">#define CR_DECRY_ERR_FLG_LOW		CTL_REG(0x0714)</span>
<span class="cp">#define CR_DECRY_ERR_FLG_HIGH		CTL_REG(0x0718)</span>

<span class="cp">#define CR_WEPKEY0			CTL_REG(0x0720)</span>
<span class="cp">#define CR_WEPKEY1			CTL_REG(0x0724)</span>
<span class="cp">#define CR_WEPKEY2			CTL_REG(0x0728)</span>
<span class="cp">#define CR_WEPKEY3			CTL_REG(0x072C)</span>
<span class="cp">#define CR_WEPKEY4			CTL_REG(0x0730)</span>
<span class="cp">#define CR_WEPKEY5			CTL_REG(0x0734)</span>
<span class="cp">#define CR_WEPKEY6			CTL_REG(0x0738)</span>
<span class="cp">#define CR_WEPKEY7			CTL_REG(0x073C)</span>
<span class="cp">#define CR_WEPKEY8			CTL_REG(0x0740)</span>
<span class="cp">#define CR_WEPKEY9			CTL_REG(0x0744)</span>
<span class="cp">#define CR_WEPKEY10			CTL_REG(0x0748)</span>
<span class="cp">#define CR_WEPKEY11			CTL_REG(0x074C)</span>
<span class="cp">#define CR_WEPKEY12			CTL_REG(0x0750)</span>
<span class="cp">#define CR_WEPKEY13			CTL_REG(0x0754)</span>
<span class="cp">#define CR_WEPKEY14			CTL_REG(0x0758)</span>
<span class="cp">#define CR_WEPKEY15			CTL_REG(0x075c)</span>
<span class="cp">#define CR_TKIP_MODE			CTL_REG(0x0760)</span>

<span class="cp">#define CR_EEPROM_PROTECT0		CTL_REG(0x0758)</span>
<span class="cp">#define CR_EEPROM_PROTECT1		CTL_REG(0x075C)</span>

<span class="cp">#define CR_DBG_FIFO_RD			CTL_REG(0x0800)</span>
<span class="cp">#define CR_DBG_SELECT			CTL_REG(0x0804)</span>
<span class="cp">#define CR_FIFO_Length			CTL_REG(0x0808)</span>


<span class="cp">#define CR_RSSI_MGC			CTL_REG(0x0810)</span>

<span class="cp">#define CR_PON				CTL_REG(0x0818)</span>
<span class="cp">#define CR_RX_ON			CTL_REG(0x081C)</span>
<span class="cp">#define CR_TX_ON			CTL_REG(0x0820)</span>
<span class="cp">#define CR_CHIP_EN			CTL_REG(0x0824)</span>
<span class="cp">#define CR_LO_SW			CTL_REG(0x0828)</span>
<span class="cp">#define CR_TXRX_SW			CTL_REG(0x082C)</span>
<span class="cp">#define CR_S_MD				CTL_REG(0x0830)</span>

<span class="cp">#define CR_USB_DEBUG_PORT		CTL_REG(0x0888)</span>
<span class="cp">#define CR_ZD1211B_CWIN_MAX_MIN_AC0	CTL_REG(0x0b00)</span>
<span class="cp">#define CR_ZD1211B_CWIN_MAX_MIN_AC1	CTL_REG(0x0b04)</span>
<span class="cp">#define CR_ZD1211B_CWIN_MAX_MIN_AC2	CTL_REG(0x0b08)</span>
<span class="cp">#define CR_ZD1211B_CWIN_MAX_MIN_AC3	CTL_REG(0x0b0c)</span>
<span class="cp">#define CR_ZD1211B_AIFS_CTL1		CTL_REG(0x0b10)</span>
<span class="cp">#define CR_ZD1211B_AIFS_CTL2		CTL_REG(0x0b14)</span>
<span class="cp">#define CR_ZD1211B_TXOP			CTL_REG(0x0b20)</span>
<span class="cp">#define CR_ZD1211B_RETRY_MAX		CTL_REG(0x0b28)</span>

<span class="cm">/* Value for CR_ZD1211_RETRY_MAX &amp; CR_ZD1211B_RETRY_MAX. Vendor driver uses 2,</span>
<span class="cm"> * we use 0. The first rate is tried (count+2), then all next rates are tried</span>
<span class="cm"> * twice, until 1 Mbits is tried. */</span>
<span class="cp">#define	ZD1211_RETRY_COUNT		0</span>
<span class="cp">#define	ZD1211B_RETRY_COUNT	\</span>
<span class="cp">	(ZD1211_RETRY_COUNT &lt;&lt;  0)|	\</span>
<span class="cp">	(ZD1211_RETRY_COUNT &lt;&lt;  8)|	\</span>
<span class="cp">	(ZD1211_RETRY_COUNT &lt;&lt; 16)|	\</span>
<span class="cp">	(ZD1211_RETRY_COUNT &lt;&lt; 24)</span>

<span class="cm">/* Used to detect PLL lock */</span>
<span class="cp">#define UW2453_INTR_REG			((zd_addr_t)0x85c1)</span>

<span class="cp">#define CWIN_SIZE			0x007f043f</span>


<span class="cp">#define HWINT_ENABLED			\</span>
<span class="cp">	(INT_TX_COMPLETE_EN|		\</span>
<span class="cp">	 INT_RX_COMPLETE_EN|		\</span>
<span class="cp">	 INT_RETRY_FAIL_EN|		\</span>
<span class="cp">	 INT_WAKEUP_EN|			\</span>
<span class="cp">	 INT_CFG_NEXT_BCN_EN)</span>

<span class="cp">#define HWINT_DISABLED			0</span>

<span class="cp">#define E2P_PWR_INT_GUARD		8</span>
<span class="cp">#define E2P_CHANNEL_COUNT		14</span>

<span class="cm">/* If you compare this addresses with the ZYDAS orignal driver, please notify</span>
<span class="cm"> * that we use word mapping for the EEPROM.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Upper 16 bit contains the regulatory domain.</span>
<span class="cm"> */</span>
<span class="cp">#define E2P_SUBID		E2P_DATA(0x00)</span>
<span class="cp">#define E2P_POD			E2P_DATA(0x02)</span>
<span class="cp">#define E2P_MAC_ADDR_P1		E2P_DATA(0x04)</span>
<span class="cp">#define E2P_MAC_ADDR_P2		E2P_DATA(0x06)</span>
<span class="cp">#define E2P_PWR_CAL_VALUE1	E2P_DATA(0x08)</span>
<span class="cp">#define E2P_PWR_CAL_VALUE2	E2P_DATA(0x0a)</span>
<span class="cp">#define E2P_PWR_CAL_VALUE3	E2P_DATA(0x0c)</span>
<span class="cp">#define E2P_PWR_CAL_VALUE4      E2P_DATA(0x0e)</span>
<span class="cp">#define E2P_PWR_INT_VALUE1	E2P_DATA(0x10)</span>
<span class="cp">#define E2P_PWR_INT_VALUE2	E2P_DATA(0x12)</span>
<span class="cp">#define E2P_PWR_INT_VALUE3	E2P_DATA(0x14)</span>
<span class="cp">#define E2P_PWR_INT_VALUE4	E2P_DATA(0x16)</span>

<span class="cm">/* Contains a bit for each allowed channel. It gives for Europe (ETSI 0x30)</span>
<span class="cm"> * also only 11 channels. */</span>
<span class="cp">#define E2P_ALLOWED_CHANNEL	E2P_DATA(0x18)</span>

<span class="cp">#define E2P_DEVICE_VER		E2P_DATA(0x20)</span>
<span class="cp">#define E2P_PHY_REG		E2P_DATA(0x25)</span>
<span class="cp">#define E2P_36M_CAL_VALUE1	E2P_DATA(0x28)</span>
<span class="cp">#define E2P_36M_CAL_VALUE2      E2P_DATA(0x2a)</span>
<span class="cp">#define E2P_36M_CAL_VALUE3      E2P_DATA(0x2c)</span>
<span class="cp">#define E2P_36M_CAL_VALUE4	E2P_DATA(0x2e)</span>
<span class="cp">#define E2P_11A_INT_VALUE1	E2P_DATA(0x30)</span>
<span class="cp">#define E2P_11A_INT_VALUE2	E2P_DATA(0x32)</span>
<span class="cp">#define E2P_11A_INT_VALUE3	E2P_DATA(0x34)</span>
<span class="cp">#define E2P_11A_INT_VALUE4	E2P_DATA(0x36)</span>
<span class="cp">#define E2P_48M_CAL_VALUE1	E2P_DATA(0x38)</span>
<span class="cp">#define E2P_48M_CAL_VALUE2	E2P_DATA(0x3a)</span>
<span class="cp">#define E2P_48M_CAL_VALUE3	E2P_DATA(0x3c)</span>
<span class="cp">#define E2P_48M_CAL_VALUE4	E2P_DATA(0x3e)</span>
<span class="cp">#define E2P_48M_INT_VALUE1	E2P_DATA(0x40)</span>
<span class="cp">#define E2P_48M_INT_VALUE2	E2P_DATA(0x42)</span>
<span class="cp">#define E2P_48M_INT_VALUE3	E2P_DATA(0x44)</span>
<span class="cp">#define E2P_48M_INT_VALUE4	E2P_DATA(0x46)</span>
<span class="cp">#define E2P_54M_CAL_VALUE1	E2P_DATA(0x48)	</span><span class="cm">/* ??? */</span><span class="cp"></span>
<span class="cp">#define E2P_54M_CAL_VALUE2	E2P_DATA(0x4a)</span>
<span class="cp">#define E2P_54M_CAL_VALUE3	E2P_DATA(0x4c)</span>
<span class="cp">#define E2P_54M_CAL_VALUE4	E2P_DATA(0x4e)</span>
<span class="cp">#define E2P_54M_INT_VALUE1	E2P_DATA(0x50)</span>
<span class="cp">#define E2P_54M_INT_VALUE2	E2P_DATA(0x52)</span>
<span class="cp">#define E2P_54M_INT_VALUE3	E2P_DATA(0x54)</span>
<span class="cp">#define E2P_54M_INT_VALUE4	E2P_DATA(0x56)</span>

<span class="cm">/* This word contains the base address of the FW_REG_ registers below */</span>
<span class="cp">#define FWRAW_REGS_ADDR		FWRAW_DATA(0x1d)</span>

<span class="cm">/* All 16 bit values, offset from the address in FWRAW_REGS_ADDR */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">FW_REG_FIRMWARE_VER</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="cm">/* non-zero if USB high speed connection */</span>
	<span class="n">FW_REG_USB_SPEED</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">FW_REG_FIX_TX_RATE</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="cm">/* Seems to be able to control LEDs over the firmware */</span>
	<span class="n">FW_REG_LED_LINK_STATUS</span>	<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">FW_REG_SOFT_RESET</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">FW_REG_FLASH_CHK</span>	<span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Values for FW_LINK_STATUS */</span>
<span class="cp">#define FW_LINK_OFF		0x0</span>
<span class="cp">#define FW_LINK_TX		0x1</span>
<span class="cm">/* 0x2 - link led on? */</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* indices for ofdm_cal_values */</span>
	<span class="n">OFDM_36M_INDEX</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">OFDM_48M_INDEX</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">OFDM_54M_INDEX</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">zd_chip</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">zd_usb</span> <span class="n">usb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zd_rf</span> <span class="n">rf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>
	<span class="cm">/* Base address of FW_REG_ registers */</span>
	<span class="n">zd_addr_t</span> <span class="n">fw_regs_base</span><span class="p">;</span>
	<span class="cm">/* EepSetPoint in the vendor driver */</span>
	<span class="n">u8</span> <span class="n">pwr_cal_values</span><span class="p">[</span><span class="n">E2P_CHANNEL_COUNT</span><span class="p">];</span>
	<span class="cm">/* integration values in the vendor driver */</span>
	<span class="n">u8</span> <span class="n">pwr_int_values</span><span class="p">[</span><span class="n">E2P_CHANNEL_COUNT</span><span class="p">];</span>
	<span class="cm">/* SetPointOFDM in the vendor driver */</span>
	<span class="n">u8</span> <span class="n">ofdm_cal_values</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">E2P_CHANNEL_COUNT</span><span class="p">];</span>
	<span class="n">u16</span> <span class="n">link_led</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pa_type</span><span class="o">:</span><span class="mi">4</span><span class="p">,</span>
		<span class="nl">patch_cck_gain:</span><span class="mi">1</span><span class="p">,</span> <span class="n">patch_cr157</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="n">patch_6m_band_edge</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
		<span class="nl">new_phy_layout:</span><span class="mi">1</span><span class="p">,</span> <span class="n">al2230s_bit</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
		<span class="nl">supports_tx_led:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="nf">zd_usb_to_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_usb</span> <span class="o">*</span><span class="n">usb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">usb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">zd_chip</span><span class="p">,</span> <span class="n">usb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="nf">zd_rf_to_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_rf</span> <span class="o">*</span><span class="n">rf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">rf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">zd_chip</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define zd_chip_dev(chip) (&amp;(chip)-&gt;usb.intf-&gt;dev)</span>

<span class="kt">void</span> <span class="n">zd_chip_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
	         <span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
	         <span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">zd_chip_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">zd_chip_read_mac_addr_fw</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">zd_chip_init_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">zd_chip_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">zd_chip_is_zd1211b</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">.</span><span class="n">is_zd1211b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">zd_ioread16v_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">values</span><span class="p">,</span>
	                              <span class="k">const</span> <span class="n">zd_addr_t</span> <span class="o">*</span><span class="n">addresses</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ZD_ASSERT</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">zd_usb_ioread16v</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">addresses</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">zd_ioread16_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
	                             <span class="k">const</span> <span class="n">zd_addr_t</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ZD_ASSERT</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">zd_usb_ioread16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">zd_ioread32v_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">values</span><span class="p">,</span>
	                <span class="k">const</span> <span class="n">zd_addr_t</span> <span class="o">*</span><span class="n">addresses</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">zd_ioread32_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
	                             <span class="k">const</span> <span class="n">zd_addr_t</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">zd_ioread32v_locked</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">zd_addr_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">zd_iowrite16_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">,</span>
	                              <span class="n">zd_addr_t</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zd_ioreq16</span> <span class="n">ioreq</span><span class="p">;</span>

	<span class="n">ZD_ASSERT</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">));</span>
	<span class="n">ioreq</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">ioreq</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">zd_usb_iowrite16v</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ioreq</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">zd_iowrite16a_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
                         <span class="k">const</span> <span class="k">struct</span> <span class="n">zd_ioreq16</span> <span class="o">*</span><span class="n">ioreqs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">_zd_iowrite32v_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">zd_ioreq32</span> <span class="o">*</span><span class="n">ioreqs</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">zd_iowrite32_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">,</span>
	                              <span class="n">zd_addr_t</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zd_ioreq32</span> <span class="n">ioreq</span><span class="p">;</span>

	<span class="n">ioreq</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">ioreq</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">_zd_iowrite32v_locked</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ioreq</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">zd_iowrite32a_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
	                 <span class="k">const</span> <span class="k">struct</span> <span class="n">zd_ioreq32</span> <span class="o">*</span><span class="n">ioreqs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">zd_rfwrite_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">,</span> <span class="n">u8</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ZD_ASSERT</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">zd_usb_rfwrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">zd_rfwrite_cr_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">zd_rfwritev_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
	               <span class="k">const</span> <span class="n">u32</span><span class="o">*</span> <span class="n">values</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">u8</span> <span class="n">bits</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">zd_rfwritev_cr_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
	                  <span class="k">const</span> <span class="n">u32</span><span class="o">*</span> <span class="n">values</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>

<span class="cm">/* Locking functions for reading and writing registers.</span>
<span class="cm"> * The different parameters are intentional.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">zd_ioread16</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">zd_addr_t</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">zd_iowrite16</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">zd_addr_t</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">zd_ioread32</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">zd_addr_t</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">zd_iowrite32</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">zd_addr_t</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">zd_ioread32v</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">const</span> <span class="n">zd_addr_t</span> <span class="o">*</span><span class="n">addresses</span><span class="p">,</span>
	          <span class="n">u32</span> <span class="o">*</span><span class="n">values</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">zd_iowrite32a</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">zd_ioreq32</span> <span class="o">*</span><span class="n">ioreqs</span><span class="p">,</span>
	           <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">zd_chip_set_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u8</span> <span class="n">channel</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">_zd_chip_get_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">rf</span><span class="p">.</span><span class="n">channel</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">u8</span>  <span class="n">zd_chip_get_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">zd_read_regdomain</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">regdomain</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">zd_write_mac_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac_addr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">zd_write_bssid</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">bssid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">zd_chip_switch_radio_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">zd_chip_switch_radio_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">zd_chip_enable_int</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">zd_chip_disable_int</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">zd_chip_enable_rxtx</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">zd_chip_disable_rxtx</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">zd_chip_enable_hwint</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">zd_chip_disable_hwint</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">zd_chip_generic_patch_6m_band</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">zd_chip_set_rts_cts_rate_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">preamble</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">zd_get_encryption_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">zd_ioread32</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CR_ENCRYPTION_TYPE</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">zd_set_encryption_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u32</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">zd_iowrite32</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CR_ENCRYPTION_TYPE</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">zd_chip_get_basic_rates</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">cr_rates</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">zd_ioread16</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CR_BASIC_RATE_TBL</span><span class="p">,</span> <span class="n">cr_rates</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">zd_chip_set_basic_rates</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u16</span> <span class="n">cr_rates</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">zd_chip_lock_phy_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">zd_chip_unlock_phy_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">led_status</span> <span class="p">{</span>
	<span class="n">ZD_LED_OFF</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">ZD_LED_SCANNING</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">ZD_LED_ASSOCIATED</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">zd_chip_control_leds</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">enum</span> <span class="n">led_status</span> <span class="n">status</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">zd_set_beacon_interval</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u16</span> <span class="n">interval</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dtim_period</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">zd_get_beacon_interval</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">interval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">zd_ioread32</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CR_BCN_INTERVAL</span><span class="p">,</span> <span class="n">interval</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">rx_status</span><span class="p">;</span>

<span class="n">u8</span> <span class="n">zd_rx_rate</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">rx_frame</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rx_status</span> <span class="o">*</span><span class="n">status</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">zd_mc_hash</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">low</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">high</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">zd_mc_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_mc_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hash</span><span class="o">-&gt;</span><span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* The interfaces must always received broadcasts.</span>
<span class="cm">	 * The hash of the broadcast address ff:ff:ff:ff:ff:ff is 63.</span>
<span class="cm">	 */</span>
	<span class="n">hash</span><span class="o">-&gt;</span><span class="n">high</span> <span class="o">=</span> <span class="mh">0x80000000</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">zd_mc_add_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_mc_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hash</span><span class="o">-&gt;</span><span class="n">low</span> <span class="o">=</span> <span class="n">hash</span><span class="o">-&gt;</span><span class="n">high</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">zd_mc_add_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_mc_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">addr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hash</span><span class="o">-&gt;</span><span class="n">low</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hash</span><span class="o">-&gt;</span><span class="n">high</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">32</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">zd_chip_set_multicast_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
	                       <span class="k">struct</span> <span class="n">zd_mc_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">);</span>

<span class="n">u64</span> <span class="n">zd_chip_get_tsf</span><span class="p">(</span><span class="k">struct</span> <span class="n">zd_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* _ZD_CHIP_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
