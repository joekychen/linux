<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › prism54 › islpci_dev.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>islpci_dev.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Copyright (C) 2002 Intersil Americas Inc.</span>
<span class="cm"> *  Copyright (C) 2003 Herbert Valerio Riedel &lt;hvr@gnu.org&gt;</span>
<span class="cm"> *  Copyright (C) 2003 Luis R. Rodriguez &lt;mcgrof@ruslug.rutgers.edu&gt;</span>
<span class="cm"> *  Copyright (C) 2003 Aurelien Alleaume &lt;slts@free.fr&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation; either version 2 of the License</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; if not, write to the Free Software</span>
<span class="cm"> *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _ISLPCI_DEV_H</span>
<span class="cp">#define _ISLPCI_DEV_H</span>

<span class="cp">#include &lt;linux/irqreturn.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/wireless.h&gt;</span>
<span class="cp">#include &lt;net/iw_handler.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>

<span class="cp">#include &quot;isl_38xx.h&quot;</span>
<span class="cp">#include &quot;isl_oid.h&quot;</span>
<span class="cp">#include &quot;islpci_mgt.h&quot;</span>

<span class="cm">/* some states might not be superflous and may be removed when</span>
<span class="cm">   design is finalized (hvr) */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">PRV_STATE_OFF</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* this means hw_unavailable is != 0 */</span>
	<span class="n">PRV_STATE_PREBOOT</span><span class="p">,</span>	<span class="cm">/* we are in a pre-boot state (empty RAM) */</span>
	<span class="n">PRV_STATE_BOOT</span><span class="p">,</span>		<span class="cm">/* boot state (fw upload, run fw) */</span>
	<span class="n">PRV_STATE_POSTBOOT</span><span class="p">,</span>	<span class="cm">/* after boot state, need reset now */</span>
	<span class="n">PRV_STATE_PREINIT</span><span class="p">,</span>	<span class="cm">/* pre-init state */</span>
	<span class="n">PRV_STATE_INIT</span><span class="p">,</span>		<span class="cm">/* init state (restore MIB backup to device) */</span>
	<span class="n">PRV_STATE_READY</span><span class="p">,</span>	<span class="cm">/* driver&amp;device are in operational state */</span>
	<span class="n">PRV_STATE_SLEEP</span>		<span class="cm">/* device in sleep mode */</span>
<span class="p">}</span> <span class="n">islpci_state_t</span><span class="p">;</span>

<span class="cm">/* ACL using MAC address */</span>
<span class="k">struct</span> <span class="n">mac_entry</span> <span class="p">{</span>
   <span class="k">struct</span> <span class="n">list_head</span> <span class="n">_list</span><span class="p">;</span>
   <span class="kt">char</span> <span class="n">addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">islpci_acl</span> <span class="p">{</span>
   <span class="k">enum</span> <span class="p">{</span> <span class="n">MAC_POLICY_OPEN</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">MAC_POLICY_ACCEPT</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">MAC_POLICY_REJECT</span><span class="o">=</span><span class="mi">2</span> <span class="p">}</span> <span class="n">policy</span><span class="p">;</span>
   <span class="k">struct</span> <span class="n">list_head</span> <span class="n">mac_list</span><span class="p">;</span>  <span class="cm">/* a list of mac_entry */</span>
   <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>   <span class="cm">/* size of queue */</span>
   <span class="k">struct</span> <span class="n">mutex</span> <span class="n">lock</span><span class="p">;</span>   <span class="cm">/* accessed in ioctls and trap_work */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">islpci_membuf</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>                   <span class="cm">/* size of memory */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">mem</span><span class="p">;</span>                  <span class="cm">/* address of memory as seen by CPU */</span>
	<span class="n">dma_addr_t</span> <span class="n">pci_addr</span><span class="p">;</span>        <span class="cm">/* address of memory as seen by device */</span>
<span class="p">};</span>

<span class="cp">#define MAX_BSS_WPA_IE_COUNT 64</span>
<span class="cp">#define MAX_WPA_IE_LEN 64</span>
<span class="k">struct</span> <span class="n">islpci_bss_wpa_ie</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_update</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bssid</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">wpa_ie</span><span class="p">[</span><span class="n">MAX_WPA_IE_LEN</span><span class="p">];</span>
	<span class="kt">size_t</span> <span class="n">wpa_ie_len</span><span class="p">;</span>

<span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="n">slock</span><span class="p">;</span>	<span class="cm">/* generic spinlock; */</span>

	<span class="n">u32</span> <span class="n">priv_oid</span><span class="p">;</span>

	<span class="cm">/* our mib cache */</span>
	<span class="n">u32</span> <span class="n">iw_mode</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">mib_sem</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">mib</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">nickname</span><span class="p">[</span><span class="n">IW_ESSID_MAX_SIZE</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>

	<span class="cm">/* Take care of the wireless stats */</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">stats_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">stats_lock</span><span class="p">;</span>
	<span class="cm">/* remember when we last updated the stats */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stats_timestamp</span><span class="p">;</span>
	<span class="cm">/* The first is accessed under semaphore locking.</span>
<span class="cm">	 * The second is the clean one we return to iwconfig.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">iw_statistics</span> <span class="n">local_iwstatistics</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iw_statistics</span> <span class="n">iwstatistics</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">iw_spy_data</span> <span class="n">spy_data</span><span class="p">;</span> <span class="cm">/* iwspy support */</span>

	<span class="k">struct</span> <span class="n">iw_public_data</span> <span class="n">wireless_data</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">monitor_type</span><span class="p">;</span> <span class="cm">/* ARPHRD_IEEE80211 or ARPHRD_IEEE80211_PRISM */</span>

	<span class="k">struct</span> <span class="n">islpci_acl</span> <span class="n">acl</span><span class="p">;</span>

	<span class="cm">/* PCI bus allocation &amp; configuration members */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>	<span class="cm">/* PCI structure information */</span>
	<span class="kt">char</span> <span class="n">firmware</span><span class="p">[</span><span class="mi">33</span><span class="p">];</span>

	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">device_base</span><span class="p">;</span>	<span class="cm">/* ioremapped device base address */</span>

	<span class="cm">/* consistent DMA region */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">driver_mem_address</span><span class="p">;</span>	<span class="cm">/* base DMA address */</span>
	<span class="n">dma_addr_t</span> <span class="n">device_host_address</span><span class="p">;</span>	<span class="cm">/* base DMA address (bus address) */</span>
	<span class="n">dma_addr_t</span> <span class="n">device_psm_buffer</span><span class="p">;</span>	<span class="cm">/* host memory for PSM buffering (bus address) */</span>

	<span class="cm">/* our network_device structure  */</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">;</span>

	<span class="cm">/* device queue interface members */</span>
	<span class="k">struct</span> <span class="n">isl38xx_cb</span> <span class="o">*</span><span class="n">control_block</span><span class="p">;</span>	<span class="cm">/* device control block</span>
<span class="cm">							   (== driver_mem_address!) */</span>

	<span class="cm">/* Each queue has three indexes:</span>
<span class="cm">	 *   free/index_mgmt/data_rx/tx (called index, see below),</span>
<span class="cm">	 *   driver_curr_frag, and device_curr_frag (in the control block)</span>
<span class="cm">	 * All indexes are ever-increasing, but interpreted modulo the</span>
<span class="cm">	 * device queue size when used.</span>
<span class="cm">	 *   index &lt;= device_curr_frag &lt;= driver_curr_frag  at all times</span>
<span class="cm">	 * For rx queues, [index, device_curr_frag) contains fragments</span>
<span class="cm">	 * that the interrupt processing needs to handle (owned by driver).</span>
<span class="cm">	 * [device_curr_frag, driver_curr_frag) is the free space in the</span>
<span class="cm">	 * rx queue, waiting for data (owned by device).  The driver</span>
<span class="cm">	 * increments driver_curr_frag to indicate to the device that more</span>
<span class="cm">	 * buffers are available.</span>
<span class="cm">	 * If device_curr_frag == driver_curr_frag, no more rx buffers are</span>
<span class="cm">	 * available, and the rx DMA engine of the device is halted.</span>
<span class="cm">	 * For tx queues, [index, device_curr_frag) contains fragments</span>
<span class="cm">	 * where tx is done; they need to be freed (owned by driver).</span>
<span class="cm">	 * [device_curr_frag, driver_curr_frag) contains the frames</span>
<span class="cm">	 * that are being transferred (owned by device).  The driver</span>
<span class="cm">	 * increments driver_curr_frag to indicate that more tx work</span>
<span class="cm">	 * needs to be done.</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">index_mgmt_rx</span><span class="p">;</span>              <span class="cm">/* real index mgmt rx queue */</span>
	<span class="n">u32</span> <span class="n">index_mgmt_tx</span><span class="p">;</span>              <span class="cm">/* read index mgmt tx queue */</span>
	<span class="n">u32</span> <span class="n">free_data_rx</span><span class="p">;</span>	<span class="cm">/* free pointer data rx queue */</span>
	<span class="n">u32</span> <span class="n">free_data_tx</span><span class="p">;</span>	<span class="cm">/* free pointer data tx queue */</span>
	<span class="n">u32</span> <span class="n">data_low_tx_full</span><span class="p">;</span>	<span class="cm">/* full detected flag */</span>

	<span class="cm">/* frame memory buffers for the device queues */</span>
	<span class="k">struct</span> <span class="n">islpci_membuf</span> <span class="n">mgmt_tx</span><span class="p">[</span><span class="n">ISL38XX_CB_MGMT_QSIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">islpci_membuf</span> <span class="n">mgmt_rx</span><span class="p">[</span><span class="n">ISL38XX_CB_MGMT_QSIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">data_low_tx</span><span class="p">[</span><span class="n">ISL38XX_CB_TX_QSIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">data_low_rx</span><span class="p">[</span><span class="n">ISL38XX_CB_RX_QSIZE</span><span class="p">];</span>
	<span class="n">dma_addr_t</span> <span class="n">pci_map_tx_address</span><span class="p">[</span><span class="n">ISL38XX_CB_TX_QSIZE</span><span class="p">];</span>
	<span class="n">dma_addr_t</span> <span class="n">pci_map_rx_address</span><span class="p">[</span><span class="n">ISL38XX_CB_RX_QSIZE</span><span class="p">];</span>

	<span class="cm">/* wait for a reset interrupt */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">reset_done</span><span class="p">;</span>

	<span class="cm">/* used by islpci_mgt_transaction */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mgmt_lock</span><span class="p">;</span> <span class="cm">/* serialize access to mailbox and wqueue */</span>
	<span class="k">struct</span> <span class="n">islpci_mgmtframe</span> <span class="o">*</span><span class="n">mgmt_received</span><span class="p">;</span>	  <span class="cm">/* mbox for incoming frame */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">mgmt_wqueue</span><span class="p">;</span>            <span class="cm">/* waitqueue for mbox */</span>

	<span class="cm">/* state machine */</span>
	<span class="n">islpci_state_t</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">state_off</span><span class="p">;</span>		<span class="cm">/* enumeration of off-state, if 0 then</span>
<span class="cm">				 * we&#39;re not in any off-state */</span>

	<span class="cm">/* WPA stuff */</span>
	<span class="kt">int</span> <span class="n">wpa</span><span class="p">;</span> <span class="cm">/* WPA mode enabled */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">bss_wpa_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_bss_wpa</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">wpa_lock</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">wpa_ie</span><span class="p">[</span><span class="n">MAX_WPA_IE_LEN</span><span class="p">];</span>
	<span class="kt">size_t</span> <span class="n">wpa_ie_len</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">reset_task</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reset_task_pending</span><span class="p">;</span>
<span class="p">}</span> <span class="n">islpci_private</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">islpci_state_t</span>
<span class="nf">islpci_get_state</span><span class="p">(</span><span class="n">islpci_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* lock */</span>
	<span class="k">return</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
	<span class="cm">/* unlock */</span>
<span class="p">}</span>

<span class="n">islpci_state_t</span> <span class="n">islpci_set_state</span><span class="p">(</span><span class="n">islpci_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="n">islpci_state_t</span> <span class="n">new_state</span><span class="p">);</span>

<span class="cp">#define ISLPCI_TX_TIMEOUT               (2*HZ)</span>

<span class="n">irqreturn_t</span> <span class="n">islpci_interrupt</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">prism54_post_setup</span><span class="p">(</span><span class="n">islpci_private</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">islpci_reset</span><span class="p">(</span><span class="n">islpci_private</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">islpci_trigger</span><span class="p">(</span><span class="n">islpci_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">isl38xx_trigger_device</span><span class="p">(</span><span class="n">islpci_get_state</span><span class="p">(</span><span class="n">priv</span><span class="p">)</span> <span class="o">==</span> <span class="n">PRV_STATE_SLEEP</span><span class="p">,</span>
			       <span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_base</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">islpci_free_memory</span><span class="p">(</span><span class="n">islpci_private</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">islpci_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#define DRV_NAME	&quot;prism54&quot;</span>
<span class="cp">#define DRV_VERSION	&quot;1.2&quot;</span>

<span class="cp">#endif				</span><span class="cm">/* _ISLPCI_DEV_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
