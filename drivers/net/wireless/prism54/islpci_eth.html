<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › prism54 › islpci_eth.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>islpci_eth.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Copyright (C) 2002 Intersil Americas Inc.</span>
<span class="cm"> *  Copyright (C) 2004 Aurelien Alleaume &lt;slts@free.fr&gt;</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation; either version 2 of the License</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; if not, write to the Free Software</span>
<span class="cm"> *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>

<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/if_arp.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="cp">#include &quot;prismcompat.h&quot;</span>
<span class="cp">#include &quot;isl_38xx.h&quot;</span>
<span class="cp">#include &quot;islpci_eth.h&quot;</span>
<span class="cp">#include &quot;islpci_mgt.h&quot;</span>
<span class="cp">#include &quot;oid_mgt.h&quot;</span>

<span class="cm">/******************************************************************************</span>
<span class="cm">    Network Interface functions</span>
<span class="cm">******************************************************************************/</span>
<span class="kt">void</span>
<span class="nf">islpci_eth_cleanup_transmit</span><span class="p">(</span><span class="n">islpci_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
			    <span class="n">isl38xx_control_block</span> <span class="o">*</span><span class="n">control_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>

	<span class="cm">/* compare the control block read pointer with the free pointer */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">free_data_tx</span> <span class="o">!=</span>
	       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">control_block</span><span class="o">-&gt;</span>
			   <span class="n">device_curr_frag</span><span class="p">[</span><span class="n">ISL38XX_CB_TX_DATA_LQ</span><span class="p">]))</span> <span class="p">{</span>
		<span class="cm">/* read the index of the first fragment to be freed */</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">free_data_tx</span> <span class="o">%</span> <span class="n">ISL38XX_CB_TX_QSIZE</span><span class="p">;</span>

		<span class="cm">/* check for holes in the arrays caused by multi fragment frames</span>
<span class="cm">		 * searching for the last fragment of a frame */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">pci_map_tx_address</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="p">{</span>
			<span class="cm">/* entry is the last fragment of a frame</span>
<span class="cm">			 * free the skb structure and unmap pci memory */</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">data_low_tx</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

<span class="cp">#if VERBOSE &gt; SHOW_ERROR_MESSAGES</span>
			<span class="n">DEBUG</span><span class="p">(</span><span class="n">SHOW_TRACING</span><span class="p">,</span>
			      <span class="s">&quot;cleanup skb %p skb-&gt;data %p skb-&gt;len %u truesize %u</span><span class="se">\n</span><span class="s"> &quot;</span><span class="p">,</span>
			      <span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">);</span>
<span class="cp">#endif</span>

			<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
					 <span class="n">priv</span><span class="o">-&gt;</span><span class="n">pci_map_tx_address</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
					 <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
			<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* increment the free data low queue pointer */</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">free_data_tx</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">netdev_tx_t</span>
<span class="nf">islpci_eth_transmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">islpci_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="n">isl38xx_control_block</span> <span class="o">*</span><span class="n">cb</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">control_block</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">pci_map_address</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">frame_size</span><span class="p">;</span>
	<span class="n">isl38xx_fragment</span> <span class="o">*</span><span class="n">fragment</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">newskb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">newskb_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">wds_mac</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">curr_frag</span><span class="p">;</span>

<span class="cp">#if VERBOSE &gt; SHOW_ERROR_MESSAGES</span>
	<span class="n">DEBUG</span><span class="p">(</span><span class="n">SHOW_FUNCTION_CALLS</span><span class="p">,</span> <span class="s">&quot;islpci_eth_transmit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* lock the driver code */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">slock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* check whether the destination queue has enough fragments for the frame */</span>
	<span class="n">curr_frag</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">driver_curr_frag</span><span class="p">[</span><span class="n">ISL38XX_CB_TX_DATA_LQ</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">curr_frag</span> <span class="o">-</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">free_data_tx</span> <span class="o">&gt;=</span> <span class="n">ISL38XX_CB_TX_QSIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: transmit device queue full when awake</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ndev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>

		<span class="cm">/* trigger the device */</span>
		<span class="n">isl38xx_w32_flush</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_base</span><span class="p">,</span> <span class="n">ISL38XX_DEV_INT_UPDATE</span><span class="p">,</span>
				  <span class="n">ISL38XX_DEV_INT_REG</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">ISL38XX_WRITEIO_DELAY</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">drop_free</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Check alignment and WDS frame formatting. The start of the packet should</span>
<span class="cm">	 * be aligned on a 4-byte boundary. If WDS is enabled add another 6 bytes</span>
<span class="cm">	 * and add WDS address information */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(((</span><span class="kt">long</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">)</span> <span class="o">|</span> <span class="n">init_wds</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* get the number of bytes to add and re-align */</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span> <span class="o">-</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">init_wds</span> <span class="o">?</span> <span class="mi">6</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* check whether the current skb can be used  */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">skb_tailroom</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">offset</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

<span class="cp">#if VERBOSE &gt; SHOW_ERROR_MESSAGES</span>
			<span class="n">DEBUG</span><span class="p">(</span><span class="n">SHOW_TRACING</span><span class="p">,</span> <span class="s">&quot;skb offset %i wds %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
			      <span class="n">init_wds</span><span class="p">);</span>
<span class="cp">#endif</span>

			<span class="cm">/* align the buffer on 4-byte boundary */</span>
			<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span> <span class="o">-</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">init_wds</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* wds requires an additional address field of 6 bytes */</span>
				<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="cp">#ifdef ISLPCI_ETH_DEBUG</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;islpci_eth_transmit:wds_mac</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
				<span class="n">memmove</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="mi">6</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
				<span class="n">skb_copy_to_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">wds_mac</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">memmove</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
			<span class="p">}</span>

<span class="cp">#if VERBOSE &gt; SHOW_ERROR_MESSAGES</span>
			<span class="n">DEBUG</span><span class="p">(</span><span class="n">SHOW_TRACING</span><span class="p">,</span> <span class="s">&quot;memmove %p %p %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
			      <span class="n">src</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">newskb</span> <span class="o">=</span>
			    <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">init_wds</span> <span class="o">?</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">6</span> <span class="o">:</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">newskb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Cannot allocate skb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">ndev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">drop_free</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">newskb_offset</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span> <span class="o">-</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">newskb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">;</span>

			<span class="cm">/* Check if newskb-&gt;data is aligned */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">newskb_offset</span><span class="p">)</span>
				<span class="n">skb_reserve</span><span class="p">(</span><span class="n">newskb</span><span class="p">,</span> <span class="n">newskb_offset</span><span class="p">);</span>

			<span class="n">skb_put</span><span class="p">(</span><span class="n">newskb</span><span class="p">,</span> <span class="n">init_wds</span> <span class="o">?</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">6</span> <span class="o">:</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">init_wds</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">skb_copy_from_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
							  <span class="n">newskb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="mi">6</span><span class="p">,</span>
							  <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
				<span class="n">skb_copy_to_linear_data</span><span class="p">(</span><span class="n">newskb</span><span class="p">,</span> <span class="n">wds_mac</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="cp">#ifdef ISLPCI_ETH_DEBUG</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;islpci_eth_transmit:wds_mac</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">skb_copy_from_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">newskb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
							  <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

<span class="cp">#if VERBOSE &gt; SHOW_ERROR_MESSAGES</span>
			<span class="n">DEBUG</span><span class="p">(</span><span class="n">SHOW_TRACING</span><span class="p">,</span> <span class="s">&quot;memcpy %p %p %i wds %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">newskb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">init_wds</span><span class="p">);</span>
<span class="cp">#endif</span>

			<span class="n">newskb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
			<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">newskb</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* display the buffer contents for debugging */</span>
<span class="cp">#if VERBOSE &gt; SHOW_ERROR_MESSAGES</span>
	<span class="n">DEBUG</span><span class="p">(</span><span class="n">SHOW_BUFFER_CONTENTS</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">tx %p &quot;</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">display_buffer</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* map the skb buffer to pci memory for DMA operation */</span>
	<span class="n">pci_map_address</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
					 <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pci_map_address</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: cannot map buffer to PCI</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ndev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">drop_free</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Place the fragment in the control block structure. */</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">curr_frag</span> <span class="o">%</span> <span class="n">ISL38XX_CB_TX_QSIZE</span><span class="p">;</span>
	<span class="n">fragment</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">tx_data_low</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">pci_map_tx_address</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">pci_map_address</span><span class="p">;</span>
	<span class="cm">/* store the skb address for future freeing  */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">data_low_tx</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="cm">/* set the proper fragment start address and size information */</span>
	<span class="n">frame_size</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">fragment</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">frame_size</span><span class="p">);</span>
	<span class="n">fragment</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>	<span class="cm">/* set to 1 if more fragments */</span>
	<span class="n">fragment</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">pci_map_address</span><span class="p">);</span>
	<span class="n">curr_frag</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* The fragment address in the control block must have been</span>
<span class="cm">	 * written before announcing the frame buffer to device. */</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">driver_curr_frag</span><span class="p">[</span><span class="n">ISL38XX_CB_TX_DATA_LQ</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">curr_frag</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">curr_frag</span> <span class="o">-</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">free_data_tx</span> <span class="o">+</span> <span class="n">ISL38XX_MIN_QTHRESHOLD</span>
	    <span class="o">&gt;</span> <span class="n">ISL38XX_CB_TX_QSIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* stop sends from upper layers */</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>

		<span class="cm">/* set the full flag for the transmission queue */</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">data_low_tx_full</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ndev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">ndev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="cm">/* trigger the device */</span>
	<span class="n">islpci_trigger</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="cm">/* unlock the driver code */</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">slock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>

      <span class="nl">drop_free:</span>
	<span class="n">ndev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_dropped</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">slock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">islpci_monitor_rx</span><span class="p">(</span><span class="n">islpci_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* The card reports full 802.11 packets but with a 20 bytes</span>
<span class="cm">	 * header and without the FCS. But there a is a bit that</span>
<span class="cm">	 * indicates if the packet is corrupted :-) */</span>
	<span class="k">struct</span> <span class="n">rfmon_header</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rfmon_header</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span>
		<span class="cm">/* This one is bad. Drop it ! */</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">ARPHRD_IEEE80211_PRISM</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">avs_80211_1_header</span> <span class="o">*</span><span class="n">avs</span><span class="p">;</span>
		<span class="cm">/* extract the relevant data from the header */</span>
		<span class="n">u32</span> <span class="n">clock</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">);</span>
		<span class="n">u8</span> <span class="n">rate</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">freq</span><span class="p">);</span>
		<span class="n">u8</span> <span class="n">rssi</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">rssi</span><span class="p">;</span>

		<span class="n">skb_pull</span><span class="p">(</span><span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rfmon_header</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb_headroom</span><span class="p">(</span><span class="o">*</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">avs_80211_1_header</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">newskb</span> <span class="o">=</span> <span class="n">skb_copy_expand</span><span class="p">(</span><span class="o">*</span><span class="n">skb</span><span class="p">,</span>
								 <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span>
									 <span class="n">avs_80211_1_header</span><span class="p">),</span>
								 <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">newskb</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="o">*</span><span class="n">skb</span><span class="p">);</span>
				<span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">newskb</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* This behavior is not very subtile... */</span>
		<span class="p">}</span>

		<span class="cm">/* make room for the new header and fill it. */</span>
		<span class="n">avs</span> <span class="o">=</span>
		    <span class="p">(</span><span class="k">struct</span> <span class="n">avs_80211_1_header</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb_push</span><span class="p">(</span><span class="o">*</span><span class="n">skb</span><span class="p">,</span>
							   <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span>
								   <span class="n">avs_80211_1_header</span><span class="p">));</span>

		<span class="n">avs</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">P80211CAPTURE_VERSION</span><span class="p">);</span>
		<span class="n">avs</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">avs_80211_1_header</span><span class="p">));</span>
		<span class="n">avs</span><span class="o">-&gt;</span><span class="n">mactime</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">clock</span><span class="p">);</span>
		<span class="n">avs</span><span class="o">-&gt;</span><span class="n">hosttime</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">jiffies</span><span class="p">);</span>
		<span class="n">avs</span><span class="o">-&gt;</span><span class="n">phytype</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>	<span class="cm">/*OFDM: 6 for (g), 8 for (a) */</span>
		<span class="n">avs</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">channel_of_freq</span><span class="p">(</span><span class="n">freq</span><span class="p">));</span>
		<span class="n">avs</span><span class="o">-&gt;</span><span class="n">datarate</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">rate</span> <span class="o">*</span> <span class="mi">5</span><span class="p">);</span>
		<span class="n">avs</span><span class="o">-&gt;</span><span class="n">antenna</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>	<span class="cm">/*unknown */</span>
		<span class="n">avs</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>	<span class="cm">/*unknown */</span>
		<span class="n">avs</span><span class="o">-&gt;</span><span class="n">ssi_type</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>	<span class="cm">/*2: dBm, 3: raw RSSI */</span>
		<span class="n">avs</span><span class="o">-&gt;</span><span class="n">ssi_signal</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">rssi</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">);</span>
		<span class="n">avs</span><span class="o">-&gt;</span><span class="n">ssi_noise</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">local_iwstatistics</span><span class="p">.</span><span class="n">qual</span><span class="p">.</span><span class="n">noise</span><span class="p">);</span>	<span class="cm">/*better than &#39;undefined&#39;, I assume */</span>
		<span class="n">avs</span><span class="o">-&gt;</span><span class="n">preamble</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>	<span class="cm">/*unknown */</span>
		<span class="n">avs</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>	<span class="cm">/*unknown */</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">skb_pull</span><span class="p">(</span><span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rfmon_header</span><span class="p">));</span>

	<span class="p">(</span><span class="o">*</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_802_2</span><span class="p">);</span>
	<span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="o">*</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">(</span><span class="o">*</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">=</span> <span class="n">PACKET_OTHERHOST</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">islpci_eth_receive</span><span class="p">(</span><span class="n">islpci_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">;</span>
	<span class="n">isl38xx_control_block</span> <span class="o">*</span><span class="n">control_block</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">control_block</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">discard</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#if VERBOSE &gt; SHOW_ERROR_MESSAGES</span>
	<span class="n">DEBUG</span><span class="p">(</span><span class="n">SHOW_FUNCTION_CALLS</span><span class="p">,</span> <span class="s">&quot;islpci_eth_receive</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* the device has written an Ethernet frame in the data area</span>
<span class="cm">	 * of the sk_buff without updating the structure, do it now */</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">free_data_rx</span> <span class="o">%</span> <span class="n">ISL38XX_CB_RX_QSIZE</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">control_block</span><span class="o">-&gt;</span><span class="n">rx_data_low</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">size</span><span class="p">);</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">data_low_rx</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span>
		  <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">control_block</span><span class="o">-&gt;</span><span class="n">rx_data_low</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">address</span><span class="p">)</span> <span class="o">-</span>
		  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>

<span class="cp">#if VERBOSE &gt; SHOW_ERROR_MESSAGES</span>
	<span class="n">DEBUG</span><span class="p">(</span><span class="n">SHOW_TRACING</span><span class="p">,</span>
	      <span class="s">&quot;frq-&gt;addr %x skb-&gt;data %p skb-&gt;len %u offset %u truesize %u</span><span class="se">\n</span><span class="s"> &quot;</span><span class="p">,</span>
	      <span class="n">control_block</span><span class="o">-&gt;</span><span class="n">rx_data_low</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">free_data_rx</span><span class="p">].</span><span class="n">address</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
	      <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* delete the streaming DMA mapping before processing the skb */</span>
	<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
			 <span class="n">priv</span><span class="o">-&gt;</span><span class="n">pci_map_rx_address</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
			 <span class="n">MAX_FRAGMENT_SIZE_RX</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>

	<span class="cm">/* update the skb structure and align the buffer */</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* shift the buffer allocation offset bytes to get the right frame */</span>
		<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#if VERBOSE &gt; SHOW_ERROR_MESSAGES</span>
	<span class="cm">/* display the buffer contents for debugging */</span>
	<span class="n">DEBUG</span><span class="p">(</span><span class="n">SHOW_BUFFER_CONTENTS</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">rx %p &quot;</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">display_buffer</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* check whether WDS is enabled and whether the data frame is a WDS frame */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">init_wds</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* WDS enabled, check for the wds address on the first 6 bytes of the buffer */</span>
		<span class="n">src</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="mi">6</span><span class="p">;</span>
		<span class="n">memmove</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="mi">6</span><span class="p">);</span>
		<span class="n">skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="mi">6</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#if VERBOSE &gt; SHOW_ERROR_MESSAGES</span>
	<span class="n">DEBUG</span><span class="p">(</span><span class="n">SHOW_TRACING</span><span class="p">,</span> <span class="s">&quot;Fragment size %i in skb at %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">DEBUG</span><span class="p">(</span><span class="n">SHOW_TRACING</span><span class="p">,</span> <span class="s">&quot;Skb data at %p, length %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="cm">/* display the buffer contents for debugging */</span>
	<span class="n">DEBUG</span><span class="p">(</span><span class="n">SHOW_BUFFER_CONTENTS</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">rx %p &quot;</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">display_buffer</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="cm">/* take care of monitor mode and spy monitoring. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">iw_mode</span> <span class="o">==</span> <span class="n">IW_MODE_MONITOR</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">ndev</span><span class="p">;</span>
		<span class="n">discard</span> <span class="o">=</span> <span class="n">islpci_monitor_rx</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ETH_ALEN</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* The packet has a rx_annex. Read it for spy monitoring, Then</span>
<span class="cm">			 * remove it, while keeping the 2 leading MAC addr.</span>
<span class="cm">			 */</span>
			<span class="k">struct</span> <span class="n">iw_quality</span> <span class="n">wstats</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">rx_annex_header</span> <span class="o">*</span><span class="n">annex</span> <span class="o">=</span>
			    <span class="p">(</span><span class="k">struct</span> <span class="n">rx_annex_header</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="n">wstats</span><span class="p">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">annex</span><span class="o">-&gt;</span><span class="n">rfmon</span><span class="p">.</span><span class="n">rssi</span><span class="p">;</span>
			<span class="cm">/* The noise value can be a bit outdated if nobody&#39;s</span>
<span class="cm">			 * reading wireless stats... */</span>
			<span class="n">wstats</span><span class="p">.</span><span class="n">noise</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">local_iwstatistics</span><span class="p">.</span><span class="n">qual</span><span class="p">.</span><span class="n">noise</span><span class="p">;</span>
			<span class="n">wstats</span><span class="p">.</span><span class="n">qual</span> <span class="o">=</span> <span class="n">wstats</span><span class="p">.</span><span class="n">level</span> <span class="o">-</span> <span class="n">wstats</span><span class="p">.</span><span class="n">noise</span><span class="p">;</span>
			<span class="n">wstats</span><span class="p">.</span><span class="n">updated</span> <span class="o">=</span> <span class="mh">0x07</span><span class="p">;</span>
			<span class="cm">/* Update spy records */</span>
			<span class="n">wireless_spy_update</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="n">annex</span><span class="o">-&gt;</span><span class="n">addr2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wstats</span><span class="p">);</span>

			<span class="n">skb_copy_from_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
						  <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span>
						   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfmon_header</span><span class="p">)),</span>
						  <span class="mi">2</span> <span class="o">*</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
			<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rfmon_header</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ndev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_NONE</span><span class="p">;</span>
	<span class="n">ndev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">ndev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/* deliver the skb to the network layer */</span>
<span class="cp">#ifdef ISLPCI_ETH_DEBUG</span>
	<span class="n">printk</span>
	    <span class="p">(</span><span class="s">&quot;islpci_eth_receive:netif_rx %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
	     <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">discard</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* increment the read index for the rx data low queue */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">free_data_rx</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* add one or more sk_buff structures */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span>
	       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">control_block</span><span class="o">-&gt;</span>
			   <span class="n">driver_curr_frag</span><span class="p">[</span><span class="n">ISL38XX_CB_RX_DATA_LQ</span><span class="p">]),</span>
	       <span class="n">index</span> <span class="o">-</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">free_data_rx</span> <span class="o">&lt;</span> <span class="n">ISL38XX_CB_RX_QSIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* allocate an sk_buff for received data frames storage</span>
<span class="cm">		 * include any required allignment operations */</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">MAX_FRAGMENT_SIZE_RX</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* error allocating an sk_buff structure elements */</span>
			<span class="n">DEBUG</span><span class="p">(</span><span class="n">SHOW_ERROR_MESSAGES</span><span class="p">,</span> <span class="s">&quot;Error allocating skb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span> <span class="o">-</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">);</span>
		<span class="cm">/* store the new skb structure pointer */</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">%</span> <span class="n">ISL38XX_CB_RX_QSIZE</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">data_low_rx</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

<span class="cp">#if VERBOSE &gt; SHOW_ERROR_MESSAGES</span>
		<span class="n">DEBUG</span><span class="p">(</span><span class="n">SHOW_TRACING</span><span class="p">,</span>
		      <span class="s">&quot;new alloc skb %p skb-&gt;data %p skb-&gt;len %u index %u truesize %u</span><span class="se">\n</span><span class="s"> &quot;</span><span class="p">,</span>
		      <span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">);</span>
<span class="cp">#endif</span>

		<span class="cm">/* set the streaming DMA mapping for proper PCI bus operation */</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">pci_map_rx_address</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span>
		    <span class="n">pci_map_single</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
				   <span class="n">MAX_FRAGMENT_SIZE_RX</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span>
				   <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">pci_map_rx_address</span><span class="p">[</span><span class="n">index</span><span class="p">]))</span> <span class="p">{</span>
			<span class="cm">/* error mapping the buffer to device accessible memory address */</span>
			<span class="n">DEBUG</span><span class="p">(</span><span class="n">SHOW_ERROR_MESSAGES</span><span class="p">,</span>
			      <span class="s">&quot;Error mapping DMA address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="cm">/* free the skbuf structure before aborting */</span>
			<span class="n">dev_kfree_skb_irq</span><span class="p">((</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="p">);</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* update the fragment address */</span>
		<span class="n">control_block</span><span class="o">-&gt;</span><span class="n">rx_data_low</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">address</span> <span class="o">=</span>
			<span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">pci_map_rx_address</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
		<span class="n">wmb</span><span class="p">();</span>

		<span class="cm">/* increment the driver read pointer */</span>
		<span class="n">le32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">control_block</span><span class="o">-&gt;</span>
			     <span class="n">driver_curr_frag</span><span class="p">[</span><span class="n">ISL38XX_CB_RX_DATA_LQ</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* trigger the device */</span>
	<span class="n">islpci_trigger</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">islpci_do_reset_and_wake</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">islpci_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">islpci_private</span><span class="p">,</span> <span class="n">reset_task</span><span class="p">);</span>

	<span class="n">islpci_reset</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">reset_task_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">islpci_eth_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">islpci_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>

	<span class="cm">/* increment the transmit error counter */</span>
	<span class="n">ndev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">reset_task_pending</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;%s: tx_timeout, scheduling reset&quot;</span><span class="p">,</span> <span class="n">ndev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">reset_task_pending</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;%s: tx_timeout, waiting for reset&quot;</span><span class="p">,</span> <span class="n">ndev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
