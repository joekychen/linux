<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › ipw2x00 › libipw_rx.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>libipw_rx.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Original code based Host AP (software wireless LAN access point) driver</span>
<span class="cm"> * for Intersil Prism2/2.5/3 - hostap.o module, common routines</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2001-2002, SSH Communications Security Corp and Jouni Malinen</span>
<span class="cm"> * &lt;j@w1.fi&gt;</span>
<span class="cm"> * Copyright (c) 2002-2003, Jouni Malinen &lt;j@w1.fi&gt;</span>
<span class="cm"> * Copyright (c) 2004-2005, Intel Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation. See README and COPYING for</span>
<span class="cm"> * more details.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/if_arp.h&gt;</span>
<span class="cp">#include &lt;linux/in6.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/tcp.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/wireless.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>

<span class="cp">#include &lt;net/lib80211.h&gt;</span>

<span class="cp">#include &quot;libipw.h&quot;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">libipw_monitor_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">libipw_device</span> <span class="o">*</span><span class="n">ieee</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">libipw_rx_stats</span> <span class="o">*</span><span class="n">rx_stats</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_hdr</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">fc</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">frame_control</span><span class="p">);</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">libipw_get_hdrlen</span><span class="p">(</span><span class="n">fc</span><span class="p">));</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">=</span> <span class="n">PACKET_OTHERHOST</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_80211_RAW</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">));</span>
	<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Called only as a tasklet (software IRQ) */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">libipw_frag_entry</span> <span class="o">*</span><span class="nf">libipw_frag_cache_find</span><span class="p">(</span><span class="k">struct</span>
							      <span class="n">libipw_device</span>
							      <span class="o">*</span><span class="n">ieee</span><span class="p">,</span>
							      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seq</span><span class="p">,</span>
							      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frag</span><span class="p">,</span>
							      <span class="n">u8</span> <span class="o">*</span> <span class="n">src</span><span class="p">,</span>
							      <span class="n">u8</span> <span class="o">*</span> <span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">libipw_frag_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LIBIPW_FRAG_CACHE_LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">frag_cache</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
		    <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">first_frag_time</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">LIBIPW_DEBUG_FRAG</span><span class="p">(</span><span class="s">&quot;expiring fragment cache entry &quot;</span>
					     <span class="s">&quot;seq=%u last_frag=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">entry</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">last_frag</span><span class="p">);</span>
			<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">==</span> <span class="n">seq</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">last_frag</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">frag</span> <span class="o">||</span> <span class="n">frag</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ether_addr_equal</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">src_addr</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ether_addr_equal</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">dst_addr</span><span class="p">,</span> <span class="n">dst</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Called only as a tasklet (software IRQ) */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">libipw_frag_cache_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">libipw_device</span> <span class="o">*</span><span class="n">ieee</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">libipw_hdr_4addr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">sc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frag</span><span class="p">,</span> <span class="n">seq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">libipw_frag_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="n">sc</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">seq_ctl</span><span class="p">);</span>
	<span class="n">frag</span> <span class="o">=</span> <span class="n">WLAN_GET_SEQ_FRAG</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="n">seq</span> <span class="o">=</span> <span class="n">WLAN_GET_SEQ_SEQ</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">frag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Reserve enough space to fit maximum frame length */</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">+</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">libipw_hdr_4addr</span><span class="p">)</span> <span class="o">+</span>
				    <span class="mi">8</span> <span class="cm">/* LLC */</span>  <span class="o">+</span>
				    <span class="mi">2</span> <span class="cm">/* alignment */</span>  <span class="o">+</span>
				    <span class="mi">8</span> <span class="cm">/* WEP */</span>  <span class="o">+</span> <span class="n">ETH_ALEN</span> <span class="cm">/* WDS */</span> <span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">frag_cache</span><span class="p">[</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">frag_next_idx</span><span class="p">];</span>
		<span class="n">ieee</span><span class="o">-&gt;</span><span class="n">frag_next_idx</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">frag_next_idx</span> <span class="o">&gt;=</span> <span class="n">LIBIPW_FRAG_CACHE_LEN</span><span class="p">)</span>
			<span class="n">ieee</span><span class="o">-&gt;</span><span class="n">frag_next_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>

		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">first_frag_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">last_frag</span> <span class="o">=</span> <span class="n">frag</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">src_addr</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr2</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">dst_addr</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr1</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* received a fragment of a frame for which the head fragment</span>
<span class="cm">		 * should have already been received */</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">libipw_frag_cache_find</span><span class="p">(</span><span class="n">ieee</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">frag</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr2</span><span class="p">,</span>
						  <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">last_frag</span> <span class="o">=</span> <span class="n">frag</span><span class="p">;</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Called only as a tasklet (software IRQ) */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">libipw_frag_cache_invalidate</span><span class="p">(</span><span class="k">struct</span> <span class="n">libipw_device</span> <span class="o">*</span><span class="n">ieee</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">libipw_hdr_4addr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">sc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">libipw_frag_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="n">sc</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">seq_ctl</span><span class="p">);</span>
	<span class="n">seq</span> <span class="o">=</span> <span class="n">WLAN_GET_SEQ_SEQ</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">libipw_frag_cache_find</span><span class="p">(</span><span class="n">ieee</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr2</span><span class="p">,</span>
					  <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">LIBIPW_DEBUG_FRAG</span><span class="p">(</span><span class="s">&quot;could not invalidate fragment cache &quot;</span>
				     <span class="s">&quot;entry (seq=%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">seq</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef NOT_YET</span>
<span class="cm">/* libipw_rx_frame_mgtmt</span>
<span class="cm"> *</span>
<span class="cm"> * Responsible for handling management control frames</span>
<span class="cm"> *</span>
<span class="cm"> * Called by libipw_rx */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">libipw_rx_frame_mgmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">libipw_device</span> <span class="o">*</span><span class="n">ieee</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">libipw_rx_stats</span> <span class="o">*</span><span class="n">rx_stats</span><span class="p">,</span> <span class="n">u16</span> <span class="n">type</span><span class="p">,</span>
			<span class="n">u16</span> <span class="n">stype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">iw_mode</span> <span class="o">==</span> <span class="n">IW_MODE_MASTER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Master mode not yet supported.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm">  hostap_update_sta_ps(ieee, (struct hostap_libipw_hdr_4addr *)</span>
<span class="cm">  skb-&gt;data);*/</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">hostapd</span> <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">==</span> <span class="n">WLAN_FC_TYPE_MGMT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stype</span> <span class="o">==</span> <span class="n">WLAN_FC_STYPE_BEACON</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">iw_mode</span> <span class="o">==</span> <span class="n">IW_MODE_MASTER</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb2</span><span class="p">;</span>
			<span class="cm">/* Process beacon frames also in kernel driver to</span>
<span class="cm">			 * update STA(AP) table statistics */</span>
			<span class="n">skb2</span> <span class="o">=</span> <span class="n">skb_clone</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb2</span><span class="p">)</span>
				<span class="n">hostap_rx</span><span class="p">(</span><span class="n">skb2</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb2</span><span class="p">,</span> <span class="n">rx_stats</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* send management frames to the user space daemon for</span>
<span class="cm">		 * processing */</span>
		<span class="n">ieee</span><span class="o">-&gt;</span><span class="n">apdevstats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ieee</span><span class="o">-&gt;</span><span class="n">apdevstats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">prism2_rx_80211</span><span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">apdev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">rx_stats</span><span class="p">,</span> <span class="n">PRISM2_RX_MGMT</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">iw_mode</span> <span class="o">==</span> <span class="n">IW_MODE_MASTER</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">WLAN_FC_TYPE_MGMT</span> <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">!=</span> <span class="n">WLAN_FC_TYPE_CTRL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: unknown management frame &quot;</span>
			       <span class="s">&quot;(type=0x%02x, stype=0x%02x) dropped</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">stype</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">hostap_rx</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">rx_stats</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: hostap_rx_frame_mgmt: management frame &quot;</span>
	       <span class="s">&quot;received in non-Host AP mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* See IEEE 802.1H for LLC/SNAP encapsulation/decapsulation */</span>
<span class="cm">/* Ethernet-II snap header (RFC1042 for most EtherTypes) */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">libipw_rfc1042_header</span><span class="p">[]</span> <span class="o">=</span>
    <span class="p">{</span> <span class="mh">0xaa</span><span class="p">,</span> <span class="mh">0xaa</span><span class="p">,</span> <span class="mh">0x03</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">};</span>

<span class="cm">/* Bridge-Tunnel header (for EtherTypes ETH_P_AARP and ETH_P_IPX) */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">libipw_bridge_tunnel_header</span><span class="p">[]</span> <span class="o">=</span>
    <span class="p">{</span> <span class="mh">0xaa</span><span class="p">,</span> <span class="mh">0xaa</span><span class="p">,</span> <span class="mh">0x03</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xf8</span> <span class="p">};</span>
<span class="cm">/* No encapsulation header if EtherType &lt; 0x600 (=length) */</span>

<span class="cm">/* Called by libipw_rx_frame_decrypt */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">libipw_is_eapol_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">libipw_device</span> <span class="o">*</span><span class="n">ieee</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">fc</span><span class="p">,</span> <span class="n">ethertype</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">libipw_hdr_3addr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">24</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">libipw_hdr_3addr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">fc</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">frame_ctl</span><span class="p">);</span>

	<span class="cm">/* check that the frame is unicast frame to us */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fc</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IEEE80211_FCTL_TODS</span> <span class="o">|</span> <span class="n">IEEE80211_FCTL_FROMDS</span><span class="p">))</span> <span class="o">==</span>
	    <span class="n">IEEE80211_FCTL_TODS</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ether_addr_equal</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr1</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ether_addr_equal</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr3</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* ToDS frame with own addr BSSID and DA */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">fc</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IEEE80211_FCTL_TODS</span> <span class="o">|</span> <span class="n">IEEE80211_FCTL_FROMDS</span><span class="p">))</span> <span class="o">==</span>
		   <span class="n">IEEE80211_FCTL_FROMDS</span> <span class="o">&amp;&amp;</span>
		   <span class="n">ether_addr_equal</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr1</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* FromDS frame with own addr as DA */</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">24</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* check for port access entity Ethernet type */</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="mi">24</span><span class="p">;</span>
	<span class="n">ethertype</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">pos</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ethertype</span> <span class="o">==</span> <span class="n">ETH_P_PAE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Called only as a tasklet (software IRQ), by libipw_rx */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">libipw_rx_frame_decrypt</span><span class="p">(</span><span class="k">struct</span> <span class="n">libipw_device</span> <span class="o">*</span><span class="n">ieee</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">lib80211_crypt_data</span> <span class="o">*</span><span class="n">crypt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">libipw_hdr_3addr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">,</span> <span class="n">hdrlen</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">crypt</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">crypt</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">decrypt_mpdu</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">libipw_hdr_3addr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">hdrlen</span> <span class="o">=</span> <span class="n">libipw_get_hdrlen</span><span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">frame_ctl</span><span class="p">));</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">crypt</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">crypt</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">decrypt_mpdu</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hdrlen</span><span class="p">,</span> <span class="n">crypt</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">crypt</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">LIBIPW_DEBUG_DROP</span><span class="p">(</span><span class="s">&quot;decryption failed (SA=%pM) res=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr2</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
			<span class="n">LIBIPW_DEBUG_DROP</span><span class="p">(</span><span class="s">&quot;Decryption failed ICV &quot;</span>
					     <span class="s">&quot;mismatch (key %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">hdrlen</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">);</span>
		<span class="n">ieee</span><span class="o">-&gt;</span><span class="n">ieee_stats</span><span class="p">.</span><span class="n">rx_discards_undecryptable</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Called only as a tasklet (software IRQ), by libipw_rx */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">libipw_rx_frame_decrypt_msdu</span><span class="p">(</span><span class="k">struct</span> <span class="n">libipw_device</span> <span class="o">*</span><span class="n">ieee</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">keyidx</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">lib80211_crypt_data</span> <span class="o">*</span><span class="n">crypt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">libipw_hdr_3addr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">,</span> <span class="n">hdrlen</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">crypt</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">crypt</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">decrypt_msdu</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">libipw_hdr_3addr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">hdrlen</span> <span class="o">=</span> <span class="n">libipw_get_hdrlen</span><span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">frame_ctl</span><span class="p">));</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">crypt</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">crypt</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">decrypt_msdu</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">keyidx</span><span class="p">,</span> <span class="n">hdrlen</span><span class="p">,</span> <span class="n">crypt</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">crypt</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: MSDU decryption/MIC verification failed&quot;</span>
		       <span class="s">&quot; (SA=%pM keyidx=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr2</span><span class="p">,</span>
		       <span class="n">keyidx</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* All received frames are sent to this function. @skb contains the frame in</span>
<span class="cm"> * IEEE 802.11 format, i.e., in the format it was sent over air.</span>
<span class="cm"> * This function is called only as a tasklet (software IRQ). */</span>
<span class="kt">int</span> <span class="nf">libipw_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">libipw_device</span> <span class="o">*</span><span class="n">ieee</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">libipw_rx_stats</span> <span class="o">*</span><span class="n">rx_stats</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">libipw_hdr_4addr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">hdrlen</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">fc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">stype</span><span class="p">,</span> <span class="n">sc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frag</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">payload</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ethertype</span><span class="p">;</span>
<span class="cp">#ifdef NOT_YET</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">wds</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">wds</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">frame_authorized</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">from_assoc_ap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">sta</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">u8</span> <span class="n">dst</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">src</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">lib80211_crypt_data</span> <span class="o">*</span><span class="n">crypt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">keyidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">can_be_decrypted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">libipw_hdr_4addr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: SKB length &lt; 10</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">rx_dropped</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fc</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">frame_ctl</span><span class="p">);</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">WLAN_FC_GET_TYPE</span><span class="p">(</span><span class="n">fc</span><span class="p">);</span>
	<span class="n">stype</span> <span class="o">=</span> <span class="n">WLAN_FC_GET_STYPE</span><span class="p">(</span><span class="n">fc</span><span class="p">);</span>
	<span class="n">sc</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">seq_ctl</span><span class="p">);</span>
	<span class="n">frag</span> <span class="o">=</span> <span class="n">WLAN_GET_SEQ_FRAG</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="n">hdrlen</span> <span class="o">=</span> <span class="n">libipw_get_hdrlen</span><span class="p">(</span><span class="n">fc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">hdrlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: invalid SKB length %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">rx_dropped</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Put this code here so that we avoid duplicating it in all</span>
<span class="cm">	 * Rx paths. - Jean II */</span>
<span class="cp">#ifdef CONFIG_WIRELESS_EXT</span>
<span class="cp">#ifdef IW_WIRELESS_SPY		</span><span class="cm">/* defined in iw_handler.h */</span><span class="cp"></span>
	<span class="cm">/* If spy monitoring on */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">spy_data</span><span class="p">.</span><span class="n">spy_number</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">iw_quality</span> <span class="n">wstats</span><span class="p">;</span>

		<span class="n">wstats</span><span class="p">.</span><span class="n">updated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rx_stats</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">LIBIPW_STATMASK_RSSI</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wstats</span><span class="p">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">rx_stats</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">;</span>
			<span class="n">wstats</span><span class="p">.</span><span class="n">updated</span> <span class="o">|=</span> <span class="n">IW_QUAL_LEVEL_UPDATED</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">wstats</span><span class="p">.</span><span class="n">updated</span> <span class="o">|=</span> <span class="n">IW_QUAL_LEVEL_INVALID</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rx_stats</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">LIBIPW_STATMASK_NOISE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wstats</span><span class="p">.</span><span class="n">noise</span> <span class="o">=</span> <span class="n">rx_stats</span><span class="o">-&gt;</span><span class="n">noise</span><span class="p">;</span>
			<span class="n">wstats</span><span class="p">.</span><span class="n">updated</span> <span class="o">|=</span> <span class="n">IW_QUAL_NOISE_UPDATED</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">wstats</span><span class="p">.</span><span class="n">updated</span> <span class="o">|=</span> <span class="n">IW_QUAL_NOISE_INVALID</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rx_stats</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">LIBIPW_STATMASK_SIGNAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wstats</span><span class="p">.</span><span class="n">qual</span> <span class="o">=</span> <span class="n">rx_stats</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">;</span>
			<span class="n">wstats</span><span class="p">.</span><span class="n">updated</span> <span class="o">|=</span> <span class="n">IW_QUAL_QUAL_UPDATED</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">wstats</span><span class="p">.</span><span class="n">updated</span> <span class="o">|=</span> <span class="n">IW_QUAL_QUAL_INVALID</span><span class="p">;</span>

		<span class="cm">/* Update spy records */</span>
		<span class="n">wireless_spy_update</span><span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wstats</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif				</span><span class="cm">/* IW_WIRELESS_SPY */</span><span class="cp"></span>
<span class="cp">#endif				</span><span class="cm">/* CONFIG_WIRELESS_EXT */</span><span class="cp"></span>

<span class="cp">#ifdef NOT_YET</span>
	<span class="n">hostap_update_rx_stats</span><span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="n">rx_stats</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">iw_mode</span> <span class="o">==</span> <span class="n">IW_MODE_MONITOR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">libipw_monitor_rx</span><span class="p">(</span><span class="n">ieee</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">rx_stats</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">can_be_decrypted</span> <span class="o">=</span> <span class="p">(</span><span class="n">is_multicast_ether_addr</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr1</span><span class="p">)</span> <span class="o">||</span>
			    <span class="n">is_broadcast_ether_addr</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr2</span><span class="p">))</span> <span class="o">?</span>
	    <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">host_mc_decrypt</span> <span class="o">:</span> <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">host_decrypt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">can_be_decrypted</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">hdrlen</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Top two-bits of byte 3 are the key index */</span>
			<span class="n">keyidx</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">hdrlen</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* ieee-&gt;crypt[] is WEP_KEY (4) in length.  Given that keyidx</span>
<span class="cm">		 * is only allowed 2-bits of storage, no value of keyidx can</span>
<span class="cm">		 * be provided via above code that would result in keyidx</span>
<span class="cm">		 * being out of range */</span>
		<span class="n">crypt</span> <span class="o">=</span> <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">crypt_info</span><span class="p">.</span><span class="n">crypt</span><span class="p">[</span><span class="n">keyidx</span><span class="p">];</span>

<span class="cp">#ifdef NOT_YET</span>
		<span class="n">sta</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/* Use station specific key to override default keys if the</span>
<span class="cm">		 * receiver address is a unicast address (&quot;individual RA&quot;). If</span>
<span class="cm">		 * bcrx_sta_key parameter is set, station specific key is used</span>
<span class="cm">		 * even with broad/multicast targets (this is against IEEE</span>
<span class="cm">		 * 802.11, but makes it easier to use different keys with</span>
<span class="cm">		 * stations that do not support WEP key mapping). */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_unicast_ether_addr</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr1</span><span class="p">)</span> <span class="o">||</span> <span class="n">local</span><span class="o">-&gt;</span><span class="n">bcrx_sta_key</span><span class="p">)</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">hostap_handle_sta_crypto</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">crypt</span><span class="p">,</span>
						       <span class="o">&amp;</span><span class="n">sta</span><span class="p">);</span>
<span class="cp">#endif</span>

		<span class="cm">/* allow NULL decrypt to indicate an station specific override</span>
<span class="cm">		 * for default encryption */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">crypt</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">crypt</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
			      <span class="n">crypt</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">decrypt_mpdu</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
			<span class="n">crypt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">crypt</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">fc</span> <span class="o">&amp;</span> <span class="n">IEEE80211_FCTL_PROTECTED</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* This seems to be triggered by some (multicast?)</span>
<span class="cm">			 * frames from other than current BSS, so just drop the</span>
<span class="cm">			 * frames silently instead of filling system log with</span>
<span class="cm">			 * these reports. */</span>
			<span class="n">LIBIPW_DEBUG_DROP</span><span class="p">(</span><span class="s">&quot;Decryption failed (not set)&quot;</span>
					     <span class="s">&quot; (SA=%pM)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr2</span><span class="p">);</span>
			<span class="n">ieee</span><span class="o">-&gt;</span><span class="n">ieee_stats</span><span class="p">.</span><span class="n">rx_discards_undecryptable</span><span class="o">++</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">rx_dropped</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#ifdef NOT_YET</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">WLAN_FC_TYPE_DATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">WLAN_FC_TYPE_MGMT</span> <span class="o">&amp;&amp;</span> <span class="n">stype</span> <span class="o">==</span> <span class="n">WLAN_FC_STYPE_AUTH</span> <span class="o">&amp;&amp;</span>
		    <span class="n">fc</span> <span class="o">&amp;</span> <span class="n">IEEE80211_FCTL_PROTECTED</span> <span class="o">&amp;&amp;</span> <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">host_decrypt</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">keyidx</span> <span class="o">=</span> <span class="n">hostap_rx_frame_decrypt</span><span class="p">(</span><span class="n">ieee</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">crypt</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: failed to decrypt mgmt::auth &quot;</span>
			       <span class="s">&quot;from %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr2</span><span class="p">);</span>
			<span class="cm">/* TODO: could inform hostapd about this so that it</span>
<span class="cm">			 * could send auth failure report */</span>
			<span class="k">goto</span> <span class="n">rx_dropped</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">libipw_rx_frame_mgmt</span><span class="p">(</span><span class="n">ieee</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">rx_stats</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">stype</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">rx_dropped</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">goto</span> <span class="n">rx_exit</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="cm">/* drop duplicate 802.11 retransmissions (IEEE 802.11 Chap. 9.29) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span> <span class="o">==</span> <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">prev_seq_ctl</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">rx_dropped</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ieee</span><span class="o">-&gt;</span><span class="n">prev_seq_ctl</span> <span class="o">=</span> <span class="n">sc</span><span class="p">;</span>

	<span class="cm">/* Data frame - extract src/dst addresses */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">LIBIPW_3ADDR_LEN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">rx_dropped</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">fc</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IEEE80211_FCTL_FROMDS</span> <span class="o">|</span> <span class="n">IEEE80211_FCTL_TODS</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IEEE80211_FCTL_FROMDS</span>:
		<span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr1</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr3</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IEEE80211_FCTL_TODS</span>:
		<span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr3</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr2</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IEEE80211_FCTL_FROMDS</span> <span class="o">|</span> <span class="n">IEEE80211_FCTL_TODS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">LIBIPW_4ADDR_LEN</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">rx_dropped</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr3</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr4</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr1</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr2</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef NOT_YET</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hostap_rx_frame_wds</span><span class="p">(</span><span class="n">ieee</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wds</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">rx_dropped</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wds</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span> <span class="o">=</span> <span class="n">wds</span><span class="p">;</span>
		<span class="n">stats</span> <span class="o">=</span> <span class="n">hostap_get_stats</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">iw_mode</span> <span class="o">==</span> <span class="n">IW_MODE_MASTER</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">wds</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">fc</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IEEE80211_FCTL_TODS</span> <span class="o">|</span> <span class="n">IEEE80211_FCTL_FROMDS</span><span class="p">))</span> <span class="o">==</span>
	    <span class="n">IEEE80211_FCTL_FROMDS</span> <span class="o">&amp;&amp;</span> <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">stadev</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ether_addr_equal</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr2</span><span class="p">,</span> <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">assoc_ap_addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Frame from BSSID of the AP for which we are a client */</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span> <span class="o">=</span> <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">stadev</span><span class="p">;</span>
		<span class="n">stats</span> <span class="o">=</span> <span class="n">hostap_get_stats</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">from_assoc_ap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef NOT_YET</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">iw_mode</span> <span class="o">==</span> <span class="n">IW_MODE_MASTER</span> <span class="o">||</span>
	     <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">iw_mode</span> <span class="o">==</span> <span class="n">IW_MODE_REPEAT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">from_assoc_ap</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">hostap_handle_sta_rx</span><span class="p">(</span><span class="n">ieee</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">rx_stats</span><span class="p">,</span>
					     <span class="n">wds</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">AP_RX_CONTINUE_NOT_AUTHORIZED</span>:
			<span class="n">frame_authorized</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AP_RX_CONTINUE</span>:
			<span class="n">frame_authorized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AP_RX_DROP</span>:
			<span class="k">goto</span> <span class="n">rx_dropped</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AP_RX_EXIT</span>:
			<span class="k">goto</span> <span class="n">rx_exit</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* Nullfunc frames may have PS-bit set, so they must be passed to</span>
<span class="cm">	 * hostap_handle_sta_rx() before being dropped here. */</span>

	<span class="n">stype</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IEEE80211_STYPE_QOS_DATA</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stype</span> <span class="o">!=</span> <span class="n">IEEE80211_STYPE_DATA</span> <span class="o">&amp;&amp;</span>
	    <span class="n">stype</span> <span class="o">!=</span> <span class="n">IEEE80211_STYPE_DATA_CFACK</span> <span class="o">&amp;&amp;</span>
	    <span class="n">stype</span> <span class="o">!=</span> <span class="n">IEEE80211_STYPE_DATA_CFPOLL</span> <span class="o">&amp;&amp;</span>
	    <span class="n">stype</span> <span class="o">!=</span> <span class="n">IEEE80211_STYPE_DATA_CFACKPOLL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stype</span> <span class="o">!=</span> <span class="n">IEEE80211_STYPE_NULLFUNC</span><span class="p">)</span>
			<span class="n">LIBIPW_DEBUG_DROP</span><span class="p">(</span><span class="s">&quot;RX: dropped data frame &quot;</span>
					     <span class="s">&quot;with no data (type=0x%02x, &quot;</span>
					     <span class="s">&quot;subtype=0x%02x, len=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">type</span><span class="p">,</span> <span class="n">stype</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">rx_dropped</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* skb: hdr + (possibly fragmented, possibly encrypted) payload */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">fc</span> <span class="o">&amp;</span> <span class="n">IEEE80211_FCTL_PROTECTED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">can_be_decrypted</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">keyidx</span> <span class="o">=</span> <span class="n">libipw_rx_frame_decrypt</span><span class="p">(</span><span class="n">ieee</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">crypt</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">rx_dropped</span><span class="p">;</span>

	<span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">libipw_hdr_4addr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* skb: hdr + (possibly fragmented) plaintext payload */</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>PR: FIXME: hostap has additional conditions in the "if" below:
ieee->host<em>decrypt &amp;&amp; (fc &amp; IEEE80211</em>FCTL_PROTECTED) &amp;&amp;</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">((</span><span class="n">frag</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">fc</span> <span class="o">&amp;</span> <span class="n">IEEE80211_FCTL_MOREFRAGS</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">flen</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">frag_skb</span> <span class="o">=</span> <span class="n">libipw_frag_cache_get</span><span class="p">(</span><span class="n">ieee</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>
		<span class="n">LIBIPW_DEBUG_FRAG</span><span class="p">(</span><span class="s">&quot;Rx Fragment received (%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">frag</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frag_skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">LIBIPW_DEBUG</span><span class="p">(</span><span class="n">LIBIPW_DL_RX</span> <span class="o">|</span> <span class="n">LIBIPW_DL_FRAG</span><span class="p">,</span>
					<span class="s">&quot;Rx cannot get skb from fragment &quot;</span>
					<span class="s">&quot;cache (morefrag=%d seq=%u frag=%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="n">fc</span> <span class="o">&amp;</span> <span class="n">IEEE80211_FCTL_MOREFRAGS</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">WLAN_GET_SEQ_SEQ</span><span class="p">(</span><span class="n">sc</span><span class="p">),</span> <span class="n">frag</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">rx_dropped</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">flen</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">frag</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">flen</span> <span class="o">-=</span> <span class="n">hdrlen</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">frag_skb</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">+</span> <span class="n">flen</span> <span class="o">&gt;</span> <span class="n">frag_skb</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: host decrypted and &quot;</span>
			       <span class="s">&quot;reassembled frame did not fit skb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">libipw_frag_cache_invalidate</span><span class="p">(</span><span class="n">ieee</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">rx_dropped</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">frag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* copy first fragment (including full headers) into</span>
<span class="cm">			 * beginning of the fragment cache skb */</span>
			<span class="n">skb_copy_from_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">frag_skb</span><span class="p">,</span> <span class="n">flen</span><span class="p">),</span> <span class="n">flen</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* append frame payload to the end of the fragment</span>
<span class="cm">			 * cache skb */</span>
			<span class="n">skb_copy_from_linear_data_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hdrlen</span><span class="p">,</span>
				      <span class="n">skb_put</span><span class="p">(</span><span class="n">frag_skb</span><span class="p">,</span> <span class="n">flen</span><span class="p">),</span> <span class="n">flen</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fc</span> <span class="o">&amp;</span> <span class="n">IEEE80211_FCTL_MOREFRAGS</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* more fragments expected - leave the skb in fragment</span>
<span class="cm">			 * cache for now; it will be delivered to upper layers</span>
<span class="cm">			 * after all fragments have been received */</span>
			<span class="k">goto</span> <span class="n">rx_exit</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* this was the last fragment and the frame will be</span>
<span class="cm">		 * delivered, so remove skb from fragment cache */</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">frag_skb</span><span class="p">;</span>
		<span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">libipw_hdr_4addr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">libipw_frag_cache_invalidate</span><span class="p">(</span><span class="n">ieee</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* skb: hdr + (possible reassembled) full MSDU payload; possibly still</span>
<span class="cm">	 * encrypted/authenticated */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fc</span> <span class="o">&amp;</span> <span class="n">IEEE80211_FCTL_PROTECTED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">can_be_decrypted</span> <span class="o">&amp;&amp;</span>
	    <span class="n">libipw_rx_frame_decrypt_msdu</span><span class="p">(</span><span class="n">ieee</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">keyidx</span><span class="p">,</span> <span class="n">crypt</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">rx_dropped</span><span class="p">;</span>

	<span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">libipw_hdr_4addr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">crypt</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">fc</span> <span class="o">&amp;</span> <span class="n">IEEE80211_FCTL_PROTECTED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">open_wep</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span>		<span class="cm">/*ieee-&gt;ieee802_1x &amp;&amp; */</span>
			   <span class="n">libipw_is_eapol_frame</span><span class="p">(</span><span class="n">ieee</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* pass unencrypted EAPOL frames even if encryption is</span>
<span class="cm">			 * configured */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">LIBIPW_DEBUG_DROP</span><span class="p">(</span><span class="s">&quot;encryption configured, but RX &quot;</span>
					     <span class="s">&quot;frame not encrypted (SA=%pM)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr2</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">rx_dropped</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">crypt</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">fc</span> <span class="o">&amp;</span> <span class="n">IEEE80211_FCTL_PROTECTED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">open_wep</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">libipw_is_eapol_frame</span><span class="p">(</span><span class="n">ieee</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">LIBIPW_DEBUG_DROP</span><span class="p">(</span><span class="s">&quot;dropped unencrypted RX data &quot;</span>
				     <span class="s">&quot;frame from %pM (drop_unencrypted=1)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr2</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">rx_dropped</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If the frame was decrypted in hardware, we may need to strip off</span>
<span class="cm">	 * any security data (IV, ICV, etc) that was left behind */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">can_be_decrypted</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">fc</span> <span class="o">&amp;</span> <span class="n">IEEE80211_FCTL_PROTECTED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">host_strip_iv_icv</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">trimlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Top two-bits of byte 3 are the key index */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">hdrlen</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>
			<span class="n">keyidx</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">hdrlen</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">;</span>

		<span class="cm">/* To strip off any security data which appears before the</span>
<span class="cm">		 * payload, we simply increase hdrlen (as the header gets</span>
<span class="cm">		 * chopped off immediately below). For the security data which</span>
<span class="cm">		 * appears after the payload, we use skb_trim. */</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">sec</span><span class="p">.</span><span class="n">encode_alg</span><span class="p">[</span><span class="n">keyidx</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SEC_ALG_WEP</span>:
			<span class="cm">/* 4 byte IV */</span>
			<span class="n">hdrlen</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="cm">/* 4 byte ICV */</span>
			<span class="n">trimlen</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SEC_ALG_TKIP</span>:
			<span class="cm">/* 4 byte IV, 4 byte ExtIV */</span>
			<span class="n">hdrlen</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="cm">/* 8 byte MIC, 4 byte ICV */</span>
			<span class="n">trimlen</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SEC_ALG_CCMP</span>:
			<span class="cm">/* 8 byte CCMP header */</span>
			<span class="n">hdrlen</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="cm">/* 8 byte MIC */</span>
			<span class="n">trimlen</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">trimlen</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">rx_dropped</span><span class="p">;</span>

		<span class="n">__skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">trimlen</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">hdrlen</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">rx_dropped</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* skb: hdr + (possible reassembled) full plaintext payload */</span>

	<span class="n">payload</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">hdrlen</span><span class="p">;</span>
	<span class="n">ethertype</span> <span class="o">=</span> <span class="p">(</span><span class="n">payload</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">payload</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>

<span class="cp">#ifdef NOT_YET</span>
	<span class="cm">/* If IEEE 802.1X is used, check whether the port is authorized to send</span>
<span class="cm">	 * the received frame. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">ieee802_1x</span> <span class="o">&amp;&amp;</span> <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">iw_mode</span> <span class="o">==</span> <span class="n">IW_MODE_MASTER</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ethertype</span> <span class="o">==</span> <span class="n">ETH_P_PAE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: RX: IEEE 802.1X frame</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">hostapd</span> <span class="o">&amp;&amp;</span> <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">apdev</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Send IEEE 802.1X frames to the user</span>
<span class="cm">				 * space daemon for processing */</span>
				<span class="n">prism2_rx_80211</span><span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">apdev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">rx_stats</span><span class="p">,</span>
						<span class="n">PRISM2_RX_MGMT</span><span class="p">);</span>
				<span class="n">ieee</span><span class="o">-&gt;</span><span class="n">apdevstats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
				<span class="n">ieee</span><span class="o">-&gt;</span><span class="n">apdevstats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">rx_exit</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frame_authorized</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: dropped frame from &quot;</span>
			       <span class="s">&quot;unauthorized port (IEEE 802.1X): &quot;</span>
			       <span class="s">&quot;ethertype=0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ethertype</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">rx_dropped</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* convert hdr + possible LLC headers into Ethernet header */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">hdrlen</span> <span class="o">&gt;=</span> <span class="mi">8</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">memcmp</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="n">libipw_rfc1042_header</span><span class="p">,</span> <span class="n">SNAP_SIZE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	      <span class="n">ethertype</span> <span class="o">!=</span> <span class="n">ETH_P_AARP</span> <span class="o">&amp;&amp;</span> <span class="n">ethertype</span> <span class="o">!=</span> <span class="n">ETH_P_IPX</span><span class="p">)</span> <span class="o">||</span>
	     <span class="n">memcmp</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="n">libipw_bridge_tunnel_header</span><span class="p">,</span> <span class="n">SNAP_SIZE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* remove RFC1042 or Bridge-Tunnel encapsulation and</span>
<span class="cm">		 * replace EtherType */</span>
		<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hdrlen</span> <span class="o">+</span> <span class="n">SNAP_SIZE</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">),</span> <span class="n">src</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">),</span> <span class="n">dst</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">__be16</span> <span class="n">len</span><span class="p">;</span>
		<span class="cm">/* Leave Ethernet header part of hdr and full payload */</span>
		<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hdrlen</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">),</span> <span class="n">src</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">),</span> <span class="n">dst</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#ifdef NOT_YET</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wds</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">fc</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IEEE80211_FCTL_TODS</span> <span class="o">|</span> <span class="n">IEEE80211_FCTL_FROMDS</span><span class="p">))</span> <span class="o">==</span>
		    <span class="n">IEEE80211_FCTL_TODS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">ETH_HLEN</span> <span class="o">+</span> <span class="n">ETH_ALEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Non-standard frame: get addr4 from its bogus location after</span>
<span class="cm">		 * the payload */</span>
		<span class="n">skb_copy_to_linear_data_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">,</span>
					       <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">ETH_ALEN</span><span class="p">,</span>
					       <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="n">skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

<span class="cp">#ifdef NOT_YET</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">iw_mode</span> <span class="o">==</span> <span class="n">IW_MODE_MASTER</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">wds</span> <span class="o">&amp;&amp;</span> <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">bridge_packets</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_multicast_ether_addr</span><span class="p">(</span><span class="n">dst</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* copy multicast frame both to the higher layers and</span>
<span class="cm">			 * to the wireless media */</span>
			<span class="n">ieee</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">bridged_multicast</span><span class="o">++</span><span class="p">;</span>
			<span class="n">skb2</span> <span class="o">=</span> <span class="n">skb_clone</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb2</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: skb_clone failed for &quot;</span>
				       <span class="s">&quot;multicast frame</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hostap_is_sta_assoc</span><span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">,</span> <span class="n">dst</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* send frame directly to the associated STA using</span>
<span class="cm">			 * wireless media and not passing to higher layers */</span>
			<span class="n">ieee</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">bridged_unicast</span><span class="o">++</span><span class="p">;</span>
			<span class="n">skb2</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb2</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* send to wireless media */</span>
		<span class="n">skb2</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
		<span class="n">skb2</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_802_3</span><span class="p">);</span>
		<span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="n">skb2</span><span class="p">);</span>
		<span class="n">skb_reset_network_header</span><span class="p">(</span><span class="n">skb2</span><span class="p">);</span>
		<span class="cm">/* skb2-&gt;network_header += ETH_HLEN; */</span>
		<span class="n">dev_queue_xmit</span><span class="p">(</span><span class="n">skb2</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">));</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_NONE</span><span class="p">;</span>	<span class="cm">/* 802.11 crc not sufficient */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">==</span> <span class="n">NET_RX_DROP</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* netif_rx always succeeds, but it might drop</span>
<span class="cm">			 * the packet.  If it drops the packet, we log that</span>
<span class="cm">			 * in our stats. */</span>
			<span class="n">LIBIPW_DEBUG_DROP</span>
			    <span class="p">(</span><span class="s">&quot;RX: netif_rx dropped the packet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

      <span class="nl">rx_exit:</span>
<span class="cp">#ifdef NOT_YET</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sta</span><span class="p">)</span>
		<span class="n">hostap_handle_sta_release</span><span class="p">(</span><span class="n">sta</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

      <span class="nl">rx_dropped:</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Returning 0 indicates to caller that we have not handled the SKB--</span>
<span class="cm">	 * so it is still allocated and can be used again by underlying</span>
<span class="cm">	 * hardware as a DMA target */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Filter out unrelated packets, call libipw_rx[_mgt]</span>
<span class="cm"> * This function takes over the skb, it should not be used again after calling</span>
<span class="cm"> * this function. */</span>
<span class="kt">void</span> <span class="nf">libipw_rx_any</span><span class="p">(</span><span class="k">struct</span> <span class="n">libipw_device</span> <span class="o">*</span><span class="n">ieee</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">libipw_rx_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">libipw_hdr_4addr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_packet_for_us</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">fc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">iw_mode</span> <span class="o">==</span> <span class="n">IW_MODE_MONITOR</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">libipw_rx</span><span class="p">(</span><span class="n">ieee</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">stats</span><span class="p">))</span>
			<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hdr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">drop_free</span><span class="p">;</span>

	<span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">libipw_hdr_4addr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">fc</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">frame_ctl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">fc</span> <span class="o">&amp;</span> <span class="n">IEEE80211_FCTL_VERS</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">drop_free</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">fc</span> <span class="o">&amp;</span> <span class="n">IEEE80211_FCTL_FTYPE</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IEEE80211_FTYPE_MGMT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">libipw_hdr_3addr</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">drop_free</span><span class="p">;</span>
		<span class="n">libipw_rx_mgt</span><span class="p">(</span><span class="n">ieee</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="n">stats</span><span class="p">);</span>
		<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IEEE80211_FTYPE_DATA</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IEEE80211_FTYPE_CTL</span>:
		<span class="k">return</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">is_packet_for_us</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">iw_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IW_MODE_ADHOC</span>:
		<span class="cm">/* our BSS and not from/to DS */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr3</span><span class="p">,</span> <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">bssid</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">fc</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IEEE80211_FCTL_TODS</span><span class="o">+</span><span class="n">IEEE80211_FCTL_FROMDS</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* promisc: get all */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span>
				<span class="n">is_packet_for_us</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* to us */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr1</span><span class="p">,</span> <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">is_packet_for_us</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* mcast */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_multicast_ether_addr</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr1</span><span class="p">))</span>
				<span class="n">is_packet_for_us</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IW_MODE_INFRA</span>:
		<span class="cm">/* our BSS (== from our AP) and from DS */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr2</span><span class="p">,</span> <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">bssid</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">fc</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IEEE80211_FCTL_TODS</span><span class="o">+</span><span class="n">IEEE80211_FCTL_FROMDS</span><span class="p">))</span> <span class="o">==</span> <span class="n">IEEE80211_FCTL_FROMDS</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* promisc: get all */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span>
				<span class="n">is_packet_for_us</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* to us */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr1</span><span class="p">,</span> <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">is_packet_for_us</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* mcast */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_multicast_ether_addr</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* not our own packet bcasted from AP */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr3</span><span class="p">,</span> <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">))</span>
					<span class="n">is_packet_for_us</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* ? */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_packet_for_us</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">libipw_rx</span><span class="p">(</span><span class="n">ieee</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">stats</span><span class="p">))</span>
			<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">drop_free:</span>
	<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">ieee</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define MGMT_FRAME_FIXED_PART_LENGTH		0x24</span>

<span class="k">static</span> <span class="n">u8</span> <span class="n">qos_oui</span><span class="p">[</span><span class="n">QOS_OUI_LEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x50</span><span class="p">,</span> <span class="mh">0xF2</span> <span class="p">};</span>

<span class="cm">/*</span>
<span class="cm">* Make the structure we read from the beacon packet to have</span>
<span class="cm">* the right values</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">libipw_verify_qos_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">libipw_qos_information_element</span>
				     <span class="o">*</span><span class="n">info_element</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sub_type</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info_element</span><span class="o">-&gt;</span><span class="n">qui_subtype</span> <span class="o">!=</span> <span class="n">sub_type</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">info_element</span><span class="o">-&gt;</span><span class="n">qui</span><span class="p">,</span> <span class="n">qos_oui</span><span class="p">,</span> <span class="n">QOS_OUI_LEN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info_element</span><span class="o">-&gt;</span><span class="n">qui_type</span> <span class="o">!=</span> <span class="n">QOS_OUI_TYPE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info_element</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">!=</span> <span class="n">QOS_VERSION_1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Parse a QoS parameter element</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">libipw_read_qos_param_element</span><span class="p">(</span><span class="k">struct</span> <span class="n">libipw_qos_parameter_info</span>
					    <span class="o">*</span><span class="n">element_param</span><span class="p">,</span> <span class="k">struct</span> <span class="n">libipw_info_element</span>
					    <span class="o">*</span><span class="n">info_element</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">libipw_qos_parameter_info</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">info_element</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">element_param</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info_element</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">QOS_ELEMENT_ID</span> <span class="o">&amp;&amp;</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">==</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">element_param</span><span class="o">-&gt;</span><span class="n">info_element</span><span class="p">.</span><span class="n">qui</span><span class="p">,</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
		       <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="n">element_param</span><span class="o">-&gt;</span><span class="n">info_element</span><span class="p">.</span><span class="n">elementID</span> <span class="o">=</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
		<span class="n">element_param</span><span class="o">-&gt;</span><span class="n">info_element</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">libipw_verify_qos_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">element_param</span><span class="o">-&gt;</span><span class="n">info_element</span><span class="p">,</span>
						<span class="n">QOS_OUI_PARAM_SUB_TYPE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Parse a QoS information element</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">libipw_read_qos_info_element</span><span class="p">(</span><span class="k">struct</span>
					   <span class="n">libipw_qos_information_element</span>
					   <span class="o">*</span><span class="n">element_info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">libipw_info_element</span>
					   <span class="o">*</span><span class="n">info_element</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">libipw_qos_information_element</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">element_info</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info_element</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">info_element</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">QOS_ELEMENT_ID</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">info_element</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">==</span> <span class="n">size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">element_info</span><span class="o">-&gt;</span><span class="n">qui</span><span class="p">,</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
		       <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="n">element_info</span><span class="o">-&gt;</span><span class="n">elementID</span> <span class="o">=</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
		<span class="n">element_info</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">libipw_verify_qos_info</span><span class="p">(</span><span class="n">element_info</span><span class="p">,</span>
						<span class="n">QOS_OUI_INFO_SUB_TYPE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write QoS parameters from the ac parameters.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">libipw_qos_convert_ac_to_parameters</span><span class="p">(</span><span class="k">struct</span>
						  <span class="n">libipw_qos_parameter_info</span>
						  <span class="o">*</span><span class="n">param_elm</span><span class="p">,</span> <span class="k">struct</span>
						  <span class="n">libipw_qos_parameters</span>
						  <span class="o">*</span><span class="n">qos_param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">libipw_qos_ac_parameter</span> <span class="o">*</span><span class="n">ac_params</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">txop</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cw_min</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cw_max</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">QOS_QUEUE_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ac_params</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">param_elm</span><span class="o">-&gt;</span><span class="n">ac_params_record</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="n">qos_param</span><span class="o">-&gt;</span><span class="n">aifs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ac_params</span><span class="o">-&gt;</span><span class="n">aci_aifsn</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">;</span>
		<span class="n">qos_param</span><span class="o">-&gt;</span><span class="n">aifs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="n">qos_param</span><span class="o">-&gt;</span><span class="n">aifs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">2</span><span class="p">;</span>

		<span class="n">cw_min</span> <span class="o">=</span> <span class="n">ac_params</span><span class="o">-&gt;</span><span class="n">ecw_min_max</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">;</span>
		<span class="n">qos_param</span><span class="o">-&gt;</span><span class="n">cw_min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cw_min</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">cw_max</span> <span class="o">=</span> <span class="p">(</span><span class="n">ac_params</span><span class="o">-&gt;</span><span class="n">ecw_min_max</span> <span class="o">&amp;</span> <span class="mh">0xF0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">qos_param</span><span class="o">-&gt;</span><span class="n">cw_max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cw_max</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">qos_param</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">ac_params</span><span class="o">-&gt;</span><span class="n">aci_aifsn</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">?</span> <span class="mh">0x01</span> <span class="o">:</span> <span class="mh">0x00</span><span class="p">;</span>

		<span class="n">txop</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ac_params</span><span class="o">-&gt;</span><span class="n">tx_op_limit</span><span class="p">)</span> <span class="o">*</span> <span class="mi">32</span><span class="p">;</span>
		<span class="n">qos_param</span><span class="o">-&gt;</span><span class="n">tx_op_limit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">txop</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * we have a generic data element which it may contain QoS information or</span>
<span class="cm"> * parameters element. check the information element length to decide</span>
<span class="cm"> * which type to read</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">libipw_parse_qos_info_param_IE</span><span class="p">(</span><span class="k">struct</span> <span class="n">libipw_info_element</span>
					     <span class="o">*</span><span class="n">info_element</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">libipw_network</span> <span class="o">*</span><span class="n">network</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">libipw_qos_parameters</span> <span class="o">*</span><span class="n">qos_param</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">libipw_qos_information_element</span> <span class="n">qos_info_element</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">libipw_read_qos_info_element</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qos_info_element</span><span class="p">,</span> <span class="n">info_element</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">network</span><span class="o">-&gt;</span><span class="n">qos_data</span><span class="p">.</span><span class="n">param_count</span> <span class="o">=</span> <span class="n">qos_info_element</span><span class="p">.</span><span class="n">ac_info</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">;</span>
		<span class="n">network</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">NETWORK_HAS_QOS_INFORMATION</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">libipw_qos_parameter_info</span> <span class="n">param_element</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">libipw_read_qos_param_element</span><span class="p">(</span><span class="o">&amp;</span><span class="n">param_element</span><span class="p">,</span>
						      <span class="n">info_element</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qos_param</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">network</span><span class="o">-&gt;</span><span class="n">qos_data</span><span class="p">.</span><span class="n">parameters</span><span class="p">);</span>
			<span class="n">libipw_qos_convert_ac_to_parameters</span><span class="p">(</span><span class="o">&amp;</span><span class="n">param_element</span><span class="p">,</span>
							       <span class="n">qos_param</span><span class="p">);</span>
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">NETWORK_HAS_QOS_PARAMETERS</span><span class="p">;</span>
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">qos_data</span><span class="p">.</span><span class="n">param_count</span> <span class="o">=</span>
			    <span class="n">param_element</span><span class="p">.</span><span class="n">info_element</span><span class="p">.</span><span class="n">ac_info</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">LIBIPW_DEBUG_QOS</span><span class="p">(</span><span class="s">&quot;QoS is supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">network</span><span class="o">-&gt;</span><span class="n">qos_data</span><span class="p">.</span><span class="n">supported</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_LIBIPW_DEBUG</span>
<span class="cp">#define MFIE_STRING(x) case WLAN_EID_ ##x: return #x</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">get_info_element_string</span><span class="p">(</span><span class="n">u16</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">MFIE_STRING</span><span class="p">(</span><span class="n">SSID</span><span class="p">);</span>
		<span class="n">MFIE_STRING</span><span class="p">(</span><span class="n">SUPP_RATES</span><span class="p">);</span>
		<span class="n">MFIE_STRING</span><span class="p">(</span><span class="n">FH_PARAMS</span><span class="p">);</span>
		<span class="n">MFIE_STRING</span><span class="p">(</span><span class="n">DS_PARAMS</span><span class="p">);</span>
		<span class="n">MFIE_STRING</span><span class="p">(</span><span class="n">CF_PARAMS</span><span class="p">);</span>
		<span class="n">MFIE_STRING</span><span class="p">(</span><span class="n">TIM</span><span class="p">);</span>
		<span class="n">MFIE_STRING</span><span class="p">(</span><span class="n">IBSS_PARAMS</span><span class="p">);</span>
		<span class="n">MFIE_STRING</span><span class="p">(</span><span class="n">COUNTRY</span><span class="p">);</span>
		<span class="n">MFIE_STRING</span><span class="p">(</span><span class="n">HP_PARAMS</span><span class="p">);</span>
		<span class="n">MFIE_STRING</span><span class="p">(</span><span class="n">HP_TABLE</span><span class="p">);</span>
		<span class="n">MFIE_STRING</span><span class="p">(</span><span class="n">REQUEST</span><span class="p">);</span>
		<span class="n">MFIE_STRING</span><span class="p">(</span><span class="n">CHALLENGE</span><span class="p">);</span>
		<span class="n">MFIE_STRING</span><span class="p">(</span><span class="n">PWR_CONSTRAINT</span><span class="p">);</span>
		<span class="n">MFIE_STRING</span><span class="p">(</span><span class="n">PWR_CAPABILITY</span><span class="p">);</span>
		<span class="n">MFIE_STRING</span><span class="p">(</span><span class="n">TPC_REQUEST</span><span class="p">);</span>
		<span class="n">MFIE_STRING</span><span class="p">(</span><span class="n">TPC_REPORT</span><span class="p">);</span>
		<span class="n">MFIE_STRING</span><span class="p">(</span><span class="n">SUPPORTED_CHANNELS</span><span class="p">);</span>
		<span class="n">MFIE_STRING</span><span class="p">(</span><span class="n">CHANNEL_SWITCH</span><span class="p">);</span>
		<span class="n">MFIE_STRING</span><span class="p">(</span><span class="n">MEASURE_REQUEST</span><span class="p">);</span>
		<span class="n">MFIE_STRING</span><span class="p">(</span><span class="n">MEASURE_REPORT</span><span class="p">);</span>
		<span class="n">MFIE_STRING</span><span class="p">(</span><span class="n">QUIET</span><span class="p">);</span>
		<span class="n">MFIE_STRING</span><span class="p">(</span><span class="n">IBSS_DFS</span><span class="p">);</span>
		<span class="n">MFIE_STRING</span><span class="p">(</span><span class="n">ERP_INFO</span><span class="p">);</span>
		<span class="n">MFIE_STRING</span><span class="p">(</span><span class="n">RSN</span><span class="p">);</span>
		<span class="n">MFIE_STRING</span><span class="p">(</span><span class="n">EXT_SUPP_RATES</span><span class="p">);</span>
		<span class="n">MFIE_STRING</span><span class="p">(</span><span class="n">GENERIC</span><span class="p">);</span>
		<span class="n">MFIE_STRING</span><span class="p">(</span><span class="n">QOS_PARAMETER</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="s">&quot;UNKNOWN&quot;</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">libipw_parse_info_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">libipw_info_element</span>
				      <span class="o">*</span><span class="n">info_element</span><span class="p">,</span> <span class="n">u16</span> <span class="n">length</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">libipw_network</span> <span class="o">*</span><span class="n">network</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DECLARE_SSID_BUF</span><span class="p">(</span><span class="n">ssid</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">i</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_LIBIPW_DEBUG</span>
	<span class="kt">char</span> <span class="n">rates_str</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info_element</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info_element</span><span class="p">)</span> <span class="o">+</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">LIBIPW_DEBUG_MGMT</span><span class="p">(</span><span class="s">&quot;Info elem: parse failed: &quot;</span>
					     <span class="s">&quot;info_element-&gt;len + 2 &gt; left : &quot;</span>
					     <span class="s">&quot;info_element-&gt;len+2=%zd left=%d, id=%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span>
					     <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info_element</span><span class="p">),</span>
					     <span class="n">length</span><span class="p">,</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
			<span class="cm">/* We stop processing but don&#39;t return an error here</span>
<span class="cm">			 * because some misbehaviour APs break this rule. ie.</span>
<span class="cm">			 * Orinoco AP1000. */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">info_element</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">WLAN_EID_SSID</span>:
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">ssid_len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">info_element</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
						<span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">IW_ESSID_MAX_SIZE</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">network</span><span class="o">-&gt;</span><span class="n">ssid</span><span class="p">,</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
			       <span class="n">network</span><span class="o">-&gt;</span><span class="n">ssid_len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">network</span><span class="o">-&gt;</span><span class="n">ssid_len</span> <span class="o">&lt;</span> <span class="n">IW_ESSID_MAX_SIZE</span><span class="p">)</span>
				<span class="n">memset</span><span class="p">(</span><span class="n">network</span><span class="o">-&gt;</span><span class="n">ssid</span> <span class="o">+</span> <span class="n">network</span><span class="o">-&gt;</span><span class="n">ssid_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				       <span class="n">IW_ESSID_MAX_SIZE</span> <span class="o">-</span> <span class="n">network</span><span class="o">-&gt;</span><span class="n">ssid_len</span><span class="p">);</span>

			<span class="n">LIBIPW_DEBUG_MGMT</span><span class="p">(</span><span class="s">&quot;WLAN_EID_SSID: &#39;%s&#39; len=%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">print_ssid</span><span class="p">(</span><span class="n">ssid</span><span class="p">,</span> <span class="n">network</span><span class="o">-&gt;</span><span class="n">ssid</span><span class="p">,</span>
							<span class="n">network</span><span class="o">-&gt;</span><span class="n">ssid_len</span><span class="p">),</span>
					     <span class="n">network</span><span class="o">-&gt;</span><span class="n">ssid_len</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">WLAN_EID_SUPP_RATES</span>:
<span class="cp">#ifdef CONFIG_LIBIPW_DEBUG</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">rates_str</span><span class="p">;</span>
<span class="cp">#endif</span>
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">rates_len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">info_element</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
						 <span class="n">MAX_RATES_LENGTH</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">network</span><span class="o">-&gt;</span><span class="n">rates_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">network</span><span class="o">-&gt;</span><span class="n">rates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="cp">#ifdef CONFIG_LIBIPW_DEBUG</span>
				<span class="n">p</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rates_str</span><span class="p">)</span> <span class="o">-</span>
					      <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">rates_str</span><span class="p">),</span> <span class="s">&quot;%02X &quot;</span><span class="p">,</span>
					      <span class="n">network</span><span class="o">-&gt;</span><span class="n">rates</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="cp">#endif</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">libipw_is_ofdm_rate</span>
				    <span class="p">(</span><span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
					<span class="n">network</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">NETWORK_HAS_OFDM</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span>
					    <span class="n">LIBIPW_BASIC_RATE_MASK</span><span class="p">)</span>
						<span class="n">network</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span>
						    <span class="o">~</span><span class="n">NETWORK_HAS_CCK</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="n">LIBIPW_DEBUG_MGMT</span><span class="p">(</span><span class="s">&quot;WLAN_EID_SUPP_RATES: &#39;%s&#39; (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">rates_str</span><span class="p">,</span> <span class="n">network</span><span class="o">-&gt;</span><span class="n">rates_len</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">WLAN_EID_EXT_SUPP_RATES</span>:
<span class="cp">#ifdef CONFIG_LIBIPW_DEBUG</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">rates_str</span><span class="p">;</span>
<span class="cp">#endif</span>
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">rates_ex_len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">info_element</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
						    <span class="n">MAX_RATES_EX_LENGTH</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">network</span><span class="o">-&gt;</span><span class="n">rates_ex_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">network</span><span class="o">-&gt;</span><span class="n">rates_ex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="cp">#ifdef CONFIG_LIBIPW_DEBUG</span>
				<span class="n">p</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rates_str</span><span class="p">)</span> <span class="o">-</span>
					      <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">rates_str</span><span class="p">),</span> <span class="s">&quot;%02X &quot;</span><span class="p">,</span>
					      <span class="n">network</span><span class="o">-&gt;</span><span class="n">rates</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="cp">#endif</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">libipw_is_ofdm_rate</span>
				    <span class="p">(</span><span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
					<span class="n">network</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">NETWORK_HAS_OFDM</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span>
					    <span class="n">LIBIPW_BASIC_RATE_MASK</span><span class="p">)</span>
						<span class="n">network</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span>
						    <span class="o">~</span><span class="n">NETWORK_HAS_CCK</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="n">LIBIPW_DEBUG_MGMT</span><span class="p">(</span><span class="s">&quot;WLAN_EID_EXT_SUPP_RATES: &#39;%s&#39; (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">rates_str</span><span class="p">,</span> <span class="n">network</span><span class="o">-&gt;</span><span class="n">rates_ex_len</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">WLAN_EID_DS_PARAMS</span>:
			<span class="n">LIBIPW_DEBUG_MGMT</span><span class="p">(</span><span class="s">&quot;WLAN_EID_DS_PARAMS: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">=</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">WLAN_EID_FH_PARAMS</span>:
			<span class="n">LIBIPW_DEBUG_MGMT</span><span class="p">(</span><span class="s">&quot;WLAN_EID_FH_PARAMS: ignored</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">WLAN_EID_CF_PARAMS</span>:
			<span class="n">LIBIPW_DEBUG_MGMT</span><span class="p">(</span><span class="s">&quot;WLAN_EID_CF_PARAMS: ignored</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">WLAN_EID_TIM</span>:
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">tim</span><span class="p">.</span><span class="n">tim_count</span> <span class="o">=</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">tim</span><span class="p">.</span><span class="n">tim_period</span> <span class="o">=</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
			<span class="n">LIBIPW_DEBUG_MGMT</span><span class="p">(</span><span class="s">&quot;WLAN_EID_TIM: partially ignored</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">WLAN_EID_ERP_INFO</span>:
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">erp_value</span> <span class="o">=</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">NETWORK_HAS_ERP_VALUE</span><span class="p">;</span>
			<span class="n">LIBIPW_DEBUG_MGMT</span><span class="p">(</span><span class="s">&quot;MFIE_TYPE_ERP_SET: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">network</span><span class="o">-&gt;</span><span class="n">erp_value</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">WLAN_EID_IBSS_PARAMS</span>:
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">atim_window</span> <span class="o">=</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">LIBIPW_DEBUG_MGMT</span><span class="p">(</span><span class="s">&quot;WLAN_EID_IBSS_PARAMS: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">network</span><span class="o">-&gt;</span><span class="n">atim_window</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">WLAN_EID_CHALLENGE</span>:
			<span class="n">LIBIPW_DEBUG_MGMT</span><span class="p">(</span><span class="s">&quot;WLAN_EID_CHALLENGE: ignored</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">WLAN_EID_GENERIC</span>:
			<span class="n">LIBIPW_DEBUG_MGMT</span><span class="p">(</span><span class="s">&quot;WLAN_EID_GENERIC: %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">libipw_parse_qos_info_param_IE</span><span class="p">(</span><span class="n">info_element</span><span class="p">,</span>
							       <span class="n">network</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">info_element</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span>
			    <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x00</span> <span class="o">&amp;&amp;</span>
			    <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x50</span> <span class="o">&amp;&amp;</span>
			    <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xf2</span> <span class="o">&amp;&amp;</span>
			    <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x01</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">network</span><span class="o">-&gt;</span><span class="n">wpa_ie_len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">info_element</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span>
							  <span class="n">MAX_WPA_IE_LEN</span><span class="p">);</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">network</span><span class="o">-&gt;</span><span class="n">wpa_ie</span><span class="p">,</span> <span class="n">info_element</span><span class="p">,</span>
				       <span class="n">network</span><span class="o">-&gt;</span><span class="n">wpa_ie_len</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">WLAN_EID_RSN</span>:
			<span class="n">LIBIPW_DEBUG_MGMT</span><span class="p">(</span><span class="s">&quot;WLAN_EID_RSN: %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">rsn_ie_len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">info_element</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span>
						  <span class="n">MAX_WPA_IE_LEN</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">network</span><span class="o">-&gt;</span><span class="n">rsn_ie</span><span class="p">,</span> <span class="n">info_element</span><span class="p">,</span>
			       <span class="n">network</span><span class="o">-&gt;</span><span class="n">rsn_ie_len</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">WLAN_EID_QOS_PARAMETER</span>:
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			       <span class="s">&quot;QoS Error need to parse QOS_PARAMETER IE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* 802.11h */</span>
		<span class="k">case</span> <span class="n">WLAN_EID_PWR_CONSTRAINT</span>:
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">power_constraint</span> <span class="o">=</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">NETWORK_HAS_POWER_CONSTRAINT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">WLAN_EID_CHANNEL_SWITCH</span>:
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">power_constraint</span> <span class="o">=</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">NETWORK_HAS_CSA</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">WLAN_EID_QUIET</span>:
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">quiet</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">quiet</span><span class="p">.</span><span class="n">period</span> <span class="o">=</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">quiet</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">quiet</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">NETWORK_HAS_QUIET</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">WLAN_EID_IBSS_DFS</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">network</span><span class="o">-&gt;</span><span class="n">ibss_dfs</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">ibss_dfs</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
						    <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
						    <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">network</span><span class="o">-&gt;</span><span class="n">ibss_dfs</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">NETWORK_HAS_IBSS_DFS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">WLAN_EID_TPC_REPORT</span>:
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">tpc_report</span><span class="p">.</span><span class="n">transmit_power</span> <span class="o">=</span>
			    <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">tpc_report</span><span class="p">.</span><span class="n">link_margin</span> <span class="o">=</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">NETWORK_HAS_TPC_REPORT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">LIBIPW_DEBUG_MGMT</span>
			    <span class="p">(</span><span class="s">&quot;Unsupported info element: %s (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">get_info_element_string</span><span class="p">(</span><span class="n">info_element</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">),</span>
			     <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">length</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info_element</span><span class="p">)</span> <span class="o">+</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">info_element</span> <span class="o">=</span>
		    <span class="p">(</span><span class="k">struct</span> <span class="n">libipw_info_element</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">info_element</span><span class="o">-&gt;</span>
		    <span class="n">data</span><span class="p">[</span><span class="n">info_element</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">libipw_handle_assoc_resp</span><span class="p">(</span><span class="k">struct</span> <span class="n">libipw_device</span> <span class="o">*</span><span class="n">ieee</span><span class="p">,</span> <span class="k">struct</span> <span class="n">libipw_assoc_response</span>
				       <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="k">struct</span> <span class="n">libipw_rx_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">libipw_network</span> <span class="n">network_resp</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ibss_dfs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">libipw_network</span> <span class="o">*</span><span class="n">network</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">network_resp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">network</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">qos_data</span><span class="p">.</span><span class="n">active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">qos_data</span><span class="p">.</span><span class="n">supported</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">qos_data</span><span class="p">.</span><span class="n">param_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">qos_data</span><span class="p">.</span><span class="n">old_param_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>network->atim<em>window = le16</em>to_cpu(frame->aid) &amp; (0x3FFF);</p></td><td class="code"><div class="highlight"><pre>	<span class="n">network</span><span class="o">-&gt;</span><span class="n">atim_window</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">aid</span><span class="p">);</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">listen_interval</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">network</span><span class="o">-&gt;</span><span class="n">bssid</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">addr3</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">capability</span><span class="p">);</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">last_scanned</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">rates_len</span> <span class="o">=</span> <span class="n">network</span><span class="o">-&gt;</span><span class="n">rates_ex_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">last_associate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">ssid_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">erp_value</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">network</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">WLAN_CAPABILITY_IBSS</span><span class="p">)</span> <span class="o">?</span> <span class="mh">0x3</span> <span class="o">:</span> <span class="mh">0x0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">freq</span> <span class="o">==</span> <span class="n">LIBIPW_52GHZ_BAND</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* for A band (No DS info) */</span>
		<span class="n">network</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">received_channel</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">network</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">NETWORK_HAS_CCK</span><span class="p">;</span>

	<span class="n">network</span><span class="o">-&gt;</span><span class="n">wpa_ie_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">rsn_ie_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">libipw_parse_info_param</span>
	    <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">info_element</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">frame</span><span class="p">),</span> <span class="n">network</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">network</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">freq</span> <span class="o">==</span> <span class="n">LIBIPW_52GHZ_BAND</span><span class="p">)</span>
		<span class="n">network</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">IEEE_A</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">network</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NETWORK_HAS_OFDM</span><span class="p">)</span>
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">|=</span> <span class="n">IEEE_G</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">network</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NETWORK_HAS_CCK</span><span class="p">)</span>
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">|=</span> <span class="n">IEEE_B</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">network</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">network</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">handle_assoc_response</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">ieee</span><span class="o">-&gt;</span><span class="n">handle_assoc_response</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">network</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/***************************************************/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">libipw_network_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">libipw_device</span> <span class="o">*</span><span class="n">ieee</span><span class="p">,</span> <span class="k">struct</span> <span class="n">libipw_probe_response</span>
					 <span class="o">*</span><span class="n">beacon</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">libipw_network</span> <span class="o">*</span><span class="n">network</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">libipw_rx_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DECLARE_SSID_BUF</span><span class="p">(</span><span class="n">ssid</span><span class="p">);</span>

	<span class="n">network</span><span class="o">-&gt;</span><span class="n">qos_data</span><span class="p">.</span><span class="n">active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">qos_data</span><span class="p">.</span><span class="n">supported</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">qos_data</span><span class="p">.</span><span class="n">param_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">qos_data</span><span class="p">.</span><span class="n">old_param_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Pull out fixed field data */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">network</span><span class="o">-&gt;</span><span class="n">bssid</span><span class="p">,</span> <span class="n">beacon</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">addr3</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">capability</span><span class="p">);</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">last_scanned</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">time_stamp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">time_stamp</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">time_stamp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">time_stamp</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">beacon_interval</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">beacon_interval</span><span class="p">);</span>
	<span class="cm">/* Where to pull this? beacon-&gt;listen_interval; */</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">listen_interval</span> <span class="o">=</span> <span class="mh">0x0A</span><span class="p">;</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">rates_len</span> <span class="o">=</span> <span class="n">network</span><span class="o">-&gt;</span><span class="n">rates_ex_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">last_associate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">ssid_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">atim_window</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">erp_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">network</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">WLAN_CAPABILITY_IBSS</span><span class="p">)</span> <span class="o">?</span>
	    <span class="mh">0x3</span> <span class="o">:</span> <span class="mh">0x0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">freq</span> <span class="o">==</span> <span class="n">LIBIPW_52GHZ_BAND</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* for A band (No DS info) */</span>
		<span class="n">network</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">received_channel</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">network</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">NETWORK_HAS_CCK</span><span class="p">;</span>

	<span class="n">network</span><span class="o">-&gt;</span><span class="n">wpa_ie_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">network</span><span class="o">-&gt;</span><span class="n">rsn_ie_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">libipw_parse_info_param</span>
	    <span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">info_element</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">beacon</span><span class="p">),</span> <span class="n">network</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">network</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">freq</span> <span class="o">==</span> <span class="n">LIBIPW_52GHZ_BAND</span><span class="p">)</span>
		<span class="n">network</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">IEEE_A</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">network</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NETWORK_HAS_OFDM</span><span class="p">)</span>
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">|=</span> <span class="n">IEEE_G</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">network</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NETWORK_HAS_CCK</span><span class="p">)</span>
			<span class="n">network</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">|=</span> <span class="n">IEEE_B</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">network</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">LIBIPW_DEBUG_SCAN</span><span class="p">(</span><span class="s">&quot;Filtered out &#39;%s (%pM)&#39; &quot;</span>
				     <span class="s">&quot;network.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">print_ssid</span><span class="p">(</span><span class="n">ssid</span><span class="p">,</span> <span class="n">network</span><span class="o">-&gt;</span><span class="n">ssid</span><span class="p">,</span>
						 <span class="n">network</span><span class="o">-&gt;</span><span class="n">ssid_len</span><span class="p">),</span>
				     <span class="n">network</span><span class="o">-&gt;</span><span class="n">bssid</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">network</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">network</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_same_network</span><span class="p">(</span><span class="k">struct</span> <span class="n">libipw_network</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">libipw_network</span> <span class="o">*</span><span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* A network is only a duplicate if the channel, BSSID, and ESSID</span>
<span class="cm">	 * all match.  We treat all &lt;hidden&gt; with the same BSSID and channel</span>
<span class="cm">	 * as one network */</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">ssid_len</span> <span class="o">==</span> <span class="n">dst</span><span class="o">-&gt;</span><span class="n">ssid_len</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">==</span> <span class="n">dst</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">ether_addr_equal</span><span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">bssid</span><span class="p">,</span> <span class="n">dst</span><span class="o">-&gt;</span><span class="n">bssid</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">ssid</span><span class="p">,</span> <span class="n">dst</span><span class="o">-&gt;</span><span class="n">ssid</span><span class="p">,</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">ssid_len</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_network</span><span class="p">(</span><span class="k">struct</span> <span class="n">libipw_network</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">libipw_network</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">qos_active</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">old_param</span><span class="p">;</span>

	<span class="n">libipw_network_reset</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">ibss_dfs</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">ibss_dfs</span><span class="p">;</span>

	<span class="cm">/* We only update the statistics if they were created by receiving</span>
<span class="cm">	 * the network information on the actual channel the network is on.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This keeps beacons received on neighbor channels from bringing</span>
<span class="cm">	 * down the signal level of an AP. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">==</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">received_channel</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">libipw_rx_stats</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">LIBIPW_DEBUG_SCAN</span><span class="p">(</span><span class="s">&quot;Network %pM info received &quot;</span>
			<span class="s">&quot;off channel (%d vs. %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">bssid</span><span class="p">,</span>
			<span class="n">dst</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">received_channel</span><span class="p">);</span>

	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">capability</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">rates</span><span class="p">,</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">rates</span><span class="p">,</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">rates_len</span><span class="p">);</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">rates_len</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">rates_len</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">rates_ex</span><span class="p">,</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">rates_ex</span><span class="p">,</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">rates_ex_len</span><span class="p">);</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">rates_ex_len</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">rates_ex_len</span><span class="p">;</span>

	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">;</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">time_stamp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">time_stamp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">time_stamp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">time_stamp</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">beacon_interval</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">beacon_interval</span><span class="p">;</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">listen_interval</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">listen_interval</span><span class="p">;</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">atim_window</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">atim_window</span><span class="p">;</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">erp_value</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">erp_value</span><span class="p">;</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">tim</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">tim</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">wpa_ie</span><span class="p">,</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">wpa_ie</span><span class="p">,</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">wpa_ie_len</span><span class="p">);</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">wpa_ie_len</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">wpa_ie_len</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">rsn_ie</span><span class="p">,</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">rsn_ie</span><span class="p">,</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">rsn_ie_len</span><span class="p">);</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">rsn_ie_len</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">rsn_ie_len</span><span class="p">;</span>

	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">last_scanned</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">qos_active</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">qos_data</span><span class="p">.</span><span class="n">active</span><span class="p">;</span>
	<span class="n">old_param</span> <span class="o">=</span> <span class="n">dst</span><span class="o">-&gt;</span><span class="n">qos_data</span><span class="p">.</span><span class="n">old_param_count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NETWORK_HAS_QOS_MASK</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">qos_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">qos_data</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">libipw_qos_data</span><span class="p">));</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">dst</span><span class="o">-&gt;</span><span class="n">qos_data</span><span class="p">.</span><span class="n">supported</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">qos_data</span><span class="p">.</span><span class="n">supported</span><span class="p">;</span>
		<span class="n">dst</span><span class="o">-&gt;</span><span class="n">qos_data</span><span class="p">.</span><span class="n">param_count</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">qos_data</span><span class="p">.</span><span class="n">param_count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">qos_data</span><span class="p">.</span><span class="n">supported</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">ssid_len</span><span class="p">)</span>
			<span class="n">LIBIPW_DEBUG_QOS</span>
			    <span class="p">(</span><span class="s">&quot;QoS the network %s is QoS supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">dst</span><span class="o">-&gt;</span><span class="n">ssid</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">LIBIPW_DEBUG_QOS</span>
			    <span class="p">(</span><span class="s">&quot;QoS the network is QoS supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">qos_data</span><span class="p">.</span><span class="n">active</span> <span class="o">=</span> <span class="n">qos_active</span><span class="p">;</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">qos_data</span><span class="p">.</span><span class="n">old_param_count</span> <span class="o">=</span> <span class="n">old_param</span><span class="p">;</span>

	<span class="cm">/* dst-&gt;last_associate is not overwritten */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_beacon</span><span class="p">(</span><span class="n">__le16</span> <span class="n">fc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">WLAN_FC_GET_STYPE</span><span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">fc</span><span class="p">))</span> <span class="o">==</span> <span class="n">IEEE80211_STYPE_BEACON</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">libipw_process_probe_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">libipw_device</span>
						    <span class="o">*</span><span class="n">ieee</span><span class="p">,</span> <span class="k">struct</span>
						    <span class="n">libipw_probe_response</span>
						    <span class="o">*</span><span class="n">beacon</span><span class="p">,</span> <span class="k">struct</span> <span class="n">libipw_rx_stats</span>
						    <span class="o">*</span><span class="n">stats</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">libipw_network</span> <span class="n">network</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ibss_dfs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">libipw_network</span> <span class="o">*</span><span class="n">target</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">libipw_network</span> <span class="o">*</span><span class="n">oldest</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_LIBIPW_DEBUG</span>
	<span class="k">struct</span> <span class="n">libipw_info_element</span> <span class="o">*</span><span class="n">info_element</span> <span class="o">=</span> <span class="n">beacon</span><span class="o">-&gt;</span><span class="n">info_element</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">DECLARE_SSID_BUF</span><span class="p">(</span><span class="n">ssid</span><span class="p">);</span>

	<span class="n">LIBIPW_DEBUG_SCAN</span><span class="p">(</span><span class="s">&quot;&#39;%s&#39; (%pM&quot;</span>
		     <span class="s">&quot;): %c%c%c%c %c%c%c%c-%c%c%c%c %c%c%c%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">print_ssid</span><span class="p">(</span><span class="n">ssid</span><span class="p">,</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">),</span>
		     <span class="n">beacon</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">addr3</span><span class="p">,</span>
		     <span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mh">0xf</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;1&#39;</span> <span class="o">:</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span>
		     <span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mh">0xe</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;1&#39;</span> <span class="o">:</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span>
		     <span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mh">0xd</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;1&#39;</span> <span class="o">:</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span>
		     <span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mh">0xc</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;1&#39;</span> <span class="o">:</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span>
		     <span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mh">0xb</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;1&#39;</span> <span class="o">:</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span>
		     <span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mh">0xa</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;1&#39;</span> <span class="o">:</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span>
		     <span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mh">0x9</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;1&#39;</span> <span class="o">:</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span>
		     <span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mh">0x8</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;1&#39;</span> <span class="o">:</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span>
		     <span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mh">0x7</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;1&#39;</span> <span class="o">:</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span>
		     <span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mh">0x6</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;1&#39;</span> <span class="o">:</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span>
		     <span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mh">0x5</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;1&#39;</span> <span class="o">:</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span>
		     <span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mh">0x4</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;1&#39;</span> <span class="o">:</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span>
		     <span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mh">0x3</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;1&#39;</span> <span class="o">:</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span>
		     <span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mh">0x2</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;1&#39;</span> <span class="o">:</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span>
		     <span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mh">0x1</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;1&#39;</span> <span class="o">:</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span>
		     <span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mh">0x0</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;1&#39;</span> <span class="o">:</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">libipw_network_init</span><span class="p">(</span><span class="n">ieee</span><span class="p">,</span> <span class="n">beacon</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">network</span><span class="p">,</span> <span class="n">stats</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">LIBIPW_DEBUG_SCAN</span><span class="p">(</span><span class="s">&quot;Dropped &#39;%s&#39; (%pM) via %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">print_ssid</span><span class="p">(</span><span class="n">ssid</span><span class="p">,</span> <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
						 <span class="n">info_element</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">),</span>
				     <span class="n">beacon</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">addr3</span><span class="p">,</span>
				     <span class="n">is_beacon</span><span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">frame_ctl</span><span class="p">)</span> <span class="o">?</span>
				     <span class="s">&quot;BEACON&quot;</span> <span class="o">:</span> <span class="s">&quot;PROBE RESPONSE&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The network parsed correctly -- so now we scan our known networks</span>
<span class="cm">	 * to see if we can find it in our list.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE:  This search is definitely not optimized.  Once its doing</span>
<span class="cm">	 *        the &quot;right thing&quot; we&#39;ll optimize it for efficiency if</span>
<span class="cm">	 *        necessary */</span>

	<span class="cm">/* Search for this entry in the list and update it if it is</span>
<span class="cm">	 * already there. */</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">network_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_same_network</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">network</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">oldest</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">time_before</span><span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">last_scanned</span><span class="p">,</span> <span class="n">oldest</span><span class="o">-&gt;</span><span class="n">last_scanned</span><span class="p">))</span>
			<span class="n">oldest</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If we didn&#39;t find a match, then get a new network slot to initialize</span>
<span class="cm">	 * with this beacon&#39;s information */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">network_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">network_free_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* If there are no more slots, expire the oldest */</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldest</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">target</span> <span class="o">=</span> <span class="n">oldest</span><span class="p">;</span>
			<span class="n">LIBIPW_DEBUG_SCAN</span><span class="p">(</span><span class="s">&quot;Expired &#39;%s&#39; (%pM) from &quot;</span>
					     <span class="s">&quot;network list.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">print_ssid</span><span class="p">(</span><span class="n">ssid</span><span class="p">,</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">ssid</span><span class="p">,</span>
							 <span class="n">target</span><span class="o">-&gt;</span><span class="n">ssid_len</span><span class="p">),</span>
					     <span class="n">target</span><span class="o">-&gt;</span><span class="n">bssid</span><span class="p">);</span>
			<span class="n">libipw_network_reset</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Otherwise just pull from the free list */</span>
			<span class="n">target</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">network_free_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">libipw_network</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">network_free_list</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
		<span class="p">}</span>

<span class="cp">#ifdef CONFIG_LIBIPW_DEBUG</span>
		<span class="n">LIBIPW_DEBUG_SCAN</span><span class="p">(</span><span class="s">&quot;Adding &#39;%s&#39; (%pM) via %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">print_ssid</span><span class="p">(</span><span class="n">ssid</span><span class="p">,</span> <span class="n">network</span><span class="p">.</span><span class="n">ssid</span><span class="p">,</span>
						 <span class="n">network</span><span class="p">.</span><span class="n">ssid_len</span><span class="p">),</span>
				     <span class="n">network</span><span class="p">.</span><span class="n">bssid</span><span class="p">,</span>
				     <span class="n">is_beacon</span><span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">frame_ctl</span><span class="p">)</span> <span class="o">?</span>
				     <span class="s">&quot;BEACON&quot;</span> <span class="o">:</span> <span class="s">&quot;PROBE RESPONSE&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">network</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">target</span><span class="p">));</span>
		<span class="n">network</span><span class="p">.</span><span class="n">ibss_dfs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">network_list</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">LIBIPW_DEBUG_SCAN</span><span class="p">(</span><span class="s">&quot;Updating &#39;%s&#39; (%pM) via %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">print_ssid</span><span class="p">(</span><span class="n">ssid</span><span class="p">,</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">ssid</span><span class="p">,</span>
						 <span class="n">target</span><span class="o">-&gt;</span><span class="n">ssid_len</span><span class="p">),</span>
				     <span class="n">target</span><span class="o">-&gt;</span><span class="n">bssid</span><span class="p">,</span>
				     <span class="n">is_beacon</span><span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">frame_ctl</span><span class="p">)</span> <span class="o">?</span>
				     <span class="s">&quot;BEACON&quot;</span> <span class="o">:</span> <span class="s">&quot;PROBE RESPONSE&quot;</span><span class="p">);</span>
		<span class="n">update_network</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">network</span><span class="p">);</span>
		<span class="n">network</span><span class="p">.</span><span class="n">ibss_dfs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_beacon</span><span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">frame_ctl</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">handle_beacon</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">ieee</span><span class="o">-&gt;</span><span class="n">handle_beacon</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">beacon</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">handle_probe_response</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">ieee</span><span class="o">-&gt;</span><span class="n">handle_probe_response</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">beacon</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">libipw_rx_mgt</span><span class="p">(</span><span class="k">struct</span> <span class="n">libipw_device</span> <span class="o">*</span><span class="n">ieee</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">libipw_hdr_4addr</span> <span class="o">*</span><span class="n">header</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">libipw_rx_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">WLAN_FC_GET_STYPE</span><span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">frame_ctl</span><span class="p">)))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IEEE80211_STYPE_ASSOC_RESP</span>:
		<span class="n">LIBIPW_DEBUG_MGMT</span><span class="p">(</span><span class="s">&quot;received ASSOCIATION RESPONSE (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">WLAN_FC_GET_STYPE</span><span class="p">(</span><span class="n">le16_to_cpu</span>
						       <span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">frame_ctl</span><span class="p">)));</span>
		<span class="n">libipw_handle_assoc_resp</span><span class="p">(</span><span class="n">ieee</span><span class="p">,</span>
					    <span class="p">(</span><span class="k">struct</span> <span class="n">libipw_assoc_response</span> <span class="o">*</span><span class="p">)</span>
					    <span class="n">header</span><span class="p">,</span> <span class="n">stats</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IEEE80211_STYPE_REASSOC_RESP</span>:
		<span class="n">LIBIPW_DEBUG_MGMT</span><span class="p">(</span><span class="s">&quot;received REASSOCIATION RESPONSE (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">WLAN_FC_GET_STYPE</span><span class="p">(</span><span class="n">le16_to_cpu</span>
						       <span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">frame_ctl</span><span class="p">)));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IEEE80211_STYPE_PROBE_REQ</span>:
		<span class="n">LIBIPW_DEBUG_MGMT</span><span class="p">(</span><span class="s">&quot;received auth (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">WLAN_FC_GET_STYPE</span><span class="p">(</span><span class="n">le16_to_cpu</span>
						       <span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">frame_ctl</span><span class="p">)));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">handle_probe_request</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">ieee</span><span class="o">-&gt;</span><span class="n">handle_probe_request</span><span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						   <span class="p">(</span><span class="k">struct</span>
						    <span class="n">libipw_probe_request</span> <span class="o">*</span><span class="p">)</span>
						   <span class="n">header</span><span class="p">,</span> <span class="n">stats</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IEEE80211_STYPE_PROBE_RESP</span>:
		<span class="n">LIBIPW_DEBUG_MGMT</span><span class="p">(</span><span class="s">&quot;received PROBE RESPONSE (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">WLAN_FC_GET_STYPE</span><span class="p">(</span><span class="n">le16_to_cpu</span>
						       <span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">frame_ctl</span><span class="p">)));</span>
		<span class="n">LIBIPW_DEBUG_SCAN</span><span class="p">(</span><span class="s">&quot;Probe response</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">libipw_process_probe_response</span><span class="p">(</span><span class="n">ieee</span><span class="p">,</span>
						 <span class="p">(</span><span class="k">struct</span>
						  <span class="n">libipw_probe_response</span> <span class="o">*</span><span class="p">)</span>
						 <span class="n">header</span><span class="p">,</span> <span class="n">stats</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IEEE80211_STYPE_BEACON</span>:
		<span class="n">LIBIPW_DEBUG_MGMT</span><span class="p">(</span><span class="s">&quot;received BEACON (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">WLAN_FC_GET_STYPE</span><span class="p">(</span><span class="n">le16_to_cpu</span>
						       <span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">frame_ctl</span><span class="p">)));</span>
		<span class="n">LIBIPW_DEBUG_SCAN</span><span class="p">(</span><span class="s">&quot;Beacon</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">libipw_process_probe_response</span><span class="p">(</span><span class="n">ieee</span><span class="p">,</span>
						 <span class="p">(</span><span class="k">struct</span>
						  <span class="n">libipw_probe_response</span> <span class="o">*</span><span class="p">)</span>
						 <span class="n">header</span><span class="p">,</span> <span class="n">stats</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IEEE80211_STYPE_AUTH</span>:

		<span class="n">LIBIPW_DEBUG_MGMT</span><span class="p">(</span><span class="s">&quot;received auth (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">WLAN_FC_GET_STYPE</span><span class="p">(</span><span class="n">le16_to_cpu</span>
						       <span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">frame_ctl</span><span class="p">)));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">handle_auth</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">ieee</span><span class="o">-&gt;</span><span class="n">handle_auth</span><span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					  <span class="p">(</span><span class="k">struct</span> <span class="n">libipw_auth</span> <span class="o">*</span><span class="p">)</span><span class="n">header</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IEEE80211_STYPE_DISASSOC</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">handle_disassoc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">ieee</span><span class="o">-&gt;</span><span class="n">handle_disassoc</span><span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					      <span class="p">(</span><span class="k">struct</span> <span class="n">libipw_disassoc</span> <span class="o">*</span><span class="p">)</span>
					      <span class="n">header</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IEEE80211_STYPE_ACTION</span>:
		<span class="n">LIBIPW_DEBUG_MGMT</span><span class="p">(</span><span class="s">&quot;ACTION</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">handle_action</span><span class="p">)</span>
			<span class="n">ieee</span><span class="o">-&gt;</span><span class="n">handle_action</span><span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					    <span class="p">(</span><span class="k">struct</span> <span class="n">libipw_action</span> <span class="o">*</span><span class="p">)</span>
					    <span class="n">header</span><span class="p">,</span> <span class="n">stats</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IEEE80211_STYPE_REASSOC_REQ</span>:
		<span class="n">LIBIPW_DEBUG_MGMT</span><span class="p">(</span><span class="s">&quot;received reassoc (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">WLAN_FC_GET_STYPE</span><span class="p">(</span><span class="n">le16_to_cpu</span>
						       <span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">frame_ctl</span><span class="p">)));</span>

		<span class="n">LIBIPW_DEBUG_MGMT</span><span class="p">(</span><span class="s">&quot;%s: LIBIPW_REASSOC_REQ received</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">handle_reassoc_request</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">ieee</span><span class="o">-&gt;</span><span class="n">handle_reassoc_request</span><span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						    <span class="p">(</span><span class="k">struct</span> <span class="n">libipw_reassoc_request</span> <span class="o">*</span><span class="p">)</span>
						     <span class="n">header</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IEEE80211_STYPE_ASSOC_REQ</span>:
		<span class="n">LIBIPW_DEBUG_MGMT</span><span class="p">(</span><span class="s">&quot;received assoc (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">WLAN_FC_GET_STYPE</span><span class="p">(</span><span class="n">le16_to_cpu</span>
						       <span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">frame_ctl</span><span class="p">)));</span>

		<span class="n">LIBIPW_DEBUG_MGMT</span><span class="p">(</span><span class="s">&quot;%s: LIBIPW_ASSOC_REQ received</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">handle_assoc_request</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">ieee</span><span class="o">-&gt;</span><span class="n">handle_assoc_request</span><span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IEEE80211_STYPE_DEAUTH</span>:
		<span class="n">LIBIPW_DEBUG_MGMT</span><span class="p">(</span><span class="s">&quot;DEAUTH</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">handle_deauth</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">ieee</span><span class="o">-&gt;</span><span class="n">handle_deauth</span><span class="p">(</span><span class="n">ieee</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					    <span class="p">(</span><span class="k">struct</span> <span class="n">libipw_deauth</span> <span class="o">*</span><span class="p">)</span>
					    <span class="n">header</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">LIBIPW_DEBUG_MGMT</span><span class="p">(</span><span class="s">&quot;received UNKNOWN (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">WLAN_FC_GET_STYPE</span><span class="p">(</span><span class="n">le16_to_cpu</span>
						       <span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">frame_ctl</span><span class="p">)));</span>
		<span class="n">LIBIPW_DEBUG_MGMT</span><span class="p">(</span><span class="s">&quot;%s: Unknown management packet: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">ieee</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				     <span class="n">WLAN_FC_GET_STYPE</span><span class="p">(</span><span class="n">le16_to_cpu</span>
						       <span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">frame_ctl</span><span class="p">)));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">libipw_rx_any</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">libipw_rx_mgt</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">libipw_rx</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
