<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › ti › wlcore › wl12xx.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>wl12xx.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is part of wl1271</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1998-2009 Texas Instruments. All rights reserved.</span>
<span class="cm"> * Copyright (C) 2008-2009 Nokia Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * Contact: Luciano Coelho &lt;luciano.coelho@nokia.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * version 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301 USA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __WL12XX_H__</span>
<span class="cp">#define __WL12XX_H__</span>

<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;net/mac80211.h&gt;</span>

<span class="cp">#include &quot;conf.h&quot;</span>
<span class="cp">#include &quot;ini.h&quot;</span>

<span class="cp">#define WL127X_FW_NAME_MULTI &quot;ti-connectivity/wl127x-fw-4-mr.bin&quot;</span>
<span class="cp">#define WL127X_FW_NAME_SINGLE &quot;ti-connectivity/wl127x-fw-4-sr.bin&quot;</span>

<span class="cp">#define WL128X_FW_NAME_MULTI &quot;ti-connectivity/wl128x-fw-4-mr.bin&quot;</span>
<span class="cp">#define WL128X_FW_NAME_SINGLE &quot;ti-connectivity/wl128x-fw-4-sr.bin&quot;</span>

<span class="cp">#define WL127X_PLT_FW_NAME &quot;ti-connectivity/wl127x-fw-4-plt.bin&quot;</span>
<span class="cp">#define WL128X_PLT_FW_NAME &quot;ti-connectivity/wl128x-fw-4-plt.bin&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * wl127x and wl128x are using the same NVS file name. However, the</span>
<span class="cm"> * ini parameters between them are different.  The driver validates</span>
<span class="cm"> * the correct NVS size in wl1271_boot_upload_nvs().</span>
<span class="cm"> */</span>
<span class="cp">#define WL12XX_NVS_NAME &quot;ti-connectivity/wl1271-nvs.bin&quot;</span>

<span class="cp">#define WL1271_TX_SECURITY_LO16(s) ((u16)((s) &amp; 0xffff))</span>
<span class="cp">#define WL1271_TX_SECURITY_HI32(s) ((u32)(((s) &gt;&gt; 16) &amp; 0xffffffff))</span>
<span class="cp">#define WL1271_TX_SQN_POST_RECOVERY_PADDING 0xff</span>

<span class="cp">#define WL1271_CIPHER_SUITE_GEM 0x00147201</span>

<span class="cp">#define WL1271_BUSY_WORD_CNT 1</span>
<span class="cp">#define WL1271_BUSY_WORD_LEN (WL1271_BUSY_WORD_CNT * sizeof(u32))</span>

<span class="cp">#define WL1271_ELP_HW_STATE_ASLEEP 0</span>
<span class="cp">#define WL1271_ELP_HW_STATE_IRQ    1</span>

<span class="cp">#define WL1271_DEFAULT_BEACON_INT  100</span>
<span class="cp">#define WL1271_DEFAULT_DTIM_PERIOD 1</span>

<span class="cp">#define WL12XX_MAX_ROLES           4</span>
<span class="cp">#define WL12XX_MAX_LINKS           12</span>
<span class="cp">#define WL12XX_INVALID_ROLE_ID     0xff</span>
<span class="cp">#define WL12XX_INVALID_LINK_ID     0xff</span>

<span class="cp">#define WL12XX_MAX_RATE_POLICIES 16</span>

<span class="cm">/* Defined by FW as 0. Will not be freed or allocated. */</span>
<span class="cp">#define WL12XX_SYSTEM_HLID         0</span>

<span class="cm">/*</span>
<span class="cm"> * When in AP-mode, we allow (at least) this number of packets</span>
<span class="cm"> * to be transmitted to FW for a STA in PS-mode. Only when packets are</span>
<span class="cm"> * present in the FW buffers it will wake the sleeping STA. We want to put</span>
<span class="cm"> * enough packets for the driver to transmit all of its buffered data before</span>
<span class="cm"> * the STA goes to sleep again. But we don&#39;t want to take too much memory</span>
<span class="cm"> * as it might hurt the throughput of active STAs.</span>
<span class="cm"> */</span>
<span class="cp">#define WL1271_PS_STA_MAX_PACKETS  2</span>

<span class="cp">#define WL1271_AP_BSS_INDEX        0</span>
<span class="cp">#define WL1271_AP_DEF_BEACON_EXP   20</span>

<span class="cp">#define WL1271_AGGR_BUFFER_SIZE (4 * PAGE_SIZE)</span>

<span class="k">enum</span> <span class="n">wl1271_state</span> <span class="p">{</span>
	<span class="n">WL1271_STATE_OFF</span><span class="p">,</span>
	<span class="n">WL1271_STATE_ON</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">wl12xx_fw_type</span> <span class="p">{</span>
	<span class="n">WL12XX_FW_TYPE_NONE</span><span class="p">,</span>
	<span class="n">WL12XX_FW_TYPE_NORMAL</span><span class="p">,</span>
	<span class="n">WL12XX_FW_TYPE_MULTI</span><span class="p">,</span>
	<span class="n">WL12XX_FW_TYPE_PLT</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">wl1271</span><span class="p">;</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">FW_VER_CHIP</span><span class="p">,</span>
	<span class="n">FW_VER_IF_TYPE</span><span class="p">,</span>
	<span class="n">FW_VER_MAJOR</span><span class="p">,</span>
	<span class="n">FW_VER_SUBTYPE</span><span class="p">,</span>
	<span class="n">FW_VER_MINOR</span><span class="p">,</span>

	<span class="n">NUM_FW_VER</span>
<span class="p">};</span>

<span class="cp">#define FW_VER_CHIP_WL127X 6</span>
<span class="cp">#define FW_VER_CHIP_WL128X 7</span>

<span class="cp">#define FW_VER_IF_TYPE_STA 1</span>
<span class="cp">#define FW_VER_IF_TYPE_AP  2</span>

<span class="cp">#define FW_VER_MINOR_1_SPARE_STA_MIN 58</span>
<span class="cp">#define FW_VER_MINOR_1_SPARE_AP_MIN  47</span>

<span class="cp">#define FW_VER_MINOR_FWLOG_STA_MIN 70</span>

<span class="k">struct</span> <span class="n">wl1271_chip</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">fw_ver_str</span><span class="p">[</span><span class="n">ETHTOOL_BUSINFO_LEN</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fw_ver</span><span class="p">[</span><span class="n">NUM_FW_VER</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">wl1271_stats</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">acx_statistics</span> <span class="o">*</span><span class="n">fw_stats</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fw_stats_update</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">retry_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">excessive_retries</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define NUM_TX_QUEUES              4</span>
<span class="cp">#define NUM_RX_PKT_DESC            8</span>

<span class="cp">#define AP_MAX_STATIONS            8</span>

<span class="k">struct</span> <span class="n">wl_fw_packet_counters</span> <span class="p">{</span>
	<span class="cm">/* Cumulative counter of released packets per AC */</span>
	<span class="n">u8</span> <span class="n">tx_released_pkts</span><span class="p">[</span><span class="n">NUM_TX_QUEUES</span><span class="p">];</span>

	<span class="cm">/* Cumulative counter of freed packets per HLID */</span>
	<span class="n">u8</span> <span class="n">tx_lnk_free_pkts</span><span class="p">[</span><span class="n">WL12XX_MAX_LINKS</span><span class="p">];</span>

	<span class="cm">/* Cumulative counter of released Voice memory blocks */</span>
	<span class="n">u8</span> <span class="n">tx_voice_released_blks</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">padding</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* FW status registers */</span>
<span class="k">struct</span> <span class="n">wl_fw_status</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">intr</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">fw_rx_counter</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">drv_rx_counter</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">reserved</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">tx_results_counter</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">rx_pkt_descs</span><span class="p">[</span><span class="n">NUM_RX_PKT_DESC</span><span class="p">];</span>
	<span class="n">__le32</span> <span class="n">fw_localtime</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A bitmap (where each bit represents a single HLID)</span>
<span class="cm">	 * to indicate if the station is in PS mode.</span>
<span class="cm">	 */</span>
	<span class="n">__le32</span> <span class="n">link_ps_bitmap</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A bitmap (where each bit represents a single HLID) to indicate</span>
<span class="cm">	 * if the station is in Fast mode</span>
<span class="cm">	 */</span>
	<span class="n">__le32</span> <span class="n">link_fast_bitmap</span><span class="p">;</span>

	<span class="cm">/* Cumulative counter of total released mem blocks since FW-reset */</span>
	<span class="n">__le32</span> <span class="n">total_released_blks</span><span class="p">;</span>

	<span class="cm">/* Size (in Memory Blocks) of TX pool */</span>
	<span class="n">__le32</span> <span class="n">tx_total</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">wl_fw_packet_counters</span> <span class="n">counters</span><span class="p">;</span>

	<span class="n">__le32</span> <span class="n">log_start_addr</span><span class="p">;</span>

	<span class="cm">/* Private status to be used by the lower drivers */</span>
	<span class="n">u8</span> <span class="n">priv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">wl1271_rx_mem_pool_addr</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr_extra</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define WL1271_MAX_CHANNELS 64</span>
<span class="k">struct</span> <span class="n">wl1271_scan</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfg80211_scan_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">scanned_ch</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">WL1271_MAX_CHANNELS</span><span class="p">)];</span>
	<span class="n">bool</span> <span class="n">failed</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ssid</span><span class="p">[</span><span class="n">IEEE80211_MAX_SSID_LEN</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
	<span class="kt">size_t</span> <span class="n">ssid_len</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">wl1271_if_operations</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
		     <span class="n">bool</span> <span class="n">fixed</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
		     <span class="n">bool</span> <span class="n">fixed</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">child</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">child</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">power</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_block_size</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">blksz</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#define MAX_NUM_KEYS 14</span>
<span class="cp">#define MAX_KEY_SIZE 32</span>

<span class="k">struct</span> <span class="n">wl1271_ap_key</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">key_type</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">key_size</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">key</span><span class="p">[</span><span class="n">MAX_KEY_SIZE</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">hlid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx_seq_32</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tx_seq_16</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">wl12xx_flags</span> <span class="p">{</span>
	<span class="n">WL1271_FLAG_GPIO_POWER</span><span class="p">,</span>
	<span class="n">WL1271_FLAG_TX_QUEUE_STOPPED</span><span class="p">,</span>
	<span class="n">WL1271_FLAG_TX_PENDING</span><span class="p">,</span>
	<span class="n">WL1271_FLAG_IN_ELP</span><span class="p">,</span>
	<span class="n">WL1271_FLAG_ELP_REQUESTED</span><span class="p">,</span>
	<span class="n">WL1271_FLAG_IRQ_RUNNING</span><span class="p">,</span>
	<span class="n">WL1271_FLAG_FW_TX_BUSY</span><span class="p">,</span>
	<span class="n">WL1271_FLAG_DUMMY_PACKET_PENDING</span><span class="p">,</span>
	<span class="n">WL1271_FLAG_SUSPENDED</span><span class="p">,</span>
	<span class="n">WL1271_FLAG_PENDING_WORK</span><span class="p">,</span>
	<span class="n">WL1271_FLAG_SOFT_GEMINI</span><span class="p">,</span>
	<span class="n">WL1271_FLAG_RECOVERY_IN_PROGRESS</span><span class="p">,</span>
	<span class="n">WL1271_FLAG_VIF_CHANGE_IN_PROGRESS</span><span class="p">,</span>
	<span class="n">WL1271_FLAG_INTENDED_FW_RECOVERY</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">wl12xx_vif_flags</span> <span class="p">{</span>
	<span class="n">WLVIF_FLAG_INITIALIZED</span><span class="p">,</span>
	<span class="n">WLVIF_FLAG_STA_ASSOCIATED</span><span class="p">,</span>
	<span class="n">WLVIF_FLAG_STA_AUTHORIZED</span><span class="p">,</span>
	<span class="n">WLVIF_FLAG_IBSS_JOINED</span><span class="p">,</span>
	<span class="n">WLVIF_FLAG_AP_STARTED</span><span class="p">,</span>
	<span class="n">WLVIF_FLAG_IN_PS</span><span class="p">,</span>
	<span class="n">WLVIF_FLAG_STA_STATE_SENT</span><span class="p">,</span>
	<span class="n">WLVIF_FLAG_RX_STREAMING_STARTED</span><span class="p">,</span>
	<span class="n">WLVIF_FLAG_PSPOLL_FAILURE</span><span class="p">,</span>
	<span class="n">WLVIF_FLAG_CS_PROGRESS</span><span class="p">,</span>
	<span class="n">WLVIF_FLAG_AP_PROBE_RESP_SET</span><span class="p">,</span>
	<span class="n">WLVIF_FLAG_IN_USE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">wl1271_link</span> <span class="p">{</span>
	<span class="cm">/* AP-mode - TX queue per AC in link */</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">tx_queue</span><span class="p">[</span><span class="n">NUM_TX_QUEUES</span><span class="p">];</span>

	<span class="cm">/* accounting for allocated / freed packets in FW */</span>
	<span class="n">u8</span> <span class="n">allocated_pkts</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">prev_freed_pkts</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>

	<span class="cm">/* bitmap of TIDs where RX BA sessions are active for this link */</span>
	<span class="n">u8</span> <span class="n">ba_bitmap</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define WL1271_MAX_RX_FILTERS 5</span>
<span class="cp">#define WL1271_RX_FILTER_MAX_FIELDS 8</span>

<span class="cp">#define WL1271_RX_FILTER_ETH_HEADER_SIZE 14</span>
<span class="cp">#define WL1271_RX_FILTER_MAX_FIELDS_SIZE 95</span>
<span class="cp">#define RX_FILTER_FIELD_OVERHEAD				\</span>
<span class="cp">	(sizeof(struct wl12xx_rx_filter_field) - sizeof(u8 *))</span>
<span class="cp">#define WL1271_RX_FILTER_MAX_PATTERN_SIZE			\</span>
<span class="cp">	(WL1271_RX_FILTER_MAX_FIELDS_SIZE - RX_FILTER_FIELD_OVERHEAD)</span>

<span class="cp">#define WL1271_RX_FILTER_FLAG_MASK                BIT(0)</span>
<span class="cp">#define WL1271_RX_FILTER_FLAG_IP_HEADER           0</span>
<span class="cp">#define WL1271_RX_FILTER_FLAG_ETHERNET_HEADER     BIT(1)</span>

<span class="k">enum</span> <span class="n">rx_filter_action</span> <span class="p">{</span>
	<span class="n">FILTER_DROP</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">FILTER_SIGNAL</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">FILTER_FW_HANDLE</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">wl12xx_rx_filter_field</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">pattern</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">wl12xx_rx_filter</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">action</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_fields</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wl12xx_rx_filter_field</span> <span class="n">fields</span><span class="p">[</span><span class="n">WL1271_RX_FILTER_MAX_FIELDS</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">wl1271_station</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">hlid</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">wl12xx_vif</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">wl1271</span> <span class="o">*</span><span class="n">wl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bss_type</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">p2p</span><span class="p">;</span> <span class="cm">/* we are using p2p role */</span>
	<span class="n">u8</span> <span class="n">role_id</span><span class="p">;</span>

	<span class="cm">/* sta/ibss specific */</span>
	<span class="n">u8</span> <span class="n">dev_role_id</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">dev_hlid</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">hlid</span><span class="p">;</span>
			<span class="n">u8</span> <span class="n">ba_rx_bitmap</span><span class="p">;</span>

			<span class="n">u8</span> <span class="n">basic_rate_idx</span><span class="p">;</span>
			<span class="n">u8</span> <span class="n">ap_rate_idx</span><span class="p">;</span>
			<span class="n">u8</span> <span class="n">p2p_rate_idx</span><span class="p">;</span>

			<span class="n">bool</span> <span class="n">qos</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">sta</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">global_hlid</span><span class="p">;</span>
			<span class="n">u8</span> <span class="n">bcast_hlid</span><span class="p">;</span>

			<span class="cm">/* HLIDs bitmap of associated stations */</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sta_hlid_map</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span>
							<span class="n">WL12XX_MAX_LINKS</span><span class="p">)];</span>

			<span class="cm">/* recoreded keys - set here before AP startup */</span>
			<span class="k">struct</span> <span class="n">wl1271_ap_key</span> <span class="o">*</span><span class="n">recorded_keys</span><span class="p">[</span><span class="n">MAX_NUM_KEYS</span><span class="p">];</span>

			<span class="n">u8</span> <span class="n">mgmt_rate_idx</span><span class="p">;</span>
			<span class="n">u8</span> <span class="n">bcast_rate_idx</span><span class="p">;</span>
			<span class="n">u8</span> <span class="n">ucast_rate_idx</span><span class="p">[</span><span class="n">CONF_TX_MAX_AC_COUNT</span><span class="p">];</span>
		<span class="p">}</span> <span class="n">ap</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/* the hlid of the last transmitted skb */</span>
	<span class="kt">int</span> <span class="n">last_tx_hlid</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">links_map</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">WL12XX_MAX_LINKS</span><span class="p">)];</span>

	<span class="n">u8</span> <span class="n">ssid</span><span class="p">[</span><span class="n">IEEE80211_MAX_SSID_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">ssid_len</span><span class="p">;</span>

	<span class="cm">/* The current band */</span>
	<span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">channel</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">bitrate_masks</span><span class="p">[</span><span class="n">IEEE80211_NUM_BANDS</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">basic_rate_set</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * currently configured rate set:</span>
<span class="cm">	 *	bits  0-15 - 802.11abg rates</span>
<span class="cm">	 *	bits 16-23 - 802.11n   MCS index mask</span>
<span class="cm">	 * support only 1 stream, thus only 8 bits for the MCS rates (0-7).</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">basic_rate</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rate_set</span><span class="p">;</span>

	<span class="cm">/* probe-req template for the current AP */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">probereq</span><span class="p">;</span>

	<span class="cm">/* Beaconing interval (needed for ad-hoc) */</span>
	<span class="n">u32</span> <span class="n">beacon_int</span><span class="p">;</span>

	<span class="cm">/* Default key (for WEP) */</span>
	<span class="n">u32</span> <span class="n">default_key</span><span class="p">;</span>

	<span class="cm">/* Our association ID */</span>
	<span class="n">u16</span> <span class="n">aid</span><span class="p">;</span>

	<span class="cm">/* Session counter for the chipset */</span>
	<span class="kt">int</span> <span class="n">session_counter</span><span class="p">;</span>

	<span class="cm">/* retry counter for PSM entries */</span>
	<span class="n">u8</span> <span class="n">psm_entry_retry</span><span class="p">;</span>

	<span class="cm">/* in dBm */</span>
	<span class="kt">int</span> <span class="n">power_level</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">rssi_thold</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_rssi_event</span><span class="p">;</span>

	<span class="cm">/* save the current encryption type for auto-arp config */</span>
	<span class="n">u8</span> <span class="n">encryption_type</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">ip_addr</span><span class="p">;</span>

	<span class="cm">/* RX BA constraint value */</span>
	<span class="n">bool</span> <span class="n">ba_support</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ba_allowed</span><span class="p">;</span>

	<span class="cm">/* Rx Streaming */</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">rx_streaming_enable_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">rx_streaming_disable_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">rx_streaming_timer</span><span class="p">;</span>

	<span class="cm">/* does the current role use GEM for encryption (AP or STA) */</span>
	<span class="n">bool</span> <span class="n">is_gem</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This struct must be last!</span>
<span class="cm">	 * data that has to be saved acrossed reconfigs (e.g. recovery)</span>
<span class="cm">	 * should be declared in this struct.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">persistent</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="cm">/*</span>
<span class="cm">		 * Security sequence number</span>
<span class="cm">		 *     bits 0-15: lower 16 bits part of sequence number</span>
<span class="cm">		 *     bits 16-47: higher 32 bits part of sequence number</span>
<span class="cm">		 *     bits 48-63: not in use</span>
<span class="cm">		 */</span>
		<span class="n">u64</span> <span class="n">tx_security_seq</span><span class="p">;</span>

		<span class="cm">/* 8 bits of the last sequence number in use */</span>
		<span class="n">u8</span> <span class="n">tx_security_last_seq_lsb</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">wl12xx_vif</span> <span class="o">*</span><span class="nf">wl12xx_vif_to_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">wl12xx_vif</span> <span class="o">*</span><span class="p">)</span><span class="n">vif</span><span class="o">-&gt;</span><span class="n">drv_priv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="nf">wl12xx_wlvif_to_vif</span><span class="p">(</span><span class="k">struct</span> <span class="n">wl12xx_vif</span> <span class="o">*</span><span class="n">wlvif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">wlvif</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span><span class="p">,</span> <span class="n">drv_priv</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define wl12xx_for_each_wlvif(wl, wlvif) \</span>
<span class="cp">		list_for_each_entry(wlvif, &amp;wl-&gt;wlvif_list, list)</span>

<span class="cp">#define wl12xx_for_each_wlvif_continue(wl, wlvif) \</span>
<span class="cp">		list_for_each_entry_continue(wlvif, &amp;wl-&gt;wlvif_list, list)</span>

<span class="cp">#define wl12xx_for_each_wlvif_bss_type(wl, wlvif, _bss_type)	\</span>
<span class="cp">		wl12xx_for_each_wlvif(wl, wlvif)		\</span>
<span class="cp">			if (wlvif-&gt;bss_type == _bss_type)</span>

<span class="cp">#define wl12xx_for_each_wlvif_sta(wl, wlvif)	\</span>
<span class="cp">		wl12xx_for_each_wlvif_bss_type(wl, wlvif, BSS_TYPE_STA_BSS)</span>

<span class="cp">#define wl12xx_for_each_wlvif_ap(wl, wlvif)	\</span>
<span class="cp">		wl12xx_for_each_wlvif_bss_type(wl, wlvif, BSS_TYPE_AP_BSS)</span>

<span class="kt">int</span> <span class="n">wl1271_plt_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">wl1271</span> <span class="o">*</span><span class="n">wl</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">wl1271_plt_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">wl1271</span> <span class="o">*</span><span class="n">wl</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">wl1271_recalc_rx_streaming</span><span class="p">(</span><span class="k">struct</span> <span class="n">wl1271</span> <span class="o">*</span><span class="n">wl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wl12xx_vif</span> <span class="o">*</span><span class="n">wlvif</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">wl12xx_queue_recovery_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">wl1271</span> <span class="o">*</span><span class="n">wl</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="n">wl12xx_copy_fwlog</span><span class="p">(</span><span class="k">struct</span> <span class="n">wl1271</span> <span class="o">*</span><span class="n">wl</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">memblock</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">maxlen</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">wl1271_rx_filter_alloc_field</span><span class="p">(</span><span class="k">struct</span> <span class="n">wl12xx_rx_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">,</span>
					<span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u8</span> <span class="n">flags</span><span class="p">,</span>
					<span class="n">u8</span> <span class="o">*</span><span class="n">pattern</span><span class="p">,</span> <span class="n">u8</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">wl1271_rx_filter_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">wl12xx_rx_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">wl12xx_rx_filter</span> <span class="o">*</span><span class="n">wl1271_rx_filter_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">wl1271_rx_filter_get_fields_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">wl12xx_rx_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">wl1271_rx_filter_flatten_fields</span><span class="p">(</span><span class="k">struct</span> <span class="n">wl12xx_rx_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">,</span>
				     <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>

<span class="cp">#define JOIN_TIMEOUT 5000 </span><span class="cm">/* 5000 milliseconds to join */</span><span class="cp"></span>

<span class="cp">#define SESSION_COUNTER_MAX 6 </span><span class="cm">/* maximum value for the session counter */</span><span class="cp"></span>
<span class="cp">#define SESSION_COUNTER_INVALID 7 </span><span class="cm">/* used with dummy_packet */</span><span class="cp"></span>

<span class="cp">#define WL1271_DEFAULT_POWER_LEVEL 0</span>

<span class="cp">#define WL1271_TX_QUEUE_LOW_WATERMARK  32</span>
<span class="cp">#define WL1271_TX_QUEUE_HIGH_WATERMARK 256</span>

<span class="cp">#define WL1271_DEFERRED_QUEUE_LIMIT    64</span>

<span class="cm">/* WL1271 needs a 200ms sleep after power on, and a 20ms sleep before power</span>
<span class="cm">   on in case is has been shut down shortly before */</span>
<span class="cp">#define WL1271_PRE_POWER_ON_SLEEP 20 </span><span class="cm">/* in milliseconds */</span><span class="cp"></span>
<span class="cp">#define WL1271_POWER_ON_SLEEP 200 </span><span class="cm">/* in milliseconds */</span><span class="cp"></span>

<span class="cm">/* Macros to handle wl1271.sta_rate_set */</span>
<span class="cp">#define HW_BG_RATES_MASK	0xffff</span>
<span class="cp">#define HW_HT_RATES_OFFSET	16</span>

<span class="cp">#define WL12XX_HW_BLOCK_SIZE	256</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
