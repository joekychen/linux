<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › rt2x00 › rt2x00.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>rt2x00.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">	Copyright (C) 2010 Willow Garage &lt;http://www.willowgarage.com&gt;</span>
<span class="cm">	Copyright (C) 2004 - 2010 Ivo van Doorn &lt;IvDoorn@gmail.com&gt;</span>
<span class="cm">	Copyright (C) 2004 - 2009 Gertjan van Wingerde &lt;gwingerde@gmail.com&gt;</span>
<span class="cm">	&lt;http://rt2x00.serialmonkey.com&gt;</span>

<span class="cm">	This program is free software; you can redistribute it and/or modify</span>
<span class="cm">	it under the terms of the GNU General Public License as published by</span>
<span class="cm">	the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">	(at your option) any later version.</span>

<span class="cm">	This program is distributed in the hope that it will be useful,</span>
<span class="cm">	but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</span>
<span class="cm">	GNU General Public License for more details.</span>

<span class="cm">	You should have received a copy of the GNU General Public License</span>
<span class="cm">	along with this program; if not, write to the</span>
<span class="cm">	Free Software Foundation, Inc.,</span>
<span class="cm">	59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm">	Module: rt2x00</span>
<span class="cm">	Abstract: rt2x00 global information.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef RT2X00_H</span>
<span class="cp">#define RT2X00_H</span>

<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/firmware.h&gt;</span>
<span class="cp">#include &lt;linux/leds.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/input-polldev.h&gt;</span>
<span class="cp">#include &lt;linux/kfifo.h&gt;</span>
<span class="cp">#include &lt;linux/hrtimer.h&gt;</span>

<span class="cp">#include &lt;net/mac80211.h&gt;</span>

<span class="cp">#include &quot;rt2x00debug.h&quot;</span>
<span class="cp">#include &quot;rt2x00dump.h&quot;</span>
<span class="cp">#include &quot;rt2x00leds.h&quot;</span>
<span class="cp">#include &quot;rt2x00reg.h&quot;</span>
<span class="cp">#include &quot;rt2x00queue.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Module information.</span>
<span class="cm"> */</span>
<span class="cp">#define DRV_VERSION	&quot;2.3.0&quot;</span>
<span class="cp">#define DRV_PROJECT	&quot;http:</span><span class="c1">//rt2x00.serialmonkey.com&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Debug definitions.</span>
<span class="cm"> * Debug output has to be enabled during compile time.</span>
<span class="cm"> */</span>
<span class="cp">#define DEBUG_PRINTK_MSG(__dev, __kernlvl, __lvl, __msg, __args...)	\</span>
<span class="cp">	printk(__kernlvl &quot;%s -&gt; %s: %s - &quot; __msg,			\</span>
<span class="cp">	       wiphy_name((__dev)-&gt;hw-&gt;wiphy), __func__, __lvl, ##__args)</span>

<span class="cp">#define DEBUG_PRINTK_PROBE(__kernlvl, __lvl, __msg, __args...)	\</span>
<span class="cp">	printk(__kernlvl &quot;%s -&gt; %s: %s - &quot; __msg,		\</span>
<span class="cp">	       KBUILD_MODNAME, __func__, __lvl, ##__args)</span>

<span class="cp">#ifdef CONFIG_RT2X00_DEBUG</span>
<span class="cp">#define DEBUG_PRINTK(__dev, __kernlvl, __lvl, __msg, __args...)	\</span>
<span class="cp">	DEBUG_PRINTK_MSG(__dev, __kernlvl, __lvl, __msg, ##__args)</span>
<span class="cp">#else</span>
<span class="cp">#define DEBUG_PRINTK(__dev, __kernlvl, __lvl, __msg, __args...)	\</span>
<span class="cp">	do { } while (0)</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_RT2X00_DEBUG */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Various debug levels.</span>
<span class="cm"> * The debug levels PANIC and ERROR both indicate serious problems,</span>
<span class="cm"> * for this reason they should never be ignored.</span>
<span class="cm"> * The special ERROR_PROBE message is for messages that are generated</span>
<span class="cm"> * when the rt2x00_dev is not yet initialized.</span>
<span class="cm"> */</span>
<span class="cp">#define PANIC(__dev, __msg, __args...) \</span>
<span class="cp">	DEBUG_PRINTK_MSG(__dev, KERN_CRIT, &quot;Panic&quot;, __msg, ##__args)</span>
<span class="cp">#define ERROR(__dev, __msg, __args...)	\</span>
<span class="cp">	DEBUG_PRINTK_MSG(__dev, KERN_ERR, &quot;Error&quot;, __msg, ##__args)</span>
<span class="cp">#define ERROR_PROBE(__msg, __args...) \</span>
<span class="cp">	DEBUG_PRINTK_PROBE(KERN_ERR, &quot;Error&quot;, __msg, ##__args)</span>
<span class="cp">#define WARNING(__dev, __msg, __args...) \</span>
<span class="cp">	DEBUG_PRINTK(__dev, KERN_WARNING, &quot;Warning&quot;, __msg, ##__args)</span>
<span class="cp">#define NOTICE(__dev, __msg, __args...) \</span>
<span class="cp">	DEBUG_PRINTK(__dev, KERN_NOTICE, &quot;Notice&quot;, __msg, ##__args)</span>
<span class="cp">#define INFO(__dev, __msg, __args...) \</span>
<span class="cp">	DEBUG_PRINTK(__dev, KERN_INFO, &quot;Info&quot;, __msg, ##__args)</span>
<span class="cp">#define DEBUG(__dev, __msg, __args...) \</span>
<span class="cp">	DEBUG_PRINTK(__dev, KERN_DEBUG, &quot;Debug&quot;, __msg, ##__args)</span>
<span class="cp">#define EEPROM(__dev, __msg, __args...) \</span>
<span class="cp">	DEBUG_PRINTK(__dev, KERN_DEBUG, &quot;EEPROM recovery&quot;, __msg, ##__args)</span>

<span class="cm">/*</span>
<span class="cm"> * Duration calculations</span>
<span class="cm"> * The rate variable passed is: 100kbs.</span>
<span class="cm"> * To convert from bytes to bits we multiply size with 8,</span>
<span class="cm"> * then the size is multiplied with 10 to make the</span>
<span class="cm"> * real rate -&gt; rate argument correction.</span>
<span class="cm"> */</span>
<span class="cp">#define GET_DURATION(__size, __rate)	(((__size) * 8 * 10) / (__rate))</span>
<span class="cp">#define GET_DURATION_RES(__size, __rate)(((__size) * 8 * 10) % (__rate))</span>

<span class="cm">/*</span>
<span class="cm"> * Determine the number of L2 padding bytes required between the header and</span>
<span class="cm"> * the payload.</span>
<span class="cm"> */</span>
<span class="cp">#define L2PAD_SIZE(__hdrlen)	(-(__hdrlen) &amp; 3)</span>

<span class="cm">/*</span>
<span class="cm"> * Determine the alignment requirement,</span>
<span class="cm"> * to make sure the 802.11 payload is padded to a 4-byte boundrary</span>
<span class="cm"> * we must determine the address of the payload and calculate the</span>
<span class="cm"> * amount of bytes needed to move the data.</span>
<span class="cm"> */</span>
<span class="cp">#define ALIGN_SIZE(__skb, __header) \</span>
<span class="cp">	(  ((unsigned long)((__skb)-&gt;data + (__header))) &amp; 3 )</span>

<span class="cm">/*</span>
<span class="cm"> * Constants for extra TX headroom for alignment purposes.</span>
<span class="cm"> */</span>
<span class="cp">#define RT2X00_ALIGN_SIZE	4 </span><span class="cm">/* Only whole frame needs alignment */</span><span class="cp"></span>
<span class="cp">#define RT2X00_L2PAD_SIZE	8 </span><span class="cm">/* Both header &amp; payload need alignment */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Standard timing and size defines.</span>
<span class="cm"> * These values should follow the ieee80211 specifications.</span>
<span class="cm"> */</span>
<span class="cp">#define ACK_SIZE		14</span>
<span class="cp">#define IEEE80211_HEADER	24</span>
<span class="cp">#define PLCP			48</span>
<span class="cp">#define BEACON			100</span>
<span class="cp">#define PREAMBLE		144</span>
<span class="cp">#define SHORT_PREAMBLE		72</span>
<span class="cp">#define SLOT_TIME		20</span>
<span class="cp">#define SHORT_SLOT_TIME		9</span>
<span class="cp">#define SIFS			10</span>
<span class="cp">#define PIFS			( SIFS + SLOT_TIME )</span>
<span class="cp">#define SHORT_PIFS		( SIFS + SHORT_SLOT_TIME )</span>
<span class="cp">#define DIFS			( PIFS + SLOT_TIME )</span>
<span class="cp">#define SHORT_DIFS		( SHORT_PIFS + SHORT_SLOT_TIME )</span>
<span class="cp">#define EIFS			( SIFS + DIFS + \</span>
<span class="cp">				  GET_DURATION(IEEE80211_HEADER + ACK_SIZE, 10) )</span>
<span class="cp">#define SHORT_EIFS		( SIFS + SHORT_DIFS + \</span>
<span class="cp">				  GET_DURATION(IEEE80211_HEADER + ACK_SIZE, 10) )</span>

<span class="cm">/*</span>
<span class="cm"> * Structure for average calculation</span>
<span class="cm"> * The avg field contains the actual average value,</span>
<span class="cm"> * but avg_weight is internally used during calculations</span>
<span class="cm"> * to prevent rounding errors.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">avg_val</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">avg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">avg_weight</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">rt2x00_chip_intf</span> <span class="p">{</span>
	<span class="n">RT2X00_CHIP_INTF_PCI</span><span class="p">,</span>
	<span class="n">RT2X00_CHIP_INTF_PCIE</span><span class="p">,</span>
	<span class="n">RT2X00_CHIP_INTF_USB</span><span class="p">,</span>
	<span class="n">RT2X00_CHIP_INTF_SOC</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Chipset identification</span>
<span class="cm"> * The chipset on the device is composed of a RT and RF chip.</span>
<span class="cm"> * The chipset combination is important for determining device capabilities.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rt2x00_chip</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">rt</span><span class="p">;</span>
<span class="cp">#define RT2460		0x2460</span>
<span class="cp">#define RT2560		0x2560</span>
<span class="cp">#define RT2570		0x2570</span>
<span class="cp">#define RT2661		0x2661</span>
<span class="cp">#define RT2573		0x2573</span>
<span class="cp">#define RT2860		0x2860	</span><span class="cm">/* 2.4GHz */</span><span class="cp"></span>
<span class="cp">#define RT2872		0x2872	</span><span class="cm">/* WSOC */</span><span class="cp"></span>
<span class="cp">#define RT2883		0x2883	</span><span class="cm">/* WSOC */</span><span class="cp"></span>
<span class="cp">#define RT3070		0x3070</span>
<span class="cp">#define RT3071		0x3071</span>
<span class="cp">#define RT3090		0x3090	</span><span class="cm">/* 2.4GHz PCIe */</span><span class="cp"></span>
<span class="cp">#define RT3390		0x3390</span>
<span class="cp">#define RT3572		0x3572</span>
<span class="cp">#define RT3593		0x3593</span>
<span class="cp">#define RT3883		0x3883	</span><span class="cm">/* WSOC */</span><span class="cp"></span>
<span class="cp">#define RT5390		0x5390  </span><span class="cm">/* 2.4GHz */</span><span class="cp"></span>
<span class="cp">#define RT5392		0x5392  </span><span class="cm">/* 2.4GHz */</span><span class="cp"></span>

	<span class="n">u16</span> <span class="n">rf</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">rev</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">rt2x00_chip_intf</span> <span class="n">intf</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * RF register values that belong to a particular channel.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rf_channel</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">channel</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rf1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rf2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rf3</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rf4</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Channel information structure</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">channel_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
<span class="cp">#define GEOGRAPHY_ALLOWED	0x00000001</span>

	<span class="kt">short</span> <span class="n">max_power</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">default_power1</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">default_power2</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Antenna setup values.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">antenna_setup</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">antenna</span> <span class="n">rx</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">antenna</span> <span class="n">tx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">rx_chain_num</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tx_chain_num</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Quality statistics about the currently active link.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">link_qual</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Statistics required for Link tuning by driver</span>
<span class="cm">	 * The rssi value is provided by rt2x00lib during the</span>
<span class="cm">	 * link_tuner() callback function.</span>
<span class="cm">	 * The false_cca field is filled during the link_stats()</span>
<span class="cm">	 * callback function and could be used during the</span>
<span class="cm">	 * link_tuner() callback function.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">rssi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">false_cca</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * VGC levels</span>
<span class="cm">	 * Hardware driver will tune the VGC level during each call</span>
<span class="cm">	 * to the link_tuner() callback function. This vgc_level is</span>
<span class="cm">	 * is determined based on the link quality statistics like</span>
<span class="cm">	 * average RSSI and the false CCA count.</span>
<span class="cm">	 *</span>
<span class="cm">	 * In some cases the drivers need to differentiate between</span>
<span class="cm">	 * the currently &quot;desired&quot; VGC level and the level configured</span>
<span class="cm">	 * in the hardware. The latter is important to reduce the</span>
<span class="cm">	 * number of BBP register reads to reduce register access</span>
<span class="cm">	 * overhead. For this reason we store both values here.</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">vgc_level</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">vgc_level_reg</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Statistics required for Signal quality calculation.</span>
<span class="cm">	 * These fields might be changed during the link_stats()</span>
<span class="cm">	 * callback function.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">rx_success</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rx_failed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_success</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_failed</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Antenna settings about the currently active link.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">link_ant</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Antenna flags</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
<span class="cp">#define ANTENNA_RX_DIVERSITY	0x00000001</span>
<span class="cp">#define ANTENNA_TX_DIVERSITY	0x00000002</span>
<span class="cp">#define ANTENNA_MODE_SAMPLE	0x00000004</span>

	<span class="cm">/*</span>
<span class="cm">	 * Currently active TX/RX antenna setup.</span>
<span class="cm">	 * When software diversity is used, this will indicate</span>
<span class="cm">	 * which antenna is actually used at this time.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">antenna_setup</span> <span class="n">active</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * RSSI history information for the antenna.</span>
<span class="cm">	 * Used to determine when to switch antenna</span>
<span class="cm">	 * when using software diversity.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">rssi_history</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Current RSSI average of the currently active antenna.</span>
<span class="cm">	 * Similar to the avg_rssi in the link_qual structure</span>
<span class="cm">	 * this value is updated by using the walking average.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">avg_val</span> <span class="n">rssi_ant</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * To optimize the quality of the link we need to store</span>
<span class="cm"> * the quality of received frames and periodically</span>
<span class="cm"> * optimize the link.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">link</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Link tuner counter</span>
<span class="cm">	 * The number of times the link has been tuned</span>
<span class="cm">	 * since the radio has been switched on.</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Quality measurement values.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">link_qual</span> <span class="n">qual</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * TX/RX antenna setup.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">link_ant</span> <span class="n">ant</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Currently active average RSSI value</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">avg_val</span> <span class="n">avg_rssi</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Work structure for scheduling periodic link tuning.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">work</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Work structure for scheduling periodic watchdog monitoring.</span>
<span class="cm">	 * This work must be scheduled on the kernel workqueue, while</span>
<span class="cm">	 * all other work structures must be queued on the mac80211</span>
<span class="cm">	 * workqueue. This guarantees that the watchdog can schedule</span>
<span class="cm">	 * other work structures and wait for their completion in order</span>
<span class="cm">	 * to bring the device/driver back into the desired state.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">watchdog_work</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Work structure for scheduling periodic AGC adjustments.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">agc_work</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Work structure for scheduling periodic VCO calibration.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">vco_work</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">rt2x00_delayed_flags</span> <span class="p">{</span>
	<span class="n">DELAYED_UPDATE_BEACON</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Interface structure</span>
<span class="cm"> * Per interface configuration details, this structure</span>
<span class="cm"> * is allocated as the private data for ieee80211_vif.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rt2x00_intf</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * beacon-&gt;skb must be protected with the mutex.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">beacon_skb_mutex</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Entry in the beacon queue which belongs to</span>
<span class="cm">	 * this interface. Each interface has its own</span>
<span class="cm">	 * dedicated beacon entry.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">beacon</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">enable_beacon</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Actions that needed rescheduling.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delayed_flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Software sequence counter, this is only required</span>
<span class="cm">	 * for hardware which doesn&#39;t support hardware</span>
<span class="cm">	 * sequence counting.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_t</span> <span class="n">seqno</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rt2x00_intf</span><span class="o">*</span> <span class="nf">vif_to_intf</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_intf</span> <span class="o">*</span><span class="p">)</span><span class="n">vif</span><span class="o">-&gt;</span><span class="n">drv_priv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * struct hw_mode_spec: Hardware specifications structure</span>
<span class="cm"> *</span>
<span class="cm"> * Details about the supported modes, rates and channels</span>
<span class="cm"> * of a particular chipset. This is used by rt2x00lib</span>
<span class="cm"> * to build the ieee80211_hw_mode array for mac80211.</span>
<span class="cm"> *</span>
<span class="cm"> * @supported_bands: Bitmask contained the supported bands (2.4GHz, 5.2GHz).</span>
<span class="cm"> * @supported_rates: Rate types which are supported (CCK, OFDM).</span>
<span class="cm"> * @num_channels: Number of supported channels. This is used as array size</span>
<span class="cm"> *	for @tx_power_a, @tx_power_bg and @channels.</span>
<span class="cm"> * @channels: Device/chipset specific channel values (See &amp;struct rf_channel).</span>
<span class="cm"> * @channels_info: Additional information for channels (See &amp;struct channel_info).</span>
<span class="cm"> * @ht: Driver HT Capabilities (See &amp;ieee80211_sta_ht_cap).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">hw_mode_spec</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">supported_bands</span><span class="p">;</span>
<span class="cp">#define SUPPORT_BAND_2GHZ	0x00000001</span>
<span class="cp">#define SUPPORT_BAND_5GHZ	0x00000002</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">supported_rates</span><span class="p">;</span>
<span class="cp">#define SUPPORT_RATE_CCK	0x00000001</span>
<span class="cp">#define SUPPORT_RATE_OFDM	0x00000002</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_channels</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">rf_channel</span> <span class="o">*</span><span class="n">channels</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">channel_info</span> <span class="o">*</span><span class="n">channels_info</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ieee80211_sta_ht_cap</span> <span class="n">ht</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Configuration structure wrapper around the</span>
<span class="cm"> * mac80211 configuration structure.</span>
<span class="cm"> * When mac80211 configures the driver, rt2x00lib</span>
<span class="cm"> * can precalculate values which are equal for all</span>
<span class="cm"> * rt2x00 drivers. Those values can be stored in here.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rt2x00lib_conf</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_conf</span> <span class="o">*</span><span class="n">conf</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">rf_channel</span> <span class="n">rf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">channel_info</span> <span class="n">channel</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Configuration structure for erp settings.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rt2x00lib_erp</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">short_preamble</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cts_protection</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">basic_rates</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">slot_time</span><span class="p">;</span>

	<span class="kt">short</span> <span class="n">sifs</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">pifs</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">difs</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">eifs</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">beacon_int</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ht_opmode</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Configuration structure for hardware encryption.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rt2x00lib_crypto</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">cipher</span> <span class="n">cipher</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">set_key_cmd</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">address</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">bssidx</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">key</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">tx_mic</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">rx_mic</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

	<span class="kt">int</span> <span class="n">wcid</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Configuration structure wrapper around the</span>
<span class="cm"> * rt2x00 interface configuration handler.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rt2x00intf_conf</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Interface type</span>
<span class="cm">	 */</span>
	<span class="k">enum</span> <span class="n">nl80211_iftype</span> <span class="n">type</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * TSF sync value, this is dependent on the operation type.</span>
<span class="cm">	 */</span>
	<span class="k">enum</span> <span class="n">tsf_sync</span> <span class="n">sync</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The MAC and BSSID addresses are simple array of bytes,</span>
<span class="cm">	 * these arrays are little endian, so when sending the addresses</span>
<span class="cm">	 * to the drivers, copy the it into a endian-signed variable.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that all devices (except rt2500usb) have 32 bits</span>
<span class="cm">	 * register word sizes. This means that whatever variable we</span>
<span class="cm">	 * pass _must_ be a multiple of 32 bits. Otherwise the device</span>
<span class="cm">	 * might not accept what we are sending to it.</span>
<span class="cm">	 * This will also make it easier for the driver to write</span>
<span class="cm">	 * the data to the device.</span>
<span class="cm">	 */</span>
	<span class="n">__le32</span> <span class="n">mac</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">__le32</span> <span class="n">bssid</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Private structure for storing STA details</span>
<span class="cm"> * wcid: Wireless Client ID</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rt2x00_sta</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">wcid</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rt2x00_sta</span><span class="o">*</span> <span class="nf">sta_to_rt2x00_sta</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_sta</span> <span class="o">*</span><span class="p">)</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">drv_priv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * rt2x00lib callback functions.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rt2x00lib_ops</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Interrupt handlers.</span>
<span class="cm">	 */</span>
	<span class="n">irq_handler_t</span> <span class="n">irq_handler</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * TX status tasklet handler.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">txstatus_tasklet</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pretbtt_tasklet</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">tbtt_tasklet</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rxdone_tasklet</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">autowake_tasklet</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Device init handlers.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe_hw</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">get_firmware_name</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">check_firmware</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
			       <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">load_firmware</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
			      <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Device initialization/deinitialization handlers.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">initialize</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">uninitialize</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * queue initialization handlers</span>
<span class="cm">	 */</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">get_entry_state</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">clear_entry</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Radio control handlers.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_device_state</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
				 <span class="k">enum</span> <span class="n">dev_state</span> <span class="n">state</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rfkill_poll</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">link_stats</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">link_qual</span> <span class="o">*</span><span class="n">qual</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">reset_tuner</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">link_qual</span> <span class="o">*</span><span class="n">qual</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">link_tuner</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">link_qual</span> <span class="o">*</span><span class="n">qual</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">count</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">gain_calibration</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">vco_calibration</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Data queue handlers.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">watchdog</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">start_queue</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">kick_queue</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">stop_queue</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">flush_queue</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span> <span class="n">bool</span> <span class="n">drop</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">tx_dma_done</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * TX control handlers</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write_tx_desc</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">txentry_desc</span> <span class="o">*</span><span class="n">txdesc</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write_tx_data</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">txentry_desc</span> <span class="o">*</span><span class="n">txdesc</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write_beacon</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">txentry_desc</span> <span class="o">*</span><span class="n">txdesc</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">clear_beacon</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_tx_data_len</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * RX control handlers</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fill_rxdone</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">rxdone_entry_desc</span> <span class="o">*</span><span class="n">rxdesc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Configuration handlers.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">config_shared_key</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">rt2x00lib_crypto</span> <span class="o">*</span><span class="n">crypto</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ieee80211_key_conf</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">config_pairwise_key</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">rt2x00lib_crypto</span> <span class="o">*</span><span class="n">crypto</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ieee80211_key_conf</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">config_filter</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">filter_flags</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">config_intf</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">rt2x00_intf</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">rt2x00intf_conf</span> <span class="o">*</span><span class="n">conf</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#define CONFIG_UPDATE_TYPE		( 1 &lt;&lt; 1 )</span>
<span class="cp">#define CONFIG_UPDATE_MAC		( 1 &lt;&lt; 2 )</span>
<span class="cp">#define CONFIG_UPDATE_BSSID		( 1 &lt;&lt; 3 )</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">config_erp</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">rt2x00lib_erp</span> <span class="o">*</span><span class="n">erp</span><span class="p">,</span>
			    <span class="n">u32</span> <span class="n">changed</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">config_ant</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">antenna_setup</span> <span class="o">*</span><span class="n">ant</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">config</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">rt2x00lib_conf</span> <span class="o">*</span><span class="n">libconf</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">changed_flags</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sta_add</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sta_remove</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">wcid</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * rt2x00 driver callback operation structure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rt2x00_ops</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">drv_data_size</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_sta_intf</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_ap_intf</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">eeprom_size</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rf_size</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_queues</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">extra_tx_headroom</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">data_queue_desc</span> <span class="o">*</span><span class="n">rx</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">data_queue_desc</span> <span class="o">*</span><span class="n">tx</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">data_queue_desc</span> <span class="o">*</span><span class="n">bcn</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">data_queue_desc</span> <span class="o">*</span><span class="n">atim</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">rt2x00lib_ops</span> <span class="o">*</span><span class="n">lib</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">drv</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_ops</span> <span class="o">*</span><span class="n">hw</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_RT2X00_LIB_DEBUGFS</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">rt2x00debug</span> <span class="o">*</span><span class="n">debugfs</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_RT2X00_LIB_DEBUGFS */</span><span class="cp"></span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * rt2x00 state flags</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">rt2x00_state_flags</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Device flags</span>
<span class="cm">	 */</span>
	<span class="n">DEVICE_STATE_PRESENT</span><span class="p">,</span>
	<span class="n">DEVICE_STATE_REGISTERED_HW</span><span class="p">,</span>
	<span class="n">DEVICE_STATE_INITIALIZED</span><span class="p">,</span>
	<span class="n">DEVICE_STATE_STARTED</span><span class="p">,</span>
	<span class="n">DEVICE_STATE_ENABLED_RADIO</span><span class="p">,</span>
	<span class="n">DEVICE_STATE_SCANNING</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * Driver configuration</span>
<span class="cm">	 */</span>
	<span class="n">CONFIG_CHANNEL_HT40</span><span class="p">,</span>
	<span class="n">CONFIG_POWERSAVING</span><span class="p">,</span>
	<span class="n">CONFIG_HT_DISABLED</span><span class="p">,</span>
	<span class="n">CONFIG_QOS_DISABLED</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * Mark we currently are sequentially reading TX_STA_FIFO register</span>
<span class="cm">	 * FIXME: this is for only rt2800usb, should go to private data</span>
<span class="cm">	 */</span>
	<span class="n">TX_STATUS_READING</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * rt2x00 capability flags</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">rt2x00_capability_flags</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Requirements</span>
<span class="cm">	 */</span>
	<span class="n">REQUIRE_FIRMWARE</span><span class="p">,</span>
	<span class="n">REQUIRE_BEACON_GUARD</span><span class="p">,</span>
	<span class="n">REQUIRE_ATIM_QUEUE</span><span class="p">,</span>
	<span class="n">REQUIRE_DMA</span><span class="p">,</span>
	<span class="n">REQUIRE_COPY_IV</span><span class="p">,</span>
	<span class="n">REQUIRE_L2PAD</span><span class="p">,</span>
	<span class="n">REQUIRE_TXSTATUS_FIFO</span><span class="p">,</span>
	<span class="n">REQUIRE_TASKLET_CONTEXT</span><span class="p">,</span>
	<span class="n">REQUIRE_SW_SEQNO</span><span class="p">,</span>
	<span class="n">REQUIRE_HT_TX_DESC</span><span class="p">,</span>
	<span class="n">REQUIRE_PS_AUTOWAKE</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * Capabilities</span>
<span class="cm">	 */</span>
	<span class="n">CAPABILITY_HW_BUTTON</span><span class="p">,</span>
	<span class="n">CAPABILITY_HW_CRYPTO</span><span class="p">,</span>
	<span class="n">CAPABILITY_POWER_LIMIT</span><span class="p">,</span>
	<span class="n">CAPABILITY_CONTROL_FILTERS</span><span class="p">,</span>
	<span class="n">CAPABILITY_CONTROL_FILTER_PSPOLL</span><span class="p">,</span>
	<span class="n">CAPABILITY_PRE_TBTT_INTERRUPT</span><span class="p">,</span>
	<span class="n">CAPABILITY_LINK_TUNING</span><span class="p">,</span>
	<span class="n">CAPABILITY_FRAME_TYPE</span><span class="p">,</span>
	<span class="n">CAPABILITY_RF_SEQUENCE</span><span class="p">,</span>
	<span class="n">CAPABILITY_EXTERNAL_LNA_A</span><span class="p">,</span>
	<span class="n">CAPABILITY_EXTERNAL_LNA_BG</span><span class="p">,</span>
	<span class="n">CAPABILITY_DOUBLE_ANTENNA</span><span class="p">,</span>
	<span class="n">CAPABILITY_BT_COEXIST</span><span class="p">,</span>
	<span class="n">CAPABILITY_VCO_RECALIBRATION</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * rt2x00 device structure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Device structure.</span>
<span class="cm">	 * The structure stored in here depends on the</span>
<span class="cm">	 * system bus (PCI or USB).</span>
<span class="cm">	 * When accessing this variable, the rt2x00dev_{pci,usb}</span>
<span class="cm">	 * macros should be used for correct typecasting.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Callback functions.</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">rt2x00_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Driver data.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * IEEE80211 control structure.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_supported_band</span> <span class="n">bands</span><span class="p">[</span><span class="n">IEEE80211_NUM_BANDS</span><span class="p">];</span>
	<span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">curr_band</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">curr_freq</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If enabled, the debugfs interface structures</span>
<span class="cm">	 * required for deregistration of debugfs.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef CONFIG_RT2X00_LIB_DEBUGFS</span>
	<span class="k">struct</span> <span class="n">rt2x00debug_intf</span> <span class="o">*</span><span class="n">debugfs_intf</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_RT2X00_LIB_DEBUGFS */</span><span class="cp"></span>

	<span class="cm">/*</span>
<span class="cm">	 * LED structure for changing the LED status</span>
<span class="cm">	 * by mac8011 or the kernel.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef CONFIG_RT2X00_LIB_LEDS</span>
	<span class="k">struct</span> <span class="n">rt2x00_led</span> <span class="n">led_radio</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt2x00_led</span> <span class="n">led_assoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt2x00_led</span> <span class="n">led_qual</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">led_mcu_reg</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_RT2X00_LIB_LEDS */</span><span class="cp"></span>

	<span class="cm">/*</span>
<span class="cm">	 * Device state flags.</span>
<span class="cm">	 * In these flags the current status is stored.</span>
<span class="cm">	 * Access to these flags should occur atomically.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Device capabiltiy flags.</span>
<span class="cm">	 * In these flags the device/driver capabilities are stored.</span>
<span class="cm">	 * Access to these flags should occur non-atomically.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cap_flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Device information, Bus IRQ and name (PCI, SoC)</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Chipset identification.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">rt2x00_chip</span> <span class="n">chip</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * hw capability specifications.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">hw_mode_spec</span> <span class="n">spec</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is the default TX/RX antenna setup as indicated</span>
<span class="cm">	 * by the device&#39;s EEPROM.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">antenna_setup</span> <span class="n">default_ant</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Register pointers</span>
<span class="cm">	 * csr.base: CSR base register address. (PCI)</span>
<span class="cm">	 * csr.cache: CSR cache for usb_control_msg. (USB)</span>
<span class="cm">	 */</span>
	<span class="k">union</span> <span class="n">csr</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">csr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Mutex to protect register accesses.</span>
<span class="cm">	 * For PCI and USB devices it protects against concurrent indirect</span>
<span class="cm">	 * register access (BBP, RF, MCU) since accessing those</span>
<span class="cm">	 * registers require multiple calls to the CSR registers.</span>
<span class="cm">	 * For USB devices it also protects the csr_cache since that</span>
<span class="cm">	 * field is used for normal CSR access and it cannot support</span>
<span class="cm">	 * multiple callers simultaneously.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">csr_mutex</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Current packet filter configuration for the device.</span>
<span class="cm">	 * This contains all currently active FIF_* flags send</span>
<span class="cm">	 * to us by mac80211 during configure_filter().</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">packet_filter</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Interface details:</span>
<span class="cm">	 *  - Open ap interface count.</span>
<span class="cm">	 *  - Open sta interface count.</span>
<span class="cm">	 *  - Association count.</span>
<span class="cm">	 *  - Beaconing enabled count.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">intf_ap_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">intf_sta_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">intf_associated</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">intf_beaconing</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Link quality</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">link</span> <span class="n">link</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * EEPROM data.</span>
<span class="cm">	 */</span>
	<span class="n">__le16</span> <span class="o">*</span><span class="n">eeprom</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Active RF register values.</span>
<span class="cm">	 * These are stored here so we don&#39;t need</span>
<span class="cm">	 * to read the rf registers and can directly</span>
<span class="cm">	 * use this value instead.</span>
<span class="cm">	 * This field should be accessed by using</span>
<span class="cm">	 * rt2x00_rf_read() and rt2x00_rf_write().</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">rf</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * LNA gain</span>
<span class="cm">	 */</span>
	<span class="kt">short</span> <span class="n">lna_gain</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Current TX power value.</span>
<span class="cm">	 */</span>
	<span class="n">u16</span> <span class="n">tx_power</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Current retry values.</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">short_retry</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">long_retry</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Rssi &lt;-&gt; Dbm offset</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">rssi_offset</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Frequency offset.</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">freq_offset</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Association id.</span>
<span class="cm">	 */</span>
	<span class="n">u16</span> <span class="n">aid</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Beacon interval.</span>
<span class="cm">	 */</span>
	<span class="n">u16</span> <span class="n">beacon_int</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Timestamp of last received beacon</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_beacon</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Low level statistics which will have</span>
<span class="cm">	 * to be kept up to date while device is running.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">ieee80211_low_level_stats</span> <span class="n">low_level_stats</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Work queue for all work which should not be placed</span>
<span class="cm">	 * on the mac80211 workqueue (because of dependencies</span>
<span class="cm">	 * between various work structures).</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">workqueue</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Scheduled work.</span>
<span class="cm">	 * NOTE: intf_work will use ieee80211_iterate_active_interfaces()</span>
<span class="cm">	 * which means it cannot be placed on the hw-&gt;workqueue</span>
<span class="cm">	 * due to RTNL locking requirements.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">intf_work</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Scheduled work for TX/RX done handling (USB devices)</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">rxdone_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">txdone_work</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Powersaving work</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">autowakeup_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">sleep_work</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Data queue arrays for RX, TX, Beacon and ATIM.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_queues</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">rx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">tx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">bcn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">atim</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Firmware image.</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * FIFO for storing tx status reports between isr and tasklet.</span>
<span class="cm">	 */</span>
	<span class="n">DECLARE_KFIFO_PTR</span><span class="p">(</span><span class="n">txstatus_fifo</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Timer to ensure tx status reports are read (rt2800usb).</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">hrtimer</span> <span class="n">txstatus_timer</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Tasklet for processing tx status reports (rt2800pci).</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">txstatus_tasklet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">pretbtt_tasklet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">tbtt_tasklet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">rxdone_tasklet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">autowake_tasklet</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Used for VCO periodic calibration.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">rf_channel</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Protect the interrupt mask register.</span>
<span class="cm">	 */</span>
	<span class="n">spinlock_t</span> <span class="n">irqmask_lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Register defines.</span>
<span class="cm"> * Some registers require multiple attempts before success,</span>
<span class="cm"> * in those cases REGISTER_BUSY_COUNT attempts should be</span>
<span class="cm"> * taken with a REGISTER_BUSY_DELAY interval.</span>
<span class="cm"> */</span>
<span class="cp">#define REGISTER_BUSY_COUNT	100</span>
<span class="cp">#define REGISTER_BUSY_DELAY	100</span>

<span class="cm">/*</span>
<span class="cm"> * Generic RF access.</span>
<span class="cm"> * The RF is being accessed by word index.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rt2x00_rf_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">word</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">word</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">word</span> <span class="o">&gt;</span> <span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">rf_size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span>
	<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">rf</span><span class="p">[</span><span class="n">word</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rt2x00_rf_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">word</span><span class="p">,</span> <span class="n">u32</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">word</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">word</span> <span class="o">&gt;</span> <span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">rf_size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span>
	<span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">rf</span><span class="p">[</span><span class="n">word</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Generic EEPROM access.</span>
<span class="cm"> * The EEPROM is being accessed by word index.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">rt2x00_eeprom_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
				       <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">word</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">[</span><span class="n">word</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rt2x00_eeprom_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
				      <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">word</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">[</span><span class="n">word</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rt2x00_eeprom_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
				       <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">word</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Chipset handlers</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rt2x00_set_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
				   <span class="k">const</span> <span class="n">u16</span> <span class="n">rt</span><span class="p">,</span> <span class="k">const</span> <span class="n">u16</span> <span class="n">rf</span><span class="p">,</span> <span class="k">const</span> <span class="n">u16</span> <span class="n">rev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">rt</span> <span class="o">=</span> <span class="n">rt</span><span class="p">;</span>
	<span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">rf</span> <span class="o">=</span> <span class="n">rf</span><span class="p">;</span>
	<span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">rev</span> <span class="o">=</span> <span class="n">rev</span><span class="p">;</span>

	<span class="n">INFO</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span>
	     <span class="s">&quot;Chipset detected - rt: %04x, rf: %04x, rev: %04x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">rt</span><span class="p">,</span> <span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">rf</span><span class="p">,</span> <span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">rev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">rt2x00_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="k">const</span> <span class="n">u16</span> <span class="n">rt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">rt</span> <span class="o">==</span> <span class="n">rt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">rt2x00_rf</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="k">const</span> <span class="n">u16</span> <span class="n">rf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">rf</span> <span class="o">==</span> <span class="n">rf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">rt2x00_rev</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">rev</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">rt2x00_rt_rev</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
				 <span class="k">const</span> <span class="n">u16</span> <span class="n">rt</span><span class="p">,</span> <span class="k">const</span> <span class="n">u16</span> <span class="n">rev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">rt2x00_rt</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">rt</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">rt2x00_rev</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">)</span> <span class="o">==</span> <span class="n">rev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">rt2x00_rt_rev_lt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
				    <span class="k">const</span> <span class="n">u16</span> <span class="n">rt</span><span class="p">,</span> <span class="k">const</span> <span class="n">u16</span> <span class="n">rev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">rt2x00_rt</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">rt</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">rt2x00_rev</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">rev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">rt2x00_rt_rev_gte</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
				     <span class="k">const</span> <span class="n">u16</span> <span class="n">rt</span><span class="p">,</span> <span class="k">const</span> <span class="n">u16</span> <span class="n">rev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">rt2x00_rt</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">rt</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">rt2x00_rev</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">rev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rt2x00_set_chip_intf</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
					<span class="k">enum</span> <span class="n">rt2x00_chip_intf</span> <span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">intf</span> <span class="o">=</span> <span class="n">intf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">rt2x00_intf</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
			       <span class="k">enum</span> <span class="n">rt2x00_chip_intf</span> <span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">intf</span> <span class="o">==</span> <span class="n">intf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">rt2x00_is_pci</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rt2x00_intf</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">RT2X00_CHIP_INTF_PCI</span><span class="p">)</span> <span class="o">||</span>
	       <span class="n">rt2x00_intf</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">RT2X00_CHIP_INTF_PCIE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">rt2x00_is_pcie</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rt2x00_intf</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">RT2X00_CHIP_INTF_PCIE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">rt2x00_is_usb</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rt2x00_intf</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">RT2X00_CHIP_INTF_USB</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">rt2x00_is_soc</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rt2x00_intf</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">RT2X00_CHIP_INTF_SOC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rt2x00queue_map_txskb - Map a skb into DMA for TX purposes.</span>
<span class="cm"> * @entry: Pointer to &amp;struct queue_entry</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">rt2x00queue_map_txskb</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rt2x00queue_unmap_skb - Unmap a skb from DMA.</span>
<span class="cm"> * @entry: Pointer to &amp;struct queue_entry</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">rt2x00queue_unmap_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rt2x00queue_get_tx_queue - Convert tx queue index to queue pointer</span>
<span class="cm"> * @rt2x00dev: Pointer to &amp;struct rt2x00_dev.</span>
<span class="cm"> * @queue: rt2x00 queue index (see &amp;enum data_queue_qid).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns NULL for non tx queues.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span>
<span class="nf">rt2x00queue_get_tx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">enum</span> <span class="n">data_queue_qid</span> <span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">queue</span> <span class="o">&lt;</span> <span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">tx_queues</span> <span class="o">&amp;&amp;</span> <span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">[</span><span class="n">queue</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">queue</span> <span class="o">==</span> <span class="n">QID_ATIM</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">atim</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rt2x00queue_get_entry - Get queue entry where the given index points to.</span>
<span class="cm"> * @queue: Pointer to &amp;struct data_queue from where we obtain the entry.</span>
<span class="cm"> * @index: Index identifier for obtaining the correct index.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">rt2x00queue_get_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span>
					  <span class="k">enum</span> <span class="n">queue_index</span> <span class="n">index</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rt2x00queue_pause_queue - Pause a data queue</span>
<span class="cm"> * @queue: Pointer to &amp;struct data_queue.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will pause the data queue locally, preventing</span>
<span class="cm"> * new frames to be added to the queue (while the hardware is</span>
<span class="cm"> * still allowed to run).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">rt2x00queue_pause_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rt2x00queue_unpause_queue - unpause a data queue</span>
<span class="cm"> * @queue: Pointer to &amp;struct data_queue.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will unpause the data queue locally, allowing</span>
<span class="cm"> * new frames to be added to the queue again.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">rt2x00queue_unpause_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rt2x00queue_start_queue - Start a data queue</span>
<span class="cm"> * @queue: Pointer to &amp;struct data_queue.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will start handling all pending frames in the queue.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">rt2x00queue_start_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rt2x00queue_stop_queue - Halt a data queue</span>
<span class="cm"> * @queue: Pointer to &amp;struct data_queue.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will stop all pending frames in the queue.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">rt2x00queue_stop_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rt2x00queue_flush_queue - Flush a data queue</span>
<span class="cm"> * @queue: Pointer to &amp;struct data_queue.</span>
<span class="cm"> * @drop: True to drop all pending frames.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will flush the queue. After this call</span>
<span class="cm"> * the queue is guaranteed to be empty.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">rt2x00queue_flush_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span> <span class="n">bool</span> <span class="n">drop</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rt2x00queue_start_queues - Start all data queues</span>
<span class="cm"> * @rt2x00dev: Pointer to &amp;struct rt2x00_dev.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will loop through all available queues to start them</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">rt2x00queue_start_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rt2x00queue_stop_queues - Halt all data queues</span>
<span class="cm"> * @rt2x00dev: Pointer to &amp;struct rt2x00_dev.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will loop through all available queues to stop</span>
<span class="cm"> * any pending frames.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">rt2x00queue_stop_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rt2x00queue_flush_queues - Flush all data queues</span>
<span class="cm"> * @rt2x00dev: Pointer to &amp;struct rt2x00_dev.</span>
<span class="cm"> * @drop: True to drop all pending frames.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will loop through all available queues to flush</span>
<span class="cm"> * any pending frames.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">rt2x00queue_flush_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">drop</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Debugfs handlers.</span>
<span class="cm"> */</span>
<span class="cm">/**</span>
<span class="cm"> * rt2x00debug_dump_frame - Dump a frame to userspace through debugfs.</span>
<span class="cm"> * @rt2x00dev: Pointer to &amp;struct rt2x00_dev.</span>
<span class="cm"> * @type: The type of frame that is being dumped.</span>
<span class="cm"> * @skb: The skb containing the frame to be dumped.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_RT2X00_LIB_DEBUGFS</span>
<span class="kt">void</span> <span class="n">rt2x00debug_dump_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
			    <span class="k">enum</span> <span class="n">rt2x00_dump_type</span> <span class="n">type</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rt2x00debug_dump_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
					  <span class="k">enum</span> <span class="n">rt2x00_dump_type</span> <span class="n">type</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_RT2X00_LIB_DEBUGFS */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Utility functions.</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="n">rt2x00lib_get_bssidx</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Interrupt context handlers.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">rt2x00lib_beacondone</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rt2x00lib_pretbtt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rt2x00lib_dmastart</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rt2x00lib_dmadone</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rt2x00lib_txdone</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">txdone_entry_desc</span> <span class="o">*</span><span class="n">txdesc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rt2x00lib_txdone_noinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="n">u32</span> <span class="n">status</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rt2x00lib_rxdone</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * mac80211 handlers.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">rt2x00mac_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">rt2x00mac_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rt2x00mac_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">rt2x00mac_add_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rt2x00mac_remove_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">rt2x00mac_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">changed</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rt2x00mac_configure_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">changed_flags</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">total_flags</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">multicast</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">rt2x00mac_set_tim</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span>
		      <span class="n">bool</span> <span class="n">set</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_RT2X00_LIB_CRYPTO</span>
<span class="kt">int</span> <span class="n">rt2x00mac_set_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">enum</span> <span class="n">set_key_cmd</span> <span class="n">cmd</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">ieee80211_key_conf</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define rt2x00mac_set_key	NULL</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_RT2X00_LIB_CRYPTO */</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">rt2x00mac_sta_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">rt2x00mac_sta_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rt2x00mac_sw_scan_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rt2x00mac_sw_scan_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">rt2x00mac_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ieee80211_low_level_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rt2x00mac_bss_info_changed</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ieee80211_bss_conf</span> <span class="o">*</span><span class="n">bss_conf</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">changes</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">rt2x00mac_conf_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span> <span class="n">u16</span> <span class="n">queue</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_tx_queue_params</span> <span class="o">*</span><span class="n">params</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rt2x00mac_rfkill_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rt2x00mac_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">bool</span> <span class="n">drop</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">rt2x00mac_set_antenna</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">tx_ant</span><span class="p">,</span> <span class="n">u32</span> <span class="n">rx_ant</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">rt2x00mac_get_antenna</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">tx_ant</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">rx_ant</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rt2x00mac_get_ringparam</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="o">*</span><span class="n">tx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">tx_max</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">rx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">rx_max</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">rt2x00mac_tx_frames_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Driver allocation handlers.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">rt2x00lib_probe_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rt2x00lib_remove_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PM</span>
<span class="kt">int</span> <span class="n">rt2x00lib_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">rt2x00lib_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* RT2X00_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
