<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › rt2x00 › rt2x00queue.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>rt2x00queue.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">	Copyright (C) 2010 Willow Garage &lt;http://www.willowgarage.com&gt;</span>
<span class="cm">	Copyright (C) 2004 - 2010 Ivo van Doorn &lt;IvDoorn@gmail.com&gt;</span>
<span class="cm">	Copyright (C) 2004 - 2009 Gertjan van Wingerde &lt;gwingerde@gmail.com&gt;</span>
<span class="cm">	&lt;http://rt2x00.serialmonkey.com&gt;</span>

<span class="cm">	This program is free software; you can redistribute it and/or modify</span>
<span class="cm">	it under the terms of the GNU General Public License as published by</span>
<span class="cm">	the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">	(at your option) any later version.</span>

<span class="cm">	This program is distributed in the hope that it will be useful,</span>
<span class="cm">	but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</span>
<span class="cm">	GNU General Public License for more details.</span>

<span class="cm">	You should have received a copy of the GNU General Public License</span>
<span class="cm">	along with this program; if not, write to the</span>
<span class="cm">	Free Software Foundation, Inc.,</span>
<span class="cm">	59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm">	Module: rt2x00lib</span>
<span class="cm">	Abstract: rt2x00 queue specific routines.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>

<span class="cp">#include &quot;rt2x00.h&quot;</span>
<span class="cp">#include &quot;rt2x00lib.h&quot;</span>

<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">rt2x00queue_alloc_rxskb</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">skb_frame_desc</span> <span class="o">*</span><span class="n">skbdesc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frame_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">head_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tail_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The frame size includes descriptor size, because the</span>
<span class="cm">	 * hardware directly receive the frame into the skbuffer.</span>
<span class="cm">	 */</span>
	<span class="n">frame_size</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">data_size</span> <span class="o">+</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">desc_size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The payload should be aligned to a 4-byte boundary,</span>
<span class="cm">	 * this means we need at least 3 bytes for moving the frame</span>
<span class="cm">	 * into the correct offset.</span>
<span class="cm">	 */</span>
	<span class="n">head_size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For IV/EIV/ICV assembly we must make sure there is</span>
<span class="cm">	 * at least 8 bytes bytes available in headroom for IV/EIV</span>
<span class="cm">	 * and 8 bytes for ICV data as tailroon.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CAPABILITY_HW_CRYPTO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">cap_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">head_size</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">tail_size</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate skbuffer.</span>
<span class="cm">	 */</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">__dev_alloc_skb</span><span class="p">(</span><span class="n">frame_size</span> <span class="o">+</span> <span class="n">head_size</span> <span class="o">+</span> <span class="n">tail_size</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure we not have a frame with the requested bytes</span>
<span class="cm">	 * available in the head and tail.</span>
<span class="cm">	 */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">head_size</span><span class="p">);</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">frame_size</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Populate skbdesc.</span>
<span class="cm">	 */</span>
	<span class="n">skbdesc</span> <span class="o">=</span> <span class="n">get_skb_frame_desc</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">skbdesc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">skbdesc</span><span class="p">));</span>
	<span class="n">skbdesc</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">REQUIRE_DMA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">cap_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skbdesc</span><span class="o">-&gt;</span><span class="n">skb_dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						  <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
						  <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
						  <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="n">skbdesc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SKBDESC_DMA_MAPPED_RX</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">rt2x00queue_map_txskb</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">skb_frame_desc</span> <span class="o">*</span><span class="n">skbdesc</span> <span class="o">=</span> <span class="n">get_skb_frame_desc</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">skbdesc</span><span class="o">-&gt;</span><span class="n">skb_dma</span> <span class="o">=</span>
	    <span class="n">dma_map_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
	<span class="n">skbdesc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SKBDESC_DMA_MAPPED_TX</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rt2x00queue_map_txskb</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">rt2x00queue_unmap_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">skb_frame_desc</span> <span class="o">*</span><span class="n">skbdesc</span> <span class="o">=</span> <span class="n">get_skb_frame_desc</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skbdesc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SKBDESC_DMA_MAPPED_RX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skbdesc</span><span class="o">-&gt;</span><span class="n">skb_dma</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
				 <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="n">skbdesc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SKBDESC_DMA_MAPPED_RX</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">skbdesc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SKBDESC_DMA_MAPPED_TX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skbdesc</span><span class="o">-&gt;</span><span class="n">skb_dma</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
				 <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="n">skbdesc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SKBDESC_DMA_MAPPED_TX</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rt2x00queue_unmap_skb</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">rt2x00queue_free_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">rt2x00queue_unmap_skb</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">rt2x00queue_align_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frame_length</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">align</span> <span class="o">=</span> <span class="n">ALIGN_SIZE</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">align</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>
	<span class="n">memmove</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">align</span><span class="p">,</span> <span class="n">frame_length</span><span class="p">);</span>
	<span class="n">skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">frame_length</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">rt2x00queue_insert_l2pad</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">header_length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">payload_length</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">header_length</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">header_align</span> <span class="o">=</span> <span class="n">ALIGN_SIZE</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">payload_align</span> <span class="o">=</span> <span class="n">ALIGN_SIZE</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">header_length</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">l2pad</span> <span class="o">=</span> <span class="n">payload_length</span> <span class="o">?</span> <span class="n">L2PAD_SIZE</span><span class="p">(</span><span class="n">header_length</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Adjust the header alignment if the payload needs to be moved more</span>
<span class="cm">	 * than the header.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">payload_align</span> <span class="o">&gt;</span> <span class="n">header_align</span><span class="p">)</span>
		<span class="n">header_align</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/* There is nothing to do if no alignment is needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">header_align</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Reserve the amount of space needed in front of the frame */</span>
	<span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">header_align</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Move the header.</span>
<span class="cm">	 */</span>
	<span class="n">memmove</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">header_align</span><span class="p">,</span> <span class="n">header_length</span><span class="p">);</span>

	<span class="cm">/* Move the payload, if present and if required */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">payload_length</span> <span class="o">&amp;&amp;</span> <span class="n">payload_align</span><span class="p">)</span>
		<span class="n">memmove</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">header_length</span> <span class="o">+</span> <span class="n">l2pad</span><span class="p">,</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">header_length</span> <span class="o">+</span> <span class="n">l2pad</span> <span class="o">+</span> <span class="n">payload_align</span><span class="p">,</span>
			<span class="n">payload_length</span><span class="p">);</span>

	<span class="cm">/* Trim the skb to the correct size */</span>
	<span class="n">skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">header_length</span> <span class="o">+</span> <span class="n">l2pad</span> <span class="o">+</span> <span class="n">payload_length</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">rt2x00queue_remove_l2pad</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">header_length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * L2 padding is only present if the skb contains more than just the</span>
<span class="cm">	 * IEEE 802.11 header.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">l2pad</span> <span class="o">=</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">header_length</span><span class="p">)</span> <span class="o">?</span>
				<span class="n">L2PAD_SIZE</span><span class="p">(</span><span class="n">header_length</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l2pad</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">memmove</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">l2pad</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">header_length</span><span class="p">);</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">l2pad</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rt2x00queue_create_tx_descriptor_seq</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">txentry_desc</span> <span class="o">*</span><span class="n">txdesc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_tx_info</span> <span class="o">*</span><span class="n">tx_info</span> <span class="o">=</span> <span class="n">IEEE80211_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ieee80211_hdr</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt2x00_intf</span> <span class="o">*</span><span class="n">intf</span> <span class="o">=</span> <span class="n">vif_to_intf</span><span class="p">(</span><span class="n">tx_info</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">.</span><span class="n">vif</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">seqno</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tx_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IEEE80211_TX_CTL_ASSIGN_SEQ</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">__set_bit</span><span class="p">(</span><span class="n">ENTRY_TXD_GENERATE_SEQ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">REQUIRE_SW_SEQNO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">cap_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * rt2800 has a H/W (or F/W) bug, device incorrectly increase</span>
<span class="cm">		 * seqno on retransmited data (non-QOS) frames. To workaround</span>
<span class="cm">		 * the problem let&#39;s generate seqno in software if QOS is</span>
<span class="cm">		 * disabled.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CONFIG_QOS_DISABLED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="n">__clear_bit</span><span class="p">(</span><span class="n">ENTRY_TXD_GENERATE_SEQ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="cm">/* H/W will generate sequence number */</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The hardware is not able to insert a sequence number. Assign a</span>
<span class="cm">	 * software generated one here.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is wrong because beacons are not getting sequence</span>
<span class="cm">	 * numbers assigned properly.</span>
<span class="cm">	 *</span>
<span class="cm">	 * A secondary problem exists for drivers that cannot toggle</span>
<span class="cm">	 * sequence counting per-frame, since those will override the</span>
<span class="cm">	 * sequence counter given by mac80211.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">ENTRY_TXD_FIRST_FRAGMENT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">seqno</span> <span class="o">=</span> <span class="n">atomic_add_return</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">seqno</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">);</span>

	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">seq_ctrl</span> <span class="o">&amp;=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">IEEE80211_SCTL_FRAG</span><span class="p">);</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">seq_ctrl</span> <span class="o">|=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">seqno</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rt2x00queue_create_tx_descriptor_plcp</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">txentry_desc</span> <span class="o">*</span><span class="n">txdesc</span><span class="p">,</span>
						  <span class="k">const</span> <span class="k">struct</span> <span class="n">rt2x00_rate</span> <span class="o">*</span><span class="n">hwrate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_tx_info</span> <span class="o">*</span><span class="n">tx_info</span> <span class="o">=</span> <span class="n">IEEE80211_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ieee80211_tx_rate</span> <span class="o">*</span><span class="n">txrate</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_info</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">.</span><span class="n">rates</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_length</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">duration</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">residual</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine with what IFS priority this frame should be send.</span>
<span class="cm">	 * Set ifs to IFS_SIFS when the this is not the first fragment,</span>
<span class="cm">	 * or this fragment came after RTS/CTS.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">ENTRY_TXD_FIRST_FRAGMENT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">plcp</span><span class="p">.</span><span class="n">ifs</span> <span class="o">=</span> <span class="n">IFS_BACKOFF</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">plcp</span><span class="p">.</span><span class="n">ifs</span> <span class="o">=</span> <span class="n">IFS_SIFS</span><span class="p">;</span>

	<span class="cm">/* Data length + CRC + Crypto overhead (IV/EIV/ICV/MIC) */</span>
	<span class="n">data_length</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">data_length</span> <span class="o">+=</span> <span class="n">rt2x00crypto_tx_overhead</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * PLCP setup</span>
<span class="cm">	 * Length calculation depends on OFDM/CCK rate.</span>
<span class="cm">	 */</span>
	<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">plcp</span><span class="p">.</span><span class="n">signal</span> <span class="o">=</span> <span class="n">hwrate</span><span class="o">-&gt;</span><span class="n">plcp</span><span class="p">;</span>
	<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">plcp</span><span class="p">.</span><span class="n">service</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hwrate</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DEV_RATE_OFDM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">plcp</span><span class="p">.</span><span class="n">length_high</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_length</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">;</span>
		<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">plcp</span><span class="p">.</span><span class="n">length_low</span> <span class="o">=</span> <span class="n">data_length</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Convert length to microseconds.</span>
<span class="cm">		 */</span>
		<span class="n">residual</span> <span class="o">=</span> <span class="n">GET_DURATION_RES</span><span class="p">(</span><span class="n">data_length</span><span class="p">,</span> <span class="n">hwrate</span><span class="o">-&gt;</span><span class="n">bitrate</span><span class="p">);</span>
		<span class="n">duration</span> <span class="o">=</span> <span class="n">GET_DURATION</span><span class="p">(</span><span class="n">data_length</span><span class="p">,</span> <span class="n">hwrate</span><span class="o">-&gt;</span><span class="n">bitrate</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">residual</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">duration</span><span class="o">++</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Check if we need to set the Length Extension</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hwrate</span><span class="o">-&gt;</span><span class="n">bitrate</span> <span class="o">==</span> <span class="mi">110</span> <span class="o">&amp;&amp;</span> <span class="n">residual</span> <span class="o">&lt;=</span> <span class="mi">30</span><span class="p">)</span>
				<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">plcp</span><span class="p">.</span><span class="n">service</span> <span class="o">|=</span> <span class="mh">0x80</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">plcp</span><span class="p">.</span><span class="n">length_high</span> <span class="o">=</span> <span class="p">(</span><span class="n">duration</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">plcp</span><span class="p">.</span><span class="n">length_low</span> <span class="o">=</span> <span class="n">duration</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * When preamble is enabled we should set the</span>
<span class="cm">		 * preamble bit for the signal.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">txrate</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IEEE80211_TX_RC_USE_SHORT_PREAMBLE</span><span class="p">)</span>
			<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">plcp</span><span class="p">.</span><span class="n">signal</span> <span class="o">|=</span> <span class="mh">0x08</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rt2x00queue_create_tx_descriptor_ht</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">txentry_desc</span> <span class="o">*</span><span class="n">txdesc</span><span class="p">,</span>
						<span class="k">const</span> <span class="k">struct</span> <span class="n">rt2x00_rate</span> <span class="o">*</span><span class="n">hwrate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_tx_info</span> <span class="o">*</span><span class="n">tx_info</span> <span class="o">=</span> <span class="n">IEEE80211_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ieee80211_tx_rate</span> <span class="o">*</span><span class="n">txrate</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_info</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">.</span><span class="n">rates</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ieee80211_hdr</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt2x00_sta</span> <span class="o">*</span><span class="n">sta_priv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tx_info</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">.</span><span class="n">sta</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ht</span><span class="p">.</span><span class="n">mpdu_density</span> <span class="o">=</span>
		    <span class="n">tx_info</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">.</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">ht_cap</span><span class="p">.</span><span class="n">ampdu_density</span><span class="p">;</span>

		<span class="n">sta_priv</span> <span class="o">=</span> <span class="n">sta_to_rt2x00_sta</span><span class="p">(</span><span class="n">tx_info</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">.</span><span class="n">sta</span><span class="p">);</span>
		<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ht</span><span class="p">.</span><span class="n">wcid</span> <span class="o">=</span> <span class="n">sta_priv</span><span class="o">-&gt;</span><span class="n">wcid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If IEEE80211_TX_RC_MCS is set txrate-&gt;idx just contains the</span>
<span class="cm">	 * mcs rate to be used</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">txrate</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IEEE80211_TX_RC_MCS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ht</span><span class="p">.</span><span class="n">mcs</span> <span class="o">=</span> <span class="n">txrate</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * MIMO PS should be set to 1 for STA&#39;s using dynamic SM PS</span>
<span class="cm">		 * when using more then one tx stream (&gt;MCS7).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tx_info</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">.</span><span class="n">sta</span> <span class="o">&amp;&amp;</span> <span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ht</span><span class="p">.</span><span class="n">mcs</span> <span class="o">&gt;</span> <span class="mi">7</span> <span class="o">&amp;&amp;</span>
		    <span class="p">((</span><span class="n">tx_info</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">.</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">ht_cap</span><span class="p">.</span><span class="n">cap</span> <span class="o">&amp;</span>
		      <span class="n">IEEE80211_HT_CAP_SM_PS</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
		     <span class="n">IEEE80211_HT_CAP_SM_PS_SHIFT</span><span class="p">)</span> <span class="o">==</span>
		    <span class="n">WLAN_HT_CAP_SM_PS_DYNAMIC</span><span class="p">)</span>
			<span class="n">__set_bit</span><span class="p">(</span><span class="n">ENTRY_TXD_HT_MIMO_PS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ht</span><span class="p">.</span><span class="n">mcs</span> <span class="o">=</span> <span class="n">rt2x00_get_rate_mcs</span><span class="p">(</span><span class="n">hwrate</span><span class="o">-&gt;</span><span class="n">mcs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">txrate</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IEEE80211_TX_RC_USE_SHORT_PREAMBLE</span><span class="p">)</span>
			<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ht</span><span class="p">.</span><span class="n">mcs</span> <span class="o">|=</span> <span class="mh">0x08</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CONFIG_HT_DISABLED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tx_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IEEE80211_TX_CTL_FIRST_FRAGMENT</span><span class="p">))</span>
			<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ht</span><span class="p">.</span><span class="n">txop</span> <span class="o">=</span> <span class="n">TXOP_SIFS</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ht</span><span class="p">.</span><span class="n">txop</span> <span class="o">=</span> <span class="n">TXOP_BACKOFF</span><span class="p">;</span>

		<span class="cm">/* Left zero on all other settings. */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ht</span><span class="p">.</span><span class="n">ba_size</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>	<span class="cm">/* FIXME: What value is needed? */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only one STBC stream is supported for now.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tx_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IEEE80211_TX_CTL_STBC</span><span class="p">)</span>
		<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ht</span><span class="p">.</span><span class="n">stbc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This frame is eligible for an AMPDU, however, don&#39;t aggregate</span>
<span class="cm">	 * frames that are intended to probe a specific tx rate.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tx_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IEEE80211_TX_CTL_AMPDU</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">tx_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IEEE80211_TX_CTL_RATE_CTRL_PROBE</span><span class="p">))</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">ENTRY_TXD_HT_AMPDU</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set 40Mhz mode if necessary (for legacy rates this will</span>
<span class="cm">	 * duplicate the frame to both channels).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">txrate</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IEEE80211_TX_RC_40_MHZ_WIDTH</span> <span class="o">||</span>
	    <span class="n">txrate</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IEEE80211_TX_RC_DUP_DATA</span><span class="p">)</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">ENTRY_TXD_HT_BW_40</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">txrate</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IEEE80211_TX_RC_SHORT_GI</span><span class="p">)</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">ENTRY_TXD_HT_SHORT_GI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine IFS values</span>
<span class="cm">	 * - Use TXOP_BACKOFF for management frames except beacons</span>
<span class="cm">	 * - Use TXOP_SIFS for fragment bursts</span>
<span class="cm">	 * - Use TXOP_HTTXOP for everything else</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: rt2800 devices won&#39;t use CTS protection (if used)</span>
<span class="cm">	 * for frames not transmitted with TXOP_HTTXOP</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ieee80211_is_mgmt</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">frame_control</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">ieee80211_is_beacon</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">frame_control</span><span class="p">))</span>
		<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ht</span><span class="p">.</span><span class="n">txop</span> <span class="o">=</span> <span class="n">TXOP_BACKOFF</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tx_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IEEE80211_TX_CTL_FIRST_FRAGMENT</span><span class="p">))</span>
		<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ht</span><span class="p">.</span><span class="n">txop</span> <span class="o">=</span> <span class="n">TXOP_SIFS</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ht</span><span class="p">.</span><span class="n">txop</span> <span class="o">=</span> <span class="n">TXOP_HTTXOP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rt2x00queue_create_tx_descriptor</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">txentry_desc</span> <span class="o">*</span><span class="n">txdesc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_tx_info</span> <span class="o">*</span><span class="n">tx_info</span> <span class="o">=</span> <span class="n">IEEE80211_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ieee80211_hdr</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_tx_rate</span> <span class="o">*</span><span class="n">txrate</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_info</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">.</span><span class="n">rates</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ieee80211_rate</span> <span class="o">*</span><span class="n">rate</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">rt2x00_rate</span> <span class="o">*</span><span class="n">hwrate</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">txdesc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">txdesc</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Header and frame information.</span>
<span class="cm">	 */</span>
	<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">header_length</span> <span class="o">=</span> <span class="n">ieee80211_get_hdrlen_from_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check whether this frame is to be acked.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tx_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IEEE80211_TX_CTL_NO_ACK</span><span class="p">))</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">ENTRY_TXD_ACK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if this is a RTS/CTS frame</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ieee80211_is_rts</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">frame_control</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">ieee80211_is_cts</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">frame_control</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">ENTRY_TXD_BURST</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ieee80211_is_rts</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">frame_control</span><span class="p">))</span>
			<span class="n">__set_bit</span><span class="p">(</span><span class="n">ENTRY_TXD_RTS_FRAME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">__set_bit</span><span class="p">(</span><span class="n">ENTRY_TXD_CTS_FRAME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tx_info</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">.</span><span class="n">rts_cts_rate_idx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">rate</span> <span class="o">=</span>
			    <span class="n">ieee80211_get_rts_cts_rate</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">tx_info</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine retry information.</span>
<span class="cm">	 */</span>
	<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">retry_limit</span> <span class="o">=</span> <span class="n">tx_info</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">.</span><span class="n">rates</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">retry_limit</span> <span class="o">&gt;=</span> <span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">long_retry</span><span class="p">)</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">ENTRY_TXD_RETRY_MODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if more fragments are pending</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ieee80211_has_morefrags</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">frame_control</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">ENTRY_TXD_BURST</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">ENTRY_TXD_MORE_FRAG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if more frames (!= fragments) are pending</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tx_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IEEE80211_TX_CTL_MORE_FRAMES</span><span class="p">)</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">ENTRY_TXD_BURST</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Beacons and probe responses require the tsf timestamp</span>
<span class="cm">	 * to be inserted into the frame.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ieee80211_is_beacon</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">frame_control</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">ieee80211_is_probe_resp</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">frame_control</span><span class="p">))</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">ENTRY_TXD_REQ_TIMESTAMP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">tx_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IEEE80211_TX_CTL_FIRST_FRAGMENT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">ENTRY_TXD_RTS_FRAME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">ENTRY_TXD_FIRST_FRAGMENT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine rate modulation.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">txrate</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IEEE80211_TX_RC_GREEN_FIELD</span><span class="p">)</span>
		<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">rate_mode</span> <span class="o">=</span> <span class="n">RATE_MODE_HT_GREENFIELD</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">txrate</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IEEE80211_TX_RC_MCS</span><span class="p">)</span>
		<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">rate_mode</span> <span class="o">=</span> <span class="n">RATE_MODE_HT_MIX</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">rate</span> <span class="o">=</span> <span class="n">ieee80211_get_tx_rate</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">tx_info</span><span class="p">);</span>
		<span class="n">hwrate</span> <span class="o">=</span> <span class="n">rt2x00_get_rate</span><span class="p">(</span><span class="n">rate</span><span class="o">-&gt;</span><span class="n">hw_value</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hwrate</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DEV_RATE_OFDM</span><span class="p">)</span>
			<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">rate_mode</span> <span class="o">=</span> <span class="n">RATE_MODE_OFDM</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">rate_mode</span> <span class="o">=</span> <span class="n">RATE_MODE_CCK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Apply TX descriptor handling by components</span>
<span class="cm">	 */</span>
	<span class="n">rt2x00crypto_create_tx_descriptor</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">txdesc</span><span class="p">);</span>
	<span class="n">rt2x00queue_create_tx_descriptor_seq</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">txdesc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">REQUIRE_HT_TX_DESC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">cap_flags</span><span class="p">))</span>
		<span class="n">rt2x00queue_create_tx_descriptor_ht</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">txdesc</span><span class="p">,</span>
						    <span class="n">hwrate</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">rt2x00queue_create_tx_descriptor_plcp</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">txdesc</span><span class="p">,</span>
						      <span class="n">hwrate</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rt2x00queue_write_tx_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">txentry_desc</span> <span class="o">*</span><span class="n">txdesc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This should not happen, we already checked the entry</span>
<span class="cm">	 * was ours. When the hardware disagrees there has been</span>
<span class="cm">	 * a queue corruption!</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">lib</span><span class="o">-&gt;</span><span class="n">get_entry_state</span> <span class="o">&amp;&amp;</span>
		     <span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">lib</span><span class="o">-&gt;</span><span class="n">get_entry_state</span><span class="p">(</span><span class="n">entry</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ERROR</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span>
		      <span class="s">&quot;Corrupt queue %d, accessing entry which is not ours.</span><span class="se">\n</span><span class="s">&quot;</span>
		      <span class="s">&quot;Please file bug report to %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">entry</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">qid</span><span class="p">,</span> <span class="n">DRV_PROJECT</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Add the requested extra tx headroom in front of the skb.</span>
<span class="cm">	 */</span>
	<span class="n">skb_push</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">extra_tx_headroom</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">extra_tx_headroom</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Call the driver&#39;s write_tx_data function, if it exists.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">lib</span><span class="o">-&gt;</span><span class="n">write_tx_data</span><span class="p">)</span>
		<span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">lib</span><span class="o">-&gt;</span><span class="n">write_tx_data</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">txdesc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Map the skb to DMA.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">REQUIRE_DMA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">cap_flags</span><span class="p">))</span>
		<span class="n">rt2x00queue_map_txskb</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rt2x00queue_write_tx_descriptor</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">txentry_desc</span> <span class="o">*</span><span class="n">txdesc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>

	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">lib</span><span class="o">-&gt;</span><span class="n">write_tx_desc</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">txdesc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * All processing on the frame has been completed, this means</span>
<span class="cm">	 * it is now ready to be dumped to userspace through debugfs.</span>
<span class="cm">	 */</span>
	<span class="n">rt2x00debug_dump_frame</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">DUMP_FRAME_TX</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rt2x00queue_kick_tx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">txentry_desc</span> <span class="o">*</span><span class="n">txdesc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check if we need to kick the queue, there are however a few rules</span>
<span class="cm">	 *	1) Don&#39;t kick unless this is the last in frame in a burst.</span>
<span class="cm">	 *	   When the burst flag is set, this frame is always followed</span>
<span class="cm">	 *	   by another frame which in some way are related to eachother.</span>
<span class="cm">	 *	   This is true for fragments, RTS or CTS-to-self frames.</span>
<span class="cm">	 *	2) Rule 1 can be broken when the available entries</span>
<span class="cm">	 *	   in the queue are less then a certain threshold.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rt2x00queue_threshold</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">ENTRY_TXD_BURST</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">lib</span><span class="o">-&gt;</span><span class="n">kick_queue</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">rt2x00queue_write_tx_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			       <span class="n">bool</span> <span class="n">local</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_tx_info</span> <span class="o">*</span><span class="n">tx_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">txentry_desc</span> <span class="n">txdesc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">skb_frame_desc</span> <span class="o">*</span><span class="n">skbdesc</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">rate_idx</span><span class="p">,</span> <span class="n">rate_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy all TX descriptor information into txdesc,</span>
<span class="cm">	 * after that we are free to use the skb-&gt;cb array</span>
<span class="cm">	 * for our information.</span>
<span class="cm">	 */</span>
	<span class="n">rt2x00queue_create_tx_descriptor</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * All information is retrieved from the skb-&gt;cb array,</span>
<span class="cm">	 * now we should claim ownership of the driver part of that</span>
<span class="cm">	 * array, preserving the bitrate index and flags.</span>
<span class="cm">	 */</span>
	<span class="n">tx_info</span> <span class="o">=</span> <span class="n">IEEE80211_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">rate_idx</span> <span class="o">=</span> <span class="n">tx_info</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">.</span><span class="n">rates</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">idx</span><span class="p">;</span>
	<span class="n">rate_flags</span> <span class="o">=</span> <span class="n">tx_info</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">.</span><span class="n">rates</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">skbdesc</span> <span class="o">=</span> <span class="n">get_skb_frame_desc</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">skbdesc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">skbdesc</span><span class="p">));</span>
	<span class="n">skbdesc</span><span class="o">-&gt;</span><span class="n">tx_rate_idx</span> <span class="o">=</span> <span class="n">rate_idx</span><span class="p">;</span>
	<span class="n">skbdesc</span><span class="o">-&gt;</span><span class="n">tx_rate_flags</span> <span class="o">=</span> <span class="n">rate_flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">local</span><span class="p">)</span>
		<span class="n">skbdesc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SKBDESC_NOT_MAC80211</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When hardware encryption is supported, and this frame</span>
<span class="cm">	 * is to be encrypted, we should strip the IV/EIV data from</span>
<span class="cm">	 * the frame so we can provide it to the driver separately.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">ENTRY_TXD_ENCRYPT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="p">.</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">ENTRY_TXD_ENCRYPT_IV</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="p">.</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">REQUIRE_COPY_IV</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">cap_flags</span><span class="p">))</span>
			<span class="n">rt2x00crypto_tx_copy_iv</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">rt2x00crypto_tx_remove_iv</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * When DMA allocation is required we should guarantee to the</span>
<span class="cm">	 * driver that the DMA is aligned to a 4-byte boundary.</span>
<span class="cm">	 * However some drivers require L2 padding to pad the payload</span>
<span class="cm">	 * rather then the header. This could be a requirement for</span>
<span class="cm">	 * PCI and USB devices, while header alignment only is valid</span>
<span class="cm">	 * for PCI devices.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">REQUIRE_L2PAD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">cap_flags</span><span class="p">))</span>
		<span class="n">rt2x00queue_insert_l2pad</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">txdesc</span><span class="p">.</span><span class="n">header_length</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">REQUIRE_DMA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">cap_flags</span><span class="p">))</span>
		<span class="n">rt2x00queue_align_frame</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * That function must be called with bh disabled.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rt2x00queue_full</span><span class="p">(</span><span class="n">queue</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ERROR</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="p">,</span>
		      <span class="s">&quot;Dropping frame due to full tx queue %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">qid</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">rt2x00queue_get_entry</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">Q_INDEX</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">ENTRY_OWNER_DEVICE_DATA</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ERROR</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="p">,</span>
		      <span class="s">&quot;Arrived at non-free entry in the non-full queue %d.</span><span class="se">\n</span><span class="s">&quot;</span>
		      <span class="s">&quot;Please file bug report to %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">queue</span><span class="o">-&gt;</span><span class="n">qid</span><span class="p">,</span> <span class="n">DRV_PROJECT</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skbdesc</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * It could be possible that the queue was corrupted and this</span>
<span class="cm">	 * call failed. Since we always return NETDEV_TX_OK to mac80211,</span>
<span class="cm">	 * this frame will simply be dropped.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rt2x00queue_write_tx_data</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">ENTRY_OWNER_DEVICE_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">ENTRY_DATA_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">rt2x00queue_index_inc</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">Q_INDEX</span><span class="p">);</span>
	<span class="n">rt2x00queue_write_tx_descriptor</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="p">);</span>
	<span class="n">rt2x00queue_kick_tx_queue</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">rt2x00queue_clear_beacon</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rt2x00_intf</span> <span class="o">*</span><span class="n">intf</span> <span class="o">=</span> <span class="n">vif_to_intf</span><span class="p">(</span><span class="n">vif</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">beacon</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">beacon_skb_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clean up the beacon skb.</span>
<span class="cm">	 */</span>
	<span class="n">rt2x00queue_free_skb</span><span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">beacon</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear beacon (single bssid devices don&#39;t need to clear the beacon</span>
<span class="cm">	 * since the beacon queue will get stopped anyway).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">lib</span><span class="o">-&gt;</span><span class="n">clear_beacon</span><span class="p">)</span>
		<span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">lib</span><span class="o">-&gt;</span><span class="n">clear_beacon</span><span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">beacon</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">beacon_skb_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">rt2x00queue_update_beacon_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rt2x00_intf</span> <span class="o">*</span><span class="n">intf</span> <span class="o">=</span> <span class="n">vif_to_intf</span><span class="p">(</span><span class="n">vif</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">skb_frame_desc</span> <span class="o">*</span><span class="n">skbdesc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">txentry_desc</span> <span class="n">txdesc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">beacon</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clean up the beacon skb.</span>
<span class="cm">	 */</span>
	<span class="n">rt2x00queue_free_skb</span><span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">beacon</span><span class="p">);</span>

	<span class="n">intf</span><span class="o">-&gt;</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">ieee80211_beacon_get</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">vif</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy all TX descriptor information into txdesc,</span>
<span class="cm">	 * after that we are free to use the skb-&gt;cb array</span>
<span class="cm">	 * for our information.</span>
<span class="cm">	 */</span>
	<span class="n">rt2x00queue_create_tx_descriptor</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fill in skb descriptor</span>
<span class="cm">	 */</span>
	<span class="n">skbdesc</span> <span class="o">=</span> <span class="n">get_skb_frame_desc</span><span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">skbdesc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">skbdesc</span><span class="p">));</span>
	<span class="n">skbdesc</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">beacon</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Send beacon to hardware.</span>
<span class="cm">	 */</span>
	<span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">lib</span><span class="o">-&gt;</span><span class="n">write_beacon</span><span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">beacon</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdesc</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="nf">rt2x00queue_update_beacon</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rt2x00_intf</span> <span class="o">*</span><span class="n">intf</span> <span class="o">=</span> <span class="n">vif_to_intf</span><span class="p">(</span><span class="n">vif</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">beacon_skb_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">rt2x00queue_update_beacon_locked</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">vif</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">beacon_skb_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">rt2x00queue_for_each_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">queue_index</span> <span class="n">start</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">queue_index</span> <span class="n">end</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
					   <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index_start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index_end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">Q_INDEX_MAX</span> <span class="o">||</span> <span class="n">end</span> <span class="o">&gt;=</span> <span class="n">Q_INDEX_MAX</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ERROR</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="p">,</span>
		      <span class="s">&quot;Entry requested from invalid index range (%d - %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only protect the range we are going to loop over,</span>
<span class="cm">	 * if during our loop a extra entry is set to pending</span>
<span class="cm">	 * it should not be kicked during this run, since it</span>
<span class="cm">	 * is part of another TX operation.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">index_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
	<span class="n">index_start</span> <span class="o">=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>
	<span class="n">index_end</span> <span class="o">=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">[</span><span class="n">end</span><span class="p">];</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">index_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start from the TX done pointer, this guarantees that we will</span>
<span class="cm">	 * send out all frames in the correct order.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index_start</span> <span class="o">&lt;</span> <span class="n">index_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">index_start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">index_end</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">data</span><span class="p">))</span>
				<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">index_start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">data</span><span class="p">))</span>
				<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">index_end</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">data</span><span class="p">))</span>
				<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rt2x00queue_for_each_entry</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="nf">rt2x00queue_get_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span>
					  <span class="k">enum</span> <span class="n">queue_index</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">Q_INDEX_MAX</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ERROR</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="p">,</span>
		      <span class="s">&quot;Entry requested from invalid index type (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">index_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">[</span><span class="n">index</span><span class="p">]];</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">index_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rt2x00queue_get_entry</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">rt2x00queue_index_inc</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="k">enum</span> <span class="n">queue_index</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">Q_INDEX_MAX</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ERROR</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="p">,</span>
		      <span class="s">&quot;Index change on invalid index type (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">index_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>

	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">)</span>
		<span class="n">queue</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">last_action</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">Q_INDEX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">queue</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">Q_INDEX_DONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">queue</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">--</span><span class="p">;</span>
		<span class="n">queue</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">index_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">rt2x00queue_pause_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DEVICE_STATE_PRESENT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">QUEUE_STARTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">QUEUE_PAUSED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">qid</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">QID_AC_VO</span>:
	<span class="k">case</span> <span class="n">QID_AC_VI</span>:
	<span class="k">case</span> <span class="n">QID_AC_BE</span>:
	<span class="k">case</span> <span class="n">QID_AC_BK</span>:
		<span class="cm">/*</span>
<span class="cm">		 * For TX queues, we have to disable the queue</span>
<span class="cm">		 * inside mac80211.</span>
<span class="cm">		 */</span>
		<span class="n">ieee80211_stop_queue</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">qid</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rt2x00queue_pause_queue</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">rt2x00queue_unpause_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DEVICE_STATE_PRESENT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">QUEUE_STARTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">QUEUE_PAUSED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">qid</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">QID_AC_VO</span>:
	<span class="k">case</span> <span class="n">QID_AC_VI</span>:
	<span class="k">case</span> <span class="n">QID_AC_BE</span>:
	<span class="k">case</span> <span class="n">QID_AC_BK</span>:
		<span class="cm">/*</span>
<span class="cm">		 * For TX queues, we have to enable the queue</span>
<span class="cm">		 * inside mac80211.</span>
<span class="cm">		 */</span>
		<span class="n">ieee80211_wake_queue</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">qid</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">QID_RX</span>:
		<span class="cm">/*</span>
<span class="cm">		 * For RX we need to kick the queue now in order to</span>
<span class="cm">		 * receive frames.</span>
<span class="cm">		 */</span>
		<span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">lib</span><span class="o">-&gt;</span><span class="n">kick_queue</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rt2x00queue_unpause_queue</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">rt2x00queue_start_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">status_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DEVICE_STATE_PRESENT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">QUEUE_STARTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">status_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">QUEUE_PAUSED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">lib</span><span class="o">-&gt;</span><span class="n">start_queue</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>

	<span class="n">rt2x00queue_unpause_queue</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">status_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rt2x00queue_start_queue</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">rt2x00queue_stop_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">status_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">QUEUE_STARTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">status_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rt2x00queue_pause_queue</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>

	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">lib</span><span class="o">-&gt;</span><span class="n">stop_queue</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">status_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rt2x00queue_stop_queue</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">rt2x00queue_flush_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span> <span class="n">bool</span> <span class="n">drop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">started</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">tx_queue</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">qid</span> <span class="o">==</span> <span class="n">QID_AC_VO</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">qid</span> <span class="o">==</span> <span class="n">QID_AC_VI</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">qid</span> <span class="o">==</span> <span class="n">QID_AC_BE</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">qid</span> <span class="o">==</span> <span class="n">QID_AC_BK</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">status_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the queue has been started, we must stop it temporarily</span>
<span class="cm">	 * to prevent any new frames to be queued on the device. If</span>
<span class="cm">	 * we are not dropping the pending frames, the queue must</span>
<span class="cm">	 * only be stopped in the software and not the hardware,</span>
<span class="cm">	 * otherwise the queue will never become empty on its own.</span>
<span class="cm">	 */</span>
	<span class="n">started</span> <span class="o">=</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">QUEUE_STARTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">started</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Pause the queue</span>
<span class="cm">		 */</span>
		<span class="n">rt2x00queue_pause_queue</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we are not supposed to drop any pending</span>
<span class="cm">		 * frames, this means we must force a start (=kick)</span>
<span class="cm">		 * to the queue to make sure the hardware will</span>
<span class="cm">		 * start transmitting.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drop</span> <span class="o">&amp;&amp;</span> <span class="n">tx_queue</span><span class="p">)</span>
			<span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">lib</span><span class="o">-&gt;</span><span class="n">kick_queue</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if driver supports flushing, if that is the case we can</span>
<span class="cm">	 * defer the flushing to the driver. Otherwise we must use the</span>
<span class="cm">	 * alternative which just waits for the queue to become empty.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">lib</span><span class="o">-&gt;</span><span class="n">flush_queue</span><span class="p">))</span>
		<span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">lib</span><span class="o">-&gt;</span><span class="n">flush_queue</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">drop</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The queue flush has failed...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">rt2x00queue_empty</span><span class="p">(</span><span class="n">queue</span><span class="p">)))</span>
		<span class="n">WARNING</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="s">&quot;Queue %d failed to flush</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">qid</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Restore the queue to the previous status</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">started</span><span class="p">)</span>
		<span class="n">rt2x00queue_unpause_queue</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">status_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rt2x00queue_flush_queue</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">rt2x00queue_start_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * rt2x00queue_start_queue will call ieee80211_wake_queue</span>
<span class="cm">	 * for each queue after is has been properly initialized.</span>
<span class="cm">	 */</span>
	<span class="n">tx_queue_for_each</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span>
		<span class="n">rt2x00queue_start_queue</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>

	<span class="n">rt2x00queue_start_queue</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rt2x00queue_start_queues</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">rt2x00queue_stop_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * rt2x00queue_stop_queue will call ieee80211_stop_queue</span>
<span class="cm">	 * as well, but we are completely shutting doing everything</span>
<span class="cm">	 * now, so it is much safer to stop all TX queues at once,</span>
<span class="cm">	 * and use rt2x00queue_stop_queue for cleaning up.</span>
<span class="cm">	 */</span>
	<span class="n">ieee80211_stop_queues</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">tx_queue_for_each</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span>
		<span class="n">rt2x00queue_stop_queue</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>

	<span class="n">rt2x00queue_stop_queue</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rt2x00queue_stop_queues</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">rt2x00queue_flush_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">drop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>

	<span class="n">tx_queue_for_each</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span>
		<span class="n">rt2x00queue_flush_queue</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">drop</span><span class="p">);</span>

	<span class="n">rt2x00queue_flush_queue</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">,</span> <span class="n">drop</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rt2x00queue_flush_queues</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rt2x00queue_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">index_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>

	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Q_INDEX_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">queue</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">index_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">rt2x00queue_init_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">queue_for_each</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rt2x00queue_reset</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">lib</span><span class="o">-&gt;</span><span class="n">clear_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rt2x00queue_alloc_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">data_queue_desc</span> <span class="o">*</span><span class="n">qdesc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">entries</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">entry_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">rt2x00queue_reset</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>

	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">limit</span> <span class="o">=</span> <span class="n">qdesc</span><span class="o">-&gt;</span><span class="n">entry_num</span><span class="p">;</span>
	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">qdesc</span><span class="o">-&gt;</span><span class="n">entry_num</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">data_size</span> <span class="o">=</span> <span class="n">qdesc</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">;</span>
	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">desc_size</span> <span class="o">=</span> <span class="n">qdesc</span><span class="o">-&gt;</span><span class="n">desc_size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate all queue entries.</span>
<span class="cm">	 */</span>
	<span class="n">entry_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entries</span><span class="p">)</span> <span class="o">+</span> <span class="n">qdesc</span><span class="o">-&gt;</span><span class="n">priv_size</span><span class="p">;</span>
	<span class="n">entries</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">,</span> <span class="n">entry_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entries</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

<span class="cp">#define QUEUE_ENTRY_PRIV_OFFSET(__base, __index, __limit, __esize, __psize) \</span>
<span class="cp">	(((char *)(__base)) + ((__limit) * (__esize)) + \</span>
<span class="cp">	    ((__index) * (__psize)))</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">queue</span> <span class="o">=</span> <span class="n">queue</span><span class="p">;</span>
		<span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">entry_idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">priv_data</span> <span class="o">=</span>
		    <span class="n">QUEUE_ENTRY_PRIV_OFFSET</span><span class="p">(</span><span class="n">entries</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">,</span>
					    <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entries</span><span class="p">),</span> <span class="n">qdesc</span><span class="o">-&gt;</span><span class="n">priv_size</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#undef QUEUE_ENTRY_PRIV_OFFSET</span>

	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="n">entries</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rt2x00queue_free_skbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rt2x00queue_free_skb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rt2x00queue_alloc_rxskbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">rt2x00queue_alloc_rxskb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">queue</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">rt2x00queue_initialize</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">rt2x00queue_alloc_entries</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">,</span> <span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">tx_queue_for_each</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">rt2x00queue_alloc_entries</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">rt2x00queue_alloc_entries</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">bcn</span><span class="p">,</span> <span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">bcn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">REQUIRE_ATIM_QUEUE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">cap_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">rt2x00queue_alloc_entries</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">atim</span><span class="p">,</span>
						   <span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">atim</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">rt2x00queue_alloc_rxskbs</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">exit:</span>
	<span class="n">ERROR</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="s">&quot;Queue entries allocation failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">rt2x00queue_uninitialize</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">rt2x00queue_uninitialize</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>

	<span class="n">rt2x00queue_free_skbs</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">);</span>

	<span class="n">queue_for_each</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">);</span>
		<span class="n">queue</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rt2x00queue_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span> <span class="k">enum</span> <span class="n">data_queue_qid</span> <span class="n">qid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">status_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">index_lock</span><span class="p">);</span>

	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">rt2x00dev</span> <span class="o">=</span> <span class="n">rt2x00dev</span><span class="p">;</span>
	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">qid</span> <span class="o">=</span> <span class="n">qid</span><span class="p">;</span>
	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">txop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">aifs</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">cw_min</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">cw_max</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">rt2x00queue_allocate</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">data_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">data_queue_qid</span> <span class="n">qid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">req_atim</span> <span class="o">=</span>
	    <span class="o">!!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">REQUIRE_ATIM_QUEUE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">cap_flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need the following queues:</span>
<span class="cm">	 * RX: 1</span>
<span class="cm">	 * TX: ops-&gt;tx_queues</span>
<span class="cm">	 * Beacon: 1</span>
<span class="cm">	 * Atim: 1 (if required)</span>
<span class="cm">	 */</span>
	<span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">data_queues</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">tx_queues</span> <span class="o">+</span> <span class="n">req_atim</span><span class="p">;</span>

	<span class="n">queue</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">data_queues</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">queue</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ERROR</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="s">&quot;Queue allocation failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize pointers</span>
<span class="cm">	 */</span>
	<span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">=</span> <span class="n">queue</span><span class="p">;</span>
	<span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">queue</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">bcn</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">queue</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">tx_queues</span><span class="p">];</span>
	<span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">atim</span> <span class="o">=</span> <span class="n">req_atim</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">queue</span><span class="p">[</span><span class="mi">2</span> <span class="o">+</span> <span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">tx_queues</span><span class="p">]</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize queue parameters.</span>
<span class="cm">	 * RX: qid = QID_RX</span>
<span class="cm">	 * TX: qid = QID_AC_VO + index</span>
<span class="cm">	 * TX: cw_min: 2^5 = 32.</span>
<span class="cm">	 * TX: cw_max: 2^10 = 1024.</span>
<span class="cm">	 * BCN: qid = QID_BEACON</span>
<span class="cm">	 * ATIM: qid = QID_ATIM</span>
<span class="cm">	 */</span>
	<span class="n">rt2x00queue_init</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">,</span> <span class="n">QID_RX</span><span class="p">);</span>

	<span class="n">qid</span> <span class="o">=</span> <span class="n">QID_AC_VO</span><span class="p">;</span>
	<span class="n">tx_queue_for_each</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span>
		<span class="n">rt2x00queue_init</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">qid</span><span class="o">++</span><span class="p">);</span>

	<span class="n">rt2x00queue_init</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">bcn</span><span class="p">,</span> <span class="n">QID_BEACON</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req_atim</span><span class="p">)</span>
		<span class="n">rt2x00queue_init</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="p">,</span> <span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">atim</span><span class="p">,</span> <span class="n">QID_ATIM</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">rt2x00queue_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt2x00_dev</span> <span class="o">*</span><span class="n">rt2x00dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">);</span>
	<span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">rt2x00dev</span><span class="o">-&gt;</span><span class="n">bcn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
