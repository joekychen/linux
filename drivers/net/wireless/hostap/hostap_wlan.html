<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › hostap › hostap_wlan.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>hostap_wlan.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef HOSTAP_WLAN_H</span>
<span class="cp">#define HOSTAP_WLAN_H</span>

<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/wireless.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;net/iw_handler.h&gt;</span>
<span class="cp">#include &lt;net/ieee80211_radiotap.h&gt;</span>
<span class="cp">#include &lt;net/lib80211.h&gt;</span>

<span class="cp">#include &quot;hostap_config.h&quot;</span>
<span class="cp">#include &quot;hostap_common.h&quot;</span>

<span class="cp">#define MAX_PARM_DEVICES 8</span>
<span class="cp">#define PARM_MIN_MAX &quot;1-&quot; __MODULE_STRING(MAX_PARM_DEVICES)</span>
<span class="cp">#define DEF_INTS -1, -1, -1, -1, -1, -1, -1</span>
<span class="cp">#define GET_INT_PARM(var,idx) var[var[idx] &lt; 0 ? 0 : idx]</span>


<span class="cm">/* Specific skb-&gt;protocol value that indicates that the packet already contains</span>
<span class="cm"> * txdesc header.</span>
<span class="cm"> * FIX: This might need own value that would be allocated especially for Prism2</span>
<span class="cm"> * txdesc; ETH_P_CONTROL is commented as &quot;Card specific control frames&quot;.</span>
<span class="cm"> * However, these skb&#39;s should have only minimal path in the kernel side since</span>
<span class="cm"> * prism2_send_mgmt() sends these with dev_queue_xmit() to prism2_tx(). */</span>
<span class="cp">#define ETH_P_HOSTAP ETH_P_CONTROL</span>

<span class="cm">/* ARPHRD_IEEE80211_PRISM uses a bloated version of Prism2 RX frame header</span>
<span class="cm"> * (from linux-wlan-ng) */</span>
<span class="k">struct</span> <span class="n">linux_wlan_ng_val</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">did</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">status</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">linux_wlan_ng_prism_hdr</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">msgcode</span><span class="p">,</span> <span class="n">msglen</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">devname</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">linux_wlan_ng_val</span> <span class="n">hosttime</span><span class="p">,</span> <span class="n">mactime</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">rssi</span><span class="p">,</span> <span class="n">sq</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span>
		<span class="n">noise</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">istx</span><span class="p">,</span> <span class="n">frmlen</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">linux_wlan_ng_cap_hdr</span> <span class="p">{</span>
	<span class="n">__be32</span> <span class="n">version</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">__be64</span> <span class="n">mactime</span><span class="p">;</span>
	<span class="n">__be64</span> <span class="n">hosttime</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">phytype</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">channel</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">datarate</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">antenna</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">priority</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">ssi_type</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">ssi_signal</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">ssi_noise</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">preamble</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">encoding</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">hostap_radiotap_rx</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_radiotap_header</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">tsft</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">rate</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">padding</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">chan_freq</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">chan_flags</span><span class="p">;</span>
	<span class="n">s8</span> <span class="n">dbm_antsignal</span><span class="p">;</span>
	<span class="n">s8</span> <span class="n">dbm_antnoise</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cp">#define LWNG_CAP_DID_BASE   (4 | (1 &lt;&lt; 6)) </span><span class="cm">/* section 4, group 1 */</span><span class="cp"></span>
<span class="cp">#define LWNG_CAPHDR_VERSION 0x80211001</span>

<span class="k">struct</span> <span class="n">hfa384x_rx_frame</span> <span class="p">{</span>
	<span class="cm">/* HFA384X RX frame descriptor */</span>
	<span class="n">__le16</span> <span class="n">status</span><span class="p">;</span> <span class="cm">/* HFA384X_RX_STATUS_ flags */</span>
	<span class="n">__le32</span> <span class="n">time</span><span class="p">;</span> <span class="cm">/* timestamp, 1 microsecond resolution */</span>
	<span class="n">u8</span> <span class="n">silence</span><span class="p">;</span> <span class="cm">/* 27 .. 154; seems to be 0 */</span>
	<span class="n">u8</span> <span class="n">signal</span><span class="p">;</span> <span class="cm">/* 27 .. 154 */</span>
	<span class="n">u8</span> <span class="n">rate</span><span class="p">;</span> <span class="cm">/* 10, 20, 55, or 110 */</span>
	<span class="n">u8</span> <span class="n">rxflow</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">reserved</span><span class="p">;</span>

	<span class="cm">/* 802.11 */</span>
	<span class="n">__le16</span> <span class="n">frame_control</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">duration_id</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">addr1</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">addr2</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">addr3</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">__le16</span> <span class="n">seq_ctrl</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">addr4</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">__le16</span> <span class="n">data_len</span><span class="p">;</span>

	<span class="cm">/* 802.3 */</span>
	<span class="n">u8</span> <span class="n">dst_addr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">src_addr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">__be16</span> <span class="n">len</span><span class="p">;</span>

	<span class="cm">/* followed by frame data; max 2304 bytes */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>


<span class="k">struct</span> <span class="n">hfa384x_tx_frame</span> <span class="p">{</span>
	<span class="cm">/* HFA384X TX frame descriptor */</span>
	<span class="n">__le16</span> <span class="n">status</span><span class="p">;</span> <span class="cm">/* HFA384X_TX_STATUS_ flags */</span>
	<span class="n">__le16</span> <span class="n">reserved1</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">reserved2</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">sw_support</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">retry_count</span><span class="p">;</span> <span class="cm">/* not yet implemented */</span>
	<span class="n">u8</span> <span class="n">tx_rate</span><span class="p">;</span> <span class="cm">/* Host AP only; 0 = firmware, or 10, 20, 55, 110 */</span>
	<span class="n">__le16</span> <span class="n">tx_control</span><span class="p">;</span> <span class="cm">/* HFA384X_TX_CTRL_ flags */</span>

	<span class="cm">/* 802.11 */</span>
	<span class="n">__le16</span> <span class="n">frame_control</span><span class="p">;</span> <span class="cm">/* parts not used */</span>
	<span class="n">__le16</span> <span class="n">duration_id</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">addr1</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">addr2</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span> <span class="cm">/* filled by firmware */</span>
	<span class="n">u8</span> <span class="n">addr3</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">__le16</span> <span class="n">seq_ctrl</span><span class="p">;</span> <span class="cm">/* filled by firmware */</span>
	<span class="n">u8</span> <span class="n">addr4</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">__le16</span> <span class="n">data_len</span><span class="p">;</span>

	<span class="cm">/* 802.3 */</span>
	<span class="n">u8</span> <span class="n">dst_addr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">src_addr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">__be16</span> <span class="n">len</span><span class="p">;</span>

	<span class="cm">/* followed by frame data; max 2304 bytes */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>


<span class="k">struct</span> <span class="n">hfa384x_rid_hdr</span>
<span class="p">{</span>
	<span class="n">__le16</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">rid</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>


<span class="cm">/* Macro for converting signal levels (range 27 .. 154) to wireless ext</span>
<span class="cm"> * dBm value with some accuracy */</span>
<span class="cp">#define HFA384X_LEVEL_TO_dBm(v) 0x100 + (v) * 100 / 255 - 100</span>

<span class="cp">#define HFA384X_LEVEL_TO_dBm_sign(v) (v) * 100 / 255 - 100</span>

<span class="k">struct</span> <span class="n">hfa384x_scan_request</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">channel_list</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">txrate</span><span class="p">;</span> <span class="cm">/* HFA384X_RATES_* */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">hfa384x_hostscan_request</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">channel_list</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">txrate</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">target_ssid_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">target_ssid</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">hfa384x_join_request</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">bssid</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">__le16</span> <span class="n">channel</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">hfa384x_info_frame</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">hfa384x_comm_tallies</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">tx_unicast_frames</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">tx_multicast_frames</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">tx_fragments</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">tx_unicast_octets</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">tx_multicast_octets</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">tx_deferred_transmissions</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">tx_single_retry_frames</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">tx_multiple_retry_frames</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">tx_retry_limit_exceeded</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">tx_discards</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">rx_unicast_frames</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">rx_multicast_frames</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">rx_fragments</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">rx_unicast_octets</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">rx_multicast_octets</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">rx_fcs_errors</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">rx_discards_no_buffer</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">tx_discards_wrong_sa</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">rx_discards_wep_undecryptable</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">rx_message_in_msg_fragments</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">rx_message_in_bad_msg_fragments</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">hfa384x_comm_tallies32</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">tx_unicast_frames</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">tx_multicast_frames</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">tx_fragments</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">tx_unicast_octets</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">tx_multicast_octets</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">tx_deferred_transmissions</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">tx_single_retry_frames</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">tx_multiple_retry_frames</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">tx_retry_limit_exceeded</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">tx_discards</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">rx_unicast_frames</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">rx_multicast_frames</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">rx_fragments</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">rx_unicast_octets</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">rx_multicast_octets</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">rx_fcs_errors</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">rx_discards_no_buffer</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">tx_discards_wrong_sa</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">rx_discards_wep_undecryptable</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">rx_message_in_msg_fragments</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">rx_message_in_bad_msg_fragments</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">hfa384x_scan_result_hdr</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">reserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">scan_reason</span><span class="p">;</span>
<span class="cp">#define HFA384X_SCAN_IN_PROGRESS 0 </span><span class="cm">/* no results available yet */</span><span class="cp"></span>
<span class="cp">#define HFA384X_SCAN_HOST_INITIATED 1</span>
<span class="cp">#define HFA384X_SCAN_FIRMWARE_INITIATED 2</span>
<span class="cp">#define HFA384X_SCAN_INQUIRY_FROM_HOST 3</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cp">#define HFA384X_SCAN_MAX_RESULTS 32</span>

<span class="k">struct</span> <span class="n">hfa384x_scan_result</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">chid</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">anl</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">sl</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bssid</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">__le16</span> <span class="n">beacon_interval</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">capability</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ssid_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ssid</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">sup_rates</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
	<span class="n">__le16</span> <span class="n">rate</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">hfa384x_hostscan_result</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">chid</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">anl</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">sl</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bssid</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">__le16</span> <span class="n">beacon_interval</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">capability</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ssid_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ssid</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">sup_rates</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
	<span class="n">__le16</span> <span class="n">rate</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">atim</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">comm_tallies_sums</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_unicast_frames</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_multicast_frames</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_fragments</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_unicast_octets</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_multicast_octets</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_deferred_transmissions</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_single_retry_frames</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_multiple_retry_frames</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_retry_limit_exceeded</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_discards</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_unicast_frames</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_multicast_frames</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_fragments</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_unicast_octets</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_multicast_octets</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_fcs_errors</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_discards_no_buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_discards_wrong_sa</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_discards_wep_undecryptable</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_message_in_msg_fragments</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_message_in_bad_msg_fragments</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">hfa384x_regs</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">evstat</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">offset0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">offset1</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">swsupport0</span><span class="p">;</span>
<span class="p">};</span>


<span class="cp">#if defined(PRISM2_PCCARD) || defined(PRISM2_PLX)</span>
<span class="cm">/* I/O ports for HFA384X Controller access */</span>
<span class="cp">#define HFA384X_CMD_OFF 0x00</span>
<span class="cp">#define HFA384X_PARAM0_OFF 0x02</span>
<span class="cp">#define HFA384X_PARAM1_OFF 0x04</span>
<span class="cp">#define HFA384X_PARAM2_OFF 0x06</span>
<span class="cp">#define HFA384X_STATUS_OFF 0x08</span>
<span class="cp">#define HFA384X_RESP0_OFF 0x0A</span>
<span class="cp">#define HFA384X_RESP1_OFF 0x0C</span>
<span class="cp">#define HFA384X_RESP2_OFF 0x0E</span>
<span class="cp">#define HFA384X_INFOFID_OFF 0x10</span>
<span class="cp">#define HFA384X_CONTROL_OFF 0x14</span>
<span class="cp">#define HFA384X_SELECT0_OFF 0x18</span>
<span class="cp">#define HFA384X_SELECT1_OFF 0x1A</span>
<span class="cp">#define HFA384X_OFFSET0_OFF 0x1C</span>
<span class="cp">#define HFA384X_OFFSET1_OFF 0x1E</span>
<span class="cp">#define HFA384X_RXFID_OFF 0x20</span>
<span class="cp">#define HFA384X_ALLOCFID_OFF 0x22</span>
<span class="cp">#define HFA384X_TXCOMPLFID_OFF 0x24</span>
<span class="cp">#define HFA384X_SWSUPPORT0_OFF 0x28</span>
<span class="cp">#define HFA384X_SWSUPPORT1_OFF 0x2A</span>
<span class="cp">#define HFA384X_SWSUPPORT2_OFF 0x2C</span>
<span class="cp">#define HFA384X_EVSTAT_OFF 0x30</span>
<span class="cp">#define HFA384X_INTEN_OFF 0x32</span>
<span class="cp">#define HFA384X_EVACK_OFF 0x34</span>
<span class="cp">#define HFA384X_DATA0_OFF 0x36</span>
<span class="cp">#define HFA384X_DATA1_OFF 0x38</span>
<span class="cp">#define HFA384X_AUXPAGE_OFF 0x3A</span>
<span class="cp">#define HFA384X_AUXOFFSET_OFF 0x3C</span>
<span class="cp">#define HFA384X_AUXDATA_OFF 0x3E</span>
<span class="cp">#endif </span><span class="cm">/* PRISM2_PCCARD || PRISM2_PLX */</span><span class="cp"></span>

<span class="cp">#ifdef PRISM2_PCI</span>
<span class="cm">/* Memory addresses for ISL3874 controller access */</span>
<span class="cp">#define HFA384X_CMD_OFF 0x00</span>
<span class="cp">#define HFA384X_PARAM0_OFF 0x04</span>
<span class="cp">#define HFA384X_PARAM1_OFF 0x08</span>
<span class="cp">#define HFA384X_PARAM2_OFF 0x0C</span>
<span class="cp">#define HFA384X_STATUS_OFF 0x10</span>
<span class="cp">#define HFA384X_RESP0_OFF 0x14</span>
<span class="cp">#define HFA384X_RESP1_OFF 0x18</span>
<span class="cp">#define HFA384X_RESP2_OFF 0x1C</span>
<span class="cp">#define HFA384X_INFOFID_OFF 0x20</span>
<span class="cp">#define HFA384X_CONTROL_OFF 0x28</span>
<span class="cp">#define HFA384X_SELECT0_OFF 0x30</span>
<span class="cp">#define HFA384X_SELECT1_OFF 0x34</span>
<span class="cp">#define HFA384X_OFFSET0_OFF 0x38</span>
<span class="cp">#define HFA384X_OFFSET1_OFF 0x3C</span>
<span class="cp">#define HFA384X_RXFID_OFF 0x40</span>
<span class="cp">#define HFA384X_ALLOCFID_OFF 0x44</span>
<span class="cp">#define HFA384X_TXCOMPLFID_OFF 0x48</span>
<span class="cp">#define HFA384X_PCICOR_OFF 0x4C</span>
<span class="cp">#define HFA384X_SWSUPPORT0_OFF 0x50</span>
<span class="cp">#define HFA384X_SWSUPPORT1_OFF 0x54</span>
<span class="cp">#define HFA384X_SWSUPPORT2_OFF 0x58</span>
<span class="cp">#define HFA384X_PCIHCR_OFF 0x5C</span>
<span class="cp">#define HFA384X_EVSTAT_OFF 0x60</span>
<span class="cp">#define HFA384X_INTEN_OFF 0x64</span>
<span class="cp">#define HFA384X_EVACK_OFF 0x68</span>
<span class="cp">#define HFA384X_DATA0_OFF 0x6C</span>
<span class="cp">#define HFA384X_DATA1_OFF 0x70</span>
<span class="cp">#define HFA384X_AUXPAGE_OFF 0x74</span>
<span class="cp">#define HFA384X_AUXOFFSET_OFF 0x78</span>
<span class="cp">#define HFA384X_AUXDATA_OFF 0x7C</span>
<span class="cp">#define HFA384X_PCI_M0_ADDRH_OFF 0x80</span>
<span class="cp">#define HFA384X_PCI_M0_ADDRL_OFF 0x84</span>
<span class="cp">#define HFA384X_PCI_M0_LEN_OFF 0x88</span>
<span class="cp">#define HFA384X_PCI_M0_CTL_OFF 0x8C</span>
<span class="cp">#define HFA384X_PCI_STATUS_OFF 0x98</span>
<span class="cp">#define HFA384X_PCI_M1_ADDRH_OFF 0xA0</span>
<span class="cp">#define HFA384X_PCI_M1_ADDRL_OFF 0xA4</span>
<span class="cp">#define HFA384X_PCI_M1_LEN_OFF 0xA8</span>
<span class="cp">#define HFA384X_PCI_M1_CTL_OFF 0xAC</span>

<span class="cm">/* PCI bus master control bits (these are undocumented; based on guessing and</span>
<span class="cm"> * experimenting..) */</span>
<span class="cp">#define HFA384X_PCI_CTL_FROM_BAP (BIT(5) | BIT(1) | BIT(0))</span>
<span class="cp">#define HFA384X_PCI_CTL_TO_BAP (BIT(5) | BIT(0))</span>

<span class="cp">#endif </span><span class="cm">/* PRISM2_PCI */</span><span class="cp"></span>


<span class="cm">/* Command codes for CMD reg. */</span>
<span class="cp">#define HFA384X_CMDCODE_INIT 0x00</span>
<span class="cp">#define HFA384X_CMDCODE_ENABLE 0x01</span>
<span class="cp">#define HFA384X_CMDCODE_DISABLE 0x02</span>
<span class="cp">#define HFA384X_CMDCODE_ALLOC 0x0A</span>
<span class="cp">#define HFA384X_CMDCODE_TRANSMIT 0x0B</span>
<span class="cp">#define HFA384X_CMDCODE_INQUIRE 0x11</span>
<span class="cp">#define HFA384X_CMDCODE_ACCESS 0x21</span>
<span class="cp">#define HFA384X_CMDCODE_ACCESS_WRITE (0x21 | BIT(8))</span>
<span class="cp">#define HFA384X_CMDCODE_DOWNLOAD 0x22</span>
<span class="cp">#define HFA384X_CMDCODE_READMIF 0x30</span>
<span class="cp">#define HFA384X_CMDCODE_WRITEMIF 0x31</span>
<span class="cp">#define HFA384X_CMDCODE_TEST 0x38</span>

<span class="cp">#define HFA384X_CMDCODE_MASK 0x3F</span>

<span class="cm">/* Test mode operations */</span>
<span class="cp">#define HFA384X_TEST_CHANGE_CHANNEL 0x08</span>
<span class="cp">#define HFA384X_TEST_MONITOR 0x0B</span>
<span class="cp">#define HFA384X_TEST_STOP 0x0F</span>
<span class="cp">#define HFA384X_TEST_CFG_BITS 0x15</span>
<span class="cp">#define HFA384X_TEST_CFG_BIT_ALC BIT(3)</span>

<span class="cp">#define HFA384X_CMD_BUSY BIT(15)</span>

<span class="cp">#define HFA384X_CMD_TX_RECLAIM BIT(8)</span>

<span class="cp">#define HFA384X_OFFSET_ERR BIT(14)</span>
<span class="cp">#define HFA384X_OFFSET_BUSY BIT(15)</span>


<span class="cm">/* ProgMode for download command */</span>
<span class="cp">#define HFA384X_PROGMODE_DISABLE 0</span>
<span class="cp">#define HFA384X_PROGMODE_ENABLE_VOLATILE 1</span>
<span class="cp">#define HFA384X_PROGMODE_ENABLE_NON_VOLATILE 2</span>
<span class="cp">#define HFA384X_PROGMODE_PROGRAM_NON_VOLATILE 3</span>

<span class="cp">#define HFA384X_AUX_MAGIC0 0xfe01</span>
<span class="cp">#define HFA384X_AUX_MAGIC1 0xdc23</span>
<span class="cp">#define HFA384X_AUX_MAGIC2 0xba45</span>

<span class="cp">#define HFA384X_AUX_PORT_DISABLED 0</span>
<span class="cp">#define HFA384X_AUX_PORT_DISABLE BIT(14)</span>
<span class="cp">#define HFA384X_AUX_PORT_ENABLE BIT(15)</span>
<span class="cp">#define HFA384X_AUX_PORT_ENABLED (BIT(14) | BIT(15))</span>
<span class="cp">#define HFA384X_AUX_PORT_MASK (BIT(14) | BIT(15))</span>

<span class="cp">#define PRISM2_PDA_SIZE 1024</span>


<span class="cm">/* Events; EvStat, Interrupt mask (IntEn), and acknowledge bits (EvAck) */</span>
<span class="cp">#define HFA384X_EV_TICK BIT(15)</span>
<span class="cp">#define HFA384X_EV_WTERR BIT(14)</span>
<span class="cp">#define HFA384X_EV_INFDROP BIT(13)</span>
<span class="cp">#ifdef PRISM2_PCI</span>
<span class="cp">#define HFA384X_EV_PCI_M1 BIT(9)</span>
<span class="cp">#define HFA384X_EV_PCI_M0 BIT(8)</span>
<span class="cp">#endif </span><span class="cm">/* PRISM2_PCI */</span><span class="cp"></span>
<span class="cp">#define HFA384X_EV_INFO BIT(7)</span>
<span class="cp">#define HFA384X_EV_DTIM BIT(5)</span>
<span class="cp">#define HFA384X_EV_CMD BIT(4)</span>
<span class="cp">#define HFA384X_EV_ALLOC BIT(3)</span>
<span class="cp">#define HFA384X_EV_TXEXC BIT(2)</span>
<span class="cp">#define HFA384X_EV_TX BIT(1)</span>
<span class="cp">#define HFA384X_EV_RX BIT(0)</span>


<span class="cm">/* HFA384X Information frames */</span>
<span class="cp">#define HFA384X_INFO_HANDOVERADDR 0xF000 </span><span class="cm">/* AP f/w ? */</span><span class="cp"></span>
<span class="cp">#define HFA384X_INFO_HANDOVERDEAUTHADDR 0xF001 </span><span class="cm">/* AP f/w 1.3.7 */</span><span class="cp"></span>
<span class="cp">#define HFA384X_INFO_COMMTALLIES 0xF100</span>
<span class="cp">#define HFA384X_INFO_SCANRESULTS 0xF101</span>
<span class="cp">#define HFA384X_INFO_CHANNELINFORESULTS 0xF102 </span><span class="cm">/* AP f/w only */</span><span class="cp"></span>
<span class="cp">#define HFA384X_INFO_HOSTSCANRESULTS 0xF103</span>
<span class="cp">#define HFA384X_INFO_LINKSTATUS 0xF200</span>
<span class="cp">#define HFA384X_INFO_ASSOCSTATUS 0xF201 </span><span class="cm">/* ? */</span><span class="cp"></span>
<span class="cp">#define HFA384X_INFO_AUTHREQ 0xF202 </span><span class="cm">/* ? */</span><span class="cp"></span>
<span class="cp">#define HFA384X_INFO_PSUSERCNT 0xF203 </span><span class="cm">/* ? */</span><span class="cp"></span>
<span class="cp">#define HFA384X_INFO_KEYIDCHANGED 0xF204 </span><span class="cm">/* ? */</span><span class="cp"></span>

<span class="k">enum</span> <span class="p">{</span> <span class="n">HFA384X_LINKSTATUS_CONNECTED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
       <span class="n">HFA384X_LINKSTATUS_DISCONNECTED</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
       <span class="n">HFA384X_LINKSTATUS_AP_CHANGE</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
       <span class="n">HFA384X_LINKSTATUS_AP_OUT_OF_RANGE</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
       <span class="n">HFA384X_LINKSTATUS_AP_IN_RANGE</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
       <span class="n">HFA384X_LINKSTATUS_ASSOC_FAILED</span> <span class="o">=</span> <span class="mi">6</span> <span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span> <span class="n">HFA384X_PORTTYPE_BSS</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">HFA384X_PORTTYPE_WDS</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
       <span class="n">HFA384X_PORTTYPE_PSEUDO_IBSS</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">HFA384X_PORTTYPE_IBSS</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
       <span class="n">HFA384X_PORTTYPE_HOSTAP</span> <span class="o">=</span> <span class="mi">6</span> <span class="p">};</span>

<span class="cp">#define HFA384X_RATES_1MBPS BIT(0)</span>
<span class="cp">#define HFA384X_RATES_2MBPS BIT(1)</span>
<span class="cp">#define HFA384X_RATES_5MBPS BIT(2)</span>
<span class="cp">#define HFA384X_RATES_11MBPS BIT(3)</span>

<span class="cp">#define HFA384X_ROAMING_FIRMWARE 1</span>
<span class="cp">#define HFA384X_ROAMING_HOST 2</span>
<span class="cp">#define HFA384X_ROAMING_DISABLED 3</span>

<span class="cp">#define HFA384X_WEPFLAGS_PRIVACYINVOKED BIT(0)</span>
<span class="cp">#define HFA384X_WEPFLAGS_EXCLUDEUNENCRYPTED BIT(1)</span>
<span class="cp">#define HFA384X_WEPFLAGS_HOSTENCRYPT BIT(4)</span>
<span class="cp">#define HFA384X_WEPFLAGS_HOSTDECRYPT BIT(7)</span>

<span class="cp">#define HFA384X_RX_STATUS_MSGTYPE (BIT(15) | BIT(14) | BIT(13))</span>
<span class="cp">#define HFA384X_RX_STATUS_PCF BIT(12)</span>
<span class="cp">#define HFA384X_RX_STATUS_MACPORT (BIT(10) | BIT(9) | BIT(8))</span>
<span class="cp">#define HFA384X_RX_STATUS_UNDECR BIT(1)</span>
<span class="cp">#define HFA384X_RX_STATUS_FCSERR BIT(0)</span>

<span class="cp">#define HFA384X_RX_STATUS_GET_MSGTYPE(s) \</span>
<span class="cp">(((s) &amp; HFA384X_RX_STATUS_MSGTYPE) &gt;&gt; 13)</span>
<span class="cp">#define HFA384X_RX_STATUS_GET_MACPORT(s) \</span>
<span class="cp">(((s) &amp; HFA384X_RX_STATUS_MACPORT) &gt;&gt; 8)</span>

<span class="k">enum</span> <span class="p">{</span> <span class="n">HFA384X_RX_MSGTYPE_NORMAL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">HFA384X_RX_MSGTYPE_RFC1042</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
       <span class="n">HFA384X_RX_MSGTYPE_BRIDGETUNNEL</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">HFA384X_RX_MSGTYPE_MGMT</span> <span class="o">=</span> <span class="mi">4</span> <span class="p">};</span>


<span class="cp">#define HFA384X_TX_CTRL_ALT_RTRY BIT(5)</span>
<span class="cp">#define HFA384X_TX_CTRL_802_11 BIT(3)</span>
<span class="cp">#define HFA384X_TX_CTRL_802_3 0</span>
<span class="cp">#define HFA384X_TX_CTRL_TX_EX BIT(2)</span>
<span class="cp">#define HFA384X_TX_CTRL_TX_OK BIT(1)</span>

<span class="cp">#define HFA384X_TX_STATUS_RETRYERR BIT(0)</span>
<span class="cp">#define HFA384X_TX_STATUS_AGEDERR BIT(1)</span>
<span class="cp">#define HFA384X_TX_STATUS_DISCON BIT(2)</span>
<span class="cp">#define HFA384X_TX_STATUS_FORMERR BIT(3)</span>

<span class="cm">/* HFA3861/3863 (BBP) Control Registers */</span>
<span class="cp">#define HFA386X_CR_TX_CONFIGURE 0x12 </span><span class="cm">/* CR9 */</span><span class="cp"></span>
<span class="cp">#define HFA386X_CR_RX_CONFIGURE 0x14 </span><span class="cm">/* CR10 */</span><span class="cp"></span>
<span class="cp">#define HFA386X_CR_A_D_TEST_MODES2 0x1A </span><span class="cm">/* CR13 */</span><span class="cp"></span>
<span class="cp">#define HFA386X_CR_MANUAL_TX_POWER 0x3E </span><span class="cm">/* CR31 */</span><span class="cp"></span>
<span class="cp">#define HFA386X_CR_MEASURED_TX_POWER 0x74 </span><span class="cm">/* CR58 */</span><span class="cp"></span>


<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#define PRISM2_TXFID_COUNT 8</span>
<span class="cp">#define PRISM2_DATA_MAXLEN 2304</span>
<span class="cp">#define PRISM2_TXFID_LEN (PRISM2_DATA_MAXLEN + sizeof(struct hfa384x_tx_frame))</span>
<span class="cp">#define PRISM2_TXFID_EMPTY 0xffff</span>
<span class="cp">#define PRISM2_TXFID_RESERVED 0xfffe</span>
<span class="cp">#define PRISM2_DUMMY_FID 0xffff</span>
<span class="cp">#define MAX_SSID_LEN 32</span>
<span class="cp">#define MAX_NAME_LEN 32 </span><span class="cm">/* this is assumed to be equal to MAX_SSID_LEN */</span><span class="cp"></span>

<span class="cp">#define PRISM2_DUMP_RX_HDR BIT(0)</span>
<span class="cp">#define PRISM2_DUMP_TX_HDR BIT(1)</span>
<span class="cp">#define PRISM2_DUMP_TXEXC_HDR BIT(2)</span>

<span class="k">struct</span> <span class="n">hostap_tx_callback_info</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">idx</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ok</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hostap_tx_callback_info</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/* IEEE 802.11 requires that STA supports concurrent reception of at least</span>
<span class="cm"> * three fragmented frames. This define can be increased to support more</span>
<span class="cm"> * concurrent frames, but it should be noted that each entry can consume about</span>
<span class="cm"> * 2 kB of RAM and increasing cache size will slow down frame reassembly. */</span>
<span class="cp">#define PRISM2_FRAG_CACHE_LEN 4</span>

<span class="k">struct</span> <span class="n">prism2_frag_entry</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">first_frag_time</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">last_frag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">src_addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">dst_addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">hostap_cmd_queue</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">compl</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">CMD_SLEEP</span><span class="p">,</span> <span class="n">CMD_CALLBACK</span><span class="p">,</span> <span class="n">CMD_COMPLETED</span> <span class="p">}</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">long</span> <span class="n">context</span><span class="p">,</span> <span class="n">u16</span> <span class="n">resp0</span><span class="p">,</span>
			 <span class="n">u16</span> <span class="n">res</span><span class="p">);</span>
	<span class="kt">long</span> <span class="n">context</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">param0</span><span class="p">,</span> <span class="n">param1</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">resp0</span><span class="p">,</span> <span class="n">res</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="kt">int</span> <span class="n">issued</span><span class="p">,</span> <span class="n">issuing</span><span class="p">;</span>

	<span class="n">atomic_t</span> <span class="n">usecnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">del_req</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* options for hw_shutdown */</span>
<span class="cp">#define HOSTAP_HW_NO_DISABLE BIT(0)</span>
<span class="cp">#define HOSTAP_HW_ENABLE_CMDCOMPL BIT(1)</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">local_info</span> <span class="n">local_info_t</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">prism2_helper_functions</span> <span class="p">{</span>
	<span class="cm">/* these functions are defined in hardware model specific files</span>
<span class="cm">	 * (hostap_{cs,plx,pci}.c */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">card_present</span><span class="p">)(</span><span class="n">local_info_t</span> <span class="o">*</span><span class="n">local</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cor_sreset</span><span class="p">)(</span><span class="n">local_info_t</span> <span class="o">*</span><span class="n">local</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">genesis_reset</span><span class="p">)(</span><span class="n">local_info_t</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hcr</span><span class="p">);</span>

	<span class="cm">/* the following functions are from hostap_hw.c, but they may have some</span>
<span class="cm">	 * hardware model specific code */</span>

	<span class="cm">/* FIX: low-level commands like cmd might disappear at some point to</span>
<span class="cm">	 * make it easier to change them if needed (e.g., cmd would be replaced</span>
<span class="cm">	 * with write_mif/read_mif/testcmd/inquire); at least get_rid and</span>
<span class="cm">	 * set_rid might move to hostap_{cs,plx,pci}.c */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">u16</span> <span class="n">param0</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">param1</span><span class="p">,</span>
		   <span class="n">u16</span> <span class="o">*</span><span class="n">resp0</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">read_regs</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hfa384x_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_rid</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">rid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">exact_len</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_rid</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">rid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">hw_enable</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">initial</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">hw_config</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">initial</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">hw_reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">hw_shutdown</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">no_disable</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">reset_port</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">schedule_reset</span><span class="p">)(</span><span class="n">local_info_t</span> <span class="o">*</span><span class="n">local</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">download</span><span class="p">)(</span><span class="n">local_info_t</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">prism2_download_param</span> <span class="o">*</span><span class="n">param</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">tx</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_tim</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">aid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_aux</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			<span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">need_tx_headroom</span><span class="p">;</span> <span class="cm">/* number of bytes of headroom needed before</span>
<span class="cm">			       * IEEE 802.11 header */</span>
	<span class="k">enum</span> <span class="p">{</span> <span class="n">HOSTAP_HW_PCCARD</span><span class="p">,</span> <span class="n">HOSTAP_HW_PLX</span><span class="p">,</span> <span class="n">HOSTAP_HW_PCI</span> <span class="p">}</span> <span class="n">hw_type</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">prism2_download_data</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">dl_cmd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">start_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num_areas</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">prism2_download_data_area</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">addr</span><span class="p">;</span> <span class="cm">/* wlan card address */</span>
		<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span> <span class="cm">/* allocated data */</span>
	<span class="p">}</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>


<span class="cp">#define HOSTAP_MAX_BSS_COUNT 64</span>
<span class="cp">#define MAX_WPA_IE_LEN 64</span>

<span class="k">struct</span> <span class="n">hostap_bss_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_update</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bssid</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">u16</span> <span class="n">capab_info</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ssid</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">size_t</span> <span class="n">ssid_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">wpa_ie</span><span class="p">[</span><span class="n">MAX_WPA_IE_LEN</span><span class="p">];</span>
	<span class="kt">size_t</span> <span class="n">wpa_ie_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">rsn_ie</span><span class="p">[</span><span class="n">MAX_WPA_IE_LEN</span><span class="p">];</span>
	<span class="kt">size_t</span> <span class="n">rsn_ie_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chan</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">included</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/* Per radio private Host AP data - shared by all net devices interfaces used</span>
<span class="cm"> * by each radio (wlan#, wlan#ap, wlan#sta, WDS).</span>
<span class="cm"> * ((struct hostap_interface *) netdev_priv(dev))-&gt;local points to this</span>
<span class="cm"> * structure. */</span>
<span class="k">struct</span> <span class="n">local_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">hw_module</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">card_idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dev_enabled</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">master_dev_auto_open</span><span class="p">;</span> <span class="cm">/* was master device opened automatically */</span>
	<span class="kt">int</span> <span class="n">num_dev_open</span><span class="p">;</span> <span class="cm">/* number of open devices */</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span> <span class="cm">/* master radio device */</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ddev</span><span class="p">;</span> <span class="cm">/* main data device */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">hostap_interfaces</span><span class="p">;</span> <span class="cm">/* Host AP interface list (contains</span>
<span class="cm">					     * struct hostap_interface entries)</span>
<span class="cm">					     */</span>
	<span class="n">rwlock_t</span> <span class="n">iface_lock</span><span class="p">;</span> <span class="cm">/* hostap_interfaces read lock; use write lock</span>
<span class="cm">			      * when removing entries from the list.</span>
<span class="cm">			      * TX and RX paths can use read lock. */</span>
	<span class="n">spinlock_t</span> <span class="n">cmdlock</span><span class="p">,</span> <span class="n">baplock</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">irq_init_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">rid_bap_mtx</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">infofid</span><span class="p">;</span> <span class="cm">/* MAC buffer id for info frame */</span>
	<span class="cm">/* txfid, intransmitfid, next_txtid, and next_alloc are protected by</span>
<span class="cm">	 * txfidlock */</span>
	<span class="n">spinlock_t</span> <span class="n">txfidlock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">txfid_len</span><span class="p">;</span> <span class="cm">/* length of allocated TX buffers */</span>
	<span class="n">u16</span> <span class="n">txfid</span><span class="p">[</span><span class="n">PRISM2_TXFID_COUNT</span><span class="p">];</span> <span class="cm">/* buffer IDs for TX frames */</span>
	<span class="cm">/* buffer IDs for intransmit frames or PRISM2_TXFID_EMPTY if</span>
<span class="cm">	 * corresponding txfid is free for next TX frame */</span>
	<span class="n">u16</span> <span class="n">intransmitfid</span><span class="p">[</span><span class="n">PRISM2_TXFID_COUNT</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">next_txfid</span><span class="p">;</span> <span class="cm">/* index to the next txfid to be checked for</span>
<span class="cm">			 * availability */</span>
	<span class="kt">int</span> <span class="n">next_alloc</span><span class="p">;</span> <span class="cm">/* index to the next intransmitfid to be checked for</span>
<span class="cm">			 * allocation events */</span>

	<span class="cm">/* bitfield for atomic bitops */</span>
<span class="cp">#define HOSTAP_BITS_TRANSMIT 0</span>
<span class="cp">#define HOSTAP_BITS_BAP_TASKLET 1</span>
<span class="cp">#define HOSTAP_BITS_BAP_TASKLET2 2</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bits</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ap_data</span> <span class="o">*</span><span class="n">ap</span><span class="p">;</span>

	<span class="kt">char</span> <span class="n">essid</span><span class="p">[</span><span class="n">MAX_SSID_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">MAX_NAME_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">name_set</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">channel_mask</span><span class="p">;</span> <span class="cm">/* mask of allowed channels */</span>
	<span class="n">u16</span> <span class="n">scan_channel_mask</span><span class="p">;</span> <span class="cm">/* mask of channels to be scanned */</span>
	<span class="k">struct</span> <span class="n">comm_tallies_sums</span> <span class="n">comm_tallies</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">proc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iw_mode</span><span class="p">;</span> <span class="cm">/* operating mode (IW_MODE_*) */</span>
	<span class="kt">int</span> <span class="n">pseudo_adhoc</span><span class="p">;</span> <span class="cm">/* 0: IW_MODE_ADHOC is real 802.11 compliant IBSS</span>
<span class="cm">			   * 1: IW_MODE_ADHOC is &quot;pseudo IBSS&quot; */</span>
	<span class="kt">char</span> <span class="n">bssid</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">channel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">beacon_int</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dtim_period</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mtu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">frame_dump</span><span class="p">;</span> <span class="cm">/* dump RX/TX frame headers, PRISM2_DUMP_ flags */</span>
	<span class="kt">int</span> <span class="n">fw_tx_rate_control</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tx_rate_control</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">basic_rates</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hw_resetting</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hw_ready</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hw_reset_tries</span><span class="p">;</span> <span class="cm">/* how many times reset has been tried */</span>
	<span class="kt">int</span> <span class="n">hw_downloading</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">shutdown</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pri_only</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">no_pri</span><span class="p">;</span> <span class="cm">/* no PRI f/w present */</span>
	<span class="kt">int</span> <span class="n">sram_type</span><span class="p">;</span> <span class="cm">/* 8 = x8 SRAM, 16 = x16 SRAM, -1 = unknown */</span>

	<span class="k">enum</span> <span class="p">{</span>
		<span class="n">PRISM2_TXPOWER_AUTO</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PRISM2_TXPOWER_OFF</span><span class="p">,</span>
		<span class="n">PRISM2_TXPOWER_FIXED</span><span class="p">,</span> <span class="n">PRISM2_TXPOWER_UNKNOWN</span>
	<span class="p">}</span> <span class="n">txpower_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">txpower</span><span class="p">;</span> <span class="cm">/* if txpower_type == PRISM2_TXPOWER_FIXED */</span>

	<span class="cm">/* command queue for hfa384x_cmd(); protected with cmdlock */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">cmd_queue</span><span class="p">;</span>
	<span class="cm">/* max_len for cmd_queue; in addition, cmd_callback can use two</span>
<span class="cm">	 * additional entries to prevent sleeping commands from stopping</span>
<span class="cm">	 * transmits */</span>
<span class="cp">#define HOSTAP_CMD_QUEUE_MAX_LEN 16</span>
	<span class="kt">int</span> <span class="n">cmd_queue_len</span><span class="p">;</span> <span class="cm">/* number of entries in cmd_queue */</span>

	<span class="cm">/* if card timeout is detected in interrupt context, reset_queue is</span>
<span class="cm">	 * used to schedule card reseting to be done in user context */</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">reset_queue</span><span class="p">;</span>

	<span class="cm">/* For scheduling a change of the promiscuous mode RID */</span>
	<span class="kt">int</span> <span class="n">is_promisc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">set_multicast_list_queue</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">set_tim_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">set_tim_list</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">set_tim_lock</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">wds_max_connections</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wds_connections</span><span class="p">;</span>
<span class="cp">#define HOSTAP_WDS_BROADCAST_RA BIT(0)</span>
<span class="cp">#define HOSTAP_WDS_AP_CLIENT BIT(1)</span>
<span class="cp">#define HOSTAP_WDS_STANDARD_FRAME BIT(2)</span>
	<span class="n">u32</span> <span class="n">wds_type</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tx_control</span><span class="p">;</span> <span class="cm">/* flags to be used in TX description */</span>
	<span class="kt">int</span> <span class="n">manual_retry_count</span><span class="p">;</span> <span class="cm">/* -1 = use f/w default; otherwise retry count</span>
<span class="cm">				 * to be used with all frames */</span>

	<span class="k">struct</span> <span class="n">iw_statistics</span> <span class="n">wstats</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">scan_timestamp</span><span class="p">;</span> <span class="cm">/* Time started to scan */</span>
	<span class="k">enum</span> <span class="p">{</span>
		<span class="n">PRISM2_MONITOR_80211</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PRISM2_MONITOR_PRISM</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="n">PRISM2_MONITOR_CAPHDR</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">PRISM2_MONITOR_RADIOTAP</span> <span class="o">=</span> <span class="mi">3</span>
	<span class="p">}</span> <span class="n">monitor_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">monitor_allow_fcserr</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">hostapd</span><span class="p">;</span> <span class="cm">/* whether user space daemon, hostapd, is used for AP</span>
<span class="cm">		      * management */</span>
	<span class="kt">int</span> <span class="n">hostapd_sta</span><span class="p">;</span> <span class="cm">/* whether hostapd is used with an extra STA interface</span>
<span class="cm">			  */</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">apdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device_stats</span> <span class="n">apdevstats</span><span class="p">;</span>

	<span class="kt">char</span> <span class="n">assoc_ap_addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">stadev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device_stats</span> <span class="n">stadevstats</span><span class="p">;</span>

<span class="cp">#define WEP_KEYS 4</span>
<span class="cp">#define WEP_KEY_LEN 13</span>
	<span class="k">struct</span> <span class="n">lib80211_crypt_info</span> <span class="n">crypt_info</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">open_wep</span><span class="p">;</span> <span class="cm">/* allow unencrypted frames */</span>
	<span class="kt">int</span> <span class="n">host_encrypt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">host_decrypt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">privacy_invoked</span><span class="p">;</span> <span class="cm">/* force privacy invoked flag even if no keys are</span>
<span class="cm">			      * configured */</span>
	<span class="kt">int</span> <span class="n">fw_encrypt_ok</span><span class="p">;</span> <span class="cm">/* whether firmware-based WEP encrypt is working</span>
<span class="cm">			    * in Host AP mode (STA f/w 1.4.9 or newer) */</span>
	<span class="kt">int</span> <span class="n">bcrx_sta_key</span><span class="p">;</span> <span class="cm">/* use individual keys to override default keys even</span>
<span class="cm">			   * with RX of broad/multicast frames */</span>

	<span class="k">struct</span> <span class="n">prism2_frag_entry</span> <span class="n">frag_cache</span><span class="p">[</span><span class="n">PRISM2_FRAG_CACHE_LEN</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frag_next_idx</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">ieee_802_1x</span><span class="p">;</span> <span class="cm">/* is IEEE 802.1X used */</span>

	<span class="kt">int</span> <span class="n">antsel_tx</span><span class="p">,</span> <span class="n">antsel_rx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rts_threshold</span><span class="p">;</span> <span class="cm">/* dot11RTSThreshold */</span>
	<span class="kt">int</span> <span class="n">fragm_threshold</span><span class="p">;</span> <span class="cm">/* dot11FragmentationThreshold */</span>
	<span class="kt">int</span> <span class="n">auth_algs</span><span class="p">;</span> <span class="cm">/* PRISM2_AUTH_ flags */</span>

	<span class="kt">int</span> <span class="n">enh_sec</span><span class="p">;</span> <span class="cm">/* cnfEnhSecurity options (broadcast SSID hide/ignore) */</span>
	<span class="kt">int</span> <span class="n">tallies32</span><span class="p">;</span> <span class="cm">/* 32-bit tallies in use */</span>

	<span class="k">struct</span> <span class="n">prism2_helper_functions</span> <span class="o">*</span><span class="n">func</span><span class="p">;</span>

	<span class="n">u8</span> <span class="o">*</span><span class="n">pda</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fw_ap</span><span class="p">;</span>
<span class="cp">#define PRISM2_FW_VER(major, minor, variant) \</span>
<span class="cp">(((major) &lt;&lt; 16) | ((minor) &lt;&lt; 8) | variant)</span>
	<span class="n">u32</span> <span class="n">sta_fw_ver</span><span class="p">;</span>

	<span class="cm">/* Tasklets for handling hardware IRQ related operations outside hw IRQ</span>
<span class="cm">	 * handler */</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">bap_tasklet</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">info_tasklet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">info_list</span><span class="p">;</span> <span class="cm">/* info frames as skb&#39;s for</span>
<span class="cm">					* info_tasklet */</span>

	<span class="k">struct</span> <span class="n">hostap_tx_callback_info</span> <span class="o">*</span><span class="n">tx_callback</span><span class="p">;</span> <span class="cm">/* registered TX callbacks</span>
<span class="cm">						      */</span>

	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">rx_tasklet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">rx_list</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">sta_tx_exc_tasklet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">sta_tx_exc_list</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">host_roaming</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_join_time</span><span class="p">;</span> <span class="cm">/* time of last JoinRequest */</span>
	<span class="k">struct</span> <span class="n">hfa384x_hostscan_result</span> <span class="o">*</span><span class="n">last_scan_results</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_scan_results_count</span><span class="p">;</span>
	<span class="k">enum</span> <span class="p">{</span> <span class="n">PRISM2_SCAN</span><span class="p">,</span> <span class="n">PRISM2_HOSTSCAN</span> <span class="p">}</span> <span class="n">last_scan_type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">info_queue</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pending_info</span><span class="p">;</span> <span class="cm">/* bit field of pending info_queue items */</span>
<span class="cp">#define PRISM2_INFO_PENDING_LINKSTATUS 0</span>
<span class="cp">#define PRISM2_INFO_PENDING_SCANRESULTS 1</span>
	<span class="kt">int</span> <span class="n">prev_link_status</span><span class="p">;</span> <span class="cm">/* previous received LinkStatus info */</span>
	<span class="kt">int</span> <span class="n">prev_linkstatus_connected</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">preferred_ap</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span> <span class="cm">/* use this AP if possible */</span>

<span class="cp">#ifdef PRISM2_CALLBACK</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">callback_data</span><span class="p">;</span> <span class="cm">/* Can be used in callbacks; e.g., allocate</span>
<span class="cm">			      * on enable event and free on disable event.</span>
<span class="cm">			      * Host AP driver code does not touch this. */</span>
<span class="cp">#endif </span><span class="cm">/* PRISM2_CALLBACK */</span><span class="cp"></span>

	<span class="n">wait_queue_head_t</span> <span class="n">hostscan_wq</span><span class="p">;</span>

	<span class="cm">/* Passive scan in Host AP mode */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">passive_scan_timer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">passive_scan_interval</span><span class="p">;</span> <span class="cm">/* in seconds, 0 = disabled */</span>
	<span class="kt">int</span> <span class="n">passive_scan_channel</span><span class="p">;</span>
	<span class="k">enum</span> <span class="p">{</span> <span class="n">PASSIVE_SCAN_WAIT</span><span class="p">,</span> <span class="n">PASSIVE_SCAN_LISTEN</span> <span class="p">}</span> <span class="n">passive_scan_state</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">tick_timer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_tick_timer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sw_tick_stuck</span><span class="p">;</span>

	<span class="cm">/* commsQuality / dBmCommsQuality data from periodic polling; only</span>
<span class="cm">	 * valid for Managed and Ad-hoc modes */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_comms_qual_update</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">comms_qual</span><span class="p">;</span> <span class="cm">/* in some odd unit.. */</span>
	<span class="kt">int</span> <span class="n">avg_signal</span><span class="p">;</span> <span class="cm">/* in dB (note: negative) */</span>
	<span class="kt">int</span> <span class="n">avg_noise</span><span class="p">;</span> <span class="cm">/* in dB (note: negative) */</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">comms_qual_update</span><span class="p">;</span>

	<span class="cm">/* RSSI to dBm adjustment (for RX descriptor fields) */</span>
	<span class="kt">int</span> <span class="n">rssi_to_dBm</span><span class="p">;</span> <span class="cm">/* subtract from RSSI to get approximate dBm value */</span>

	<span class="cm">/* BSS list / protected by local-&gt;lock */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">bss_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_bss_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wpa</span><span class="p">;</span> <span class="cm">/* WPA support enabled */</span>
	<span class="kt">int</span> <span class="n">tkip_countermeasures</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">drop_unencrypted</span><span class="p">;</span>
	<span class="cm">/* Generic IEEE 802.11 info element to be added to</span>
<span class="cm">	 * ProbeResp/Beacon/(Re)AssocReq */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">generic_elem</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">generic_elem_len</span><span class="p">;</span>

<span class="cp">#ifdef PRISM2_DOWNLOAD_SUPPORT</span>
	<span class="cm">/* Persistent volatile download data */</span>
	<span class="k">struct</span> <span class="n">prism2_download_data</span> <span class="o">*</span><span class="n">dl_pri</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">prism2_download_data</span> <span class="o">*</span><span class="n">dl_sec</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* PRISM2_DOWNLOAD_SUPPORT */</span><span class="cp"></span>

<span class="cp">#ifdef PRISM2_IO_DEBUG</span>
<span class="cp">#define PRISM2_IO_DEBUG_SIZE 10000</span>
	<span class="n">u32</span> <span class="n">io_debug</span><span class="p">[</span><span class="n">PRISM2_IO_DEBUG_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">io_debug_head</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">io_debug_enabled</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* PRISM2_IO_DEBUG */</span><span class="cp"></span>

	<span class="cm">/* Pointer to hardware model specific (cs,pci,plx) private data. */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">hw_priv</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/* Per interface private Host AP data</span>
<span class="cm"> * Allocated for each net device that Host AP uses (wlan#, wlan#ap, wlan#sta,</span>
<span class="cm"> * WDS) and netdev_priv(dev) points to this structure. */</span>
<span class="k">struct</span> <span class="n">hostap_interface</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span> <span class="cm">/* list entry in Host AP interface list */</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span> <span class="cm">/* pointer to this device */</span>
	<span class="k">struct</span> <span class="n">local_info</span> <span class="o">*</span><span class="n">local</span><span class="p">;</span> <span class="cm">/* pointer to shared private data */</span>
	<span class="k">struct</span> <span class="n">net_device_stats</span> <span class="n">stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iw_spy_data</span> <span class="n">spy_data</span><span class="p">;</span> <span class="cm">/* iwspy support */</span>
	<span class="k">struct</span> <span class="n">iw_public_data</span> <span class="n">wireless_data</span><span class="p">;</span>

	<span class="k">enum</span> <span class="p">{</span>
		<span class="n">HOSTAP_INTERFACE_MASTER</span><span class="p">,</span>
		<span class="n">HOSTAP_INTERFACE_MAIN</span><span class="p">,</span>
		<span class="n">HOSTAP_INTERFACE_AP</span><span class="p">,</span>
		<span class="n">HOSTAP_INTERFACE_STA</span><span class="p">,</span>
		<span class="n">HOSTAP_INTERFACE_WDS</span><span class="p">,</span>
	<span class="p">}</span> <span class="n">type</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hostap_interface_wds</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">remote_addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
		<span class="p">}</span> <span class="n">wds</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
<span class="p">};</span>


<span class="cp">#define HOSTAP_SKB_TX_DATA_MAGIC 0xf08a36a2</span>

<span class="cm">/*</span>
<span class="cm"> * TX meta data - stored in skb-&gt;cb buffer, so this must not be increased over</span>
<span class="cm"> * the 48-byte limit.</span>
<span class="cm"> * THE PADDING THIS STARTS WITH IS A HORRIBLE HACK THAT SHOULD NOT LIVE</span>
<span class="cm"> * TO SEE THE DAY.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">hostap_skb_tx_data</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__padding_for_default_qdiscs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">magic</span><span class="p">;</span> <span class="cm">/* HOSTAP_SKB_TX_DATA_MAGIC */</span>
	<span class="n">u8</span> <span class="n">rate</span><span class="p">;</span> <span class="cm">/* transmit rate */</span>
<span class="cp">#define HOSTAP_TX_FLAGS_WDS BIT(0)</span>
<span class="cp">#define HOSTAP_TX_FLAGS_BUFFERED_FRAME BIT(1)</span>
<span class="cp">#define HOSTAP_TX_FLAGS_ADD_MOREDATA BIT(2)</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* HOSTAP_TX_FLAGS_* */</span>
	<span class="n">u16</span> <span class="n">tx_cb_idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hostap_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">jiffies</span><span class="p">;</span> <span class="cm">/* queueing timestamp */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ethertype</span><span class="p">;</span>
<span class="p">};</span>


<span class="cp">#ifndef PRISM2_NO_DEBUG</span>

<span class="cp">#define DEBUG_FID BIT(0)</span>
<span class="cp">#define DEBUG_PS BIT(1)</span>
<span class="cp">#define DEBUG_FLOW BIT(2)</span>
<span class="cp">#define DEBUG_AP BIT(3)</span>
<span class="cp">#define DEBUG_HW BIT(4)</span>
<span class="cp">#define DEBUG_EXTRA BIT(5)</span>
<span class="cp">#define DEBUG_EXTRA2 BIT(6)</span>
<span class="cp">#define DEBUG_PS2 BIT(7)</span>
<span class="cp">#define DEBUG_MASK (DEBUG_PS | DEBUG_AP | DEBUG_HW | DEBUG_EXTRA)</span>
<span class="cp">#define PDEBUG(n, args...) \</span>
<span class="cp">do { if ((n) &amp; DEBUG_MASK) printk(KERN_DEBUG args); } while (0)</span>
<span class="cp">#define PDEBUG2(n, args...) \</span>
<span class="cp">do { if ((n) &amp; DEBUG_MASK) printk(args); } while (0)</span>

<span class="cp">#else </span><span class="cm">/* PRISM2_NO_DEBUG */</span><span class="cp"></span>

<span class="cp">#define PDEBUG(n, args...)</span>
<span class="cp">#define PDEBUG2(n, args...)</span>

<span class="cp">#endif </span><span class="cm">/* PRISM2_NO_DEBUG */</span><span class="cp"></span>

<span class="k">enum</span> <span class="p">{</span> <span class="n">BAP0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">BAP1</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">};</span>

<span class="cp">#define PRISM2_IO_DEBUG_CMD_INB 0</span>
<span class="cp">#define PRISM2_IO_DEBUG_CMD_INW 1</span>
<span class="cp">#define PRISM2_IO_DEBUG_CMD_INSW 2</span>
<span class="cp">#define PRISM2_IO_DEBUG_CMD_OUTB 3</span>
<span class="cp">#define PRISM2_IO_DEBUG_CMD_OUTW 4</span>
<span class="cp">#define PRISM2_IO_DEBUG_CMD_OUTSW 5</span>
<span class="cp">#define PRISM2_IO_DEBUG_CMD_ERROR 6</span>
<span class="cp">#define PRISM2_IO_DEBUG_CMD_INTERRUPT 7</span>

<span class="cp">#ifdef PRISM2_IO_DEBUG</span>

<span class="cp">#define PRISM2_IO_DEBUG_ENTRY(cmd, reg, value) \</span>
<span class="cp">(((cmd) &lt;&lt; 24) | ((reg) &lt;&lt; 16) | value)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">prism2_io_debug_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hostap_interface</span> <span class="o">*</span><span class="n">iface</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">local_info_t</span> <span class="o">*</span><span class="n">local</span> <span class="o">=</span> <span class="n">iface</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">io_debug_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">local</span><span class="o">-&gt;</span><span class="n">io_debug</span><span class="p">[</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">io_debug_head</span><span class="p">]</span> <span class="o">=</span>	<span class="n">jiffies</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">io_debug_head</span> <span class="o">&gt;=</span> <span class="n">PRISM2_IO_DEBUG_SIZE</span><span class="p">)</span>
		<span class="n">local</span><span class="o">-&gt;</span><span class="n">io_debug_head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">local</span><span class="o">-&gt;</span><span class="n">io_debug</span><span class="p">[</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">io_debug_head</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">PRISM2_IO_DEBUG_ENTRY</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">io_debug_head</span> <span class="o">&gt;=</span> <span class="n">PRISM2_IO_DEBUG_SIZE</span><span class="p">)</span>
		<span class="n">local</span><span class="o">-&gt;</span><span class="n">io_debug_head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">prism2_io_debug_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hostap_interface</span> <span class="o">*</span><span class="n">iface</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">local_info_t</span> <span class="o">*</span><span class="n">local</span> <span class="o">=</span> <span class="n">iface</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">io_debug_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">prism2_io_debug_add</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PRISM2_IO_DEBUG_CMD_ERROR</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">io_debug_enabled</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">local</span><span class="o">-&gt;</span><span class="n">io_debug_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: I/O debug stopped</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* PRISM2_IO_DEBUG */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">prism2_io_debug_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">prism2_io_debug_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* PRISM2_IO_DEBUG */</span><span class="cp"></span>


<span class="cp">#ifdef PRISM2_CALLBACK</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* Called when card is enabled */</span>
	<span class="n">PRISM2_CALLBACK_ENABLE</span><span class="p">,</span>

	<span class="cm">/* Called when card is disabled */</span>
	<span class="n">PRISM2_CALLBACK_DISABLE</span><span class="p">,</span>

	<span class="cm">/* Called when RX/TX starts/ends */</span>
	<span class="n">PRISM2_CALLBACK_RX_START</span><span class="p">,</span> <span class="n">PRISM2_CALLBACK_RX_END</span><span class="p">,</span>
	<span class="n">PRISM2_CALLBACK_TX_START</span><span class="p">,</span> <span class="n">PRISM2_CALLBACK_TX_END</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">prism2_callback</span><span class="p">(</span><span class="n">local_info_t</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span> <span class="kt">int</span> <span class="n">event</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* PRISM2_CALLBACK */</span><span class="cp"></span>
<span class="cp">#define prism2_callback(d, e) do { } while (0)</span>
<span class="cp">#endif </span><span class="cm">/* PRISM2_CALLBACK */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* HOSTAP_WLAN_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
