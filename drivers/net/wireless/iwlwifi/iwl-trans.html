<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › iwlwifi › iwl-trans.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>iwl-trans.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * This file is provided under a dual BSD/GPLv2 license.  When using or</span>
<span class="cm"> * redistributing this file, you may do so under either license.</span>
<span class="cm"> *</span>
<span class="cm"> * GPL LICENSE SUMMARY</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2007 - 2012 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of version 2 of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,</span>
<span class="cm"> * USA</span>
<span class="cm"> *</span>
<span class="cm"> * The full GNU General Public License is included in this distribution</span>
<span class="cm"> * in the file called LICENSE.GPL.</span>
<span class="cm"> *</span>
<span class="cm"> * Contact Information:</span>
<span class="cm"> *  Intel Linux Wireless &lt;ilw@linux.intel.com&gt;</span>
<span class="cm"> * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>
<span class="cm"> *</span>
<span class="cm"> * BSD LICENSE</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2005 - 2012 Intel Corporation. All rights reserved.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> *</span>
<span class="cm"> *  * Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *  * Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer in</span>
<span class="cm"> *    the documentation and/or other materials provided with the</span>
<span class="cm"> *    distribution.</span>
<span class="cm"> *  * Neither the name Intel Corporation nor the names of its</span>
<span class="cm"> *    contributors may be used to endorse or promote products derived</span>
<span class="cm"> *    from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="cm"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="cm"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="cm"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="cm"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>
<span class="cp">#ifndef __iwl_trans_h__</span>
<span class="cp">#define __iwl_trans_h__</span>

<span class="cp">#include &lt;linux/ieee80211.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt; </span><span class="cm">/* for page_address */</span><span class="cp"></span>

<span class="cp">#include &quot;iwl-debug.h&quot;</span>
<span class="cp">#include &quot;iwl-config.h&quot;</span>
<span class="cp">#include &quot;iwl-fw.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: Transport layer - what is it ?</span>
<span class="cm"> *</span>
<span class="cm"> * The tranport layer is the layer that deals with the HW directly. It provides</span>
<span class="cm"> * an abstraction of the underlying HW to the upper layer. The transport layer</span>
<span class="cm"> * doesn&#39;t provide any policy, algorithm or anything of this kind, but only</span>
<span class="cm"> * mechanisms to make the HW do something.It is not completely stateless but</span>
<span class="cm"> * close to it.</span>
<span class="cm"> * We will have an implementation for each different supported bus.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: Life cycle of the transport layer</span>
<span class="cm"> *</span>
<span class="cm"> * The transport layer has a very precise life cycle.</span>
<span class="cm"> *</span>
<span class="cm"> *	1) A helper function is called during the module initialization and</span>
<span class="cm"> *	   registers the bus driver&#39;s ops with the transport&#39;s alloc function.</span>
<span class="cm"> *	2) Bus&#39;s probe calls to the transport layer&#39;s allocation functions.</span>
<span class="cm"> *	   Of course this function is bus specific.</span>
<span class="cm"> *	3) This allocation functions will spawn the upper layer which will</span>
<span class="cm"> *	   register mac80211.</span>
<span class="cm"> *</span>
<span class="cm"> *	4) At some point (i.e. mac80211&#39;s start call), the op_mode will call</span>
<span class="cm"> *	   the following sequence:</span>
<span class="cm"> *	   start_hw</span>
<span class="cm"> *	   start_fw</span>
<span class="cm"> *</span>
<span class="cm"> *	5) Then when finished (or reset):</span>
<span class="cm"> *	   stop_fw (a.k.a. stop device for the moment)</span>
<span class="cm"> *	   stop_hw</span>
<span class="cm"> *</span>
<span class="cm"> *	6) Eventually, the free function will be called.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: Host command section</span>
<span class="cm"> *</span>
<span class="cm"> * A host command is a commaned issued by the upper layer to the fw. There are</span>
<span class="cm"> * several versions of fw that have several APIs. The transport layer is</span>
<span class="cm"> * completely agnostic to these differences.</span>
<span class="cm"> * The transport does provide helper functionnality (i.e. SYNC / ASYNC mode),</span>
<span class="cm"> */</span>
<span class="cp">#define SEQ_TO_SN(seq) (((seq) &amp; IEEE80211_SCTL_SEQ) &gt;&gt; 4)</span>
<span class="cp">#define SN_TO_SEQ(ssn) (((ssn) &lt;&lt; 4) &amp; IEEE80211_SCTL_SEQ)</span>
<span class="cp">#define MAX_SN ((IEEE80211_SCTL_SEQ) &gt;&gt; 4)</span>
<span class="cp">#define SEQ_TO_QUEUE(s)	(((s) &gt;&gt; 8) &amp; 0x1f)</span>
<span class="cp">#define QUEUE_TO_SEQ(q)	(((q) &amp; 0x1f) &lt;&lt; 8)</span>
<span class="cp">#define SEQ_TO_INDEX(s)	((s) &amp; 0xff)</span>
<span class="cp">#define INDEX_TO_SEQ(i)	((i) &amp; 0xff)</span>
<span class="cp">#define SEQ_RX_FRAME	cpu_to_le16(0x8000)</span>

<span class="cm">/**</span>
<span class="cm"> * struct iwl_cmd_header</span>
<span class="cm"> *</span>
<span class="cm"> * This header format appears in the beginning of each command sent from the</span>
<span class="cm"> * driver, and each response/notification received from uCode.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_cmd_header</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">cmd</span><span class="p">;</span>		<span class="cm">/* Command ID:  REPLY_RXON, etc. */</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>	<span class="cm">/* 0:5 reserved, 6 abort, 7 internal */</span>
	<span class="cm">/*</span>
<span class="cm">	 * The driver sets up the sequence number to values of its choosing.</span>
<span class="cm">	 * uCode does not use this value, but passes it back to the driver</span>
<span class="cm">	 * when sending the response to each driver-originated command, so</span>
<span class="cm">	 * the driver can match the response to the command.  Since the values</span>
<span class="cm">	 * don&#39;t get used by uCode, the driver may set up an arbitrary format.</span>
<span class="cm">	 *</span>
<span class="cm">	 * There is one exception:  uCode sets bit 15 when it originates</span>
<span class="cm">	 * the response/notification, i.e. when the response/notification</span>
<span class="cm">	 * is not a direct response to a command sent by the driver.  For</span>
<span class="cm">	 * example, uCode issues REPLY_RX when it sends a received frame</span>
<span class="cm">	 * to the driver; it is not a direct response to any driver command.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The Linux driver uses the following format:</span>
<span class="cm">	 *</span>
<span class="cm">	 *  0:7		tfd index - position within TX queue</span>
<span class="cm">	 *  8:12	TX queue id</span>
<span class="cm">	 *  13:14	reserved</span>
<span class="cm">	 *  15		unsolicited RX or uCode-originated notification</span>
<span class="cm">	 */</span>
	<span class="n">__le16</span> <span class="n">sequence</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>


<span class="cp">#define FH_RSCSR_FRAME_SIZE_MSK		0x00003FFF	</span><span class="cm">/* bits 0-13 */</span><span class="cp"></span>
<span class="cp">#define FH_RSCSR_FRAME_INVALID		0x55550000</span>
<span class="cp">#define FH_RSCSR_FRAME_ALIGN		0x40</span>

<span class="k">struct</span> <span class="n">iwl_rx_packet</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The first 4 bytes of the RX frame header contain both the RX frame</span>
<span class="cm">	 * size and some flags.</span>
<span class="cm">	 * Bit fields:</span>
<span class="cm">	 * 31:    flag flush RB request</span>
<span class="cm">	 * 30:    flag ignore TC (terminal counter) request</span>
<span class="cm">	 * 29:    flag fast IRQ request</span>
<span class="cm">	 * 28-14: Reserved</span>
<span class="cm">	 * 13-00: RX frame size</span>
<span class="cm">	 */</span>
	<span class="n">__le32</span> <span class="n">len_n_flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_cmd_header</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * enum CMD_MODE - how to send the host commands ?</span>
<span class="cm"> *</span>
<span class="cm"> * @CMD_SYNC: The caller will be stalled until the fw responds to the command</span>
<span class="cm"> * @CMD_ASYNC: Return right away and don&#39;t want for the response</span>
<span class="cm"> * @CMD_WANT_SKB: valid only with CMD_SYNC. The caller needs the buffer of the</span>
<span class="cm"> *	response.</span>
<span class="cm"> * @CMD_ON_DEMAND: This command is sent by the test mode pipe.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">CMD_MODE</span> <span class="p">{</span>
	<span class="n">CMD_SYNC</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">CMD_ASYNC</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="n">CMD_WANT_SKB</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
	<span class="n">CMD_ON_DEMAND</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
<span class="p">};</span>

<span class="cp">#define DEF_CMD_PAYLOAD_SIZE 320</span>

<span class="cm">/**</span>
<span class="cm"> * struct iwl_device_cmd</span>
<span class="cm"> *</span>
<span class="cm"> * For allocation of the command and tx queues, this establishes the overall</span>
<span class="cm"> * size of the largest command we send to uCode, except for commands that</span>
<span class="cm"> * aren&#39;t fully copied and use other TFD space.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_device_cmd</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_cmd_header</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* uCode API */</span>
	<span class="n">u8</span> <span class="n">payload</span><span class="p">[</span><span class="n">DEF_CMD_PAYLOAD_SIZE</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cp">#define TFD_MAX_PAYLOAD_SIZE (sizeof(struct iwl_device_cmd))</span>

<span class="cp">#define IWL_MAX_CMD_TFDS	2</span>

<span class="cm">/**</span>
<span class="cm"> * struct iwl_hcmd_dataflag - flag for each one of the chunks of the command</span>
<span class="cm"> *</span>
<span class="cm"> * IWL_HCMD_DFL_NOCOPY: By default, the command is copied to the host command&#39;s</span>
<span class="cm"> *	ring. The transport layer doesn&#39;t map the command&#39;s buffer to DMA, but</span>
<span class="cm"> *	rather copies it to an previously allocated DMA buffer. This flag tells</span>
<span class="cm"> *	the transport layer not to copy the command, but to map the existing</span>
<span class="cm"> *	buffer. This can save memcpy and is worth with very big comamnds.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">iwl_hcmd_dataflag</span> <span class="p">{</span>
	<span class="n">IWL_HCMD_DFL_NOCOPY</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct iwl_host_cmd - Host command to the uCode</span>
<span class="cm"> *</span>
<span class="cm"> * @data: array of chunks that composes the data of the host command</span>
<span class="cm"> * @resp_pkt: response packet, if %CMD_WANT_SKB was set</span>
<span class="cm"> * @_rx_page_order: (internally used to free response packet)</span>
<span class="cm"> * @_rx_page_addr: (internally used to free response packet)</span>
<span class="cm"> * @handler_status: return value of the handler of the command</span>
<span class="cm"> *	(put in setup_rx_handlers) - valid for SYNC mode only</span>
<span class="cm"> * @flags: can be CMD_*</span>
<span class="cm"> * @len: array of the lenths of the chunks in data</span>
<span class="cm"> * @dataflags: IWL_HCMD_DFL_*</span>
<span class="cm"> * @id: id of the host command</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_host_cmd</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">[</span><span class="n">IWL_MAX_CMD_TFDS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">iwl_rx_packet</span> <span class="o">*</span><span class="n">resp_pkt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_rx_page_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">_rx_page_order</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">handler_status</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">len</span><span class="p">[</span><span class="n">IWL_MAX_CMD_TFDS</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">dataflags</span><span class="p">[</span><span class="n">IWL_MAX_CMD_TFDS</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">id</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iwl_free_resp</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_host_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_pages</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">_rx_page_addr</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">_rx_page_order</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">iwl_rx_cmd_buffer</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">_page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">_offset</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">_page_stolen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">truesize</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">rxb_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_rx_cmd_buffer</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">_page</span><span class="p">)</span> <span class="o">+</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">rxb_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_rx_cmd_buffer</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">rxb_steal_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_rx_cmd_buffer</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">_page_stolen</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">get_page</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">_page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_page</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define MAX_NO_RECLAIM_CMDS	6</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum number of HW queues the transport layer</span>
<span class="cm"> * currently supports</span>
<span class="cm"> */</span>
<span class="cp">#define IWL_MAX_HW_QUEUES		32</span>

<span class="cm">/**</span>
<span class="cm"> * struct iwl_trans_config - transport configuration</span>
<span class="cm"> *</span>
<span class="cm"> * @op_mode: pointer to the upper layer.</span>
<span class="cm"> * @queue_to_fifo: queue to FIFO mapping to set up by</span>
<span class="cm"> *	default</span>
<span class="cm"> * @n_queue_to_fifo: number of queues to set up</span>
<span class="cm"> * @cmd_queue: the index of the command queue.</span>
<span class="cm"> *	Must be set before start_fw.</span>
<span class="cm"> * @no_reclaim_cmds: Some devices erroneously don&#39;t set the</span>
<span class="cm"> *	SEQ_RX_FRAME bit on some notifications, this is the</span>
<span class="cm"> *	list of such notifications to filter. Max length is</span>
<span class="cm"> *	%MAX_NO_RECLAIM_CMDS.</span>
<span class="cm"> * @n_no_reclaim_cmds: # of commands in list</span>
<span class="cm"> * @rx_buf_size_8k: 8 kB RX buffer size needed for A-MSDUs,</span>
<span class="cm"> *	if unset 4k will be the RX buffer size</span>
<span class="cm"> * @queue_watchdog_timeout: time (in ms) after which queues</span>
<span class="cm"> *	are considered stuck and will trigger device restart</span>
<span class="cm"> * @command_names: array of command names, must be 256 entries</span>
<span class="cm"> *	(one for each command); for debugging only</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_trans_config</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_op_mode</span> <span class="o">*</span><span class="n">op_mode</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">queue_to_fifo</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">n_queue_to_fifo</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">cmd_queue</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">no_reclaim_cmds</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_no_reclaim_cmds</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">rx_buf_size_8k</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">queue_watchdog_timeout</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">command_names</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">iwl_trans</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct iwl_trans_ops - transport specific operations</span>
<span class="cm"> *</span>
<span class="cm"> * All the handlers MUST be implemented</span>
<span class="cm"> *</span>
<span class="cm"> * @start_hw: starts the HW- from that point on, the HW can send interrupts</span>
<span class="cm"> *	May sleep</span>
<span class="cm"> * @stop_hw: stops the HW- from that point on, the HW will be in low power but</span>
<span class="cm"> *	will still issue interrupt if the HW RF kill is triggered unless</span>
<span class="cm"> *	op_mode_leaving is true.</span>
<span class="cm"> *	May sleep</span>
<span class="cm"> * @start_fw: allocates and inits all the resources for the transport</span>
<span class="cm"> *	layer. Also kick a fw image.</span>
<span class="cm"> *	May sleep</span>
<span class="cm"> * @fw_alive: called when the fw sends alive notification</span>
<span class="cm"> *	May sleep</span>
<span class="cm"> * @stop_device:stops the whole device (embedded CPU put to reset)</span>
<span class="cm"> *	May sleep</span>
<span class="cm"> * @wowlan_suspend: put the device into the correct mode for WoWLAN during</span>
<span class="cm"> *	suspend. This is optional, if not implemented WoWLAN will not be</span>
<span class="cm"> *	supported. This callback may sleep.</span>
<span class="cm"> * @send_cmd:send a host command</span>
<span class="cm"> *	May sleep only if CMD_SYNC is set</span>
<span class="cm"> * @tx: send an skb</span>
<span class="cm"> *	Must be atomic</span>
<span class="cm"> * @reclaim: free packet until ssn. Returns a list of freed packets.</span>
<span class="cm"> *	Must be atomic</span>
<span class="cm"> * @tx_agg_setup: setup a tx queue for AMPDU - will be called once the HW is</span>
<span class="cm"> *	ready and a successful ADDBA response has been received.</span>
<span class="cm"> *	May sleep</span>
<span class="cm"> * @tx_agg_disable: de-configure a Tx queue to send AMPDUs</span>
<span class="cm"> *	Must be atomic</span>
<span class="cm"> * @wait_tx_queue_empty: wait until all tx queues are empty</span>
<span class="cm"> *	May sleep</span>
<span class="cm"> * @dbgfs_register: add the dbgfs files under this directory. Files will be</span>
<span class="cm"> *	automatically deleted.</span>
<span class="cm"> * @suspend: stop the device unless WoWLAN is configured</span>
<span class="cm"> * @resume: resume activity of the device</span>
<span class="cm"> * @write8: write a u8 to a register at offset ofs from the BAR</span>
<span class="cm"> * @write32: write a u32 to a register at offset ofs from the BAR</span>
<span class="cm"> * @read32: read a u32 register at offset ofs from the BAR</span>
<span class="cm"> * @configure: configure parameters required by the transport layer from</span>
<span class="cm"> *	the op_mode. May be called several times before start_fw, can&#39;t be</span>
<span class="cm"> *	called after that.</span>
<span class="cm"> * @set_pmi: set the power pmi state</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_trans_ops</span> <span class="p">{</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">start_hw</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">iwl_trans</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">stop_hw</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">iwl_trans</span><span class="p">,</span> <span class="n">bool</span> <span class="n">op_mode_leaving</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">start_fw</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">fw_img</span> <span class="o">*</span><span class="n">fw</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fw_alive</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">stop_device</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">wowlan_suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">send_cmd</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwl_host_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">tx</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">iwl_device_cmd</span> <span class="o">*</span><span class="n">dev_cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">reclaim</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ssn</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">skbs</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">tx_agg_setup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fifo</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">sta_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">frame_limit</span><span class="p">,</span> <span class="n">u16</span> <span class="n">ssn</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">tx_agg_disable</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">dbgfs_register</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span><span class="o">*</span> <span class="n">dir</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">wait_tx_queue_empty</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PM_SLEEP</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write8</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">u8</span> <span class="n">val</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write32</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">u32</span> <span class="p">(</span><span class="o">*</span><span class="n">read32</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ofs</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">configure</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">iwl_trans_config</span> <span class="o">*</span><span class="n">trans_cfg</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_pmi</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">bool</span> <span class="n">state</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum iwl_trans_state - state of the transport layer</span>
<span class="cm"> *</span>
<span class="cm"> * @IWL_TRANS_NO_FW: no fw has sent an alive response</span>
<span class="cm"> * @IWL_TRANS_FW_ALIVE: a fw has sent an alive response</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">iwl_trans_state</span> <span class="p">{</span>
	<span class="n">IWL_TRANS_NO_FW</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IWL_TRANS_FW_ALIVE</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct iwl_trans - transport common data</span>
<span class="cm"> *</span>
<span class="cm"> * @ops - pointer to iwl_trans_ops</span>
<span class="cm"> * @op_mode - pointer to the op_mode</span>
<span class="cm"> * @cfg - pointer to the configuration</span>
<span class="cm"> * @reg_lock - protect hw register access</span>
<span class="cm"> * @dev - pointer to struct device * that represents the device</span>
<span class="cm"> * @hw_id: a u32 with the ID of the device / subdevice.</span>
<span class="cm"> *	Set during transport allocation.</span>
<span class="cm"> * @hw_id_str: a string with info about HW ID. Set during transport allocation.</span>
<span class="cm"> * @pm_support: set to true in start_hw if link pm is supported</span>
<span class="cm"> * @wait_command_queue: the wait_queue for SYNC host commands</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_trans</span> <span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">iwl_trans_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_op_mode</span> <span class="o">*</span><span class="n">op_mode</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">iwl_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">iwl_trans_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">reg_lock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hw_rev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hw_id</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">hw_id_str</span><span class="p">[</span><span class="mi">52</span><span class="p">];</span>

	<span class="n">bool</span> <span class="n">pm_support</span><span class="p">;</span>

	<span class="n">wait_queue_head_t</span> <span class="n">wait_command_queue</span><span class="p">;</span>

	<span class="cm">/* pointer to trans specific struct */</span>
	<span class="cm">/*Ensure that this pointer will always be aligned to sizeof pointer */</span>
	<span class="kt">char</span> <span class="n">trans_specific</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">__aligned</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iwl_trans_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">iwl_trans_config</span> <span class="o">*</span><span class="n">trans_cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * only set the op_mode for the moment. Later on, this function will do</span>
<span class="cm">	 * more</span>
<span class="cm">	 */</span>
	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">op_mode</span> <span class="o">=</span> <span class="n">trans_cfg</span><span class="o">-&gt;</span><span class="n">op_mode</span><span class="p">;</span>

	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">configure</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">trans_cfg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">iwl_trans_start_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">start_hw</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iwl_trans_stop_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				     <span class="n">bool</span> <span class="n">op_mode_leaving</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">stop_hw</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">op_mode_leaving</span><span class="p">);</span>

	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">IWL_TRANS_NO_FW</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iwl_trans_fw_alive</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">fw_alive</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">IWL_TRANS_FW_ALIVE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">iwl_trans_start_fw</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">fw_img</span> <span class="o">*</span><span class="n">fw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">start_fw</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">fw</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iwl_trans_stop_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">stop_device</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">IWL_TRANS_NO_FW</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iwl_trans_wowlan_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">wowlan_suspend</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">iwl_trans_send_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">iwl_host_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">IWL_TRANS_FW_ALIVE</span><span class="p">,</span>
		  <span class="s">&quot;%s bad state = %d&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">send_cmd</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">iwl_trans_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">iwl_device_cmd</span> <span class="o">*</span><span class="n">dev_cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">IWL_TRANS_FW_ALIVE</span><span class="p">,</span>
		  <span class="s">&quot;%s bad state = %d&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">dev_cmd</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iwl_trans_reclaim</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">ssn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">skbs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">IWL_TRANS_FW_ALIVE</span><span class="p">,</span>
		  <span class="s">&quot;%s bad state = %d&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">reclaim</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">ssn</span><span class="p">,</span> <span class="n">skbs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iwl_trans_tx_agg_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">IWL_TRANS_FW_ALIVE</span><span class="p">,</span>
		  <span class="s">&quot;%s bad state = %d&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">tx_agg_disable</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iwl_trans_tx_agg_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">fifo</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sta_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tid</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">frame_limit</span><span class="p">,</span> <span class="n">u16</span> <span class="n">ssn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">IWL_TRANS_FW_ALIVE</span><span class="p">,</span>
		  <span class="s">&quot;%s bad state = %d&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">tx_agg_setup</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">fifo</span><span class="p">,</span> <span class="n">sta_id</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span>
				 <span class="n">frame_limit</span><span class="p">,</span> <span class="n">ssn</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">iwl_trans_wait_tx_queue_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">IWL_TRANS_FW_ALIVE</span><span class="p">,</span>
		  <span class="s">&quot;%s bad state = %d&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">wait_tx_queue_empty</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">iwl_trans_dbgfs_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">dbgfs_register</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM_SLEEP</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">iwl_trans_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">iwl_trans_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iwl_trans_write8</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">u8</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write8</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iwl_trans_write32</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">iwl_trans_read32</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ofs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">read32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">ofs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iwl_trans_set_pmi</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">bool</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_pmi</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*****************************************************</span>
<span class="cm">* driver (transport) register/unregister functions</span>
<span class="cm">******************************************************/</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">iwl_pci_register_driver</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">iwl_pci_unregister_driver</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __iwl_trans_h__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
