<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › iwlwifi › iwl-trans-pcie.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>iwl-trans-pcie.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * This file is provided under a dual BSD/GPLv2 license.  When using or</span>
<span class="cm"> * redistributing this file, you may do so under either license.</span>
<span class="cm"> *</span>
<span class="cm"> * GPL LICENSE SUMMARY</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2007 - 2012 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of version 2 of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,</span>
<span class="cm"> * USA</span>
<span class="cm"> *</span>
<span class="cm"> * The full GNU General Public License is included in this distribution</span>
<span class="cm"> * in the file called LICENSE.GPL.</span>
<span class="cm"> *</span>
<span class="cm"> * Contact Information:</span>
<span class="cm"> *  Intel Linux Wireless &lt;ilw@linux.intel.com&gt;</span>
<span class="cm"> * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>
<span class="cm"> *</span>
<span class="cm"> * BSD LICENSE</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2005 - 2012 Intel Corporation. All rights reserved.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> *</span>
<span class="cm"> *  * Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *  * Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer in</span>
<span class="cm"> *    the documentation and/or other materials provided with the</span>
<span class="cm"> *    distribution.</span>
<span class="cm"> *  * Neither the name Intel Corporation nor the names of its</span>
<span class="cm"> *    contributors may be used to endorse or promote products derived</span>
<span class="cm"> *    from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="cm"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="cm"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="cm"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="cm"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/pci-aspm.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>

<span class="cp">#include &quot;iwl-drv.h&quot;</span>
<span class="cp">#include &quot;iwl-trans.h&quot;</span>
<span class="cp">#include &quot;iwl-trans-pcie-int.h&quot;</span>
<span class="cp">#include &quot;iwl-csr.h&quot;</span>
<span class="cp">#include &quot;iwl-prph.h&quot;</span>
<span class="cp">#include &quot;iwl-eeprom.h&quot;</span>
<span class="cp">#include &quot;iwl-agn-hw.h&quot;</span>
<span class="cm">/* FIXME: need to abstract out TX command (once we know what it looks like) */</span>
<span class="cp">#include &quot;iwl-commands.h&quot;</span>

<span class="cp">#define IWL_MASK(lo, hi) ((1 &lt;&lt; (hi)) | ((1 &lt;&lt; (hi)) - (1 &lt;&lt; (lo))))</span>

<span class="cp">#define SCD_QUEUECHAIN_SEL_ALL(trans, trans_pcie)	\</span>
<span class="cp">	(((1&lt;&lt;trans-&gt;cfg-&gt;base_params-&gt;num_of_queues) - 1) &amp;\</span>
<span class="cp">	(~(1&lt;&lt;(trans_pcie)-&gt;cmd_queue)))</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_trans_rx_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span>
		<span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_rx_queue</span> <span class="o">*</span><span class="n">rxq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">rxq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">rxq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">rxq</span><span class="p">));</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">bd</span> <span class="o">||</span> <span class="n">rxq</span><span class="o">-&gt;</span><span class="n">rb_stts</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Allocate the circular buffer of Read Buffer Descriptors (RBDs) */</span>
	<span class="n">rxq</span><span class="o">-&gt;</span><span class="n">bd</span> <span class="o">=</span> <span class="n">dma_zalloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__le32</span><span class="p">)</span> <span class="o">*</span> <span class="n">RX_QUEUE_SIZE</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">bd_dma</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">bd</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_bd</span><span class="p">;</span>

	<span class="cm">/*Allocate the driver&#39;s pointer to receive buffer status */</span>
	<span class="n">rxq</span><span class="o">-&gt;</span><span class="n">rb_stts</span> <span class="o">=</span> <span class="n">dma_zalloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">rb_stts</span><span class="p">),</span>
					   <span class="o">&amp;</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">rb_stts_dma</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">rb_stts</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_rb_stts</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_rb_stts:</span>
	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__le32</span><span class="p">)</span> <span class="o">*</span> <span class="n">RX_QUEUE_SIZE</span><span class="p">,</span>
			<span class="n">rxq</span><span class="o">-&gt;</span><span class="n">bd</span><span class="p">,</span> <span class="n">rxq</span><span class="o">-&gt;</span><span class="n">bd_dma</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">bd_dma</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">bd_dma</span><span class="p">));</span>
	<span class="n">rxq</span><span class="o">-&gt;</span><span class="n">bd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">err_bd:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwl_trans_rxq_free_rx_bufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span>
		<span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_rx_queue</span> <span class="o">*</span><span class="n">rxq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">rxq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Fill the rx_used queue with _all_ of the Rx buffers */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RX_FREE_BUFFERS</span> <span class="o">+</span> <span class="n">RX_QUEUE_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* In the reset function, these buffers may have been allocated</span>
<span class="cm">		 * to an SKB, so we need to unmap and free potential storage */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">page</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dma_unmap_page</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">rxq</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">page_dma</span><span class="p">,</span>
				<span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">rx_page_order</span><span class="p">,</span>
				<span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
			<span class="n">__free_pages</span><span class="p">(</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">page</span><span class="p">,</span>
				     <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">rx_page_order</span><span class="p">);</span>
			<span class="n">rxq</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">rx_used</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwl_trans_rx_hw_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">iwl_rx_queue</span> <span class="o">*</span><span class="n">rxq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">rb_size</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">rfdnlog</span> <span class="o">=</span> <span class="n">RX_QUEUE_SIZE_LOG</span><span class="p">;</span> <span class="cm">/* 256 RBDs */</span>
	<span class="n">u32</span> <span class="n">rb_timeout</span> <span class="o">=</span> <span class="n">RX_RB_TIMEOUT</span><span class="p">;</span> <span class="cm">/* FIXME: RX_RB_TIMEOUT for all devices? */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">rx_buf_size_8k</span><span class="p">)</span>
		<span class="n">rb_size</span> <span class="o">=</span> <span class="n">FH_RCSR_RX_CONFIG_REG_VAL_RB_SIZE_8K</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rb_size</span> <span class="o">=</span> <span class="n">FH_RCSR_RX_CONFIG_REG_VAL_RB_SIZE_4K</span><span class="p">;</span>

	<span class="cm">/* Stop Rx DMA */</span>
	<span class="n">iwl_write_direct32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">FH_MEM_RCSR_CHNL0_CONFIG_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Reset driver&#39;s Rx queue write index */</span>
	<span class="n">iwl_write_direct32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">FH_RSCSR_CHNL0_RBDCB_WPTR_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Tell device where to find RBD circular buffer in DRAM */</span>
	<span class="n">iwl_write_direct32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">FH_RSCSR_CHNL0_RBDCB_BASE_REG</span><span class="p">,</span>
			   <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">bd_dma</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">));</span>

	<span class="cm">/* Tell device where in DRAM to update its Rx status */</span>
	<span class="n">iwl_write_direct32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">FH_RSCSR_CHNL0_STTS_WPTR_REG</span><span class="p">,</span>
			   <span class="n">rxq</span><span class="o">-&gt;</span><span class="n">rb_stts_dma</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>

	<span class="cm">/* Enable Rx DMA</span>
<span class="cm">	 * FH_RCSR_CHNL0_RX_IGNORE_RXF_EMPTY is set because of HW bug in</span>
<span class="cm">	 *      the credit mechanism in 5000 HW RX FIFO</span>
<span class="cm">	 * Direct rx interrupts to hosts</span>
<span class="cm">	 * Rx buffer size 4 or 8k</span>
<span class="cm">	 * RB timeout 0x10</span>
<span class="cm">	 * 256 RBDs</span>
<span class="cm">	 */</span>
	<span class="n">iwl_write_direct32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">FH_MEM_RCSR_CHNL0_CONFIG_REG</span><span class="p">,</span>
			   <span class="n">FH_RCSR_RX_CONFIG_CHNL_EN_ENABLE_VAL</span> <span class="o">|</span>
			   <span class="n">FH_RCSR_CHNL0_RX_IGNORE_RXF_EMPTY</span> <span class="o">|</span>
			   <span class="n">FH_RCSR_CHNL0_RX_CONFIG_IRQ_DEST_INT_HOST_VAL</span> <span class="o">|</span>
			   <span class="n">rb_size</span><span class="o">|</span>
			   <span class="p">(</span><span class="n">rb_timeout</span> <span class="o">&lt;&lt;</span> <span class="n">FH_RCSR_RX_CONFIG_REG_IRQ_RBTH_POS</span><span class="p">)</span><span class="o">|</span>
			   <span class="p">(</span><span class="n">rfdnlog</span> <span class="o">&lt;&lt;</span> <span class="n">FH_RCSR_RX_CONFIG_RBDCB_SIZE_POS</span><span class="p">));</span>

	<span class="cm">/* Set interrupt coalescing timer to default (2048 usecs) */</span>
	<span class="n">iwl_write8</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_INT_COALESCING</span><span class="p">,</span> <span class="n">IWL_HOST_INT_TIMEOUT_DEF</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_rx_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span>
		<span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_rx_queue</span> <span class="o">*</span><span class="n">rxq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">rxq</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">bd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">iwl_trans_rx_alloc</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">rx_free</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">rx_used</span><span class="p">);</span>

	<span class="n">iwl_trans_rxq_free_rx_bufs</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RX_QUEUE_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">rxq</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Set us so that we have processed and used all buffers, but have</span>
<span class="cm">	 * not restocked the Rx queue with fresh buffers */</span>
	<span class="n">rxq</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">=</span> <span class="n">rxq</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rxq</span><span class="o">-&gt;</span><span class="n">write_actual</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rxq</span><span class="o">-&gt;</span><span class="n">free_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">iwlagn_rx_replenish</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="n">iwl_trans_rx_hw_init</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">rxq</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">rxq</span><span class="o">-&gt;</span><span class="n">need_update</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">iwl_rx_queue_update_write_ptr</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">rxq</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwl_trans_pcie_rx_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span>
		<span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_rx_queue</span> <span class="o">*</span><span class="n">rxq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">rxq</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*if rxq-&gt;bd is NULL, it means that nothing has been allocated,</span>
<span class="cm">	 * exit now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">bd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_DEBUG_INFO</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Free NULL rx context</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">iwl_trans_rxq_free_rx_bufs</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__le32</span><span class="p">)</span> <span class="o">*</span> <span class="n">RX_QUEUE_SIZE</span><span class="p">,</span>
			  <span class="n">rxq</span><span class="o">-&gt;</span><span class="n">bd</span><span class="p">,</span> <span class="n">rxq</span><span class="o">-&gt;</span><span class="n">bd_dma</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">bd_dma</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">bd_dma</span><span class="p">));</span>
	<span class="n">rxq</span><span class="o">-&gt;</span><span class="n">bd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">rb_stts</span><span class="p">)</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_rb_status</span><span class="p">),</span>
				  <span class="n">rxq</span><span class="o">-&gt;</span><span class="n">rb_stts</span><span class="p">,</span> <span class="n">rxq</span><span class="o">-&gt;</span><span class="n">rb_stts_dma</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">IWL_DEBUG_INFO</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Free rxq-&gt;rb_stts which is NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">rb_stts_dma</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">rb_stts_dma</span><span class="p">));</span>
	<span class="n">rxq</span><span class="o">-&gt;</span><span class="n">rb_stts</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_trans_rx_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/* stop Rx DMA */</span>
	<span class="n">iwl_write_direct32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">FH_MEM_RCSR_CHNL0_CONFIG_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">iwl_poll_direct_bit</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">FH_MEM_RSSR_RX_STATUS_REG</span><span class="p">,</span>
			    <span class="n">FH_RSSR_CHNL0_RX_STATUS_CHNL_IDLE</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">iwlagn_alloc_dma_ptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">iwl_dma_ptr</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ptr</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">ptr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iwlagn_free_dma_ptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">iwl_dma_ptr</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwl_trans_pcie_queue_stuck_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">trans_pcie</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span> <span class="o">=</span> <span class="n">iwl_trans_pcie_get_trans</span><span class="p">(</span><span class="n">trans_pcie</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/* check if triggered erroneously */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">read_ptr</span> <span class="o">==</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">write_ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>


	<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Queue %d stuck for %u ms.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
		<span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">wd_timeout</span><span class="p">));</span>
	<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Current SW read_ptr %d write_ptr %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">read_ptr</span><span class="p">,</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">write_ptr</span><span class="p">);</span>
	<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Current HW read_ptr %d write_ptr %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">iwl_read_prph</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">SCD_QUEUE_RDPTR</span><span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">id</span><span class="p">))</span>
					<span class="o">&amp;</span> <span class="p">(</span><span class="n">TFD_QUEUE_SIZE_MAX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
		<span class="n">iwl_read_prph</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">SCD_QUEUE_WRPTR</span><span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">id</span><span class="p">)));</span>

	<span class="n">iwl_op_mode_nic_error</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">op_mode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_trans_txq_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slots_num</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">txq_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">tfd_sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_tfd</span><span class="p">)</span> <span class="o">*</span> <span class="n">TFD_QUEUE_SIZE_MAX</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">||</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">tfds</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">stuck_timer</span><span class="p">,</span> <span class="n">iwl_trans_pcie_queue_stuck_timer</span><span class="p">,</span>
		    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">txq</span><span class="p">);</span>
	<span class="n">txq</span><span class="o">-&gt;</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">trans_pcie</span><span class="p">;</span>

	<span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">n_window</span> <span class="o">=</span> <span class="n">slots_num</span><span class="p">;</span>

	<span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">slots_num</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_pcie_tx_queue_entry</span><span class="p">),</span>
			       <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">txq_id</span> <span class="o">==</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">cmd_queue</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">slots_num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmd</span> <span class="o">=</span>
				<span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_device_cmd</span><span class="p">),</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmd</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/* Circular buffer of transmit frame descriptors (TFDs),</span>
<span class="cm">	 * shared with device */</span>
	<span class="n">txq</span><span class="o">-&gt;</span><span class="n">tfds</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">tfd_sz</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">tfds</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;dma_alloc_coherent(%zd) failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tfd_sz</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">txq_id</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">&amp;&amp;</span> <span class="n">txq_id</span> <span class="o">==</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">cmd_queue</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">slots_num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">);</span>
	<span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_trans_txq_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">slots_num</span><span class="p">,</span> <span class="n">u32</span> <span class="n">txq_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">txq</span><span class="o">-&gt;</span><span class="n">need_update</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* TFD_QUEUE_SIZE_MAX must be power-of-two size, otherwise</span>
<span class="cm">	 * iwl_queue_inc_wrap and iwl_queue_dec_wrap are broken. */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">TFD_QUEUE_SIZE_MAX</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TFD_QUEUE_SIZE_MAX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

	<span class="cm">/* Initialize queue&#39;s high/low-water marks, and head/tail indexes */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_queue_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">,</span> <span class="n">TFD_QUEUE_SIZE_MAX</span><span class="p">,</span> <span class="n">slots_num</span><span class="p">,</span>
			<span class="n">txq_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Tell nic where to find circular buffer of Tx Frame Descriptors for</span>
<span class="cm">	 * given Tx queue, and enable the DMA channel used for that queue.</span>
<span class="cm">	 * Circular buffer (TFD queue in DRAM) physical base address */</span>
	<span class="n">iwl_write_direct32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">FH_MEM_CBBC_QUEUE</span><span class="p">(</span><span class="n">txq_id</span><span class="p">),</span>
			     <span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">dma_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iwl_tx_queue_unmap -  Unmap any remaining DMA mappings and free skb&#39;s</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwl_tx_queue_unmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="kt">int</span> <span class="n">txq_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">txq_id</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">iwl_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dma_dir</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">n_bd</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* In the command queue, all the TBs are mapped as BIDI</span>
<span class="cm">	 * so unmap them as such.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">txq_id</span> <span class="o">==</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">cmd_queue</span><span class="p">)</span>
		<span class="n">dma_dir</span> <span class="o">=</span> <span class="n">DMA_BIDIRECTIONAL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">dma_dir</span> <span class="o">=</span> <span class="n">DMA_TO_DEVICE</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span> <span class="o">!=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">read_ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iwlagn_txq_free_tfd</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">txq</span><span class="p">,</span> <span class="n">dma_dir</span><span class="p">);</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">read_ptr</span> <span class="o">=</span> <span class="n">iwl_queue_inc_wrap</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">read_ptr</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">n_bd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iwl_tx_queue_free - Deallocate DMA queue.</span>
<span class="cm"> * @txq: Transmit queue to deallocate.</span>
<span class="cm"> *</span>
<span class="cm"> * Empty queue by removing and destroying all BD&#39;s.</span>
<span class="cm"> * Free all buffers.</span>
<span class="cm"> * 0-fill, but do not free &quot;txq&quot; descriptor structure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwl_tx_queue_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="kt">int</span> <span class="n">txq_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">txq_id</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">txq</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">iwl_tx_queue_unmap</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">txq_id</span><span class="p">);</span>

	<span class="cm">/* De-alloc array of command/tx buffers */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">txq_id</span> <span class="o">==</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">cmd_queue</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">n_window</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmd</span><span class="p">);</span>

	<span class="cm">/* De-alloc circular buffer of TFDs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">n_bd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_tfd</span><span class="p">)</span> <span class="o">*</span>
				  <span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">n_bd</span><span class="p">,</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">tfds</span><span class="p">,</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">);</span>
	<span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">stuck_timer</span><span class="p">);</span>

	<span class="cm">/* 0-fill queue descriptor structure */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">txq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">txq</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iwl_trans_tx_free - Free TXQ Context</span>
<span class="cm"> *</span>
<span class="cm"> * Destroy all TX DMA queues and structures</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwl_trans_pcie_tx_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">txq_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="cm">/* Tx queues */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">txq_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		     <span class="n">txq_id</span> <span class="o">&lt;</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">base_params</span><span class="o">-&gt;</span><span class="n">num_of_queues</span><span class="p">;</span> <span class="n">txq_id</span><span class="o">++</span><span class="p">)</span>
			<span class="n">iwl_tx_queue_free</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">txq_id</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">);</span>
	<span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">iwlagn_free_dma_ptr</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">kw</span><span class="p">);</span>

	<span class="n">iwlagn_free_dma_ptr</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">scd_bc_tbls</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iwl_trans_tx_alloc - allocate TX context</span>
<span class="cm"> * Allocate all Tx DMA structures and initialize them</span>
<span class="cm"> *</span>
<span class="cm"> * @param priv</span>
<span class="cm"> * @return error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_trans_tx_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">txq_id</span><span class="p">,</span> <span class="n">slots_num</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="n">u16</span> <span class="n">scd_bc_tbls_size</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">base_params</span><span class="o">-&gt;</span><span class="n">num_of_queues</span> <span class="o">*</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwlagn_scd_bc_tbl</span><span class="p">);</span>

	<span class="cm">/*It is not allowed to alloc twice, so warn when this happens.</span>
<span class="cm">	 * We cannot rely on the previous allocation, so free and fail */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">iwlagn_alloc_dma_ptr</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">scd_bc_tbls</span><span class="p">,</span>
				   <span class="n">scd_bc_tbls_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Scheduler BC Table allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Alloc keep-warm buffer */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">iwlagn_alloc_dma_ptr</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">kw</span><span class="p">,</span> <span class="n">IWL_KW_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Keep Warm allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">base_params</span><span class="o">-&gt;</span><span class="n">num_of_queues</span><span class="p">,</span>
				  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_tx_queue</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Not enough memory for txq</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Alloc and init all Tx queues, including the command queue (#4/#9) */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">txq_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">txq_id</span> <span class="o">&lt;</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">base_params</span><span class="o">-&gt;</span><span class="n">num_of_queues</span><span class="p">;</span>
	     <span class="n">txq_id</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">slots_num</span> <span class="o">=</span> <span class="p">(</span><span class="n">txq_id</span> <span class="o">==</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">cmd_queue</span><span class="p">)</span> <span class="o">?</span>
					<span class="n">TFD_CMD_SLOTS</span> <span class="o">:</span> <span class="n">TFD_TX_CMD_SLOTS</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_trans_txq_alloc</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">txq_id</span><span class="p">],</span>
					  <span class="n">slots_num</span><span class="p">,</span> <span class="n">txq_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Tx %d queue alloc failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">txq_id</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="n">iwl_trans_pcie_tx_free</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_tx_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">txq_id</span><span class="p">,</span> <span class="n">slots_num</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">alloc</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_trans_tx_alloc</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">alloc</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Turn off all Tx DMA fifos */</span>
	<span class="n">iwl_write_prph</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">SCD_TXFACT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Tell NIC where to find the &quot;keep warm&quot; buffer */</span>
	<span class="n">iwl_write_direct32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">FH_KW_MEM_ADDR_REG</span><span class="p">,</span>
			   <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">kw</span><span class="p">.</span><span class="n">dma</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Alloc and init all Tx queues, including the command queue (#4/#9) */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">txq_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">txq_id</span> <span class="o">&lt;</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">base_params</span><span class="o">-&gt;</span><span class="n">num_of_queues</span><span class="p">;</span>
	     <span class="n">txq_id</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">slots_num</span> <span class="o">=</span> <span class="p">(</span><span class="n">txq_id</span> <span class="o">==</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">cmd_queue</span><span class="p">)</span> <span class="o">?</span>
					<span class="n">TFD_CMD_SLOTS</span> <span class="o">:</span> <span class="n">TFD_TX_CMD_SLOTS</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_trans_txq_init</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">txq_id</span><span class="p">],</span>
					 <span class="n">slots_num</span><span class="p">,</span> <span class="n">txq_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Tx %d queue init failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">txq_id</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="cm">/*Upon error, free only if we allocated something */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc</span><span class="p">)</span>
		<span class="n">iwl_trans_pcie_tx_free</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwl_set_pwr_vmain</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/*</span>
<span class="cm"> * (for documentation purposes)</span>
<span class="cm"> * to set power to V_AUX, do:</span>

<span class="cm">		if (pci_pme_capable(priv-&gt;pci_dev, PCI_D3cold))</span>
<span class="cm">			iwl_set_bits_mask_prph(trans, APMG_PS_CTRL_REG,</span>
<span class="cm">					       APMG_PS_CTRL_VAL_PWR_SRC_VAUX,</span>
<span class="cm">					       ~APMG_PS_CTRL_MSK_PWR_SRC);</span>
<span class="cm"> */</span>

	<span class="n">iwl_set_bits_mask_prph</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">APMG_PS_CTRL_REG</span><span class="p">,</span>
			       <span class="n">APMG_PS_CTRL_VAL_PWR_SRC_VMAIN</span><span class="p">,</span>
			       <span class="o">~</span><span class="n">APMG_PS_CTRL_MSK_PWR_SRC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* PCI registers */</span>
<span class="cp">#define PCI_CFG_RETRY_TIMEOUT	0x041</span>
<span class="cp">#define PCI_CFG_LINK_CTRL_VAL_L0S_EN	0x01</span>
<span class="cp">#define PCI_CFG_LINK_CTRL_VAL_L1_EN	0x02</span>

<span class="k">static</span> <span class="n">u16</span> <span class="nf">iwl_pciexp_link_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pci_lnk_ctl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span>
		<span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_pcie_cap</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_LNKCTL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_lnk_ctl</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pci_lnk_ctl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwl_apm_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * HW bug W/A for instability in PCIe bus L0S-&gt;L1 transition.</span>
<span class="cm">	 * Check if BIOS (or OS) enabled L1-ASPM on this device.</span>
<span class="cm">	 * If so (likely), disable L0S, so device moves directly L0-&gt;L1;</span>
<span class="cm">	 *    costs negligible amount of power savings.</span>
<span class="cm">	 * If not (unlikely), enable L0S, so there is at least some</span>
<span class="cm">	 *    power savings, even without L1.</span>
<span class="cm">	 */</span>
	<span class="n">u16</span> <span class="n">lctl</span> <span class="o">=</span> <span class="n">iwl_pciexp_link_ctrl</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">lctl</span> <span class="o">&amp;</span> <span class="n">PCI_CFG_LINK_CTRL_VAL_L1_EN</span><span class="p">)</span> <span class="o">==</span>
				<span class="n">PCI_CFG_LINK_CTRL_VAL_L1_EN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* L1-ASPM enabled; disable(!) L0S */</span>
		<span class="n">iwl_set_bit</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_GIO_REG</span><span class="p">,</span> <span class="n">CSR_GIO_REG_VAL_L0S_ENABLED</span><span class="p">);</span>
		<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			   <span class="s">&quot;L1 Enabled; Disabling L0S</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* L1-ASPM disabled; enable(!) L0S */</span>
		<span class="n">iwl_clear_bit</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_GIO_REG</span><span class="p">,</span> <span class="n">CSR_GIO_REG_VAL_L0S_ENABLED</span><span class="p">);</span>
		<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			   <span class="s">&quot;L1 Disabled; Enabling L0S</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">pm_support</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">lctl</span> <span class="o">&amp;</span> <span class="n">PCI_CFG_LINK_CTRL_VAL_L0S_EN</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Start up NIC&#39;s basic functionality after it has been reset</span>
<span class="cm"> * (e.g. after platform boot, or shutdown via iwl_apm_stop())</span>
<span class="cm"> * NOTE:  This does not load uCode nor start the embedded processor</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_apm_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">IWL_DEBUG_INFO</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Init card&#39;s basic functions</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use &quot;set_bit&quot; below rather than &quot;write&quot;, to preserve any hardware</span>
<span class="cm">	 * bits already set by default after reset.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Disable L0S exit timer (platform NMI Work/Around) */</span>
	<span class="n">iwl_set_bit</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_GIO_CHICKEN_BITS</span><span class="p">,</span>
			  <span class="n">CSR_GIO_CHICKEN_BITS_REG_BIT_DIS_L0S_EXIT_TIMER</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable L0s without affecting L1;</span>
<span class="cm">	 *  don&#39;t wait for ICH L0s (ICH bug W/A)</span>
<span class="cm">	 */</span>
	<span class="n">iwl_set_bit</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_GIO_CHICKEN_BITS</span><span class="p">,</span>
			  <span class="n">CSR_GIO_CHICKEN_BITS_REG_BIT_L1A_NO_L0S_RX</span><span class="p">);</span>

	<span class="cm">/* Set FH wait threshold to maximum (HW error during stress W/A) */</span>
	<span class="n">iwl_set_bit</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_DBG_HPET_MEM_REG</span><span class="p">,</span> <span class="n">CSR_DBG_HPET_MEM_REG_VAL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enable HAP INTA (interrupt from management bus) to</span>
<span class="cm">	 * wake device&#39;s PCI Express link L1a -&gt; L0s</span>
<span class="cm">	 */</span>
	<span class="n">iwl_set_bit</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_HW_IF_CONFIG_REG</span><span class="p">,</span>
				    <span class="n">CSR_HW_IF_CONFIG_REG_BIT_HAP_WAKE_L1A</span><span class="p">);</span>

	<span class="n">iwl_apm_config</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="cm">/* Configure analog phase-lock-loop before activating to D0A */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">base_params</span><span class="o">-&gt;</span><span class="n">pll_cfg_val</span><span class="p">)</span>
		<span class="n">iwl_set_bit</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_ANA_PLL_CFG</span><span class="p">,</span>
			    <span class="n">trans</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">base_params</span><span class="o">-&gt;</span><span class="n">pll_cfg_val</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set &quot;initialization complete&quot; bit to move adapter from</span>
<span class="cm">	 * D0U* --&gt; D0A* (powered-up active) state.</span>
<span class="cm">	 */</span>
	<span class="n">iwl_set_bit</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_GP_CNTRL</span><span class="p">,</span> <span class="n">CSR_GP_CNTRL_REG_FLAG_INIT_DONE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait for clock stabilization; once stabilized, access to</span>
<span class="cm">	 * device-internal resources is supported, e.g. iwl_write_prph()</span>
<span class="cm">	 * and accesses to uCode SRAM.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_poll_bit</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_GP_CNTRL</span><span class="p">,</span>
			<span class="n">CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY</span><span class="p">,</span>
			<span class="n">CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY</span><span class="p">,</span> <span class="mi">25000</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_DEBUG_INFO</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Failed to init the card</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enable DMA clock and wait for it to stabilize.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Write to &quot;CLK_EN_REG&quot;; &quot;1&quot; bits enable clocks, while &quot;0&quot; bits</span>
<span class="cm">	 * do not disable clocks.  This preserves any hardware bits already</span>
<span class="cm">	 * set by default in &quot;CLK_CTRL_REG&quot; after reset.</span>
<span class="cm">	 */</span>
	<span class="n">iwl_write_prph</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">APMG_CLK_EN_REG</span><span class="p">,</span> <span class="n">APMG_CLK_VAL_DMA_CLK_RQT</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>

	<span class="cm">/* Disable L1-Active */</span>
	<span class="n">iwl_set_bits_prph</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">APMG_PCIDEV_STT_REG</span><span class="p">,</span>
			  <span class="n">APMG_PCIDEV_STT_VAL_L1_ACT_DIS</span><span class="p">);</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">STATUS_DEVICE_ENABLED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_apm_stop_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* stop device&#39;s busmaster DMA activity */</span>
	<span class="n">iwl_set_bit</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_RESET</span><span class="p">,</span> <span class="n">CSR_RESET_REG_FLAG_STOP_MASTER</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_poll_bit</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_RESET</span><span class="p">,</span>
			<span class="n">CSR_RESET_REG_FLAG_MASTER_DISABLED</span><span class="p">,</span>
			<span class="n">CSR_RESET_REG_FLAG_MASTER_DISABLED</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">IWL_WARN</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Master Disable Timed Out, 100 usec</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">IWL_DEBUG_INFO</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;stop master</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwl_apm_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="n">IWL_DEBUG_INFO</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Stop card, put in low power state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">STATUS_DEVICE_ENABLED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>

	<span class="cm">/* Stop device&#39;s DMA activity */</span>
	<span class="n">iwl_apm_stop_master</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="cm">/* Reset the entire device */</span>
	<span class="n">iwl_set_bit</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_RESET</span><span class="p">,</span> <span class="n">CSR_RESET_REG_FLAG_SW_RESET</span><span class="p">);</span>

	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear &quot;initialization complete&quot; bit to move adapter from</span>
<span class="cm">	 * D0A* (powered-up Active) --&gt; D0U* (Uninitialized) state.</span>
<span class="cm">	 */</span>
	<span class="n">iwl_clear_bit</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_GP_CNTRL</span><span class="p">,</span>
		      <span class="n">CSR_GP_CNTRL_REG_FLAG_INIT_DONE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_nic_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* nic_init */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">iwl_apm_init</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="cm">/* Set interrupt coalescing calibration timer to default (512 usecs) */</span>
	<span class="n">iwl_write8</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_INT_COALESCING</span><span class="p">,</span>
		<span class="n">IWL_HOST_INT_CALIB_TIMEOUT_DEF</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">iwl_set_pwr_vmain</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="n">iwl_op_mode_nic_config</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">op_mode</span><span class="p">);</span>

<span class="cp">#ifndef CONFIG_IWLWIFI_IDI</span>
	<span class="cm">/* Allocate the RX queue, or reset if it is already allocated */</span>
	<span class="n">iwl_rx_init</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* Allocate or reset and init all Tx and Command queues */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iwl_tx_init</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">base_params</span><span class="o">-&gt;</span><span class="n">shadow_reg_enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* enable shadow regs in HW */</span>
		<span class="n">iwl_set_bit</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_MAC_SHADOW_REG_CTRL</span><span class="p">,</span>
			<span class="mh">0x800FFFFF</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define HW_READY_TIMEOUT (50)</span>

<span class="cm">/* Note: returns poll_bit return value, which is &gt;= 0 if success */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_set_hw_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">iwl_set_bit</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_HW_IF_CONFIG_REG</span><span class="p">,</span>
		<span class="n">CSR_HW_IF_CONFIG_REG_BIT_NIC_READY</span><span class="p">);</span>

	<span class="cm">/* See if we got it */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_poll_bit</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_HW_IF_CONFIG_REG</span><span class="p">,</span>
				<span class="n">CSR_HW_IF_CONFIG_REG_BIT_NIC_READY</span><span class="p">,</span>
				<span class="n">CSR_HW_IF_CONFIG_REG_BIT_NIC_READY</span><span class="p">,</span>
				<span class="n">HW_READY_TIMEOUT</span><span class="p">);</span>

	<span class="n">IWL_DEBUG_INFO</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;hardware%s ready</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">&quot; not&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Note: returns standard 0/-ERROR code */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_prepare_card_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">IWL_DEBUG_INFO</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;iwl_trans_prepare_card_hw enter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_set_hw_ready</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="cm">/* If the card is ready, exit 0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If HW is not ready, prepare the conditions to check again */</span>
	<span class="n">iwl_set_bit</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_HW_IF_CONFIG_REG</span><span class="p">,</span>
			<span class="n">CSR_HW_IF_CONFIG_REG_PREPARE</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_poll_bit</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_HW_IF_CONFIG_REG</span><span class="p">,</span>
			<span class="o">~</span><span class="n">CSR_HW_IF_CONFIG_REG_BIT_NIC_PREPARE_DONE</span><span class="p">,</span>
			<span class="n">CSR_HW_IF_CONFIG_REG_BIT_NIC_PREPARE_DONE</span><span class="p">,</span> <span class="mi">150000</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* HW should be ready by now, check again. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_set_hw_ready</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ucode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_load_section</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">u8</span> <span class="n">section_num</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">struct</span> <span class="n">fw_desc</span> <span class="o">*</span><span class="n">section</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="n">dma_addr_t</span> <span class="n">phy_addr</span> <span class="o">=</span> <span class="n">section</span><span class="o">-&gt;</span><span class="n">p_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">byte_cnt</span> <span class="o">=</span> <span class="n">section</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dst_addr</span> <span class="o">=</span> <span class="n">section</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">ucode_write_complete</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">iwl_write_direct32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span>
		<span class="n">FH_TCSR_CHNL_TX_CONFIG_REG</span><span class="p">(</span><span class="n">FH_SRVC_CHNL</span><span class="p">),</span>
		<span class="n">FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_PAUSE</span><span class="p">);</span>

	<span class="n">iwl_write_direct32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span>
		<span class="n">FH_SRVC_CHNL_SRAM_ADDR_REG</span><span class="p">(</span><span class="n">FH_SRVC_CHNL</span><span class="p">),</span> <span class="n">dst_addr</span><span class="p">);</span>

	<span class="n">iwl_write_direct32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span>
		<span class="n">FH_TFDIB_CTRL0_REG</span><span class="p">(</span><span class="n">FH_SRVC_CHNL</span><span class="p">),</span>
		<span class="n">phy_addr</span> <span class="o">&amp;</span> <span class="n">FH_MEM_TFDIB_DRAM_ADDR_LSB_MSK</span><span class="p">);</span>

	<span class="n">iwl_write_direct32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span>
		<span class="n">FH_TFDIB_CTRL1_REG</span><span class="p">(</span><span class="n">FH_SRVC_CHNL</span><span class="p">),</span>
		<span class="p">(</span><span class="n">iwl_get_dma_hi_addr</span><span class="p">(</span><span class="n">phy_addr</span><span class="p">)</span>
			<span class="o">&lt;&lt;</span> <span class="n">FH_MEM_TFDIB_REG1_ADDR_BITSHIFT</span><span class="p">)</span> <span class="o">|</span> <span class="n">byte_cnt</span><span class="p">);</span>

	<span class="n">iwl_write_direct32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span>
		<span class="n">FH_TCSR_CHNL_TX_BUF_STS_REG</span><span class="p">(</span><span class="n">FH_SRVC_CHNL</span><span class="p">),</span>
		<span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">FH_TCSR_CHNL_TX_BUF_STS_REG_POS_TB_NUM</span> <span class="o">|</span>
		<span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">FH_TCSR_CHNL_TX_BUF_STS_REG_POS_TB_IDX</span> <span class="o">|</span>
		<span class="n">FH_TCSR_CHNL_TX_BUF_STS_REG_VAL_TFDB_VALID</span><span class="p">);</span>

	<span class="n">iwl_write_direct32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span>
		<span class="n">FH_TCSR_CHNL_TX_CONFIG_REG</span><span class="p">(</span><span class="n">FH_SRVC_CHNL</span><span class="p">),</span>
		<span class="n">FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_ENABLE</span>	<span class="o">|</span>
		<span class="n">FH_TCSR_TX_CONFIG_REG_VAL_DMA_CREDIT_DISABLE</span>	<span class="o">|</span>
		<span class="n">FH_TCSR_TX_CONFIG_REG_VAL_CIRQ_HOST_ENDTFD</span><span class="p">);</span>

	<span class="n">IWL_DEBUG_FW</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;[%d] uCode section being loaded...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">section_num</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_event_timeout</span><span class="p">(</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">ucode_write_waitq</span><span class="p">,</span>
				 <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">ucode_write_complete</span><span class="p">,</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Could not load the [%d] uCode section</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">section_num</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_load_given_ucode</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">fw_img</span> <span class="o">*</span><span class="n">image</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IWL_UCODE_SECTION_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">sec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_addr</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_load_section</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">sec</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/* Remove all resets to allow NIC to operate */</span>
	<span class="n">iwl_write32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_RESET</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_trans_pcie_start_fw</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">fw_img</span> <span class="o">*</span><span class="n">fw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">hw_rfkill</span><span class="p">;</span>

	<span class="cm">/* This may fail if AMT took ownership of the device */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iwl_prepare_card_hw</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IWL_WARN</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Exit HW not ready</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iwl_enable_rfkill_int</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="cm">/* If platform&#39;s RF_KILL switch is NOT set to KILL */</span>
	<span class="n">hw_rfkill</span> <span class="o">=</span> <span class="n">iwl_is_rfkill_set</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="n">iwl_op_mode_hw_rf_kill</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">op_mode</span><span class="p">,</span> <span class="n">hw_rfkill</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw_rfkill</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ERFKILL</span><span class="p">;</span>

	<span class="n">iwl_write32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_INT</span><span class="p">,</span> <span class="mh">0xFFFFFFFF</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_nic_init</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Unable to init nic</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* make sure rfkill handshake bits are cleared */</span>
	<span class="n">iwl_write32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_UCODE_DRV_GP1_CLR</span><span class="p">,</span> <span class="n">CSR_UCODE_SW_BIT_RFKILL</span><span class="p">);</span>
	<span class="n">iwl_write32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_UCODE_DRV_GP1_CLR</span><span class="p">,</span>
		    <span class="n">CSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED</span><span class="p">);</span>

	<span class="cm">/* clear (again), then enable host interrupts */</span>
	<span class="n">iwl_write32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_INT</span><span class="p">,</span> <span class="mh">0xFFFFFFFF</span><span class="p">);</span>
	<span class="n">iwl_enable_interrupts</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="cm">/* really make sure rfkill handshake bits are cleared */</span>
	<span class="n">iwl_write32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_UCODE_DRV_GP1_CLR</span><span class="p">,</span> <span class="n">CSR_UCODE_SW_BIT_RFKILL</span><span class="p">);</span>
	<span class="n">iwl_write32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_UCODE_DRV_GP1_CLR</span><span class="p">,</span> <span class="n">CSR_UCODE_SW_BIT_RFKILL</span><span class="p">);</span>

	<span class="cm">/* Load the given image to the HW */</span>
	<span class="k">return</span> <span class="n">iwl_load_given_ucode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">fw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Activate/Deactivate Tx DMA/FIFO channels according tx fifos mask</span>
<span class="cm"> * must be called under the irq lock and with MAC access</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwl_trans_txq_set_sched</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="n">__maybe_unused</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span>
		<span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">);</span>

	<span class="n">iwl_write_prph</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">SCD_TXFACT</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwl_tx_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">a</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">chan</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_val</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">scd_base_addr</span> <span class="o">=</span>
		<span class="n">iwl_read_prph</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">SCD_SRAM_BASE_ADDR</span><span class="p">);</span>
	<span class="n">a</span> <span class="o">=</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">scd_base_addr</span> <span class="o">+</span> <span class="n">SCD_CONTEXT_MEM_LOWER_BOUND</span><span class="p">;</span>
	<span class="cm">/* reset conext data memory */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">scd_base_addr</span> <span class="o">+</span> <span class="n">SCD_CONTEXT_MEM_UPPER_BOUND</span><span class="p">;</span>
		<span class="n">a</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">iwl_write_targ_mem</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* reset tx status memory */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">scd_base_addr</span> <span class="o">+</span> <span class="n">SCD_TX_STTS_MEM_UPPER_BOUND</span><span class="p">;</span>
		<span class="n">a</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">iwl_write_targ_mem</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">scd_base_addr</span> <span class="o">+</span>
	       <span class="n">SCD_TRANS_TBL_OFFSET_QUEUE</span><span class="p">(</span>
				<span class="n">trans</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">base_params</span><span class="o">-&gt;</span><span class="n">num_of_queues</span><span class="p">);</span>
	       <span class="n">a</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">iwl_write_targ_mem</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">iwl_write_prph</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">SCD_DRAM_BASE_ADDR</span><span class="p">,</span>
		       <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">scd_bc_tbls</span><span class="p">.</span><span class="n">dma</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>

	<span class="cm">/* The chain extension of the SCD doesn&#39;t work well. This feature is</span>
<span class="cm">	 * enabled by default by the HW, so we need to disable it manually.</span>
<span class="cm">	 */</span>
	<span class="n">iwl_write_prph</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">SCD_CHAINEXT_EN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Enable DMA channel */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">chan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">chan</span> <span class="o">&lt;</span> <span class="n">FH_TCSR_CHNL_NUM</span> <span class="p">;</span> <span class="n">chan</span><span class="o">++</span><span class="p">)</span>
		<span class="n">iwl_write_direct32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">FH_TCSR_CHNL_TX_CONFIG_REG</span><span class="p">(</span><span class="n">chan</span><span class="p">),</span>
				<span class="n">FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_ENABLE</span> <span class="o">|</span>
				<span class="n">FH_TCSR_TX_CONFIG_REG_VAL_DMA_CREDIT_ENABLE</span><span class="p">);</span>

	<span class="cm">/* Update FH chicken bits */</span>
	<span class="n">reg_val</span> <span class="o">=</span> <span class="n">iwl_read_direct32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">FH_TX_CHICKEN_BITS_REG</span><span class="p">);</span>
	<span class="n">iwl_write_direct32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">FH_TX_CHICKEN_BITS_REG</span><span class="p">,</span>
			   <span class="n">reg_val</span> <span class="o">|</span> <span class="n">FH_TX_CHICKEN_BITS_SCD_AUTO_RETRY_EN</span><span class="p">);</span>

	<span class="n">iwl_write_prph</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">SCD_QUEUECHAIN_SEL</span><span class="p">,</span>
		<span class="n">SCD_QUEUECHAIN_SEL_ALL</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">trans_pcie</span><span class="p">));</span>
	<span class="n">iwl_write_prph</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">SCD_AGGR_SEL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* initiate the queues */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">base_params</span><span class="o">-&gt;</span><span class="n">num_of_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iwl_write_prph</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">SCD_QUEUE_RDPTR</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">iwl_write_direct32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">HBUS_TARG_WRPTR</span><span class="p">,</span> <span class="mi">0</span> <span class="o">|</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">));</span>
		<span class="n">iwl_write_targ_mem</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">scd_base_addr</span> <span class="o">+</span>
				<span class="n">SCD_CONTEXT_QUEUE_OFFSET</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">iwl_write_targ_mem</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">scd_base_addr</span> <span class="o">+</span>
				<span class="n">SCD_CONTEXT_QUEUE_OFFSET</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span>
				<span class="p">((</span><span class="n">SCD_WIN_SIZE</span> <span class="o">&lt;&lt;</span>
				<span class="n">SCD_QUEUE_CTX_REG2_WIN_SIZE_POS</span><span class="p">)</span> <span class="o">&amp;</span>
				<span class="n">SCD_QUEUE_CTX_REG2_WIN_SIZE_MSK</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">((</span><span class="n">SCD_FRAME_LIMIT</span> <span class="o">&lt;&lt;</span>
				<span class="n">SCD_QUEUE_CTX_REG2_FRAME_LIMIT_POS</span><span class="p">)</span> <span class="o">&amp;</span>
				<span class="n">SCD_QUEUE_CTX_REG2_FRAME_LIMIT_MSK</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">iwl_write_prph</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">SCD_INTERRUPT_MASK</span><span class="p">,</span>
			<span class="n">IWL_MASK</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">base_params</span><span class="o">-&gt;</span><span class="n">num_of_queues</span><span class="p">));</span>

	<span class="cm">/* Activate all Tx DMA/FIFO channels */</span>
	<span class="n">iwl_trans_txq_set_sched</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">IWL_MASK</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">));</span>

	<span class="n">iwl_trans_set_wr_ptrs</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">cmd_queue</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* make sure all queue are not stopped/used */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">queue_stopped</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">queue_stopped</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">queue_used</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">queue_used</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">n_q_to_fifo</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">fifo</span> <span class="o">=</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">setup_q_to_fifo</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">queue_used</span><span class="p">);</span>

		<span class="n">iwl_trans_tx_queue_set_status</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					      <span class="n">fifo</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Enable L1-Active */</span>
	<span class="n">iwl_clear_bits_prph</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">APMG_PCIDEV_STT_REG</span><span class="p">,</span>
			  <span class="n">APMG_PCIDEV_STT_VAL_L1_ACT_DIS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwl_trans_pcie_fw_alive</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iwl_reset_ict</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="n">iwl_tx_start</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iwlagn_txq_ctx_stop - Stop all Tx DMA channels</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_trans_tx_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ch</span><span class="p">,</span> <span class="n">txq_id</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="cm">/* Turn off all Tx DMA fifos */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">iwl_trans_txq_set_sched</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Stop each Tx DMA channel, and wait for it to be idle */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ch</span> <span class="o">&lt;</span> <span class="n">FH_TCSR_CHNL_NUM</span><span class="p">;</span> <span class="n">ch</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iwl_write_direct32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span>
				   <span class="n">FH_TCSR_CHNL_TX_CONFIG_REG</span><span class="p">(</span><span class="n">ch</span><span class="p">),</span> <span class="mh">0x0</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_poll_direct_bit</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">FH_TSSR_TX_STATUS_REG</span><span class="p">,</span>
				    <span class="n">FH_TSSR_TX_STATUS_REG_MSK_CHNL_IDLE</span><span class="p">(</span><span class="n">ch</span><span class="p">),</span>
				    <span class="mi">1000</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Failing on timeout while stopping&quot;</span>
			    <span class="s">&quot; DMA channel %d [0x%08x]&quot;</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span>
			    <span class="n">iwl_read_direct32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span>
					      <span class="n">FH_TSSR_TX_STATUS_REG</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_WARN</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Stopping tx queues that aren&#39;t allocated...&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Unmap DMA from host system and free skb&#39;s */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">txq_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">txq_id</span> <span class="o">&lt;</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">base_params</span><span class="o">-&gt;</span><span class="n">num_of_queues</span><span class="p">;</span>
	     <span class="n">txq_id</span><span class="o">++</span><span class="p">)</span>
		<span class="n">iwl_tx_queue_unmap</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">txq_id</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwl_trans_pcie_stop_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="cm">/* tell the device to stop sending interrupts */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">iwl_disable_interrupts</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* device going down, Stop using ICT table */</span>
	<span class="n">iwl_disable_ict</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If a HW restart happens during firmware loading,</span>
<span class="cm">	 * then the firmware loading might call this function</span>
<span class="cm">	 * and later it might be called again due to the</span>
<span class="cm">	 * restart. So don&#39;t process again if the device is</span>
<span class="cm">	 * already dead.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">STATUS_DEVICE_ENABLED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">iwl_trans_tx_stop</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
<span class="cp">#ifndef CONFIG_IWLWIFI_IDI</span>
		<span class="n">iwl_trans_rx_stop</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="cm">/* Power-down device&#39;s busmaster DMA clocks */</span>
		<span class="n">iwl_write_prph</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">APMG_CLK_DIS_REG</span><span class="p">,</span>
			       <span class="n">APMG_CLK_VAL_DMA_CLK_RQT</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure (redundant) we&#39;ve released our request to stay awake */</span>
	<span class="n">iwl_clear_bit</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_GP_CNTRL</span><span class="p">,</span>
			<span class="n">CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ</span><span class="p">);</span>

	<span class="cm">/* Stop the device, and put it in low power state */</span>
	<span class="n">iwl_apm_stop</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="cm">/* Upon stop, the APM issues an interrupt if HW RF kill is set.</span>
<span class="cm">	 * Clean again the interrupt here</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">iwl_disable_interrupts</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">iwl_enable_rfkill_int</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="cm">/* wait to make sure we flush pending tasklet*/</span>
	<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">tasklet_kill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq_tasklet</span><span class="p">);</span>

	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">rx_replenish</span><span class="p">);</span>

	<span class="cm">/* stop and reset the on-board processor */</span>
	<span class="n">iwl_write32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_RESET</span><span class="p">,</span> <span class="n">CSR_RESET_REG_FLAG_NEVO_RESET</span><span class="p">);</span>

	<span class="cm">/* clear all status bits */</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">STATUS_HCMD_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">STATUS_INT_ENABLED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">STATUS_DEVICE_ENABLED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">STATUS_TPOWER_PMI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwl_trans_pcie_wowlan_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* let the ucode operate on its own */</span>
	<span class="n">iwl_write32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_UCODE_DRV_GP1_SET</span><span class="p">,</span>
		    <span class="n">CSR_UCODE_DRV_GP1_BIT_D3_CFG_COMPLETE</span><span class="p">);</span>

	<span class="n">iwl_disable_interrupts</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="n">iwl_clear_bit</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_GP_CNTRL</span><span class="p">,</span>
		      <span class="n">CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_trans_pcie_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">iwl_device_cmd</span> <span class="o">*</span><span class="n">dev_cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">txq_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ieee80211_hdr</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_tx_cmd</span> <span class="o">*</span><span class="n">tx_cmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iwl_tx_cmd</span> <span class="o">*</span><span class="p">)</span> <span class="n">dev_cmd</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_cmd_meta</span> <span class="o">*</span><span class="n">out_meta</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">phys_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">txcmd_phys</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">scratch_phys</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">len</span><span class="p">,</span> <span class="n">firstlen</span><span class="p">,</span> <span class="n">secondlen</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">wait_write_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">fc</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">frame_control</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">hdr_len</span> <span class="o">=</span> <span class="n">ieee80211_hdrlen</span><span class="p">(</span><span class="n">fc</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">__maybe_unused</span> <span class="n">wifi_seq</span><span class="p">;</span>

	<span class="n">txq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">txq_id</span><span class="p">];</span>
	<span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">txq_id</span><span class="p">,</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">queue_used</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Set up driver data for this TFD */</span>
	<span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span><span class="p">].</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span><span class="p">].</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">dev_cmd</span><span class="p">;</span>

	<span class="n">dev_cmd</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">REPLY_TX</span><span class="p">;</span>
	<span class="n">dev_cmd</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">((</span><span class="n">u16</span><span class="p">)(</span><span class="n">QUEUE_TO_SEQ</span><span class="p">(</span><span class="n">txq_id</span><span class="p">)</span> <span class="o">|</span>
				<span class="n">INDEX_TO_SEQ</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span><span class="p">)));</span>

	<span class="cm">/* Set up first empty entry in queue&#39;s array of Tx/cmd buffers */</span>
	<span class="n">out_meta</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span><span class="p">].</span><span class="n">meta</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use the first empty entry in this queue&#39;s command buffer array</span>
<span class="cm">	 * to contain the Tx command and MAC header concatenated together</span>
<span class="cm">	 * (payload data will be in another buffer).</span>
<span class="cm">	 * Size of this varies, due to varying MAC header length.</span>
<span class="cm">	 * If end is not dword aligned, we&#39;ll have 2 extra bytes at the end</span>
<span class="cm">	 * of the MAC header (device reads on dword boundaries).</span>
<span class="cm">	 * We&#39;ll tell device about this padding later.</span>
<span class="cm">	 */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_tx_cmd</span><span class="p">)</span> <span class="o">+</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_cmd_header</span><span class="p">)</span> <span class="o">+</span> <span class="n">hdr_len</span><span class="p">;</span>
	<span class="n">firstlen</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">3</span><span class="p">;</span>

	<span class="cm">/* Tell NIC about any 2-byte padding after MAC header */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">firstlen</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span>
		<span class="n">tx_cmd</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">TX_CMD_FLG_MH_PAD_MSK</span><span class="p">;</span>

	<span class="cm">/* Physical address of this Tx command&#39;s header (not MAC header!),</span>
<span class="cm">	 * within command buffer array. */</span>
	<span class="n">txcmd_phys</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">dev_cmd</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">,</span> <span class="n">firstlen</span><span class="p">,</span>
				    <span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">txcmd_phys</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="n">dma_unmap_addr_set</span><span class="p">(</span><span class="n">out_meta</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">txcmd_phys</span><span class="p">);</span>
	<span class="n">dma_unmap_len_set</span><span class="p">(</span><span class="n">out_meta</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">firstlen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ieee80211_has_morefrags</span><span class="p">(</span><span class="n">fc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">txq</span><span class="o">-&gt;</span><span class="n">need_update</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">wait_write_ptr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">txq</span><span class="o">-&gt;</span><span class="n">need_update</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set up TFD&#39;s 2nd entry to point directly to remainder of skb,</span>
<span class="cm">	 * if any (802.11 null frames have no payload). */</span>
	<span class="n">secondlen</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">hdr_len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">secondlen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phys_addr</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">hdr_len</span><span class="p">,</span>
					   <span class="n">secondlen</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">phys_addr</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					 <span class="n">dma_unmap_addr</span><span class="p">(</span><span class="n">out_meta</span><span class="p">,</span> <span class="n">mapping</span><span class="p">),</span>
					 <span class="n">dma_unmap_len</span><span class="p">(</span><span class="n">out_meta</span><span class="p">,</span> <span class="n">len</span><span class="p">),</span>
					 <span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Attach buffers to TFD */</span>
	<span class="n">iwlagn_txq_attach_buf_to_tfd</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">txq</span><span class="p">,</span> <span class="n">txcmd_phys</span><span class="p">,</span> <span class="n">firstlen</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">secondlen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">iwlagn_txq_attach_buf_to_tfd</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">txq</span><span class="p">,</span> <span class="n">phys_addr</span><span class="p">,</span>
					     <span class="n">secondlen</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">scratch_phys</span> <span class="o">=</span> <span class="n">txcmd_phys</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_cmd_header</span><span class="p">)</span> <span class="o">+</span>
				<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_tx_cmd</span><span class="p">,</span> <span class="n">scratch</span><span class="p">);</span>

	<span class="cm">/* take back ownership of DMA buffer to enable update */</span>
	<span class="n">dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">txcmd_phys</span><span class="p">,</span> <span class="n">firstlen</span><span class="p">,</span>
			<span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>
	<span class="n">tx_cmd</span><span class="o">-&gt;</span><span class="n">dram_lsb_ptr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">scratch_phys</span><span class="p">);</span>
	<span class="n">tx_cmd</span><span class="o">-&gt;</span><span class="n">dram_msb_ptr</span> <span class="o">=</span> <span class="n">iwl_get_dma_hi_addr</span><span class="p">(</span><span class="n">scratch_phys</span><span class="p">);</span>

	<span class="n">IWL_DEBUG_TX</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;sequence nr = 0X%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dev_cmd</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">sequence</span><span class="p">));</span>
	<span class="n">IWL_DEBUG_TX</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;tx_flags = 0X%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">tx_cmd</span><span class="o">-&gt;</span><span class="n">tx_flags</span><span class="p">));</span>

	<span class="cm">/* Set up entry for this TFD in Tx byte-count array */</span>
	<span class="n">iwl_trans_txq_update_byte_cnt_tbl</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">txq</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">tx_cmd</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">));</span>

	<span class="n">dma_sync_single_for_device</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">txcmd_phys</span><span class="p">,</span> <span class="n">firstlen</span><span class="p">,</span>
			<span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>

	<span class="n">trace_iwlwifi_dev_tx</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="p">((</span><span class="k">struct</span> <span class="n">iwl_tfd</span> <span class="o">*</span><span class="p">)</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">tfds</span><span class="p">)[</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">write_ptr</span><span class="p">],</span>
			     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_tfd</span><span class="p">),</span>
			     <span class="o">&amp;</span><span class="n">dev_cmd</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">,</span> <span class="n">firstlen</span><span class="p">,</span>
			     <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">hdr_len</span><span class="p">,</span> <span class="n">secondlen</span><span class="p">);</span>

	<span class="cm">/* start timer if queue currently empty */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">read_ptr</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span> <span class="o">&amp;&amp;</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">wd_timeout</span><span class="p">)</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">stuck_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">wd_timeout</span><span class="p">);</span>

	<span class="cm">/* Tell device the write index *just past* this latest filled TFD */</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span> <span class="o">=</span> <span class="n">iwl_queue_inc_wrap</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">n_bd</span><span class="p">);</span>
	<span class="n">iwl_txq_update_write_ptr</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">txq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * At this point the frame is &quot;transmitted&quot; successfully</span>
<span class="cm">	 * and we will get a TX status notification eventually,</span>
<span class="cm">	 * regardless of the value of ret. &quot;ret&quot; only indicates</span>
<span class="cm">	 * whether or not we should update the write pointer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iwl_queue_space</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">high_mark</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wait_write_ptr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">txq</span><span class="o">-&gt;</span><span class="n">need_update</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">iwl_txq_update_write_ptr</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">txq</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">iwl_stop_queue</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">txq</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">out_err:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_trans_pcie_start_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span>
		<span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">hw_rfkill</span><span class="p">;</span>

	<span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">inta_mask</span> <span class="o">=</span> <span class="n">CSR_INI_SET_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq_requested</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq_tasklet</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))</span>
			<span class="n">iwl_irq_tasklet</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">trans</span><span class="p">);</span>

		<span class="n">iwl_alloc_isr_ict</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">iwl_isr_ict</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
			<span class="n">DRV_NAME</span><span class="p">,</span> <span class="n">trans</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Error allocating IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">rx_replenish</span><span class="p">,</span> <span class="n">iwl_bg_rx_replenish</span><span class="p">);</span>
		<span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq_requested</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">iwl_prepare_card_hw</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Error while preparing HW: %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_free_irq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iwl_apm_init</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="cm">/* From now on, the op_mode will be kept updated about RF kill state */</span>
	<span class="n">iwl_enable_rfkill_int</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="n">hw_rfkill</span> <span class="o">=</span> <span class="n">iwl_is_rfkill_set</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="n">iwl_op_mode_hw_rf_kill</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">op_mode</span><span class="p">,</span> <span class="n">hw_rfkill</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">err_free_irq:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">trans</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="n">iwl_free_isr_ict</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="n">tasklet_kill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq_tasklet</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwl_trans_pcie_stop_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				   <span class="n">bool</span> <span class="n">op_mode_leaving</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">hw_rfkill</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="n">iwl_apm_stop</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">iwl_disable_interrupts</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">iwl_write32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_INT</span><span class="p">,</span> <span class="mh">0xFFFFFFFF</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">op_mode_leaving</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Even if we stop the HW, we still want the RF kill</span>
<span class="cm">		 * interrupt</span>
<span class="cm">		 */</span>
		<span class="n">iwl_enable_rfkill_int</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check again since the RF kill state may have changed while</span>
<span class="cm">		 * all the interrupts were disabled, in this case we couldn&#39;t</span>
<span class="cm">		 * receive the RF kill interrupt and update the state in the</span>
<span class="cm">		 * op_mode.</span>
<span class="cm">		 */</span>
		<span class="n">hw_rfkill</span> <span class="o">=</span> <span class="n">iwl_is_rfkill_set</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
		<span class="n">iwl_op_mode_hw_rf_kill</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">op_mode</span><span class="p">,</span> <span class="n">hw_rfkill</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwl_trans_pcie_reclaim</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="kt">int</span> <span class="n">txq_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ssn</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">skbs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">txq_id</span><span class="p">];</span>
	<span class="cm">/* n_bd is usually 256 =&gt; n_bd - 1 = 0xff */</span>
	<span class="kt">int</span> <span class="n">tfd_num</span> <span class="o">=</span> <span class="n">ssn</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">n_bd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">freed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">read_ptr</span> <span class="o">!=</span> <span class="n">tfd_num</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_DEBUG_TX_REPLY</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;[Q %d] %d -&gt; %d (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">txq_id</span><span class="p">,</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">read_ptr</span><span class="p">,</span> <span class="n">tfd_num</span><span class="p">,</span> <span class="n">ssn</span><span class="p">);</span>
		<span class="n">freed</span> <span class="o">=</span> <span class="n">iwl_tx_queue_reclaim</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">txq_id</span><span class="p">,</span> <span class="n">tfd_num</span><span class="p">,</span> <span class="n">skbs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iwl_queue_space</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">low_mark</span><span class="p">)</span>
			<span class="n">iwl_wake_queue</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">txq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwl_trans_pcie_write8</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">u8</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hw_base</span> <span class="o">+</span> <span class="n">ofs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwl_trans_pcie_write32</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hw_base</span> <span class="o">+</span> <span class="n">ofs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">iwl_trans_pcie_read32</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ofs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hw_base</span> <span class="o">+</span> <span class="n">ofs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwl_trans_pcie_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">iwl_trans_config</span> <span class="o">*</span><span class="n">trans_cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">cmd_queue</span> <span class="o">=</span> <span class="n">trans_cfg</span><span class="o">-&gt;</span><span class="n">cmd_queue</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">trans_cfg</span><span class="o">-&gt;</span><span class="n">n_no_reclaim_cmds</span> <span class="o">&gt;</span> <span class="n">MAX_NO_RECLAIM_CMDS</span><span class="p">))</span>
		<span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">n_no_reclaim_cmds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">n_no_reclaim_cmds</span> <span class="o">=</span> <span class="n">trans_cfg</span><span class="o">-&gt;</span><span class="n">n_no_reclaim_cmds</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">n_no_reclaim_cmds</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">no_reclaim_cmds</span><span class="p">,</span> <span class="n">trans_cfg</span><span class="o">-&gt;</span><span class="n">no_reclaim_cmds</span><span class="p">,</span>
		       <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">n_no_reclaim_cmds</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u8</span><span class="p">));</span>

	<span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">n_q_to_fifo</span> <span class="o">=</span> <span class="n">trans_cfg</span><span class="o">-&gt;</span><span class="n">n_queue_to_fifo</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">n_q_to_fifo</span> <span class="o">&gt;</span> <span class="n">IWL_MAX_HW_QUEUES</span><span class="p">))</span>
		<span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">n_q_to_fifo</span> <span class="o">=</span> <span class="n">IWL_MAX_HW_QUEUES</span><span class="p">;</span>

	<span class="cm">/* at least the command queue must be mapped */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">n_q_to_fifo</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">setup_q_to_fifo</span><span class="p">,</span> <span class="n">trans_cfg</span><span class="o">-&gt;</span><span class="n">queue_to_fifo</span><span class="p">,</span>
	       <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">n_q_to_fifo</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u8</span><span class="p">));</span>

	<span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">rx_buf_size_8k</span> <span class="o">=</span> <span class="n">trans_cfg</span><span class="o">-&gt;</span><span class="n">rx_buf_size_8k</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">rx_buf_size_8k</span><span class="p">)</span>
		<span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">rx_page_order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">rx_page_order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">);</span>

	<span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">wd_timeout</span> <span class="o">=</span>
		<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">trans_cfg</span><span class="o">-&gt;</span><span class="n">queue_watchdog_timeout</span><span class="p">);</span>

	<span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">command_names</span> <span class="o">=</span> <span class="n">trans_cfg</span><span class="o">-&gt;</span><span class="n">command_names</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">iwl_trans_pcie_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span>
		<span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="n">iwl_trans_pcie_tx_free</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
<span class="cp">#ifndef CONFIG_IWLWIFI_IDI</span>
	<span class="n">iwl_trans_pcie_rx_free</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq_requested</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">trans</span><span class="p">);</span>
		<span class="n">iwl_free_isr_ict</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">hw_base</span><span class="p">);</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwl_trans_pcie_set_pmi</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">bool</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">STATUS_TPOWER_PMI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">STATUS_TPOWER_PMI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM_SLEEP</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_trans_pcie_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_trans_pcie_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">hw_rfkill</span><span class="p">;</span>

	<span class="n">iwl_enable_rfkill_int</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="n">hw_rfkill</span> <span class="o">=</span> <span class="n">iwl_is_rfkill_set</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="n">iwl_op_mode_hw_rf_kill</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">op_mode</span><span class="p">,</span> <span class="n">hw_rfkill</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw_rfkill</span><span class="p">)</span>
		<span class="n">iwl_enable_interrupts</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM_SLEEP */</span><span class="cp"></span>

<span class="cp">#define IWL_FLUSH_WAIT_MS	2000</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_trans_pcie_wait_tx_queue_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* waiting for all the tx frames complete might take a while */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">base_params</span><span class="o">-&gt;</span><span class="n">num_of_queues</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">cmd_queue</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">txq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">cnt</span><span class="p">];</span>
		<span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">read_ptr</span> <span class="o">!=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span>
		       <span class="n">now</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">IWL_FLUSH_WAIT_MS</span><span class="p">)))</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">read_ptr</span> <span class="o">!=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;fail to flush all tx fifo queues</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">get_fh_string</span><span class="p">(</span><span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#define IWL_CMD(x) case x: return #x</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">FH_RSCSR_CHNL0_STTS_WPTR_REG</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">FH_RSCSR_CHNL0_RBDCB_BASE_REG</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">FH_RSCSR_CHNL0_WPTR</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">FH_MEM_RCSR_CHNL0_CONFIG_REG</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">FH_MEM_RSSR_SHARED_CTRL_REG</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">FH_MEM_RSSR_RX_STATUS_REG</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">FH_MEM_RSSR_RX_ENABLE_ERR_IRQ2DRV</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">FH_TSSR_TX_STATUS_REG</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">FH_TSSR_TX_ERROR_REG</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="s">&quot;UNKNOWN&quot;</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#undef IWL_CMD</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">iwl_dump_fh</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">buf</span><span class="p">,</span> <span class="n">bool</span> <span class="n">display</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_IWLWIFI_DEBUG</span>
	<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">bufsz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">fh_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">FH_RSCSR_CHNL0_STTS_WPTR_REG</span><span class="p">,</span>
		<span class="n">FH_RSCSR_CHNL0_RBDCB_BASE_REG</span><span class="p">,</span>
		<span class="n">FH_RSCSR_CHNL0_WPTR</span><span class="p">,</span>
		<span class="n">FH_MEM_RCSR_CHNL0_CONFIG_REG</span><span class="p">,</span>
		<span class="n">FH_MEM_RSSR_SHARED_CTRL_REG</span><span class="p">,</span>
		<span class="n">FH_MEM_RSSR_RX_STATUS_REG</span><span class="p">,</span>
		<span class="n">FH_MEM_RSSR_RX_ENABLE_ERR_IRQ2DRV</span><span class="p">,</span>
		<span class="n">FH_TSSR_TX_STATUS_REG</span><span class="p">,</span>
		<span class="n">FH_TSSR_TX_ERROR_REG</span>
	<span class="p">};</span>
<span class="cp">#ifdef CONFIG_IWLWIFI_DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">display</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bufsz</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">fh_tbl</span><span class="p">)</span> <span class="o">*</span> <span class="mi">48</span> <span class="o">+</span> <span class="mi">40</span><span class="p">;</span>
		<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">bufsz</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">buf</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="o">*</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bufsz</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span>
				<span class="s">&quot;FH register values:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">fh_tbl</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pos</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="o">*</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bufsz</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span>
				<span class="s">&quot;  %34s: 0X%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">get_fh_string</span><span class="p">(</span><span class="n">fh_tbl</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
				<span class="n">iwl_read_direct32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">fh_tbl</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;FH register values:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span>  <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">fh_tbl</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;  %34s: 0X%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">get_fh_string</span><span class="p">(</span><span class="n">fh_tbl</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
			<span class="n">iwl_read_direct32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">fh_tbl</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">get_csr_string</span><span class="p">(</span><span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#define IWL_CMD(x) case x: return #x</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">CSR_HW_IF_CONFIG_REG</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">CSR_INT_COALESCING</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">CSR_INT</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">CSR_INT_MASK</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">CSR_FH_INT_STATUS</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">CSR_GPIO_IN</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">CSR_RESET</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">CSR_GP_CNTRL</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">CSR_HW_REV</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">CSR_EEPROM_REG</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">CSR_EEPROM_GP</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">CSR_OTP_GP_REG</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">CSR_GIO_REG</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">CSR_GP_UCODE_REG</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">CSR_GP_DRIVER_REG</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">CSR_UCODE_DRV_GP1</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">CSR_UCODE_DRV_GP2</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">CSR_LED_REG</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">CSR_DRAM_INT_TBL_REG</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">CSR_GIO_CHICKEN_BITS</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">CSR_ANA_PLL_CFG</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">CSR_HW_REV_WA_REG</span><span class="p">);</span>
	<span class="n">IWL_CMD</span><span class="p">(</span><span class="n">CSR_DBG_HPET_MEM_REG</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="s">&quot;UNKNOWN&quot;</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#undef IWL_CMD</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">iwl_dump_csr</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">csr_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">CSR_HW_IF_CONFIG_REG</span><span class="p">,</span>
		<span class="n">CSR_INT_COALESCING</span><span class="p">,</span>
		<span class="n">CSR_INT</span><span class="p">,</span>
		<span class="n">CSR_INT_MASK</span><span class="p">,</span>
		<span class="n">CSR_FH_INT_STATUS</span><span class="p">,</span>
		<span class="n">CSR_GPIO_IN</span><span class="p">,</span>
		<span class="n">CSR_RESET</span><span class="p">,</span>
		<span class="n">CSR_GP_CNTRL</span><span class="p">,</span>
		<span class="n">CSR_HW_REV</span><span class="p">,</span>
		<span class="n">CSR_EEPROM_REG</span><span class="p">,</span>
		<span class="n">CSR_EEPROM_GP</span><span class="p">,</span>
		<span class="n">CSR_OTP_GP_REG</span><span class="p">,</span>
		<span class="n">CSR_GIO_REG</span><span class="p">,</span>
		<span class="n">CSR_GP_UCODE_REG</span><span class="p">,</span>
		<span class="n">CSR_GP_DRIVER_REG</span><span class="p">,</span>
		<span class="n">CSR_UCODE_DRV_GP1</span><span class="p">,</span>
		<span class="n">CSR_UCODE_DRV_GP2</span><span class="p">,</span>
		<span class="n">CSR_LED_REG</span><span class="p">,</span>
		<span class="n">CSR_DRAM_INT_TBL_REG</span><span class="p">,</span>
		<span class="n">CSR_GIO_CHICKEN_BITS</span><span class="p">,</span>
		<span class="n">CSR_ANA_PLL_CFG</span><span class="p">,</span>
		<span class="n">CSR_HW_REV_WA_REG</span><span class="p">,</span>
		<span class="n">CSR_DBG_HPET_MEM_REG</span>
	<span class="p">};</span>
	<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;CSR values:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;(2nd byte of CSR_INT_COALESCING is &quot;</span>
		<span class="s">&quot;CSR_INT_PERIODIC_REG)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span>  <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">csr_tbl</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;  %25s: 0X%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">get_csr_string</span><span class="p">(</span><span class="n">csr_tbl</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
			<span class="n">iwl_read32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">csr_tbl</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_IWLWIFI_DEBUGFS</span>
<span class="cm">/* create and remove of files */</span>
<span class="cp">#define DEBUGFS_ADD_FILE(name, parent, mode) do {			\</span>
<span class="cp">	if (!debugfs_create_file(#name, mode, parent, trans,		\</span>
<span class="cp">				 &amp;iwl_dbgfs_##name##_ops))		\</span>
<span class="cp">		return -ENOMEM;						\</span>
<span class="cp">} while (0)</span>

<span class="cm">/* file operation */</span>
<span class="cp">#define DEBUGFS_READ_FUNC(name)                                         \</span>
<span class="cp">static ssize_t iwl_dbgfs_##name##_read(struct file *file,               \</span>
<span class="cp">					char __user *user_buf,          \</span>
<span class="cp">					size_t count, loff_t *ppos);</span>

<span class="cp">#define DEBUGFS_WRITE_FUNC(name)                                        \</span>
<span class="cp">static ssize_t iwl_dbgfs_##name##_write(struct file *file,              \</span>
<span class="cp">					const char __user *user_buf,    \</span>
<span class="cp">					size_t count, loff_t *ppos);</span>


<span class="cp">#define DEBUGFS_READ_FILE_OPS(name)					\</span>
<span class="cp">	DEBUGFS_READ_FUNC(name);					\</span>
<span class="cp">static const struct file_operations iwl_dbgfs_##name##_ops = {		\</span>
<span class="cp">	.read = iwl_dbgfs_##name##_read,				\</span>
<span class="cp">	.open = simple_open,						\</span>
<span class="cp">	.llseek = generic_file_llseek,					\</span>
<span class="cp">};</span>

<span class="cp">#define DEBUGFS_WRITE_FILE_OPS(name)                                    \</span>
<span class="cp">	DEBUGFS_WRITE_FUNC(name);                                       \</span>
<span class="cp">static const struct file_operations iwl_dbgfs_##name##_ops = {          \</span>
<span class="cp">	.write = iwl_dbgfs_##name##_write,                              \</span>
<span class="cp">	.open = simple_open,						\</span>
<span class="cp">	.llseek = generic_file_llseek,					\</span>
<span class="cp">};</span>

<span class="cp">#define DEBUGFS_READ_WRITE_FILE_OPS(name)				\</span>
<span class="cp">	DEBUGFS_READ_FUNC(name);					\</span>
<span class="cp">	DEBUGFS_WRITE_FUNC(name);					\</span>
<span class="cp">static const struct file_operations iwl_dbgfs_##name##_ops = {		\</span>
<span class="cp">	.write = iwl_dbgfs_##name##_write,				\</span>
<span class="cp">	.read = iwl_dbgfs_##name##_read,				\</span>
<span class="cp">	.open = simple_open,						\</span>
<span class="cp">	.llseek = generic_file_llseek,					\</span>
<span class="cp">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">iwl_dbgfs_tx_queue_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
						<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_buf</span><span class="p">,</span>
						<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">bufsz</span><span class="p">;</span>

	<span class="n">bufsz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="mi">64</span> <span class="o">*</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">base_params</span><span class="o">-&gt;</span><span class="n">num_of_queues</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">bufsz</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">base_params</span><span class="o">-&gt;</span><span class="n">num_of_queues</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">txq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">cnt</span><span class="p">];</span>
		<span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">;</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bufsz</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span>
				<span class="s">&quot;hwq %.2d: read=%u write=%u use=%d stop=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cnt</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">read_ptr</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span><span class="p">,</span>
				<span class="o">!!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">queue_used</span><span class="p">),</span>
				<span class="o">!!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">queue_stopped</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">user_buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">iwl_dbgfs_rx_queue_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
						<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_buf</span><span class="p">,</span>
						<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span>
		<span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_rx_queue</span> <span class="o">*</span><span class="n">rxq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">rxq</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">bufsz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

	<span class="n">pos</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bufsz</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span> <span class="s">&quot;read: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">rxq</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">);</span>
	<span class="n">pos</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bufsz</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span> <span class="s">&quot;write: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">rxq</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">);</span>
	<span class="n">pos</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bufsz</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span> <span class="s">&quot;free_count: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">rxq</span><span class="o">-&gt;</span><span class="n">free_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">rb_stts</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bufsz</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span> <span class="s">&quot;closed_rb_num: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rxq</span><span class="o">-&gt;</span><span class="n">rb_stts</span><span class="o">-&gt;</span><span class="n">closed_rb_num</span><span class="p">)</span> <span class="o">&amp;</span>  <span class="mh">0x0FFF</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bufsz</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span>
					<span class="s">&quot;closed_rb_num: Not Allocated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">user_buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">iwl_dbgfs_interrupt_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
					<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_buf</span><span class="p">,</span>
					<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span>
		<span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">isr_statistics</span> <span class="o">*</span><span class="n">isr_stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">isr_stats</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bufsz</span> <span class="o">=</span> <span class="mi">24</span> <span class="o">*</span> <span class="mi">64</span><span class="p">;</span> <span class="cm">/* 24 items * 64 char per item */</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">bufsz</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bufsz</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span>
			<span class="s">&quot;Interrupt Statistics Report:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">pos</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bufsz</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span> <span class="s">&quot;HW Error:</span><span class="se">\t\t\t</span><span class="s"> %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">isr_stats</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">pos</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bufsz</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span> <span class="s">&quot;SW Error:</span><span class="se">\t\t\t</span><span class="s"> %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">isr_stats</span><span class="o">-&gt;</span><span class="n">sw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isr_stats</span><span class="o">-&gt;</span><span class="n">sw</span> <span class="o">||</span> <span class="n">isr_stats</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bufsz</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span>
			<span class="s">&quot;</span><span class="se">\t</span><span class="s">Last Restarting Code:  0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">isr_stats</span><span class="o">-&gt;</span><span class="n">err_code</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_IWLWIFI_DEBUG</span>
	<span class="n">pos</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bufsz</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span> <span class="s">&quot;Frame transmitted:</span><span class="se">\t\t</span><span class="s"> %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">isr_stats</span><span class="o">-&gt;</span><span class="n">sch</span><span class="p">);</span>
	<span class="n">pos</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bufsz</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span> <span class="s">&quot;Alive interrupt:</span><span class="se">\t\t</span><span class="s"> %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">isr_stats</span><span class="o">-&gt;</span><span class="n">alive</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">pos</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bufsz</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span>
		<span class="s">&quot;HW RF KILL switch toggled:</span><span class="se">\t</span><span class="s"> %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">isr_stats</span><span class="o">-&gt;</span><span class="n">rfkill</span><span class="p">);</span>

	<span class="n">pos</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bufsz</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span> <span class="s">&quot;CT KILL:</span><span class="se">\t\t\t</span><span class="s"> %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">isr_stats</span><span class="o">-&gt;</span><span class="n">ctkill</span><span class="p">);</span>

	<span class="n">pos</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bufsz</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span> <span class="s">&quot;Wakeup Interrupt:</span><span class="se">\t\t</span><span class="s"> %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">isr_stats</span><span class="o">-&gt;</span><span class="n">wakeup</span><span class="p">);</span>

	<span class="n">pos</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bufsz</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span>
		<span class="s">&quot;Rx command responses:</span><span class="se">\t\t</span><span class="s"> %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">isr_stats</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">);</span>

	<span class="n">pos</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bufsz</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span> <span class="s">&quot;Tx/FH interrupt:</span><span class="se">\t\t</span><span class="s"> %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">isr_stats</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">);</span>

	<span class="n">pos</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bufsz</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span> <span class="s">&quot;Unexpected INTA:</span><span class="se">\t\t</span><span class="s"> %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">isr_stats</span><span class="o">-&gt;</span><span class="n">unhandled</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">user_buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">iwl_dbgfs_interrupt_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
					 <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_buf</span><span class="p">,</span>
					 <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span>
		<span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">isr_statistics</span> <span class="o">*</span><span class="n">isr_stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">isr_stats</span><span class="p">;</span>

	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">buf_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reset_flag</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
	<span class="n">buf_size</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">-</span>  <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">user_buf</span><span class="p">,</span> <span class="n">buf_size</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%x&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reset_flag</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reset_flag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">isr_stats</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">isr_stats</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">iwl_dbgfs_csr_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
					 <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_buf</span><span class="p">,</span>
					 <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">buf_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">csr</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
	<span class="n">buf_size</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">-</span>  <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">user_buf</span><span class="p">,</span> <span class="n">buf_size</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">csr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">iwl_dump_csr</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">iwl_dbgfs_fh_reg_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
					 <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_buf</span><span class="p">,</span>
					 <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">iwl_dump_fh</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">user_buf</span><span class="p">,</span>
					      <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">iwl_dbgfs_fw_restart_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
					  <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_buf</span><span class="p">,</span>
					  <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">op_mode</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="n">iwl_op_mode_nic_error</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">op_mode</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">DEBUGFS_READ_WRITE_FILE_OPS</span><span class="p">(</span><span class="n">interrupt</span><span class="p">);</span>
<span class="n">DEBUGFS_READ_FILE_OPS</span><span class="p">(</span><span class="n">fh_reg</span><span class="p">);</span>
<span class="n">DEBUGFS_READ_FILE_OPS</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">);</span>
<span class="n">DEBUGFS_READ_FILE_OPS</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">);</span>
<span class="n">DEBUGFS_WRITE_FILE_OPS</span><span class="p">(</span><span class="n">csr</span><span class="p">);</span>
<span class="n">DEBUGFS_WRITE_FILE_OPS</span><span class="p">(</span><span class="n">fw_restart</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Create the debugfs files and directories</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_trans_pcie_dbgfs_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEBUGFS_ADD_FILE</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">S_IRUSR</span><span class="p">);</span>
	<span class="n">DEBUGFS_ADD_FILE</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">S_IRUSR</span><span class="p">);</span>
	<span class="n">DEBUGFS_ADD_FILE</span><span class="p">(</span><span class="n">interrupt</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">S_IWUSR</span> <span class="o">|</span> <span class="n">S_IRUSR</span><span class="p">);</span>
	<span class="n">DEBUGFS_ADD_FILE</span><span class="p">(</span><span class="n">csr</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">);</span>
	<span class="n">DEBUGFS_ADD_FILE</span><span class="p">(</span><span class="n">fh_reg</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">S_IRUSR</span><span class="p">);</span>
	<span class="n">DEBUGFS_ADD_FILE</span><span class="p">(</span><span class="n">fw_restart</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_trans_pcie_dbgfs_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dir</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/*CONFIG_IWLWIFI_DEBUGFS */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iwl_trans_ops</span> <span class="n">trans_ops_pcie</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start_hw</span> <span class="o">=</span> <span class="n">iwl_trans_pcie_start_hw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop_hw</span> <span class="o">=</span> <span class="n">iwl_trans_pcie_stop_hw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fw_alive</span> <span class="o">=</span> <span class="n">iwl_trans_pcie_fw_alive</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start_fw</span> <span class="o">=</span> <span class="n">iwl_trans_pcie_start_fw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop_device</span> <span class="o">=</span> <span class="n">iwl_trans_pcie_stop_device</span><span class="p">,</span>

	<span class="p">.</span><span class="n">wowlan_suspend</span> <span class="o">=</span> <span class="n">iwl_trans_pcie_wowlan_suspend</span><span class="p">,</span>

	<span class="p">.</span><span class="n">send_cmd</span> <span class="o">=</span> <span class="n">iwl_trans_pcie_send_cmd</span><span class="p">,</span>

	<span class="p">.</span><span class="n">tx</span> <span class="o">=</span> <span class="n">iwl_trans_pcie_tx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reclaim</span> <span class="o">=</span> <span class="n">iwl_trans_pcie_reclaim</span><span class="p">,</span>

	<span class="p">.</span><span class="n">tx_agg_disable</span> <span class="o">=</span> <span class="n">iwl_trans_pcie_tx_agg_disable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tx_agg_setup</span> <span class="o">=</span> <span class="n">iwl_trans_pcie_tx_agg_setup</span><span class="p">,</span>

	<span class="p">.</span><span class="n">dbgfs_register</span> <span class="o">=</span> <span class="n">iwl_trans_pcie_dbgfs_register</span><span class="p">,</span>

	<span class="p">.</span><span class="n">wait_tx_queue_empty</span> <span class="o">=</span> <span class="n">iwl_trans_pcie_wait_tx_queue_empty</span><span class="p">,</span>

<span class="cp">#ifdef CONFIG_PM_SLEEP</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">iwl_trans_pcie_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">iwl_trans_pcie_resume</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">write8</span> <span class="o">=</span> <span class="n">iwl_trans_pcie_write8</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write32</span> <span class="o">=</span> <span class="n">iwl_trans_pcie_write32</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read32</span> <span class="o">=</span> <span class="n">iwl_trans_pcie_read32</span><span class="p">,</span>
	<span class="p">.</span><span class="n">configure</span> <span class="o">=</span> <span class="n">iwl_trans_pcie_configure</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_pmi</span> <span class="o">=</span> <span class="n">iwl_trans_pcie_set_pmi</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="nf">iwl_trans_pcie_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">iwl_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pci_cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">trans</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span><span class="p">)</span> <span class="o">+</span>
			     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans_pcie</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">trans</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trans_ops_pcie</span><span class="p">;</span>
	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">cfg</span> <span class="o">=</span> <span class="n">cfg</span><span class="p">;</span>
	<span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">trans</span> <span class="o">=</span> <span class="n">trans</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">ucode_write_waitq</span><span class="p">);</span>

	<span class="cm">/* W/A - seems to solve weird behavior. We need to remove this if we</span>
<span class="cm">	 * don&#39;t want to stay in L1 all the time. This wastes a lot of power */</span>
	<span class="n">pci_disable_link_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCIE_LINK_STATE_L0S</span> <span class="o">|</span> <span class="n">PCIE_LINK_STATE_L1</span> <span class="o">|</span>
				<span class="n">PCIE_LINK_STATE_CLKPM</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_no_pci</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">36</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">36</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
							<span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
		<span class="cm">/* both attempts failed: */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				   <span class="s">&quot;No suitable DMA available.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_pci_disable_device</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_request_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pci_request_regions failed&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_pci_disable_device</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">hw_base</span> <span class="o">=</span> <span class="n">pci_ioremap_bar</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">hw_base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pci_ioremap_bar failed&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_pci_release_regions</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;pci_resource_len = 0x%08llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
	<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;pci_resource_base = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">hw_base</span><span class="p">);</span>

	<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;HW Revision ID = 0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">);</span>

	<span class="cm">/* We disable the RETRY_TIMEOUT register (0x41) to keep</span>
<span class="cm">	 * PCI Tx retries from interfering with C3 CPU state */</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CFG_RETRY_TIMEOUT</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_msi</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;pci_enable_msi failed(0X%x)&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>

	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">hw_rev</span> <span class="o">=</span> <span class="n">iwl_read32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_HW_REV</span><span class="p">);</span>
	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">hw_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">;</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">hw_id_str</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">hw_id_str</span><span class="p">),</span>
		 <span class="s">&quot;PCI ID: 0x%04X:0x%04X&quot;</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">);</span>

	<span class="cm">/* TODO: Move this away, not needed if not MSI */</span>
	<span class="cm">/* enable rfkill interrupt: hw bug w/a */</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_cmd</span> <span class="o">&amp;</span> <span class="n">PCI_COMMAND_INTX_DISABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_cmd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_COMMAND_INTX_DISABLE</span><span class="p">;</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="n">pci_cmd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize the wait queue for commands */</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">wait_command_queue</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">trans</span><span class="p">;</span>

<span class="nl">out_pci_release_regions:</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="nl">out_pci_disable_device:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="nl">out_no_pci:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
