<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › iwlwifi › iwl-trans-pcie-int.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>iwl-trans-pcie-int.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2003 - 2012 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Portions of this file are derived from the ipw3945 project, as well</span>
<span class="cm"> * as portions of the ieee80211 subsystem header files.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of version 2 of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA</span>
<span class="cm"> *</span>
<span class="cm"> * The full GNU General Public License is included in this distribution in the</span>
<span class="cm"> * file called LICENSE.</span>
<span class="cm"> *</span>
<span class="cm"> * Contact Information:</span>
<span class="cm"> *  Intel Linux Wireless &lt;ilw@linux.intel.com&gt;</span>
<span class="cm"> * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>
<span class="cp">#ifndef __iwl_trans_int_pcie_h__</span>
<span class="cp">#define __iwl_trans_int_pcie_h__</span>

<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>

<span class="cp">#include &quot;iwl-fh.h&quot;</span>
<span class="cp">#include &quot;iwl-csr.h&quot;</span>
<span class="cp">#include &quot;iwl-trans.h&quot;</span>
<span class="cp">#include &quot;iwl-debug.h&quot;</span>
<span class="cp">#include &quot;iwl-io.h&quot;</span>
<span class="cp">#include &quot;iwl-op-mode.h&quot;</span>

<span class="k">struct</span> <span class="n">iwl_host_cmd</span><span class="p">;</span>

<span class="cm">/*This file includes the declaration that are internal to the</span>
<span class="cm"> * trans_pcie layer */</span>

<span class="k">struct</span> <span class="n">iwl_rx_mem_buffer</span> <span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">page_dma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct isr_statistics - interrupt statistics</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">isr_statistics</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">err_code</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sch</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">alive</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rfkill</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctkill</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">wakeup</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">unhandled</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct iwl_rx_queue - Rx queue</span>
<span class="cm"> * @bd: driver&#39;s pointer to buffer of receive buffer descriptors (rbd)</span>
<span class="cm"> * @bd_dma: bus address of buffer of receive buffer descriptors (rbd)</span>
<span class="cm"> * @pool:</span>
<span class="cm"> * @queue:</span>
<span class="cm"> * @read: Shared index to newest available Rx buffer</span>
<span class="cm"> * @write: Shared index to oldest written Rx packet</span>
<span class="cm"> * @free_count: Number of pre-allocated buffers in rx_free</span>
<span class="cm"> * @write_actual:</span>
<span class="cm"> * @rx_free: list of free SKBs for use</span>
<span class="cm"> * @rx_used: List of Rx buffers with no SKB</span>
<span class="cm"> * @need_update: flag to indicate we need to update read/write index</span>
<span class="cm"> * @rb_stts: driver&#39;s pointer to receive buffer status</span>
<span class="cm"> * @rb_stts_dma: bus address of receive buffer status</span>
<span class="cm"> * @lock:</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  rx_free and rx_used are used as a FIFO for iwl_rx_mem_buffers</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_rx_queue</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">bd</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">bd_dma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_rx_mem_buffer</span> <span class="n">pool</span><span class="p">[</span><span class="n">RX_QUEUE_SIZE</span> <span class="o">+</span> <span class="n">RX_FREE_BUFFERS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">iwl_rx_mem_buffer</span> <span class="o">*</span><span class="n">queue</span><span class="p">[</span><span class="n">RX_QUEUE_SIZE</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">read</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">write</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">free_count</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">write_actual</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rx_free</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rx_used</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">need_update</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_rb_status</span> <span class="o">*</span><span class="n">rb_stts</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">rb_stts_dma</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">iwl_dma_ptr</span> <span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">dma</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * iwl_queue_inc_wrap - increment queue index, wrap back to beginning</span>
<span class="cm"> * @index -- current index</span>
<span class="cm"> * @n_bd -- total number of entries in queue (must be power of 2)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">iwl_queue_inc_wrap</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n_bd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">++</span><span class="n">index</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n_bd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iwl_queue_dec_wrap - decrement queue index, wrap back to end</span>
<span class="cm"> * @index -- current index</span>
<span class="cm"> * @n_bd -- total number of entries in queue (must be power of 2)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">iwl_queue_dec_wrap</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n_bd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">--</span><span class="n">index</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n_bd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">iwl_cmd_meta</span> <span class="p">{</span>
	<span class="cm">/* only for SYNC commands, iff the reply skb is wanted */</span>
	<span class="k">struct</span> <span class="n">iwl_host_cmd</span> <span class="o">*</span><span class="n">source</span><span class="p">;</span>

	<span class="n">DEFINE_DMA_UNMAP_ADDR</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
	<span class="n">DEFINE_DMA_UNMAP_LEN</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>

	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Generic queue structure</span>
<span class="cm"> *</span>
<span class="cm"> * Contains common data for Rx and Tx queues.</span>
<span class="cm"> *</span>
<span class="cm"> * Note the difference between n_bd and n_window: the hardware</span>
<span class="cm"> * always assumes 256 descriptors, so n_bd is always 256 (unless</span>
<span class="cm"> * there might be HW changes in the future). For the normal TX</span>
<span class="cm"> * queues, n_window, which is the size of the software queue data</span>
<span class="cm"> * is also 256; however, for the command queue, n_window is only</span>
<span class="cm"> * 32 since we don&#39;t need so many commands pending. Since the HW</span>
<span class="cm"> * still uses 256 BDs for DMA though, n_bd stays 256. As a result,</span>
<span class="cm"> * the software buffers (in the variables @meta, @txb in struct</span>
<span class="cm"> * iwl_tx_queue) only have 32 entries, while the HW buffers (@tfds</span>
<span class="cm"> * in the same struct) have 256.</span>
<span class="cm"> * This means that we end up with the following:</span>
<span class="cm"> *  HW entries: | 0 | ... | N * 32 | ... | N * 32 + 31 | ... | 255 |</span>
<span class="cm"> *  SW entries:           | 0      | ... | 31          |</span>
<span class="cm"> * where N is a number between 0 and 7. This means that the SW</span>
<span class="cm"> * data is a window overlayed over the HW queue.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_queue</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">n_bd</span><span class="p">;</span>              <span class="cm">/* number of BDs in this queue */</span>
	<span class="kt">int</span> <span class="n">write_ptr</span><span class="p">;</span>       <span class="cm">/* 1-st empty entry (index) host_w*/</span>
	<span class="kt">int</span> <span class="n">read_ptr</span><span class="p">;</span>         <span class="cm">/* last used entry (index) host_r*/</span>
	<span class="cm">/* use for monitoring and recovering the stuck queue */</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">;</span>   <span class="cm">/* physical addr for BD&#39;s */</span>
	<span class="kt">int</span> <span class="n">n_window</span><span class="p">;</span>	       <span class="cm">/* safe queue window */</span>
	<span class="n">u32</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">low_mark</span><span class="p">;</span>	       <span class="cm">/* low watermark, resume queue if free</span>
<span class="cm">				* space more than this */</span>
	<span class="kt">int</span> <span class="n">high_mark</span><span class="p">;</span>         <span class="cm">/* high watermark, stop queue if free</span>
<span class="cm">				* space less than this */</span>
<span class="p">};</span>

<span class="cp">#define TFD_TX_CMD_SLOTS 256</span>
<span class="cp">#define TFD_CMD_SLOTS 32</span>

<span class="k">struct</span> <span class="n">iwl_pcie_tx_queue_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_device_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_cmd_meta</span> <span class="n">meta</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct iwl_tx_queue - Tx Queue for DMA</span>
<span class="cm"> * @q: generic Rx/Tx queue descriptor</span>
<span class="cm"> * @tfds: transmit frame descriptors (DMA memory)</span>
<span class="cm"> * @entries: transmit entries (driver state)</span>
<span class="cm"> * @lock: queue lock</span>
<span class="cm"> * @stuck_timer: timer that fires if queue gets stuck</span>
<span class="cm"> * @trans_pcie: pointer back to transport (for timer)</span>
<span class="cm"> * @need_update: indicates need to update read/write index</span>
<span class="cm"> * @active: stores if queue is active</span>
<span class="cm"> *</span>
<span class="cm"> * A Tx queue consists of circular buffer of BDs (a.k.a. TFDs, transmit frame</span>
<span class="cm"> * descriptors) and required locking structures.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_queue</span> <span class="n">q</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_tfd</span> <span class="o">*</span><span class="n">tfds</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_pcie_tx_queue_entry</span> <span class="o">*</span><span class="n">entries</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">stuck_timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">need_update</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">active</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct iwl_trans_pcie - PCIe transport specific data</span>
<span class="cm"> * @rxq: all the RX queue data</span>
<span class="cm"> * @rx_replenish: work that will be called when buffers need to be allocated</span>
<span class="cm"> * @drv - pointer to iwl_drv</span>
<span class="cm"> * @trans: pointer to the generic transport area</span>
<span class="cm"> * @irq - the irq number for the device</span>
<span class="cm"> * @irq_requested: true when the irq has been requested</span>
<span class="cm"> * @scd_base_addr: scheduler sram base address in SRAM</span>
<span class="cm"> * @scd_bc_tbls: pointer to the byte count table of the scheduler</span>
<span class="cm"> * @kw: keep warm address</span>
<span class="cm"> * @pci_dev: basic pci-network driver stuff</span>
<span class="cm"> * @hw_base: pci hardware address support</span>
<span class="cm"> * @ucode_write_complete: indicates that the ucode has been copied.</span>
<span class="cm"> * @ucode_write_waitq: wait queue for uCode load</span>
<span class="cm"> * @status - transport specific status flags</span>
<span class="cm"> * @cmd_queue - command queue number</span>
<span class="cm"> * @rx_buf_size_8k: 8 kB RX buffer size</span>
<span class="cm"> * @rx_page_order: page order for receive buffer size</span>
<span class="cm"> * @wd_timeout: queue watchdog timeout (jiffies)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_rx_queue</span> <span class="n">rxq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">rx_replenish</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_drv</span> <span class="o">*</span><span class="n">drv</span><span class="p">;</span>

	<span class="cm">/* INT ICT Table */</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">ict_tbl</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">ict_tbl_dma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ict_index</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">inta</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">use_ict</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">irq_requested</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">irq_tasklet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isr_statistics</span> <span class="n">isr_stats</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">irq_lock</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">inta_mask</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">scd_base_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_dma_ptr</span> <span class="n">scd_bc_tbls</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_dma_ptr</span> <span class="n">kw</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">queue_used</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">IWL_MAX_HW_QUEUES</span><span class="p">)];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">queue_stopped</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">IWL_MAX_HW_QUEUES</span><span class="p">)];</span>

	<span class="cm">/* PCI bus related data */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">hw_base</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">ucode_write_complete</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">ucode_write_waitq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cmd_queue</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">n_no_reclaim_cmds</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">no_reclaim_cmds</span><span class="p">[</span><span class="n">MAX_NO_RECLAIM_CMDS</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">setup_q_to_fifo</span><span class="p">[</span><span class="n">IWL_MAX_HW_QUEUES</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">n_q_to_fifo</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">rx_buf_size_8k</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rx_page_order</span><span class="p">;</span>

	<span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">command_names</span><span class="p">;</span>

	<span class="cm">/* queue watchdog */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">wd_timeout</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*****************************************************</span>
<span class="cm">* DRIVER STATUS FUNCTIONS</span>
<span class="cm">******************************************************/</span>
<span class="cp">#define STATUS_HCMD_ACTIVE	0</span>
<span class="cp">#define STATUS_DEVICE_ENABLED	1</span>
<span class="cp">#define STATUS_TPOWER_PMI	2</span>
<span class="cp">#define STATUS_INT_ENABLED	3</span>

<span class="cp">#define IWL_TRANS_GET_PCIE_TRANS(_iwl_trans) \</span>
<span class="cp">	((struct iwl_trans_pcie *) ((_iwl_trans)-&gt;trans_specific))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span>
<span class="nf">iwl_trans_pcie_get_trans</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">trans_pcie</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwl_trans</span><span class="p">,</span>
			    <span class="n">trans_specific</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">iwl_trans_pcie_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">iwl_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">iwl_trans_pcie_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">);</span>

<span class="cm">/*****************************************************</span>
<span class="cm">* RX</span>
<span class="cm">******************************************************/</span>
<span class="kt">void</span> <span class="n">iwl_bg_rx_replenish</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">iwl_irq_tasklet</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">iwlagn_rx_replenish</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">iwl_rx_queue_update_write_ptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">iwl_rx_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>

<span class="cm">/*****************************************************</span>
<span class="cm">* ICT</span>
<span class="cm">******************************************************/</span>
<span class="kt">void</span> <span class="n">iwl_reset_ict</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">iwl_disable_ict</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">iwl_alloc_isr_ict</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">iwl_free_isr_ict</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">);</span>
<span class="n">irqreturn_t</span> <span class="n">iwl_isr_ict</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="cm">/*****************************************************</span>
<span class="cm">* TX / HCMD</span>
<span class="cm">******************************************************/</span>
<span class="kt">void</span> <span class="n">iwl_txq_update_write_ptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">iwlagn_txq_attach_buf_to_tfd</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">,</span>
				 <span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u16</span> <span class="n">len</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reset</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">iwl_queue_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slots_num</span><span class="p">,</span> <span class="n">u32</span> <span class="n">id</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">iwl_trans_pcie_send_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwl_host_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">iwl_tx_cmd_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">iwl_rx_cmd_buffer</span> <span class="o">*</span><span class="n">rxb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">handler_status</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">iwl_trans_txq_update_byte_cnt_tbl</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">,</span>
					   <span class="n">u16</span> <span class="n">byte_cnt</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">iwl_trans_pcie_tx_agg_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">iwl_trans_set_wr_ptrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="kt">int</span> <span class="n">txq_id</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">iwl_trans_tx_queue_set_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">tx_fifo_id</span><span class="p">,</span> <span class="n">bool</span> <span class="n">active</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">iwl_trans_pcie_tx_agg_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fifo</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">sta_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">frame_limit</span><span class="p">,</span> <span class="n">u16</span> <span class="n">ssn</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">iwlagn_txq_free_tfd</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">,</span>
			 <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dma_dir</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">iwl_tx_queue_reclaim</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="kt">int</span> <span class="n">txq_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">skbs</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">iwl_queue_space</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">iwl_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>

<span class="cm">/*****************************************************</span>
<span class="cm">* Error handling</span>
<span class="cm">******************************************************/</span>
<span class="kt">int</span> <span class="n">iwl_dump_fh</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">buf</span><span class="p">,</span> <span class="n">bool</span> <span class="n">display</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">iwl_dump_csr</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">);</span>

<span class="cm">/*****************************************************</span>
<span class="cm">* Helpers</span>
<span class="cm">******************************************************/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iwl_disable_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">STATUS_INT_ENABLED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>

	<span class="cm">/* disable interrupts from uCode/NIC to host */</span>
	<span class="n">iwl_write32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_INT_MASK</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">);</span>

	<span class="cm">/* acknowledge/clear/reset any interrupts still pending</span>
<span class="cm">	 * from uCode or flow handler (Rx/Tx DMA) */</span>
	<span class="n">iwl_write32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_INT</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
	<span class="n">iwl_write32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_FH_INT_STATUS</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
	<span class="n">IWL_DEBUG_ISR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Disabled interrupts</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iwl_enable_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="n">IWL_DEBUG_ISR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Enabling interrupts</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">STATUS_INT_ENABLED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="n">iwl_write32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_INT_MASK</span><span class="p">,</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">inta_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iwl_enable_rfkill_int</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IWL_DEBUG_ISR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Enabling rfkill interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">iwl_write32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_INT_MASK</span><span class="p">,</span> <span class="n">CSR_INT_BIT_RF_KILL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iwl_wake_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">queue_stopped</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IWL_DEBUG_TX_QUEUES</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Wake hwq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>
		<span class="n">iwl_op_mode_queue_not_full</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">op_mode</span><span class="p">,</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iwl_stop_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">queue_stopped</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">iwl_op_mode_queue_full</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">op_mode</span><span class="p">,</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>
		<span class="n">IWL_DEBUG_TX_QUEUES</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Stop hwq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">IWL_DEBUG_TX_QUEUES</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;hwq %d already stopped</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">iwl_queue_used</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">iwl_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">read_ptr</span> <span class="o">?</span>
		<span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">read_ptr</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span><span class="p">)</span> <span class="o">:</span>
		<span class="o">!</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">read_ptr</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">get_cmd_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">index</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">n_window</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">trans_pcie_get_cmd_string</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span><span class="p">,</span> <span class="n">u8</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">command_names</span> <span class="o">||</span> <span class="o">!</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">command_names</span><span class="p">[</span><span class="n">cmd</span><span class="p">])</span>
		<span class="k">return</span> <span class="s">&quot;UNKNOWN&quot;</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">command_names</span><span class="p">[</span><span class="n">cmd</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">iwl_is_rfkill_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">iwl_read32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_GP_CNTRL</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="n">CSR_GP_CNTRL_REG_FLAG_HW_RF_KILL_SW</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* __iwl_trans_int_pcie_h__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
