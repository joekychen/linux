<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › iwlwifi › iwl-fh.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>iwl-fh.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * This file is provided under a dual BSD/GPLv2 license.  When using or</span>
<span class="cm"> * redistributing this file, you may do so under either license.</span>
<span class="cm"> *</span>
<span class="cm"> * GPL LICENSE SUMMARY</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2005 - 2012 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of version 2 of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,</span>
<span class="cm"> * USA</span>
<span class="cm"> *</span>
<span class="cm"> * The full GNU General Public License is included in this distribution</span>
<span class="cm"> * in the file called LICENSE.GPL.</span>
<span class="cm"> *</span>
<span class="cm"> * Contact Information:</span>
<span class="cm"> *  Intel Linux Wireless &lt;ilw@linux.intel.com&gt;</span>
<span class="cm"> * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>
<span class="cm"> *</span>
<span class="cm"> * BSD LICENSE</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2005 - 2012 Intel Corporation. All rights reserved.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> *</span>
<span class="cm"> *  * Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *  * Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer in</span>
<span class="cm"> *    the documentation and/or other materials provided with the</span>
<span class="cm"> *    distribution.</span>
<span class="cm"> *  * Neither the name Intel Corporation nor the names of its</span>
<span class="cm"> *    contributors may be used to endorse or promote products derived</span>
<span class="cm"> *    from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="cm"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="cm"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="cm"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="cm"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>
<span class="cp">#ifndef __iwl_fh_h__</span>
<span class="cp">#define __iwl_fh_h__</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cm">/****************************/</span>
<span class="cm">/* Flow Handler Definitions */</span>
<span class="cm">/****************************/</span>

<span class="cm">/**</span>
<span class="cm"> * This I/O area is directly read/writable by driver (e.g. Linux uses writel())</span>
<span class="cm"> * Addresses are offsets from device&#39;s PCI hardware base address.</span>
<span class="cm"> */</span>
<span class="cp">#define FH_MEM_LOWER_BOUND                   (0x1000)</span>
<span class="cp">#define FH_MEM_UPPER_BOUND                   (0x2000)</span>

<span class="cm">/**</span>
<span class="cm"> * Keep-Warm (KW) buffer base address.</span>
<span class="cm"> *</span>
<span class="cm"> * Driver must allocate a 4KByte buffer that is for keeping the</span>
<span class="cm"> * host DRAM powered on (via dummy accesses to DRAM) to maintain low-latency</span>
<span class="cm"> * DRAM access when doing Txing or Rxing.  The dummy accesses prevent host</span>
<span class="cm"> * from going into a power-savings mode that would cause higher DRAM latency,</span>
<span class="cm"> * and possible data over/under-runs, before all Tx/Rx is complete.</span>
<span class="cm"> *</span>
<span class="cm"> * Driver loads FH_KW_MEM_ADDR_REG with the physical address (bits 35:4)</span>
<span class="cm"> * of the buffer, which must be 4K aligned.  Once this is set up, the device</span>
<span class="cm"> * automatically invokes keep-warm accesses when normal accesses might not</span>
<span class="cm"> * be sufficient to maintain fast DRAM response.</span>
<span class="cm"> *</span>
<span class="cm"> * Bit fields:</span>
<span class="cm"> *  31-0:  Keep-warm buffer physical base address [35:4], must be 4K aligned</span>
<span class="cm"> */</span>
<span class="cp">#define FH_KW_MEM_ADDR_REG		     (FH_MEM_LOWER_BOUND + 0x97C)</span>


<span class="cm">/**</span>
<span class="cm"> * TFD Circular Buffers Base (CBBC) addresses</span>
<span class="cm"> *</span>
<span class="cm"> * Device has 16 base pointer registers, one for each of 16 host-DRAM-resident</span>
<span class="cm"> * circular buffers (CBs/queues) containing Transmit Frame Descriptors (TFDs)</span>
<span class="cm"> * (see struct iwl_tfd_frame).  These 16 pointer registers are offset by 0x04</span>
<span class="cm"> * bytes from one another.  Each TFD circular buffer in DRAM must be 256-byte</span>
<span class="cm"> * aligned (address bits 0-7 must be 0).</span>
<span class="cm"> * Later devices have 20 (5000 series) or 30 (higher) queues, but the registers</span>
<span class="cm"> * for them are in different places.</span>
<span class="cm"> *</span>
<span class="cm"> * Bit fields in each pointer register:</span>
<span class="cm"> *  27-0: TFD CB physical base address [35:8], must be 256-byte aligned</span>
<span class="cm"> */</span>
<span class="cp">#define FH_MEM_CBBC_0_15_LOWER_BOUND		(FH_MEM_LOWER_BOUND + 0x9D0)</span>
<span class="cp">#define FH_MEM_CBBC_0_15_UPPER_BOUND		(FH_MEM_LOWER_BOUND + 0xA10)</span>
<span class="cp">#define FH_MEM_CBBC_16_19_LOWER_BOUND		(FH_MEM_LOWER_BOUND + 0xBF0)</span>
<span class="cp">#define FH_MEM_CBBC_16_19_UPPER_BOUND		(FH_MEM_LOWER_BOUND + 0xC00)</span>
<span class="cp">#define FH_MEM_CBBC_20_31_LOWER_BOUND		(FH_MEM_LOWER_BOUND + 0xB20)</span>
<span class="cp">#define FH_MEM_CBBC_20_31_UPPER_BOUND		(FH_MEM_LOWER_BOUND + 0xB80)</span>

<span class="cm">/* Find TFD CB base pointer for given queue */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">FH_MEM_CBBC_QUEUE</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chnl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chnl</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">FH_MEM_CBBC_0_15_LOWER_BOUND</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">chnl</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chnl</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">FH_MEM_CBBC_16_19_LOWER_BOUND</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">chnl</span> <span class="o">-</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">chnl</span> <span class="o">&gt;=</span> <span class="mi">32</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">FH_MEM_CBBC_20_31_LOWER_BOUND</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">chnl</span> <span class="o">-</span> <span class="mi">20</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * Rx SRAM Control and Status Registers (RSCSR)</span>
<span class="cm"> *</span>
<span class="cm"> * These registers provide handshake between driver and device for the Rx queue</span>
<span class="cm"> * (this queue handles *all* command responses, notifications, Rx data, etc.</span>
<span class="cm"> * sent from uCode to host driver).  Unlike Tx, there is only one Rx</span>
<span class="cm"> * queue, and only one Rx DMA/FIFO channel.  Also unlike Tx, which can</span>
<span class="cm"> * concatenate up to 20 DRAM buffers to form a Tx frame, each Receive Buffer</span>
<span class="cm"> * Descriptor (RBD) points to only one Rx Buffer (RB); there is a 1:1</span>
<span class="cm"> * mapping between RBDs and RBs.</span>
<span class="cm"> *</span>
<span class="cm"> * Driver must allocate host DRAM memory for the following, and set the</span>
<span class="cm"> * physical address of each into device registers:</span>
<span class="cm"> *</span>
<span class="cm"> * 1)  Receive Buffer Descriptor (RBD) circular buffer (CB), typically with 256</span>
<span class="cm"> *     entries (although any power of 2, up to 4096, is selectable by driver).</span>
<span class="cm"> *     Each entry (1 dword) points to a receive buffer (RB) of consistent size</span>
<span class="cm"> *     (typically 4K, although 8K or 16K are also selectable by driver).</span>
<span class="cm"> *     Driver sets up RB size and number of RBDs in the CB via Rx config</span>
<span class="cm"> *     register FH_MEM_RCSR_CHNL0_CONFIG_REG.</span>
<span class="cm"> *</span>
<span class="cm"> *     Bit fields within one RBD:</span>
<span class="cm"> *     27-0:  Receive Buffer physical address bits [35:8], 256-byte aligned</span>
<span class="cm"> *</span>
<span class="cm"> *     Driver sets physical address [35:8] of base of RBD circular buffer</span>
<span class="cm"> *     into FH_RSCSR_CHNL0_RBDCB_BASE_REG [27:0].</span>
<span class="cm"> *</span>
<span class="cm"> * 2)  Rx status buffer, 8 bytes, in which uCode indicates which Rx Buffers</span>
<span class="cm"> *     (RBs) have been filled, via a &quot;write pointer&quot;, actually the index of</span>
<span class="cm"> *     the RB&#39;s corresponding RBD within the circular buffer.  Driver sets</span>
<span class="cm"> *     physical address [35:4] into FH_RSCSR_CHNL0_STTS_WPTR_REG [31:0].</span>
<span class="cm"> *</span>
<span class="cm"> *     Bit fields in lower dword of Rx status buffer (upper dword not used</span>
<span class="cm"> *     by driver:</span>
<span class="cm"> *     31-12:  Not used by driver</span>
<span class="cm"> *     11- 0:  Index of last filled Rx buffer descriptor</span>
<span class="cm"> *             (device writes, driver reads this value)</span>
<span class="cm"> *</span>
<span class="cm"> * As the driver prepares Receive Buffers (RBs) for device to fill, driver must</span>
<span class="cm"> * enter pointers to these RBs into contiguous RBD circular buffer entries,</span>
<span class="cm"> * and update the device&#39;s &quot;write&quot; index register,</span>
<span class="cm"> * FH_RSCSR_CHNL0_RBDCB_WPTR_REG.</span>
<span class="cm"> *</span>
<span class="cm"> * This &quot;write&quot; index corresponds to the *next* RBD that the driver will make</span>
<span class="cm"> * available, i.e. one RBD past the tail of the ready-to-fill RBDs within</span>
<span class="cm"> * the circular buffer.  This value should initially be 0 (before preparing any</span>
<span class="cm"> * RBs), should be 8 after preparing the first 8 RBs (for example), and must</span>
<span class="cm"> * wrap back to 0 at the end of the circular buffer (but don&#39;t wrap before</span>
<span class="cm"> * &quot;read&quot; index has advanced past 1!  See below).</span>
<span class="cm"> * NOTE:  DEVICE EXPECTS THE WRITE INDEX TO BE INCREMENTED IN MULTIPLES OF 8.</span>
<span class="cm"> *</span>
<span class="cm"> * As the device fills RBs (referenced from contiguous RBDs within the circular</span>
<span class="cm"> * buffer), it updates the Rx status buffer in host DRAM, 2) described above,</span>
<span class="cm"> * to tell the driver the index of the latest filled RBD.  The driver must</span>
<span class="cm"> * read this &quot;read&quot; index from DRAM after receiving an Rx interrupt from device</span>
<span class="cm"> *</span>
<span class="cm"> * The driver must also internally keep track of a third index, which is the</span>
<span class="cm"> * next RBD to process.  When receiving an Rx interrupt, driver should process</span>
<span class="cm"> * all filled but unprocessed RBs up to, but not including, the RB</span>
<span class="cm"> * corresponding to the &quot;read&quot; index.  For example, if &quot;read&quot; index becomes &quot;1&quot;,</span>
<span class="cm"> * driver may process the RB pointed to by RBD 0.  Depending on volume of</span>
<span class="cm"> * traffic, there may be many RBs to process.</span>
<span class="cm"> *</span>
<span class="cm"> * If read index == write index, device thinks there is no room to put new data.</span>
<span class="cm"> * Due to this, the maximum number of filled RBs is 255, instead of 256.  To</span>
<span class="cm"> * be safe, make sure that there is a gap of at least 2 RBDs between &quot;write&quot;</span>
<span class="cm"> * and &quot;read&quot; indexes; that is, make sure that there are no more than 254</span>
<span class="cm"> * buffers waiting to be filled.</span>
<span class="cm"> */</span>
<span class="cp">#define FH_MEM_RSCSR_LOWER_BOUND	(FH_MEM_LOWER_BOUND + 0xBC0)</span>
<span class="cp">#define FH_MEM_RSCSR_UPPER_BOUND	(FH_MEM_LOWER_BOUND + 0xC00)</span>
<span class="cp">#define FH_MEM_RSCSR_CHNL0		(FH_MEM_RSCSR_LOWER_BOUND)</span>

<span class="cm">/**</span>
<span class="cm"> * Physical base address of 8-byte Rx Status buffer.</span>
<span class="cm"> * Bit fields:</span>
<span class="cm"> *  31-0: Rx status buffer physical base address [35:4], must 16-byte aligned.</span>
<span class="cm"> */</span>
<span class="cp">#define FH_RSCSR_CHNL0_STTS_WPTR_REG	(FH_MEM_RSCSR_CHNL0)</span>

<span class="cm">/**</span>
<span class="cm"> * Physical base address of Rx Buffer Descriptor Circular Buffer.</span>
<span class="cm"> * Bit fields:</span>
<span class="cm"> *  27-0:  RBD CD physical base address [35:8], must be 256-byte aligned.</span>
<span class="cm"> */</span>
<span class="cp">#define FH_RSCSR_CHNL0_RBDCB_BASE_REG	(FH_MEM_RSCSR_CHNL0 + 0x004)</span>

<span class="cm">/**</span>
<span class="cm"> * Rx write pointer (index, really!).</span>
<span class="cm"> * Bit fields:</span>
<span class="cm"> *  11-0:  Index of driver&#39;s most recent prepared-to-be-filled RBD, + 1.</span>
<span class="cm"> *         NOTE:  For 256-entry circular buffer, use only bits [7:0].</span>
<span class="cm"> */</span>
<span class="cp">#define FH_RSCSR_CHNL0_RBDCB_WPTR_REG	(FH_MEM_RSCSR_CHNL0 + 0x008)</span>
<span class="cp">#define FH_RSCSR_CHNL0_WPTR        (FH_RSCSR_CHNL0_RBDCB_WPTR_REG)</span>


<span class="cm">/**</span>
<span class="cm"> * Rx Config/Status Registers (RCSR)</span>
<span class="cm"> * Rx Config Reg for channel 0 (only channel used)</span>
<span class="cm"> *</span>
<span class="cm"> * Driver must initialize FH_MEM_RCSR_CHNL0_CONFIG_REG as follows for</span>
<span class="cm"> * normal operation (see bit fields).</span>
<span class="cm"> *</span>
<span class="cm"> * Clearing FH_MEM_RCSR_CHNL0_CONFIG_REG to 0 turns off Rx DMA.</span>
<span class="cm"> * Driver should poll FH_MEM_RSSR_RX_STATUS_REG	for</span>
<span class="cm"> * FH_RSSR_CHNL0_RX_STATUS_CHNL_IDLE (bit 24) before continuing.</span>
<span class="cm"> *</span>
<span class="cm"> * Bit fields:</span>
<span class="cm"> * 31-30: Rx DMA channel enable: &#39;00&#39; off/pause, &#39;01&#39; pause at end of frame,</span>
<span class="cm"> *        &#39;10&#39; operate normally</span>
<span class="cm"> * 29-24: reserved</span>
<span class="cm"> * 23-20: # RBDs in circular buffer = 2^value; use &quot;8&quot; for 256 RBDs (normal),</span>
<span class="cm"> *        min &quot;5&quot; for 32 RBDs, max &quot;12&quot; for 4096 RBDs.</span>
<span class="cm"> * 19-18: reserved</span>
<span class="cm"> * 17-16: size of each receive buffer; &#39;00&#39; 4K (normal), &#39;01&#39; 8K,</span>
<span class="cm"> *        &#39;10&#39; 12K, &#39;11&#39; 16K.</span>
<span class="cm"> * 15-14: reserved</span>
<span class="cm"> * 13-12: IRQ destination; &#39;00&#39; none, &#39;01&#39; host driver (normal operation)</span>
<span class="cm"> * 11- 4: timeout for closing Rx buffer and interrupting host (units 32 usec)</span>
<span class="cm"> *        typical value 0x10 (about 1/2 msec)</span>
<span class="cm"> *  3- 0: reserved</span>
<span class="cm"> */</span>
<span class="cp">#define FH_MEM_RCSR_LOWER_BOUND      (FH_MEM_LOWER_BOUND + 0xC00)</span>
<span class="cp">#define FH_MEM_RCSR_UPPER_BOUND      (FH_MEM_LOWER_BOUND + 0xCC0)</span>
<span class="cp">#define FH_MEM_RCSR_CHNL0            (FH_MEM_RCSR_LOWER_BOUND)</span>

<span class="cp">#define FH_MEM_RCSR_CHNL0_CONFIG_REG	(FH_MEM_RCSR_CHNL0)</span>

<span class="cp">#define FH_RCSR_CHNL0_RX_CONFIG_RB_TIMEOUT_MSK (0x00000FF0) </span><span class="cm">/* bits 4-11 */</span><span class="cp"></span>
<span class="cp">#define FH_RCSR_CHNL0_RX_CONFIG_IRQ_DEST_MSK   (0x00001000) </span><span class="cm">/* bits 12 */</span><span class="cp"></span>
<span class="cp">#define FH_RCSR_CHNL0_RX_CONFIG_SINGLE_FRAME_MSK (0x00008000) </span><span class="cm">/* bit 15 */</span><span class="cp"></span>
<span class="cp">#define FH_RCSR_CHNL0_RX_CONFIG_RB_SIZE_MSK   (0x00030000) </span><span class="cm">/* bits 16-17 */</span><span class="cp"></span>
<span class="cp">#define FH_RCSR_CHNL0_RX_CONFIG_RBDBC_SIZE_MSK (0x00F00000) </span><span class="cm">/* bits 20-23 */</span><span class="cp"></span>
<span class="cp">#define FH_RCSR_CHNL0_RX_CONFIG_DMA_CHNL_EN_MSK (0xC0000000) </span><span class="cm">/* bits 30-31*/</span><span class="cp"></span>

<span class="cp">#define FH_RCSR_RX_CONFIG_RBDCB_SIZE_POS	(20)</span>
<span class="cp">#define FH_RCSR_RX_CONFIG_REG_IRQ_RBTH_POS	(4)</span>
<span class="cp">#define RX_RB_TIMEOUT	(0x10)</span>

<span class="cp">#define FH_RCSR_RX_CONFIG_CHNL_EN_PAUSE_VAL         (0x00000000)</span>
<span class="cp">#define FH_RCSR_RX_CONFIG_CHNL_EN_PAUSE_EOF_VAL     (0x40000000)</span>
<span class="cp">#define FH_RCSR_RX_CONFIG_CHNL_EN_ENABLE_VAL        (0x80000000)</span>

<span class="cp">#define FH_RCSR_RX_CONFIG_REG_VAL_RB_SIZE_4K    (0x00000000)</span>
<span class="cp">#define FH_RCSR_RX_CONFIG_REG_VAL_RB_SIZE_8K    (0x00010000)</span>
<span class="cp">#define FH_RCSR_RX_CONFIG_REG_VAL_RB_SIZE_12K   (0x00020000)</span>
<span class="cp">#define FH_RCSR_RX_CONFIG_REG_VAL_RB_SIZE_16K   (0x00030000)</span>

<span class="cp">#define FH_RCSR_CHNL0_RX_IGNORE_RXF_EMPTY              (0x00000004)</span>
<span class="cp">#define FH_RCSR_CHNL0_RX_CONFIG_IRQ_DEST_NO_INT_VAL    (0x00000000)</span>
<span class="cp">#define FH_RCSR_CHNL0_RX_CONFIG_IRQ_DEST_INT_HOST_VAL  (0x00001000)</span>

<span class="cm">/**</span>
<span class="cm"> * Rx Shared Status Registers (RSSR)</span>
<span class="cm"> *</span>
<span class="cm"> * After stopping Rx DMA channel (writing 0 to</span>
<span class="cm"> * FH_MEM_RCSR_CHNL0_CONFIG_REG), driver must poll</span>
<span class="cm"> * FH_MEM_RSSR_RX_STATUS_REG until Rx channel is idle.</span>
<span class="cm"> *</span>
<span class="cm"> * Bit fields:</span>
<span class="cm"> *  24:  1 = Channel 0 is idle</span>
<span class="cm"> *</span>
<span class="cm"> * FH_MEM_RSSR_SHARED_CTRL_REG and FH_MEM_RSSR_RX_ENABLE_ERR_IRQ2DRV</span>
<span class="cm"> * contain default values that should not be altered by the driver.</span>
<span class="cm"> */</span>
<span class="cp">#define FH_MEM_RSSR_LOWER_BOUND           (FH_MEM_LOWER_BOUND + 0xC40)</span>
<span class="cp">#define FH_MEM_RSSR_UPPER_BOUND           (FH_MEM_LOWER_BOUND + 0xD00)</span>

<span class="cp">#define FH_MEM_RSSR_SHARED_CTRL_REG       (FH_MEM_RSSR_LOWER_BOUND)</span>
<span class="cp">#define FH_MEM_RSSR_RX_STATUS_REG	(FH_MEM_RSSR_LOWER_BOUND + 0x004)</span>
<span class="cp">#define FH_MEM_RSSR_RX_ENABLE_ERR_IRQ2DRV\</span>
<span class="cp">					(FH_MEM_RSSR_LOWER_BOUND + 0x008)</span>

<span class="cp">#define FH_RSSR_CHNL0_RX_STATUS_CHNL_IDLE	(0x01000000)</span>

<span class="cp">#define FH_MEM_TFDIB_REG1_ADDR_BITSHIFT	28</span>

<span class="cm">/* TFDB  Area - TFDs buffer table */</span>
<span class="cp">#define FH_MEM_TFDIB_DRAM_ADDR_LSB_MSK      (0xFFFFFFFF)</span>
<span class="cp">#define FH_TFDIB_LOWER_BOUND       (FH_MEM_LOWER_BOUND + 0x900)</span>
<span class="cp">#define FH_TFDIB_UPPER_BOUND       (FH_MEM_LOWER_BOUND + 0x958)</span>
<span class="cp">#define FH_TFDIB_CTRL0_REG(_chnl)  (FH_TFDIB_LOWER_BOUND + 0x8 * (_chnl))</span>
<span class="cp">#define FH_TFDIB_CTRL1_REG(_chnl)  (FH_TFDIB_LOWER_BOUND + 0x8 * (_chnl) + 0x4)</span>

<span class="cm">/**</span>
<span class="cm"> * Transmit DMA Channel Control/Status Registers (TCSR)</span>
<span class="cm"> *</span>
<span class="cm"> * Device has one configuration register for each of 8 Tx DMA/FIFO channels</span>
<span class="cm"> * supported in hardware (don&#39;t confuse these with the 16 Tx queues in DRAM,</span>
<span class="cm"> * which feed the DMA/FIFO channels); config regs are separated by 0x20 bytes.</span>
<span class="cm"> *</span>
<span class="cm"> * To use a Tx DMA channel, driver must initialize its</span>
<span class="cm"> * FH_TCSR_CHNL_TX_CONFIG_REG(chnl) with:</span>
<span class="cm"> *</span>
<span class="cm"> * FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_ENABLE |</span>
<span class="cm"> * FH_TCSR_TX_CONFIG_REG_VAL_DMA_CREDIT_ENABLE_VAL</span>
<span class="cm"> *</span>
<span class="cm"> * All other bits should be 0.</span>
<span class="cm"> *</span>
<span class="cm"> * Bit fields:</span>
<span class="cm"> * 31-30: Tx DMA channel enable: &#39;00&#39; off/pause, &#39;01&#39; pause at end of frame,</span>
<span class="cm"> *        &#39;10&#39; operate normally</span>
<span class="cm"> * 29- 4: Reserved, set to &quot;0&quot;</span>
<span class="cm"> *     3: Enable internal DMA requests (1, normal operation), disable (0)</span>
<span class="cm"> *  2- 0: Reserved, set to &quot;0&quot;</span>
<span class="cm"> */</span>
<span class="cp">#define FH_TCSR_LOWER_BOUND  (FH_MEM_LOWER_BOUND + 0xD00)</span>
<span class="cp">#define FH_TCSR_UPPER_BOUND  (FH_MEM_LOWER_BOUND + 0xE60)</span>

<span class="cm">/* Find Control/Status reg for given Tx DMA/FIFO channel */</span>
<span class="cp">#define FH_TCSR_CHNL_NUM                            (8)</span>

<span class="cm">/* TCSR: tx_config register values */</span>
<span class="cp">#define FH_TCSR_CHNL_TX_CONFIG_REG(_chnl)	\</span>
<span class="cp">		(FH_TCSR_LOWER_BOUND + 0x20 * (_chnl))</span>
<span class="cp">#define FH_TCSR_CHNL_TX_CREDIT_REG(_chnl)	\</span>
<span class="cp">		(FH_TCSR_LOWER_BOUND + 0x20 * (_chnl) + 0x4)</span>
<span class="cp">#define FH_TCSR_CHNL_TX_BUF_STS_REG(_chnl)	\</span>
<span class="cp">		(FH_TCSR_LOWER_BOUND + 0x20 * (_chnl) + 0x8)</span>

<span class="cp">#define FH_TCSR_TX_CONFIG_REG_VAL_MSG_MODE_TXF		(0x00000000)</span>
<span class="cp">#define FH_TCSR_TX_CONFIG_REG_VAL_MSG_MODE_DRV		(0x00000001)</span>

<span class="cp">#define FH_TCSR_TX_CONFIG_REG_VAL_DMA_CREDIT_DISABLE	(0x00000000)</span>
<span class="cp">#define FH_TCSR_TX_CONFIG_REG_VAL_DMA_CREDIT_ENABLE	(0x00000008)</span>

<span class="cp">#define FH_TCSR_TX_CONFIG_REG_VAL_CIRQ_HOST_NOINT	(0x00000000)</span>
<span class="cp">#define FH_TCSR_TX_CONFIG_REG_VAL_CIRQ_HOST_ENDTFD	(0x00100000)</span>
<span class="cp">#define FH_TCSR_TX_CONFIG_REG_VAL_CIRQ_HOST_IFTFD	(0x00200000)</span>

<span class="cp">#define FH_TCSR_TX_CONFIG_REG_VAL_CIRQ_RTC_NOINT	(0x00000000)</span>
<span class="cp">#define FH_TCSR_TX_CONFIG_REG_VAL_CIRQ_RTC_ENDTFD	(0x00400000)</span>
<span class="cp">#define FH_TCSR_TX_CONFIG_REG_VAL_CIRQ_RTC_IFTFD	(0x00800000)</span>

<span class="cp">#define FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_PAUSE	(0x00000000)</span>
<span class="cp">#define FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_PAUSE_EOF	(0x40000000)</span>
<span class="cp">#define FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_ENABLE	(0x80000000)</span>

<span class="cp">#define FH_TCSR_CHNL_TX_BUF_STS_REG_VAL_TFDB_EMPTY	(0x00000000)</span>
<span class="cp">#define FH_TCSR_CHNL_TX_BUF_STS_REG_VAL_TFDB_WAIT	(0x00002000)</span>
<span class="cp">#define FH_TCSR_CHNL_TX_BUF_STS_REG_VAL_TFDB_VALID	(0x00000003)</span>

<span class="cp">#define FH_TCSR_CHNL_TX_BUF_STS_REG_POS_TB_NUM		(20)</span>
<span class="cp">#define FH_TCSR_CHNL_TX_BUF_STS_REG_POS_TB_IDX		(12)</span>

<span class="cm">/**</span>
<span class="cm"> * Tx Shared Status Registers (TSSR)</span>
<span class="cm"> *</span>
<span class="cm"> * After stopping Tx DMA channel (writing 0 to</span>
<span class="cm"> * FH_TCSR_CHNL_TX_CONFIG_REG(chnl)), driver must poll</span>
<span class="cm"> * FH_TSSR_TX_STATUS_REG until selected Tx channel is idle</span>
<span class="cm"> * (channel&#39;s buffers empty | no pending requests).</span>
<span class="cm"> *</span>
<span class="cm"> * Bit fields:</span>
<span class="cm"> * 31-24:  1 = Channel buffers empty (channel 7:0)</span>
<span class="cm"> * 23-16:  1 = No pending requests (channel 7:0)</span>
<span class="cm"> */</span>
<span class="cp">#define FH_TSSR_LOWER_BOUND		(FH_MEM_LOWER_BOUND + 0xEA0)</span>
<span class="cp">#define FH_TSSR_UPPER_BOUND		(FH_MEM_LOWER_BOUND + 0xEC0)</span>

<span class="cp">#define FH_TSSR_TX_STATUS_REG		(FH_TSSR_LOWER_BOUND + 0x010)</span>

<span class="cm">/**</span>
<span class="cm"> * Bit fields for TSSR(Tx Shared Status &amp; Control) error status register:</span>
<span class="cm"> * 31:  Indicates an address error when accessed to internal memory</span>
<span class="cm"> *	uCode/driver must write &quot;1&quot; in order to clear this flag</span>
<span class="cm"> * 30:  Indicates that Host did not send the expected number of dwords to FH</span>
<span class="cm"> *	uCode/driver must write &quot;1&quot; in order to clear this flag</span>
<span class="cm"> * 16-9:Each status bit is for one channel. Indicates that an (Error) ActDMA</span>
<span class="cm"> *	command was received from the scheduler while the TRB was already full</span>
<span class="cm"> *	with previous command</span>
<span class="cm"> *	uCode/driver must write &quot;1&quot; in order to clear this flag</span>
<span class="cm"> * 7-0: Each status bit indicates a channel&#39;s TxCredit error. When an error</span>
<span class="cm"> *	bit is set, it indicates that the FH has received a full indication</span>
<span class="cm"> *	from the RTC TxFIFO and the current value of the TxCredit counter was</span>
<span class="cm"> *	not equal to zero. This mean that the credit mechanism was not</span>
<span class="cm"> *	synchronized to the TxFIFO status</span>
<span class="cm"> *	uCode/driver must write &quot;1&quot; in order to clear this flag</span>
<span class="cm"> */</span>
<span class="cp">#define FH_TSSR_TX_ERROR_REG		(FH_TSSR_LOWER_BOUND + 0x018)</span>

<span class="cp">#define FH_TSSR_TX_STATUS_REG_MSK_CHNL_IDLE(_chnl) ((1 &lt;&lt; (_chnl)) &lt;&lt; 16)</span>

<span class="cm">/* Tx service channels */</span>
<span class="cp">#define FH_SRVC_CHNL		(9)</span>
<span class="cp">#define FH_SRVC_LOWER_BOUND	(FH_MEM_LOWER_BOUND + 0x9C8)</span>
<span class="cp">#define FH_SRVC_UPPER_BOUND	(FH_MEM_LOWER_BOUND + 0x9D0)</span>
<span class="cp">#define FH_SRVC_CHNL_SRAM_ADDR_REG(_chnl) \</span>
<span class="cp">		(FH_SRVC_LOWER_BOUND + ((_chnl) - 9) * 0x4)</span>

<span class="cp">#define FH_TX_CHICKEN_BITS_REG	(FH_MEM_LOWER_BOUND + 0xE98)</span>
<span class="cm">/* Instruct FH to increment the retry count of a packet when</span>
<span class="cm"> * it is brought from the memory to TX-FIFO</span>
<span class="cm"> */</span>
<span class="cp">#define FH_TX_CHICKEN_BITS_SCD_AUTO_RETRY_EN	(0x00000002)</span>

<span class="cp">#define RX_QUEUE_SIZE                         256</span>
<span class="cp">#define RX_QUEUE_MASK                         255</span>
<span class="cp">#define RX_QUEUE_SIZE_LOG                     8</span>

<span class="cm">/*</span>
<span class="cm"> * RX related structures and functions</span>
<span class="cm"> */</span>
<span class="cp">#define RX_FREE_BUFFERS 64</span>
<span class="cp">#define RX_LOW_WATERMARK 8</span>

<span class="cm">/**</span>
<span class="cm"> * struct iwl_rb_status - reseve buffer status</span>
<span class="cm"> * 	host memory mapped FH registers</span>
<span class="cm"> * @closed_rb_num [0:11] - Indicates the index of the RB which was closed</span>
<span class="cm"> * @closed_fr_num [0:11] - Indicates the index of the RX Frame which was closed</span>
<span class="cm"> * @finished_rb_num [0:11] - Indicates the index of the current RB</span>
<span class="cm"> * 	in which the last frame was written to</span>
<span class="cm"> * @finished_fr_num [0:11] - Indicates the index of the RX Frame</span>
<span class="cm"> * 	which was transferred</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_rb_status</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">closed_rb_num</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">closed_fr_num</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">finished_rb_num</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">finished_fr_nam</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">__unused</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>


<span class="cp">#define TFD_QUEUE_SIZE_MAX      (256)</span>
<span class="cp">#define TFD_QUEUE_SIZE_BC_DUP	(64)</span>
<span class="cp">#define TFD_QUEUE_BC_SIZE	(TFD_QUEUE_SIZE_MAX + TFD_QUEUE_SIZE_BC_DUP)</span>
<span class="cp">#define IWL_TX_DMA_MASK        DMA_BIT_MASK(36)</span>
<span class="cp">#define IWL_NUM_OF_TBS		20</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">iwl_get_dma_hi_addr</span><span class="p">(</span><span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * struct iwl_tfd_tb transmit buffer descriptor within transmit frame descriptor</span>
<span class="cm"> *</span>
<span class="cm"> * This structure contains dma address and length of transmission address</span>
<span class="cm"> *</span>
<span class="cm"> * @lo: low [31:0] portion of the dma address of TX buffer</span>
<span class="cm"> * 	every even is unaligned on 16 bit boundary</span>
<span class="cm"> * @hi_n_len 0-3 [35:32] portion of dma</span>
<span class="cm"> *	     4-15 length of the tx buffer</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_tfd_tb</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">lo</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">hi_n_len</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct iwl_tfd</span>
<span class="cm"> *</span>
<span class="cm"> * Transmit Frame Descriptor (TFD)</span>
<span class="cm"> *</span>
<span class="cm"> * @ __reserved1[3] reserved</span>
<span class="cm"> * @ num_tbs 0-4 number of active tbs</span>
<span class="cm"> *	     5   reserved</span>
<span class="cm"> * 	     6-7 padding (not used)</span>
<span class="cm"> * @ tbs[20]	transmit frame buffer descriptors</span>
<span class="cm"> * @ __pad 	padding</span>
<span class="cm"> *</span>
<span class="cm"> * Each Tx queue uses a circular buffer of 256 TFDs stored in host DRAM.</span>
<span class="cm"> * Both driver and device share these circular buffers, each of which must be</span>
<span class="cm"> * contiguous 256 TFDs x 128 bytes-per-TFD = 32 KBytes</span>
<span class="cm"> *</span>
<span class="cm"> * Driver must indicate the physical address of the base of each</span>
<span class="cm"> * circular buffer via the FH_MEM_CBBC_QUEUE registers.</span>
<span class="cm"> *</span>
<span class="cm"> * Each TFD contains pointer/size information for up to 20 data buffers</span>
<span class="cm"> * in host DRAM.  These buffers collectively contain the (one) frame described</span>
<span class="cm"> * by the TFD.  Each buffer must be a single contiguous block of memory within</span>
<span class="cm"> * itself, but buffers may be scattered in host DRAM.  Each buffer has max size</span>
<span class="cm"> * of (4K - 4).  The concatenates all of a TFD&#39;s buffers into a single</span>
<span class="cm"> * Tx frame, up to 8 KBytes in size.</span>
<span class="cm"> *</span>
<span class="cm"> * A maximum of 255 (not 256!) TFDs may be on a queue waiting for Tx.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_tfd</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">__reserved1</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">num_tbs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_tfd_tb</span> <span class="n">tbs</span><span class="p">[</span><span class="n">IWL_NUM_OF_TBS</span><span class="p">];</span>
	<span class="n">__le32</span> <span class="n">__pad</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* Keep Warm Size */</span>
<span class="cp">#define IWL_KW_SIZE 0x1000	</span><span class="cm">/* 4k */</span><span class="cp"></span>

<span class="cm">/* Fixed (non-configurable) rx data from phy */</span>

<span class="cm">/**</span>
<span class="cm"> * struct iwlagn_schedq_bc_tbl scheduler byte count table</span>
<span class="cm"> *	base physical address provided by SCD_DRAM_BASE_ADDR</span>
<span class="cm"> * @tfd_offset  0-12 - tx command byte count</span>
<span class="cm"> *	       12-16 - station index</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwlagn_scd_bc_tbl</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">tfd_offset</span><span class="p">[</span><span class="n">TFD_QUEUE_BC_SIZE</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* !__iwl_fh_h__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
