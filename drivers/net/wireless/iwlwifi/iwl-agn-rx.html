<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › iwlwifi › iwl-agn-rx.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>iwl-agn-rx.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2003 - 2012 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Portions of this file are derived from the ipw3945 project, as well</span>
<span class="cm"> * as portionhelp of the ieee80211 subsystem header files.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of version 2 of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA</span>
<span class="cm"> *</span>
<span class="cm"> * The full GNU General Public License is included in this distribution in the</span>
<span class="cm"> * file called LICENSE.</span>
<span class="cm"> *</span>
<span class="cm"> * Contact Information:</span>
<span class="cm"> *  Intel Linux Wireless &lt;ilw@linux.intel.com&gt;</span>
<span class="cm"> * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;net/mac80211.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>
<span class="cp">#include &quot;iwl-eeprom.h&quot;</span>
<span class="cp">#include &quot;iwl-dev.h&quot;</span>
<span class="cp">#include &quot;iwl-io.h&quot;</span>
<span class="cp">#include &quot;iwl-agn-calib.h&quot;</span>
<span class="cp">#include &quot;iwl-agn.h&quot;</span>
<span class="cp">#include &quot;iwl-modparams.h&quot;</span>

<span class="cp">#define IWL_CMD_ENTRY(x) [x] = #x</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">iwl_dvm_cmd_strings</span><span class="p">[</span><span class="n">REPLY_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_ALIVE</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_ERROR</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_ECHO</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_RXON</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_RXON_ASSOC</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_QOS_PARAM</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_RXON_TIMING</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_ADD_STA</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_REMOVE_STA</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_REMOVE_ALL_STA</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_TXFIFO_FLUSH</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_WEPKEY</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_TX</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_LEDS_CMD</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_TX_LINK_QUALITY_CMD</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">COEX_PRIORITY_TABLE_CMD</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">COEX_MEDIUM_NOTIFICATION</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">COEX_EVENT_CMD</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_QUIET_CMD</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_CHANNEL_SWITCH</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">CHANNEL_SWITCH_NOTIFICATION</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_SPECTRUM_MEASUREMENT_CMD</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">SPECTRUM_MEASURE_NOTIFICATION</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">POWER_TABLE_CMD</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">PM_SLEEP_NOTIFICATION</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">PM_DEBUG_STATISTIC_NOTIFIC</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_SCAN_CMD</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_SCAN_ABORT_CMD</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">SCAN_START_NOTIFICATION</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">SCAN_RESULTS_NOTIFICATION</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">SCAN_COMPLETE_NOTIFICATION</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">BEACON_NOTIFICATION</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_TX_BEACON</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">WHO_IS_AWAKE_NOTIFICATION</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">QUIET_NOTIFICATION</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_TX_PWR_TABLE_CMD</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">MEASURE_ABORT_NOTIFICATION</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_BT_CONFIG</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_STATISTICS_CMD</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">STATISTICS_NOTIFICATION</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_CARD_STATE_CMD</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">CARD_STATE_NOTIFICATION</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">MISSED_BEACONS_NOTIFICATION</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_CT_KILL_CONFIG_CMD</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">SENSITIVITY_CMD</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_PHY_CALIBRATION_CMD</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_RX_PHY_CMD</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_RX_MPDU_CMD</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_RX</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_COMPRESSED_BA</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">CALIBRATION_CFG_CMD</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">CALIBRATION_RES_NOTIFICATION</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">CALIBRATION_COMPLETE_NOTIFICATION</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_TX_POWER_DBM_CMD</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">TEMPERATURE_NOTIFICATION</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">TX_ANT_CONFIGURATION_CMD</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_BT_COEX_PROFILE_NOTIF</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_BT_COEX_PRIO_TABLE</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_BT_COEX_PROT_ENV</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_WIPAN_PARAMS</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_WIPAN_RXON</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_WIPAN_RXON_TIMING</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_WIPAN_RXON_ASSOC</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_WIPAN_QOS_PARAM</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_WIPAN_WEPKEY</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_WIPAN_P2P_CHANNEL_SWITCH</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_WIPAN_NOA_NOTIFICATION</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_WIPAN_DEACTIVATION_COMPLETE</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_WOWLAN_PATTERNS</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_WOWLAN_WAKEUP_FILTER</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_WOWLAN_TSC_RSC_PARAMS</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_WOWLAN_TKIP_PARAMS</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_WOWLAN_KEK_KCK_MATERIAL</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_WOWLAN_GET_STATUS</span><span class="p">),</span>
	<span class="n">IWL_CMD_ENTRY</span><span class="p">(</span><span class="n">REPLY_D3_CONFIG</span><span class="p">),</span>
<span class="p">};</span>
<span class="cp">#undef IWL_CMD_ENTRY</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Generic RX handler implementations</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwlagn_rx_reply_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">iwl_rx_cmd_buffer</span> <span class="o">*</span><span class="n">rxb</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">iwl_device_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_rx_packet</span> <span class="o">*</span><span class="n">pkt</span> <span class="o">=</span> <span class="n">rxb_addr</span><span class="p">(</span><span class="n">rxb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_error_resp</span> <span class="o">*</span><span class="n">err_resp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Error Reply type 0x%08X cmd REPLY_ERROR (0x%02X) &quot;</span>
		<span class="s">&quot;seq 0x%04X ser 0x%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">err_resp</span><span class="o">-&gt;</span><span class="n">error_type</span><span class="p">),</span>
		<span class="n">err_resp</span><span class="o">-&gt;</span><span class="n">cmd_id</span><span class="p">,</span>
		<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">err_resp</span><span class="o">-&gt;</span><span class="n">bad_cmd_seq_num</span><span class="p">),</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">err_resp</span><span class="o">-&gt;</span><span class="n">error_info</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwlagn_rx_csa</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwl_rx_cmd_buffer</span> <span class="o">*</span><span class="n">rxb</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">iwl_device_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_rx_packet</span> <span class="o">*</span><span class="n">pkt</span> <span class="o">=</span> <span class="n">rxb_addr</span><span class="p">(</span><span class="n">rxb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_csa_notification</span> <span class="o">*</span><span class="n">csa</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * MULTI-FIXME</span>
<span class="cm">	 * See iwlagn_mac_channel_switch.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">iwl_rxon_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">contexts</span><span class="p">[</span><span class="n">IWL_RXON_CTX_BSS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">iwl_rxon_cmd</span> <span class="o">*</span><span class="n">rxon</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">STATUS_CHANNEL_SWITCH_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">==</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">switch_channel</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rxon</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">=</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">;</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">staging</span><span class="p">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">;</span>
		<span class="n">IWL_DEBUG_11H</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;CSA notif: channel %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">));</span>
		<span class="n">iwl_chswitch_done</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;CSA notif (fail) : channel %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">));</span>
		<span class="n">iwl_chswitch_done</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwlagn_rx_spectrum_measure_notif</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">iwl_rx_cmd_buffer</span> <span class="o">*</span><span class="n">rxb</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">iwl_device_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_rx_packet</span> <span class="o">*</span><span class="n">pkt</span> <span class="o">=</span> <span class="n">rxb_addr</span><span class="p">(</span><span class="n">rxb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_spectrum_notification</span> <span class="o">*</span><span class="n">report</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">report</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_DEBUG_11H</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span>
			<span class="s">&quot;Spectrum Measure Notification: Start</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">measure_report</span><span class="p">,</span> <span class="n">report</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">report</span><span class="p">));</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">measurement_status</span> <span class="o">|=</span> <span class="n">MEASUREMENT_READY</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwlagn_rx_pm_sleep_notif</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">iwl_rx_cmd_buffer</span> <span class="o">*</span><span class="n">rxb</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">iwl_device_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_IWLWIFI_DEBUG</span>
	<span class="k">struct</span> <span class="n">iwl_rx_packet</span> <span class="o">*</span><span class="n">pkt</span> <span class="o">=</span> <span class="n">rxb_addr</span><span class="p">(</span><span class="n">rxb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_sleep_notification</span> <span class="o">*</span><span class="n">sleep</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">IWL_DEBUG_RX</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;sleep mode: %d, src: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">sleep</span><span class="o">-&gt;</span><span class="n">pm_sleep_mode</span><span class="p">,</span> <span class="n">sleep</span><span class="o">-&gt;</span><span class="n">pm_wakeup_src</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwlagn_rx_pm_debug_statistics_notif</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">iwl_rx_cmd_buffer</span> <span class="o">*</span><span class="n">rxb</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">iwl_device_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_rx_packet</span> <span class="o">*</span><span class="n">pkt</span> <span class="o">=</span> <span class="n">rxb_addr</span><span class="p">(</span><span class="n">rxb</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">__maybe_unused</span> <span class="n">len</span> <span class="o">=</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">len_n_flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FH_RSCSR_FRAME_SIZE_MSK</span><span class="p">;</span>
	<span class="n">IWL_DEBUG_RADIO</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Dumping %d bytes of unhandled &quot;</span>
			<span class="s">&quot;notification for PM_DEBUG_STATISTIC_NOTIFIC:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">iwl_print_hex_dump</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">IWL_DL_RADIO</span><span class="p">,</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwlagn_rx_beacon_notif</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">iwl_rx_cmd_buffer</span> <span class="o">*</span><span class="n">rxb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">iwl_device_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_rx_packet</span> <span class="o">*</span><span class="n">pkt</span> <span class="o">=</span> <span class="n">rxb_addr</span><span class="p">(</span><span class="n">rxb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwlagn_beacon_notif</span> <span class="o">*</span><span class="n">beacon</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_IWLWIFI_DEBUG</span>
	<span class="n">u16</span> <span class="n">status</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">beacon_notify_hdr</span><span class="p">.</span><span class="n">status</span><span class="p">.</span><span class="n">status</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">rate</span> <span class="o">=</span> <span class="n">iwl_hw_get_rate</span><span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">beacon_notify_hdr</span><span class="p">.</span><span class="n">rate_n_flags</span><span class="p">);</span>

	<span class="n">IWL_DEBUG_RX</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;beacon status %#x, retries:%d ibssmgr:%d &quot;</span>
		<span class="s">&quot;tsf:0x%.8x%.8x rate:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">status</span> <span class="o">&amp;</span> <span class="n">TX_STATUS_MSK</span><span class="p">,</span>
		<span class="n">beacon</span><span class="o">-&gt;</span><span class="n">beacon_notify_hdr</span><span class="p">.</span><span class="n">failure_frame</span><span class="p">,</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">ibss_mgr_status</span><span class="p">),</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">high_tsf</span><span class="p">),</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">low_tsf</span><span class="p">),</span> <span class="n">rate</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ibss_manager</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">beacon</span><span class="o">-&gt;</span><span class="n">ibss_mgr_status</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iwl_good_plcp_health - checks for plcp error.</span>
<span class="cm"> *</span>
<span class="cm"> * When the plcp error is exceeding the thresholds, reset the radio</span>
<span class="cm"> * to improve the throughput.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">iwlagn_good_plcp_health</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">statistics_rx_phy</span> <span class="o">*</span><span class="n">cur_ofdm</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">statistics_rx_ht_phy</span> <span class="o">*</span><span class="n">cur_ofdm_ht</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msecs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">delta</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">threshold</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">plcp_delta_threshold</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">threshold</span> <span class="o">==</span> <span class="n">IWL_MAX_PLCP_ERR_THRESHOLD_DISABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_DEBUG_RADIO</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;plcp_err check disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">delta</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cur_ofdm</span><span class="o">-&gt;</span><span class="n">plcp_err</span><span class="p">)</span> <span class="o">-</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">rx_ofdm</span><span class="p">.</span><span class="n">plcp_err</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cur_ofdm_ht</span><span class="o">-&gt;</span><span class="n">plcp_err</span><span class="p">)</span> <span class="o">-</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">rx_ofdm_ht</span><span class="p">.</span><span class="n">plcp_err</span><span class="p">);</span>

	<span class="cm">/* Can be negative if firmware reset statistics */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">delta</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="n">msecs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_DEBUG_RADIO</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span>
				<span class="s">&quot;plcp health threshold %u delta %d msecs %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">threshold</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">msecs</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">iwl_force_rf_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="n">bool</span> <span class="n">external</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_rf_reset</span> <span class="o">*</span><span class="n">rf_reset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">STATUS_EXIT_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iwl_is_any_associated</span><span class="p">(</span><span class="n">priv</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IWL_DEBUG_SCAN</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;force reset rejected: not associated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOLINK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rf_reset</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rf_reset</span><span class="p">;</span>
	<span class="n">rf_reset</span><span class="o">-&gt;</span><span class="n">reset_request_count</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">external</span> <span class="o">&amp;&amp;</span> <span class="n">rf_reset</span><span class="o">-&gt;</span><span class="n">last_reset_jiffies</span> <span class="o">&amp;&amp;</span>
	    <span class="n">time_after</span><span class="p">(</span><span class="n">rf_reset</span><span class="o">-&gt;</span><span class="n">last_reset_jiffies</span> <span class="o">+</span>
		       <span class="n">IWL_DELAY_NEXT_FORCE_RF_RESET</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IWL_DEBUG_INFO</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;RF reset rejected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rf_reset</span><span class="o">-&gt;</span><span class="n">reset_reject_count</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rf_reset</span><span class="o">-&gt;</span><span class="n">reset_success_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">rf_reset</span><span class="o">-&gt;</span><span class="n">last_reset_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * There is no easy and better way to force reset the radio,</span>
<span class="cm">	 * the only known method is switching channel which will force to</span>
<span class="cm">	 * reset and tune the radio.</span>
<span class="cm">	 * Use internal short scan (single channel) operation to should</span>
<span class="cm">	 * achieve this objective.</span>
<span class="cm">	 * Driver should reset the radio when number of consecutive missed</span>
<span class="cm">	 * beacon, or any other uCode error condition detected.</span>
<span class="cm">	 */</span>
	<span class="n">IWL_DEBUG_INFO</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;perform radio reset.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">iwl_internal_short_hw_scan</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwlagn_recover_from_statistics</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">statistics_rx_phy</span> <span class="o">*</span><span class="n">cur_ofdm</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">statistics_rx_ht_phy</span> <span class="o">*</span><span class="n">cur_ofdm_ht</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">statistics_tx</span> <span class="o">*</span><span class="n">tx</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stamp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msecs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">STATUS_EXIT_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">msecs</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">stamp</span> <span class="o">-</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_statistics_jiffies</span><span class="p">);</span>

	<span class="cm">/* Only gather statistics and update time stamp when not associated */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iwl_is_any_associated</span><span class="p">(</span><span class="n">priv</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Do not check/recover when do not have enough statistics data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msecs</span> <span class="o">&lt;</span> <span class="mi">99</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iwlwifi_mod_params</span><span class="p">.</span><span class="n">plcp_check</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">iwlagn_good_plcp_health</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">cur_ofdm</span><span class="p">,</span> <span class="n">cur_ofdm_ht</span><span class="p">,</span> <span class="n">msecs</span><span class="p">))</span>
		<span class="n">iwl_force_rf_reset</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Calculate noise level, based on measurements during network silence just</span>
<span class="cm"> *   before arriving beacon.  This measurement can be done only if we know</span>
<span class="cm"> *   exactly when to expect beacons, therefore only when we&#39;re associated. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwlagn_rx_calc_noise</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">statistics_rx_non_phy</span> <span class="o">*</span><span class="n">rx_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_active_rx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">total_silence</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bcn_silence_a</span><span class="p">,</span> <span class="n">bcn_silence_b</span><span class="p">,</span> <span class="n">bcn_silence_c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_rx_noise</span><span class="p">;</span>

	<span class="n">rx_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">rx_non_phy</span><span class="p">;</span>

	<span class="n">bcn_silence_a</span> <span class="o">=</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_info</span><span class="o">-&gt;</span><span class="n">beacon_silence_rssi_a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IN_BAND_FILTER</span><span class="p">;</span>
	<span class="n">bcn_silence_b</span> <span class="o">=</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_info</span><span class="o">-&gt;</span><span class="n">beacon_silence_rssi_b</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IN_BAND_FILTER</span><span class="p">;</span>
	<span class="n">bcn_silence_c</span> <span class="o">=</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_info</span><span class="o">-&gt;</span><span class="n">beacon_silence_rssi_c</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IN_BAND_FILTER</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bcn_silence_a</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">total_silence</span> <span class="o">+=</span> <span class="n">bcn_silence_a</span><span class="p">;</span>
		<span class="n">num_active_rx</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bcn_silence_b</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">total_silence</span> <span class="o">+=</span> <span class="n">bcn_silence_b</span><span class="p">;</span>
		<span class="n">num_active_rx</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bcn_silence_c</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">total_silence</span> <span class="o">+=</span> <span class="n">bcn_silence_c</span><span class="p">;</span>
		<span class="n">num_active_rx</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Average among active antennas */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_active_rx</span><span class="p">)</span>
		<span class="n">last_rx_noise</span> <span class="o">=</span> <span class="p">(</span><span class="n">total_silence</span> <span class="o">/</span> <span class="n">num_active_rx</span><span class="p">)</span> <span class="o">-</span> <span class="mi">107</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">last_rx_noise</span> <span class="o">=</span> <span class="n">IWL_NOISE_MEAS_NOT_AVAILABLE</span><span class="p">;</span>

	<span class="n">IWL_DEBUG_CALIB</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;inband silence a %u, b %u, c %u, dBm %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">bcn_silence_a</span><span class="p">,</span> <span class="n">bcn_silence_b</span><span class="p">,</span> <span class="n">bcn_silence_c</span><span class="p">,</span>
			<span class="n">last_rx_noise</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_IWLWIFI_DEBUGFS</span>
<span class="cm">/*</span>
<span class="cm"> *  based on the assumption of all statistics counter are in DWORD</span>
<span class="cm"> *  FIXME: This function is for debugging, do not deal with</span>
<span class="cm"> *  the case of counters roll-over.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">accum_stats</span><span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">cur</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">delta</span><span class="p">,</span>
			<span class="n">__le32</span> <span class="o">*</span><span class="n">max_delta</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">accum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	     <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__le32</span><span class="p">);</span>
	     <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">prev</span><span class="o">++</span><span class="p">,</span> <span class="n">cur</span><span class="o">++</span><span class="p">,</span> <span class="n">delta</span><span class="o">++</span><span class="p">,</span> <span class="n">max_delta</span><span class="o">++</span><span class="p">,</span> <span class="n">accum</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">cur</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">prev</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">delta</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>
				<span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">cur</span><span class="p">)</span> <span class="o">-</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">prev</span><span class="p">));</span>
			<span class="n">le32_add_cpu</span><span class="p">(</span><span class="n">accum</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">delta</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">delta</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">max_delta</span><span class="p">))</span>
				<span class="o">*</span><span class="n">max_delta</span> <span class="o">=</span> <span class="o">*</span><span class="n">delta</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">iwlagn_accumulative_statistics</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">statistics_general_common</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">statistics_rx_non_phy</span> <span class="o">*</span><span class="n">rx_non_phy</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">statistics_rx_phy</span> <span class="o">*</span><span class="n">rx_ofdm</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">statistics_rx_ht_phy</span> <span class="o">*</span><span class="n">rx_ofdm_ht</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">statistics_rx_phy</span> <span class="o">*</span><span class="n">rx_cck</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">statistics_tx</span> <span class="o">*</span><span class="n">tx</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">statistics_bt_activity</span> <span class="o">*</span><span class="n">bt_activity</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#define ACCUM(_name)	\</span>
<span class="cp">	accum_stats((__le32 *)&amp;priv-&gt;statistics._name,		\</span>
<span class="cp">		    (__le32 *)_name,				\</span>
<span class="cp">		    (__le32 *)&amp;priv-&gt;delta_stats._name,		\</span>
<span class="cp">		    (__le32 *)&amp;priv-&gt;max_delta_stats._name,	\</span>
<span class="cp">		    (__le32 *)&amp;priv-&gt;accum_stats._name,		\</span>
<span class="cp">		    sizeof(*_name));</span>

	<span class="n">ACCUM</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
	<span class="n">ACCUM</span><span class="p">(</span><span class="n">rx_non_phy</span><span class="p">);</span>
	<span class="n">ACCUM</span><span class="p">(</span><span class="n">rx_ofdm</span><span class="p">);</span>
	<span class="n">ACCUM</span><span class="p">(</span><span class="n">rx_ofdm_ht</span><span class="p">);</span>
	<span class="n">ACCUM</span><span class="p">(</span><span class="n">rx_cck</span><span class="p">);</span>
	<span class="n">ACCUM</span><span class="p">(</span><span class="n">tx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bt_activity</span><span class="p">)</span>
		<span class="n">ACCUM</span><span class="p">(</span><span class="n">bt_activity</span><span class="p">);</span>
<span class="cp">#undef ACCUM</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">iwlagn_accumulative_statistics</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">statistics_general_common</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">statistics_rx_non_phy</span> <span class="o">*</span><span class="n">rx_non_phy</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">statistics_rx_phy</span> <span class="o">*</span><span class="n">rx_ofdm</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">statistics_rx_ht_phy</span> <span class="o">*</span><span class="n">rx_ofdm_ht</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">statistics_rx_phy</span> <span class="o">*</span><span class="n">rx_cck</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">statistics_tx</span> <span class="o">*</span><span class="n">tx</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">statistics_bt_activity</span> <span class="o">*</span><span class="n">bt_activity</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwlagn_rx_statistics</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">iwl_rx_cmd_buffer</span> <span class="o">*</span><span class="n">rxb</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">iwl_device_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">reg_recalib_period</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">change</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_rx_packet</span> <span class="o">*</span><span class="n">pkt</span> <span class="o">=</span> <span class="n">rxb_addr</span><span class="p">(</span><span class="n">rxb</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">len</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">len_n_flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FH_RSCSR_FRAME_SIZE_MSK</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">flag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">statistics_general_common</span> <span class="o">*</span><span class="n">common</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">statistics_rx_non_phy</span> <span class="o">*</span><span class="n">rx_non_phy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">statistics_rx_phy</span> <span class="o">*</span><span class="n">rx_ofdm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">statistics_rx_ht_phy</span> <span class="o">*</span><span class="n">rx_ofdm_ht</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">statistics_rx_phy</span> <span class="o">*</span><span class="n">rx_cck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">statistics_tx</span> <span class="o">*</span><span class="n">tx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">statistics_bt_activity</span> <span class="o">*</span><span class="n">bt_activity</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_cmd_header</span><span class="p">);</span> <span class="cm">/* skip header */</span>

	<span class="n">IWL_DEBUG_RX</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Statistics notification received (%d bytes).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">len</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_bt_notif_statistics</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">iwl_bt_notif_statistics</span> <span class="o">*</span><span class="n">stats</span><span class="p">;</span>
		<span class="n">stats</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">flag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">;</span>
		<span class="n">common</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">general</span><span class="p">.</span><span class="n">common</span><span class="p">;</span>
		<span class="n">rx_non_phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">general</span><span class="p">.</span><span class="n">common</span><span class="p">;</span>
		<span class="n">rx_ofdm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">ofdm</span><span class="p">;</span>
		<span class="n">rx_ofdm_ht</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">ofdm_ht</span><span class="p">;</span>
		<span class="n">rx_cck</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">cck</span><span class="p">;</span>
		<span class="n">tx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">;</span>
		<span class="n">bt_activity</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">general</span><span class="p">.</span><span class="n">activity</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_IWLWIFI_DEBUGFS</span>
		<span class="cm">/* handle this exception directly */</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">num_bt_kills</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">general</span><span class="p">.</span><span class="n">num_bt_kills</span><span class="p">;</span>
		<span class="n">le32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">accum_num_bt_kills</span><span class="p">,</span>
			     <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">general</span><span class="p">.</span><span class="n">num_bt_kills</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_notif_statistics</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">iwl_notif_statistics</span> <span class="o">*</span><span class="n">stats</span><span class="p">;</span>
		<span class="n">stats</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">flag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">;</span>
		<span class="n">common</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">general</span><span class="p">.</span><span class="n">common</span><span class="p">;</span>
		<span class="n">rx_non_phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">general</span><span class="p">;</span>
		<span class="n">rx_ofdm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">ofdm</span><span class="p">;</span>
		<span class="n">rx_ofdm_ht</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">ofdm_ht</span><span class="p">;</span>
		<span class="n">rx_cck</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">cck</span><span class="p">;</span>
		<span class="n">tx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">;</span>
		<span class="n">bt_activity</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;len %d doesn&#39;t match BT (%zu) or normal (%zu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_bt_notif_statistics</span><span class="p">),</span>
			  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_notif_statistics</span><span class="p">));</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">change</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">temperature</span> <span class="o">!=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">common</span><span class="p">.</span><span class="n">temperature</span> <span class="o">||</span>
		 <span class="p">(</span><span class="o">*</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">STATISTICS_REPLY_FLG_HT40_MODE_MSK</span><span class="p">)</span> <span class="o">!=</span>
		 <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">STATISTICS_REPLY_FLG_HT40_MODE_MSK</span><span class="p">);</span>

	<span class="n">iwlagn_accumulative_statistics</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">common</span><span class="p">,</span> <span class="n">rx_non_phy</span><span class="p">,</span> <span class="n">rx_ofdm</span><span class="p">,</span>
				    <span class="n">rx_ofdm_ht</span><span class="p">,</span> <span class="n">rx_cck</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">bt_activity</span><span class="p">);</span>

	<span class="n">iwlagn_recover_from_statistics</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">rx_ofdm</span><span class="p">,</span> <span class="n">rx_ofdm_ht</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">stamp</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">flag</span> <span class="o">=</span> <span class="o">*</span><span class="n">flag</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">common</span><span class="p">,</span> <span class="n">common</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">common</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">rx_non_phy</span><span class="p">,</span> <span class="n">rx_non_phy</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rx_non_phy</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">rx_ofdm</span><span class="p">,</span> <span class="n">rx_ofdm</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rx_ofdm</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">rx_ofdm_ht</span><span class="p">,</span> <span class="n">rx_ofdm_ht</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rx_ofdm_ht</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">rx_cck</span><span class="p">,</span> <span class="n">rx_cck</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rx_cck</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">tx</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tx</span><span class="p">));</span>
<span class="cp">#ifdef CONFIG_IWLWIFI_DEBUGFS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bt_activity</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">bt_activity</span><span class="p">,</span> <span class="n">bt_activity</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bt_activity</span><span class="p">));</span>
<span class="cp">#endif</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_statistics_jiffies</span> <span class="o">=</span> <span class="n">stamp</span><span class="p">;</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">STATUS_STATISTICS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>

	<span class="cm">/* Reschedule the statistics timer to occur in</span>
<span class="cm">	 * reg_recalib_period seconds to ensure we get a</span>
<span class="cm">	 * thermal update even if the uCode doesn&#39;t give</span>
<span class="cm">	 * us one */</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">statistics_periodic</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span>
		  <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">reg_recalib_period</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">STATUS_SCANNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">STATISTICS_NOTIFICATION</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">iwlagn_rx_calc_noise</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">run_time_calib_work</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lib</span><span class="o">-&gt;</span><span class="n">temperature</span> <span class="o">&amp;&amp;</span> <span class="n">change</span><span class="p">)</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">lib</span><span class="o">-&gt;</span><span class="n">temperature</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwlagn_rx_reply_statistics</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">iwl_rx_cmd_buffer</span> <span class="o">*</span><span class="n">rxb</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">iwl_device_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_rx_packet</span> <span class="o">*</span><span class="n">pkt</span> <span class="o">=</span> <span class="n">rxb_addr</span><span class="p">(</span><span class="n">rxb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_notif_statistics</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UCODE_STATISTICS_CLEAR_MSK</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_IWLWIFI_DEBUGFS</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">accum_stats</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">accum_stats</span><span class="p">));</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">delta_stats</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">delta_stats</span><span class="p">));</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">max_delta_stats</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">max_delta_stats</span><span class="p">));</span>
<span class="cp">#endif</span>
		<span class="n">IWL_DEBUG_RX</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Statistics have been cleared</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">iwlagn_rx_statistics</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">rxb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Handle notification from uCode that card&#39;s power state is changing</span>
<span class="cm"> * due to software, hardware, or critical temperature RFKILL */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwlagn_rx_card_state_notif</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">iwl_rx_cmd_buffer</span> <span class="o">*</span><span class="n">rxb</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">iwl_device_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_rx_packet</span> <span class="o">*</span><span class="n">pkt</span> <span class="o">=</span> <span class="n">rxb_addr</span><span class="p">(</span><span class="n">rxb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_card_state_notif</span> <span class="o">*</span><span class="n">card_state_notif</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">card_state_notif</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">status</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>

	<span class="n">IWL_DEBUG_RF_KILL</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Card state received: HW:%s SW:%s CT:%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HW_CARD_DISABLED</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Kill&quot;</span> <span class="o">:</span> <span class="s">&quot;On&quot;</span><span class="p">,</span>
			  <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SW_CARD_DISABLED</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Kill&quot;</span> <span class="o">:</span> <span class="s">&quot;On&quot;</span><span class="p">,</span>
			  <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CT_CARD_DISABLED</span><span class="p">)</span> <span class="o">?</span>
			  <span class="s">&quot;Reached&quot;</span> <span class="o">:</span> <span class="s">&quot;Not reached&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SW_CARD_DISABLED</span> <span class="o">|</span> <span class="n">HW_CARD_DISABLED</span> <span class="o">|</span>
		     <span class="n">CT_CARD_DISABLED</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">iwl_write32</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_UCODE_DRV_GP1_SET</span><span class="p">,</span>
			    <span class="n">CSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED</span><span class="p">);</span>

		<span class="n">iwl_write_direct32</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">HBUS_TARG_MBX_C</span><span class="p">,</span>
					<span class="n">HBUS_TARG_MBX_C_REG_BIT_CMD_BLOCKED</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RXON_CARD_DISABLED</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">iwl_write32</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_UCODE_DRV_GP1_CLR</span><span class="p">,</span>
				    <span class="n">CSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED</span><span class="p">);</span>
			<span class="n">iwl_write_direct32</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">HBUS_TARG_MBX_C</span><span class="p">,</span>
					<span class="n">HBUS_TARG_MBX_C_REG_BIT_CMD_BLOCKED</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CT_CARD_DISABLED</span><span class="p">)</span>
			<span class="n">iwl_tt_enter_ct_kill</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CT_CARD_DISABLED</span><span class="p">))</span>
		<span class="n">iwl_tt_exit_ct_kill</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HW_CARD_DISABLED</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">STATUS_RF_KILL_HW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">STATUS_RF_KILL_HW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>


	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RXON_CARD_DISABLED</span><span class="p">))</span>
		<span class="n">iwl_scan_cancel</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">test_bit</span><span class="p">(</span><span class="n">STATUS_RF_KILL_HW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">)</span> <span class="o">!=</span>
	     <span class="n">test_bit</span><span class="p">(</span><span class="n">STATUS_RF_KILL_HW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)))</span>
		<span class="n">wiphy_rfkill_set_hw_state</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wiphy</span><span class="p">,</span>
			<span class="n">test_bit</span><span class="p">(</span><span class="n">STATUS_RF_KILL_HW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">wait_command_queue</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwlagn_rx_missed_beacon_notif</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">iwl_rx_cmd_buffer</span> <span class="o">*</span><span class="n">rxb</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">iwl_device_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>

<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_rx_packet</span> <span class="o">*</span><span class="n">pkt</span> <span class="o">=</span> <span class="n">rxb_addr</span><span class="p">(</span><span class="n">rxb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_missed_beacon_notif</span> <span class="o">*</span><span class="n">missed_beacon</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">missed_beacon</span><span class="o">-&gt;</span><span class="n">consecutive_missed_beacons</span><span class="p">)</span> <span class="o">&gt;</span>
	    <span class="n">priv</span><span class="o">-&gt;</span><span class="n">missed_beacon_threshold</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_DEBUG_CALIB</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span>
		    <span class="s">&quot;missed bcn cnsq %d totl %d rcd %d expctd %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">missed_beacon</span><span class="o">-&gt;</span><span class="n">consecutive_missed_beacons</span><span class="p">),</span>
		    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">missed_beacon</span><span class="o">-&gt;</span><span class="n">total_missed_becons</span><span class="p">),</span>
		    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">missed_beacon</span><span class="o">-&gt;</span><span class="n">num_recvd_beacons</span><span class="p">),</span>
		    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">missed_beacon</span><span class="o">-&gt;</span><span class="n">num_expected_beacons</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">STATUS_SCANNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">))</span>
			<span class="n">iwl_init_sensitivity</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Cache phy data (Rx signal strength, etc) for HT frame (REPLY_RX_PHY_CMD).</span>
<span class="cm"> * This will be used later in iwl_rx_reply_rx() for REPLY_RX_MPDU_CMD. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwlagn_rx_reply_rx_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">iwl_rx_cmd_buffer</span> <span class="o">*</span><span class="n">rxb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">iwl_device_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_rx_packet</span> <span class="o">*</span><span class="n">pkt</span> <span class="o">=</span> <span class="n">rxb_addr</span><span class="p">(</span><span class="n">rxb</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">last_phy_res_valid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">last_phy_res</span><span class="p">,</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_rx_phy_res</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * returns non-zero if packet should be dropped</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwlagn_set_decrypted_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ieee80211_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">decrypt_res</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ieee80211_rx_status</span> <span class="o">*</span><span class="n">stats</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">fc</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">frame_control</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * All contexts have the same setting here due to it being</span>
<span class="cm">	 * a module parameter, so OK to check any context.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">contexts</span><span class="p">[</span><span class="n">IWL_RXON_CTX_BSS</span><span class="p">].</span><span class="n">active</span><span class="p">.</span><span class="n">filter_flags</span> <span class="o">&amp;</span>
						<span class="n">RXON_FILTER_DIS_DECRYPT_MSK</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fc</span> <span class="o">&amp;</span> <span class="n">IEEE80211_FCTL_PROTECTED</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IWL_DEBUG_RX</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;decrypt_res:0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">decrypt_res</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">decrypt_res</span> <span class="o">&amp;</span> <span class="n">RX_RES_STATUS_SEC_TYPE_MSK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RX_RES_STATUS_SEC_TYPE_TKIP</span>:
		<span class="cm">/* The uCode has got a bad phase 1 Key, pushes the packet.</span>
<span class="cm">		 * Decryption will be done in SW. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">decrypt_res</span> <span class="o">&amp;</span> <span class="n">RX_RES_STATUS_DECRYPT_TYPE_MSK</span><span class="p">)</span> <span class="o">==</span>
		    <span class="n">RX_RES_STATUS_BAD_KEY_TTAK</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">RX_RES_STATUS_SEC_TYPE_WEP</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">decrypt_res</span> <span class="o">&amp;</span> <span class="n">RX_RES_STATUS_DECRYPT_TYPE_MSK</span><span class="p">)</span> <span class="o">==</span>
		    <span class="n">RX_RES_STATUS_BAD_ICV_MIC</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* bad ICV, the packet is destroyed since the</span>
<span class="cm">			 * decryption is inplace, drop it */</span>
			<span class="n">IWL_DEBUG_RX</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Packet destroyed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="n">RX_RES_STATUS_SEC_TYPE_CCMP</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">decrypt_res</span> <span class="o">&amp;</span> <span class="n">RX_RES_STATUS_DECRYPT_TYPE_MSK</span><span class="p">)</span> <span class="o">==</span>
		    <span class="n">RX_RES_STATUS_DECRYPT_OK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IWL_DEBUG_RX</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;hw decrypt successfully!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">stats</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">RX_FLAG_DECRYPTED</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwlagn_pass_packet_to_mac80211</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ieee80211_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span>
					<span class="n">u16</span> <span class="n">len</span><span class="p">,</span>
					<span class="n">u32</span> <span class="n">ampdu_status</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">iwl_rx_cmd_buffer</span> <span class="o">*</span><span class="n">rxb</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ieee80211_rx_status</span> <span class="o">*</span><span class="n">stats</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">fc</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">frame_control</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_rxon_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hdrlen</span><span class="p">,</span> <span class="n">fraglen</span><span class="p">;</span>

	<span class="cm">/* We only process data packets if the interface is open */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">is_open</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IWL_DEBUG_DROP_LIMIT</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span>
		    <span class="s">&quot;Dropping packet while interface is not open.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* In case of HW accelerated crypto and bad decryption, drop */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iwlwifi_mod_params</span><span class="p">.</span><span class="n">sw_crypto</span> <span class="o">&amp;&amp;</span>
	    <span class="n">iwlagn_set_decrypted_flag</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="n">ampdu_status</span><span class="p">,</span> <span class="n">stats</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Dont use dev_alloc_skb(), we&#39;ll have enough headroom once</span>
<span class="cm">	 * ieee80211_hdr pulled.</span>
<span class="cm">	 */</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;alloc_skb failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* If frame is small enough to fit in skb-&gt;head, pull it completely.</span>
<span class="cm">	 * If not, only pull ieee80211_hdr so that splice() or TCP coalesce</span>
<span class="cm">	 * are more efficient.</span>
<span class="cm">	 */</span>
	<span class="n">hdrlen</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">skb_tailroom</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="o">?</span> <span class="n">len</span> <span class="o">:</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hdrlen</span><span class="p">),</span> <span class="n">hdr</span><span class="p">,</span> <span class="n">hdrlen</span><span class="p">);</span>
	<span class="n">fraglen</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">hdrlen</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fraglen</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">hdrlen</span> <span class="o">-</span>
			     <span class="n">rxb_addr</span><span class="p">(</span><span class="n">rxb</span><span class="p">)</span> <span class="o">+</span> <span class="n">rxb_offset</span><span class="p">(</span><span class="n">rxb</span><span class="p">);</span>

		<span class="n">skb_add_rx_frag</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rxb_steal_page</span><span class="p">(</span><span class="n">rxb</span><span class="p">),</span> <span class="n">offset</span><span class="p">,</span>
				<span class="n">fraglen</span><span class="p">,</span> <span class="n">rxb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	* Wake any queues that were stopped due to a passive channel tx</span>
<span class="cm">	* failure. This can happen because the regulatory enforcement in</span>
<span class="cm">	* the device waits for a beacon before allowing transmission,</span>
<span class="cm">	* sometimes even after already having transmitted frames for the</span>
<span class="cm">	* association because the new RXON may reset the information.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ieee80211_is_beacon</span><span class="p">(</span><span class="n">fc</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">passive_no_rx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">for_each_context</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ether_addr_equal</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">addr3</span><span class="p">,</span>
					      <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">.</span><span class="n">bssid_addr</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">iwlagn_lift_passive_no_rx</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">IEEE80211_SKB_RXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">stats</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">stats</span><span class="p">));</span>

	<span class="n">ieee80211_rx</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">iwlagn_translate_rx_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="n">u32</span> <span class="n">decrypt_in</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">decrypt_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">decrypt_in</span> <span class="o">&amp;</span> <span class="n">RX_RES_STATUS_STATION_FOUND</span><span class="p">)</span> <span class="o">==</span>
					<span class="n">RX_RES_STATUS_STATION_FOUND</span><span class="p">)</span>
		<span class="n">decrypt_out</span> <span class="o">|=</span> <span class="p">(</span><span class="n">RX_RES_STATUS_STATION_FOUND</span> <span class="o">|</span>
				<span class="n">RX_RES_STATUS_NO_STATION_INFO_MISMATCH</span><span class="p">);</span>

	<span class="n">decrypt_out</span> <span class="o">|=</span> <span class="p">(</span><span class="n">decrypt_in</span> <span class="o">&amp;</span> <span class="n">RX_RES_STATUS_SEC_TYPE_MSK</span><span class="p">);</span>

	<span class="cm">/* packet was not encrypted */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">decrypt_in</span> <span class="o">&amp;</span> <span class="n">RX_RES_STATUS_SEC_TYPE_MSK</span><span class="p">)</span> <span class="o">==</span>
					<span class="n">RX_RES_STATUS_SEC_TYPE_NONE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">decrypt_out</span><span class="p">;</span>

	<span class="cm">/* packet was encrypted with unknown alg */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">decrypt_in</span> <span class="o">&amp;</span> <span class="n">RX_RES_STATUS_SEC_TYPE_MSK</span><span class="p">)</span> <span class="o">==</span>
					<span class="n">RX_RES_STATUS_SEC_TYPE_ERR</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">decrypt_out</span><span class="p">;</span>

	<span class="cm">/* decryption was not done in HW */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">decrypt_in</span> <span class="o">&amp;</span> <span class="n">RX_MPDU_RES_STATUS_DEC_DONE_MSK</span><span class="p">)</span> <span class="o">!=</span>
					<span class="n">RX_MPDU_RES_STATUS_DEC_DONE_MSK</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">decrypt_out</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">decrypt_in</span> <span class="o">&amp;</span> <span class="n">RX_RES_STATUS_SEC_TYPE_MSK</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">RX_RES_STATUS_SEC_TYPE_CCMP</span>:
		<span class="cm">/* alg is CCM: check MIC only */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">decrypt_in</span> <span class="o">&amp;</span> <span class="n">RX_MPDU_RES_STATUS_MIC_OK</span><span class="p">))</span>
			<span class="cm">/* Bad MIC */</span>
			<span class="n">decrypt_out</span> <span class="o">|=</span> <span class="n">RX_RES_STATUS_BAD_ICV_MIC</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">decrypt_out</span> <span class="o">|=</span> <span class="n">RX_RES_STATUS_DECRYPT_OK</span><span class="p">;</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">RX_RES_STATUS_SEC_TYPE_TKIP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">decrypt_in</span> <span class="o">&amp;</span> <span class="n">RX_MPDU_RES_STATUS_TTAK_OK</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Bad TTAK */</span>
			<span class="n">decrypt_out</span> <span class="o">|=</span> <span class="n">RX_RES_STATUS_BAD_KEY_TTAK</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* fall through if TTAK OK */</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">decrypt_in</span> <span class="o">&amp;</span> <span class="n">RX_MPDU_RES_STATUS_ICV_OK</span><span class="p">))</span>
			<span class="n">decrypt_out</span> <span class="o">|=</span> <span class="n">RX_RES_STATUS_BAD_ICV_MIC</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">decrypt_out</span> <span class="o">|=</span> <span class="n">RX_RES_STATUS_DECRYPT_OK</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">IWL_DEBUG_RX</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;decrypt_in:0x%x  decrypt_out = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">decrypt_in</span><span class="p">,</span> <span class="n">decrypt_out</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">decrypt_out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Calc max signal level (dBm) among 3 possible receivers */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwlagn_calc_rssi</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">iwl_rx_phy_res</span> <span class="o">*</span><span class="n">rx_resp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* data from PHY/DSP regarding signal strength, etc.,</span>
<span class="cm">	 *   contents are always there, not configurable by host</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">iwlagn_non_cfg_phy</span> <span class="o">*</span><span class="n">ncphy</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">iwlagn_non_cfg_phy</span> <span class="o">*</span><span class="p">)</span><span class="n">rx_resp</span><span class="o">-&gt;</span><span class="n">non_cfg_phy_buf</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">,</span> <span class="n">rssi_a</span><span class="p">,</span> <span class="n">rssi_b</span><span class="p">,</span> <span class="n">rssi_c</span><span class="p">,</span> <span class="n">max_rssi</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">agc</span><span class="p">;</span>

	<span class="n">val</span>  <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ncphy</span><span class="o">-&gt;</span><span class="n">non_cfg_phy</span><span class="p">[</span><span class="n">IWLAGN_RX_RES_AGC_IDX</span><span class="p">]);</span>
	<span class="n">agc</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">IWLAGN_OFDM_AGC_MSK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">IWLAGN_OFDM_AGC_BIT_POS</span><span class="p">;</span>

	<span class="cm">/* Find max rssi among 3 possible receivers.</span>
<span class="cm">	 * These values are measured by the digital signal processor (DSP).</span>
<span class="cm">	 * They should stay fairly constant even as the signal strength varies,</span>
<span class="cm">	 *   if the radio&#39;s automatic gain control (AGC) is working right.</span>
<span class="cm">	 * AGC value (see below) will provide the &quot;interesting&quot; info.</span>
<span class="cm">	 */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ncphy</span><span class="o">-&gt;</span><span class="n">non_cfg_phy</span><span class="p">[</span><span class="n">IWLAGN_RX_RES_RSSI_AB_IDX</span><span class="p">]);</span>
	<span class="n">rssi_a</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">IWLAGN_OFDM_RSSI_INBAND_A_BITMSK</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
		<span class="n">IWLAGN_OFDM_RSSI_A_BIT_POS</span><span class="p">;</span>
	<span class="n">rssi_b</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">IWLAGN_OFDM_RSSI_INBAND_B_BITMSK</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
		<span class="n">IWLAGN_OFDM_RSSI_B_BIT_POS</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ncphy</span><span class="o">-&gt;</span><span class="n">non_cfg_phy</span><span class="p">[</span><span class="n">IWLAGN_RX_RES_RSSI_C_IDX</span><span class="p">]);</span>
	<span class="n">rssi_c</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">IWLAGN_OFDM_RSSI_INBAND_C_BITMSK</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
		<span class="n">IWLAGN_OFDM_RSSI_C_BIT_POS</span><span class="p">;</span>

	<span class="n">max_rssi</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">rssi_a</span><span class="p">,</span> <span class="n">rssi_b</span><span class="p">);</span>
	<span class="n">max_rssi</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">max_rssi</span><span class="p">,</span> <span class="n">rssi_c</span><span class="p">);</span>

	<span class="n">IWL_DEBUG_STATS</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Rssi In A %d B %d C %d Max %d AGC dB %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">rssi_a</span><span class="p">,</span> <span class="n">rssi_b</span><span class="p">,</span> <span class="n">rssi_c</span><span class="p">,</span> <span class="n">max_rssi</span><span class="p">,</span> <span class="n">agc</span><span class="p">);</span>

	<span class="cm">/* dBm = max_rssi dB - agc dB - constant.</span>
<span class="cm">	 * Higher AGC (higher radio gain) means lower signal. */</span>
	<span class="k">return</span> <span class="n">max_rssi</span> <span class="o">-</span> <span class="n">agc</span> <span class="o">-</span> <span class="n">IWLAGN_RSSI_OFFSET</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Called for REPLY_RX (legacy ABG frames), or</span>
<span class="cm"> * REPLY_RX_MPDU_CMD (HT high-throughput N frames). */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwlagn_rx_reply_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">iwl_rx_cmd_buffer</span> <span class="o">*</span><span class="n">rxb</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">iwl_device_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_hdr</span> <span class="o">*</span><span class="n">header</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_rx_status</span> <span class="n">rx_status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_rx_packet</span> <span class="o">*</span><span class="n">pkt</span> <span class="o">=</span> <span class="n">rxb_addr</span><span class="p">(</span><span class="n">rxb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_rx_phy_res</span> <span class="o">*</span><span class="n">phy_res</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">rx_pkt_status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_rx_mpdu_res_start</span> <span class="o">*</span><span class="n">amsdu</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ampdu_status</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rate_n_flags</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * REPLY_RX and REPLY_RX_MPDU_CMD are handled differently.</span>
<span class="cm">	 *	REPLY_RX: physical layer info is in this buffer</span>
<span class="cm">	 *	REPLY_RX_MPDU_CMD: physical layer info was sent in separate</span>
<span class="cm">	 *		command and cached in priv-&gt;last_phy_res</span>
<span class="cm">	 *</span>
<span class="cm">	 * Here we set up local variables depending on which command is</span>
<span class="cm">	 * received.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">REPLY_RX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phy_res</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iwl_rx_phy_res</span> <span class="o">*</span><span class="p">)</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">header</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hdr</span> <span class="o">*</span><span class="p">)(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">phy_res</span><span class="p">)</span>
				<span class="o">+</span> <span class="n">phy_res</span><span class="o">-&gt;</span><span class="n">cfg_phy_cnt</span><span class="p">);</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">phy_res</span><span class="o">-&gt;</span><span class="n">byte_count</span><span class="p">);</span>
		<span class="n">rx_pkt_status</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">phy_res</span><span class="p">)</span> <span class="o">+</span>
				<span class="n">phy_res</span><span class="o">-&gt;</span><span class="n">cfg_phy_cnt</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">ampdu_status</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_pkt_status</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">last_phy_res_valid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;MPDU frame without cached PHY data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">phy_res</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">last_phy_res</span><span class="p">;</span>
		<span class="n">amsdu</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iwl_rx_mpdu_res_start</span> <span class="o">*</span><span class="p">)</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">header</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hdr</span> <span class="o">*</span><span class="p">)(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">amsdu</span><span class="p">));</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">amsdu</span><span class="o">-&gt;</span><span class="n">byte_count</span><span class="p">);</span>
		<span class="n">rx_pkt_status</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">amsdu</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">ampdu_status</span> <span class="o">=</span> <span class="n">iwlagn_translate_rx_status</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span>
						<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_pkt_status</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">unlikely</span><span class="p">(</span><span class="n">phy_res</span><span class="o">-&gt;</span><span class="n">cfg_phy_cnt</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">IWL_DEBUG_DROP</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;dsp size out of range [0,20]: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">phy_res</span><span class="o">-&gt;</span><span class="n">cfg_phy_cnt</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rx_pkt_status</span> <span class="o">&amp;</span> <span class="n">RX_RES_STATUS_NO_CRC32_ERROR</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">rx_pkt_status</span> <span class="o">&amp;</span> <span class="n">RX_RES_STATUS_NO_RXE_OVERFLOW</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IWL_DEBUG_RX</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Bad CRC or FIFO: 0x%08X.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_pkt_status</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* This will be used in several places later */</span>
	<span class="n">rate_n_flags</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">phy_res</span><span class="o">-&gt;</span><span class="n">rate_n_flags</span><span class="p">);</span>

	<span class="cm">/* rx_status carries information about the packet to mac80211 */</span>
	<span class="n">rx_status</span><span class="p">.</span><span class="n">mactime</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">phy_res</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">);</span>
	<span class="n">rx_status</span><span class="p">.</span><span class="n">band</span> <span class="o">=</span> <span class="p">(</span><span class="n">phy_res</span><span class="o">-&gt;</span><span class="n">phy_flags</span> <span class="o">&amp;</span> <span class="n">RX_RES_PHY_FLAGS_BAND_24_MSK</span><span class="p">)</span> <span class="o">?</span>
				<span class="n">IEEE80211_BAND_2GHZ</span> <span class="o">:</span> <span class="n">IEEE80211_BAND_5GHZ</span><span class="p">;</span>
	<span class="n">rx_status</span><span class="p">.</span><span class="n">freq</span> <span class="o">=</span>
		<span class="n">ieee80211_channel_to_frequency</span><span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">phy_res</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">),</span>
					       <span class="n">rx_status</span><span class="p">.</span><span class="n">band</span><span class="p">);</span>
	<span class="n">rx_status</span><span class="p">.</span><span class="n">rate_idx</span> <span class="o">=</span>
		<span class="n">iwlagn_hwrate_to_mac80211_idx</span><span class="p">(</span><span class="n">rate_n_flags</span><span class="p">,</span> <span class="n">rx_status</span><span class="p">.</span><span class="n">band</span><span class="p">);</span>
	<span class="n">rx_status</span><span class="p">.</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* TSF isn&#39;t reliable. In order to allow smooth user experience,</span>
<span class="cm">	 * this W/A doesn&#39;t propagate it to the mac80211 */</span>
	<span class="cm">/*rx_status.flag |= RX_FLAG_MACTIME_MPDU;*/</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ucode_beacon_time</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">phy_res</span><span class="o">-&gt;</span><span class="n">beacon_time_stamp</span><span class="p">);</span>

	<span class="cm">/* Find max signal strength (dBm) among 3 antenna/receiver chains */</span>
	<span class="n">rx_status</span><span class="p">.</span><span class="n">signal</span> <span class="o">=</span> <span class="n">iwlagn_calc_rssi</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">phy_res</span><span class="p">);</span>

	<span class="n">IWL_DEBUG_STATS_LIMIT</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Rssi %d, TSF %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">rx_status</span><span class="p">.</span><span class="n">signal</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">rx_status</span><span class="p">.</span><span class="n">mactime</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * &quot;antenna number&quot;</span>
<span class="cm">	 *</span>
<span class="cm">	 * It seems that the antenna field in the phy flags value</span>
<span class="cm">	 * is actually a bit field. This is undefined by radiotap,</span>
<span class="cm">	 * it wants an actual antenna number but I always get &quot;7&quot;</span>
<span class="cm">	 * for most legacy frames I receive indicating that the</span>
<span class="cm">	 * same frame was received on all three RX chains.</span>
<span class="cm">	 *</span>
<span class="cm">	 * I think this field should be removed in favor of a</span>
<span class="cm">	 * new 802.11n radiotap field &quot;RX chains&quot; that is defined</span>
<span class="cm">	 * as a bitmask.</span>
<span class="cm">	 */</span>
	<span class="n">rx_status</span><span class="p">.</span><span class="n">antenna</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">phy_res</span><span class="o">-&gt;</span><span class="n">phy_flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RX_RES_PHY_FLAGS_ANTENNA_MSK</span><span class="p">)</span>
		<span class="o">&gt;&gt;</span> <span class="n">RX_RES_PHY_FLAGS_ANTENNA_POS</span><span class="p">;</span>

	<span class="cm">/* set the preamble flag if appropriate */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phy_res</span><span class="o">-&gt;</span><span class="n">phy_flags</span> <span class="o">&amp;</span> <span class="n">RX_RES_PHY_FLAGS_SHORT_PREAMBLE_MSK</span><span class="p">)</span>
		<span class="n">rx_status</span><span class="p">.</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">RX_FLAG_SHORTPRE</span><span class="p">;</span>

	<span class="cm">/* Set up the HT phy flags */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rate_n_flags</span> <span class="o">&amp;</span> <span class="n">RATE_MCS_HT_MSK</span><span class="p">)</span>
		<span class="n">rx_status</span><span class="p">.</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">RX_FLAG_HT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rate_n_flags</span> <span class="o">&amp;</span> <span class="n">RATE_MCS_HT40_MSK</span><span class="p">)</span>
		<span class="n">rx_status</span><span class="p">.</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">RX_FLAG_40MHZ</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rate_n_flags</span> <span class="o">&amp;</span> <span class="n">RATE_MCS_SGI_MSK</span><span class="p">)</span>
		<span class="n">rx_status</span><span class="p">.</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">RX_FLAG_SHORT_GI</span><span class="p">;</span>

	<span class="n">iwlagn_pass_packet_to_mac80211</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ampdu_status</span><span class="p">,</span>
				    <span class="n">rxb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_status</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwlagn_rx_noa_notification</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">iwl_rx_cmd_buffer</span> <span class="o">*</span><span class="n">rxb</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">iwl_device_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_wipan_noa_data</span> <span class="o">*</span><span class="n">new_data</span><span class="p">,</span> <span class="o">*</span><span class="n">old_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_rx_packet</span> <span class="o">*</span><span class="n">pkt</span> <span class="o">=</span> <span class="n">rxb_addr</span><span class="p">(</span><span class="n">rxb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_wipan_noa_notification</span> <span class="o">*</span><span class="n">noa_notif</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* no condition -- we&#39;re in softirq */</span>
	<span class="n">old_data</span> <span class="o">=</span> <span class="n">rcu_dereference_protected</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">noa_data</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">noa_notif</span><span class="o">-&gt;</span><span class="n">noa_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">len</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">noa_notif</span><span class="o">-&gt;</span><span class="n">noa_attribute</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
		<span class="n">u32</span> <span class="n">copylen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

		<span class="cm">/* EID, len, OUI, subtype */</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* P2P id, P2P length */</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">copylen</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>

		<span class="n">new_data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">new_data</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_data</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_data</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">new_data</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">WLAN_EID_VENDOR_SPECIFIC</span><span class="p">;</span>
			<span class="n">new_data</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* not counting EID, len */</span>
			<span class="n">new_data</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">WLAN_OUI_WFA</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
			<span class="n">new_data</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">WLAN_OUI_WFA</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
			<span class="n">new_data</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">WLAN_OUI_WFA</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
			<span class="n">new_data</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">WLAN_OUI_TYPE_WFA_P2P</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_data</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">noa_notif</span><span class="o">-&gt;</span><span class="n">noa_attribute</span><span class="p">,</span>
			       <span class="n">copylen</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">new_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">noa_data</span><span class="p">,</span> <span class="n">new_data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_data</span><span class="p">)</span>
		<span class="n">kfree_rcu</span><span class="p">(</span><span class="n">old_data</span><span class="p">,</span> <span class="n">rcu_head</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iwl_setup_rx_handlers - Initialize Rx handler callbacks</span>
<span class="cm"> *</span>
<span class="cm"> * Setup the RX handlers for each of the reply types sent from the uCode</span>
<span class="cm"> * to the host.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">iwl_setup_rx_handlers</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">**</span><span class="n">handlers</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwl_rx_cmd_buffer</span> <span class="o">*</span><span class="n">rxb</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">iwl_device_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>

	<span class="n">handlers</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_handlers</span><span class="p">;</span>

	<span class="n">handlers</span><span class="p">[</span><span class="n">REPLY_ERROR</span><span class="p">]</span>			<span class="o">=</span> <span class="n">iwlagn_rx_reply_error</span><span class="p">;</span>
	<span class="n">handlers</span><span class="p">[</span><span class="n">CHANNEL_SWITCH_NOTIFICATION</span><span class="p">]</span>	<span class="o">=</span> <span class="n">iwlagn_rx_csa</span><span class="p">;</span>
	<span class="n">handlers</span><span class="p">[</span><span class="n">SPECTRUM_MEASURE_NOTIFICATION</span><span class="p">]</span>	<span class="o">=</span>
		<span class="n">iwlagn_rx_spectrum_measure_notif</span><span class="p">;</span>
	<span class="n">handlers</span><span class="p">[</span><span class="n">PM_SLEEP_NOTIFICATION</span><span class="p">]</span>		<span class="o">=</span> <span class="n">iwlagn_rx_pm_sleep_notif</span><span class="p">;</span>
	<span class="n">handlers</span><span class="p">[</span><span class="n">PM_DEBUG_STATISTIC_NOTIFIC</span><span class="p">]</span>	<span class="o">=</span>
		<span class="n">iwlagn_rx_pm_debug_statistics_notif</span><span class="p">;</span>
	<span class="n">handlers</span><span class="p">[</span><span class="n">BEACON_NOTIFICATION</span><span class="p">]</span>		<span class="o">=</span> <span class="n">iwlagn_rx_beacon_notif</span><span class="p">;</span>
	<span class="n">handlers</span><span class="p">[</span><span class="n">REPLY_ADD_STA</span><span class="p">]</span>			<span class="o">=</span> <span class="n">iwl_add_sta_callback</span><span class="p">;</span>

	<span class="n">handlers</span><span class="p">[</span><span class="n">REPLY_WIPAN_NOA_NOTIFICATION</span><span class="p">]</span>	<span class="o">=</span> <span class="n">iwlagn_rx_noa_notification</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The same handler is used for both the REPLY to a discrete</span>
<span class="cm">	 * statistics request from the host as well as for the periodic</span>
<span class="cm">	 * statistics notifications (after received beacons) from the uCode.</span>
<span class="cm">	 */</span>
	<span class="n">handlers</span><span class="p">[</span><span class="n">REPLY_STATISTICS_CMD</span><span class="p">]</span>		<span class="o">=</span> <span class="n">iwlagn_rx_reply_statistics</span><span class="p">;</span>
	<span class="n">handlers</span><span class="p">[</span><span class="n">STATISTICS_NOTIFICATION</span><span class="p">]</span>	<span class="o">=</span> <span class="n">iwlagn_rx_statistics</span><span class="p">;</span>

	<span class="n">iwl_setup_rx_scan_handlers</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="n">handlers</span><span class="p">[</span><span class="n">CARD_STATE_NOTIFICATION</span><span class="p">]</span>	<span class="o">=</span> <span class="n">iwlagn_rx_card_state_notif</span><span class="p">;</span>
	<span class="n">handlers</span><span class="p">[</span><span class="n">MISSED_BEACONS_NOTIFICATION</span><span class="p">]</span>	<span class="o">=</span>
		<span class="n">iwlagn_rx_missed_beacon_notif</span><span class="p">;</span>

	<span class="cm">/* Rx handlers */</span>
	<span class="n">handlers</span><span class="p">[</span><span class="n">REPLY_RX_PHY_CMD</span><span class="p">]</span>		<span class="o">=</span> <span class="n">iwlagn_rx_reply_rx_phy</span><span class="p">;</span>
	<span class="n">handlers</span><span class="p">[</span><span class="n">REPLY_RX_MPDU_CMD</span><span class="p">]</span>		<span class="o">=</span> <span class="n">iwlagn_rx_reply_rx</span><span class="p">;</span>

	<span class="cm">/* block ack */</span>
	<span class="n">handlers</span><span class="p">[</span><span class="n">REPLY_COMPRESSED_BA</span><span class="p">]</span>		<span class="o">=</span>
		<span class="n">iwlagn_rx_reply_compressed_ba</span><span class="p">;</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_handlers</span><span class="p">[</span><span class="n">REPLY_TX</span><span class="p">]</span> <span class="o">=</span> <span class="n">iwlagn_rx_reply_tx</span><span class="p">;</span>

	<span class="cm">/* set up notification wait support */</span>
	<span class="n">iwl_notification_wait_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">notif_wait</span><span class="p">);</span>

	<span class="cm">/* Set up BT Rx handlers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">bt_params</span><span class="p">)</span>
		<span class="n">iwlagn_bt_rx_handler_setup</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">iwl_rx_dispatch</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_op_mode</span> <span class="o">*</span><span class="n">op_mode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwl_rx_cmd_buffer</span> <span class="o">*</span><span class="n">rxb</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">iwl_device_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_rx_packet</span> <span class="o">*</span><span class="n">pkt</span> <span class="o">=</span> <span class="n">rxb_addr</span><span class="p">(</span><span class="n">rxb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">IWL_OP_MODE_GET_DVM</span><span class="p">(</span><span class="n">op_mode</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pre_rx_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">iwl_rx_cmd_buffer</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do the notification wait before RX handlers so</span>
<span class="cm">	 * even if the RX handler consumes the RXB we have</span>
<span class="cm">	 * access to it in the notification wait entry.</span>
<span class="cm">	 */</span>
	<span class="n">iwl_notification_wait_notify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">notif_wait</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>

	<span class="cm">/* RX data may be forwarded to userspace (using pre_rx_handler) in one</span>
<span class="cm">	 * of two cases: the first, that the user owns the uCode through</span>
<span class="cm">	 * testmode - in such case the pre_rx_handler is set and no further</span>
<span class="cm">	 * processing takes place. The other case is when the user want to</span>
<span class="cm">	 * monitor the rx w/o affecting the regular flow - the pre_rx_handler</span>
<span class="cm">	 * will be set but the ownership flag != IWL_OWNERSHIP_TM and the flow</span>
<span class="cm">	 * continues.</span>
<span class="cm">	 * We need to use ACCESS_ONCE to prevent a case where the handler</span>
<span class="cm">	 * changes between the check and the call.</span>
<span class="cm">	 */</span>
	<span class="n">pre_rx_handler</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">pre_rx_handler</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pre_rx_handler</span><span class="p">)</span>
		<span class="n">pre_rx_handler</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">rxb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ucode_owner</span> <span class="o">!=</span> <span class="n">IWL_OWNERSHIP_TM</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Based on type of command response or notification,</span>
<span class="cm">		 *   handle those that need handling via function in</span>
<span class="cm">		 *   rx_handlers table.  See iwl_setup_rx_handlers() */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_handlers</span><span class="p">[</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_handlers_stats</span><span class="p">[</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_handlers</span><span class="p">[</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd</span><span class="p">]</span> <span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">rxb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* No handling needed */</span>
			<span class="n">IWL_DEBUG_RX</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;No handler needed for %s, 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">iwl_dvm_get_cmd_string</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd</span><span class="p">),</span>
				     <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
