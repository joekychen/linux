<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › iwlwifi › iwl-trans-pcie-tx.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>iwl-trans-pcie-tx.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2003 - 2012 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Portions of this file are derived from the ipw3945 project, as well</span>
<span class="cm"> * as portions of the ieee80211 subsystem header files.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of version 2 of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA</span>
<span class="cm"> *</span>
<span class="cm"> * The full GNU General Public License is included in this distribution in the</span>
<span class="cm"> * file called LICENSE.</span>
<span class="cm"> *</span>
<span class="cm"> * Contact Information:</span>
<span class="cm"> *  Intel Linux Wireless &lt;ilw@linux.intel.com&gt;</span>
<span class="cm"> * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>

<span class="cp">#include &quot;iwl-debug.h&quot;</span>
<span class="cp">#include &quot;iwl-csr.h&quot;</span>
<span class="cp">#include &quot;iwl-prph.h&quot;</span>
<span class="cp">#include &quot;iwl-io.h&quot;</span>
<span class="cp">#include &quot;iwl-agn-hw.h&quot;</span>
<span class="cp">#include &quot;iwl-op-mode.h&quot;</span>
<span class="cp">#include &quot;iwl-trans-pcie-int.h&quot;</span>
<span class="cm">/* FIXME: need to abstract out TX command (once we know what it looks like) */</span>
<span class="cp">#include &quot;iwl-commands.h&quot;</span>

<span class="cp">#define IWL_TX_CRC_SIZE 4</span>
<span class="cp">#define IWL_TX_DELIMITER_SIZE 4</span>

<span class="cm">/**</span>
<span class="cm"> * iwl_trans_txq_update_byte_cnt_tbl - Set up entry in Tx byte-count array</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">iwl_trans_txq_update_byte_cnt_tbl</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">,</span>
					   <span class="n">u16</span> <span class="n">byte_cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwlagn_scd_bc_tbl</span> <span class="o">*</span><span class="n">scd_bc_tbl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span>
		<span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">write_ptr</span> <span class="o">=</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">write_ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">txq_id</span> <span class="o">=</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">sec_ctl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">sta_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">len</span> <span class="o">=</span> <span class="n">byte_cnt</span> <span class="o">+</span> <span class="n">IWL_TX_CRC_SIZE</span> <span class="o">+</span> <span class="n">IWL_TX_DELIMITER_SIZE</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">bc_ent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_tx_cmd</span> <span class="o">*</span><span class="n">tx_cmd</span> <span class="o">=</span>
		<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">write_ptr</span><span class="p">].</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">;</span>

	<span class="n">scd_bc_tbl</span> <span class="o">=</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">scd_bc_tbls</span><span class="p">.</span><span class="n">addr</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mh">0xFFF</span> <span class="o">||</span> <span class="n">write_ptr</span> <span class="o">&gt;=</span> <span class="n">TFD_QUEUE_SIZE_MAX</span><span class="p">);</span>

	<span class="n">sta_id</span> <span class="o">=</span> <span class="n">tx_cmd</span><span class="o">-&gt;</span><span class="n">sta_id</span><span class="p">;</span>
	<span class="n">sec_ctl</span> <span class="o">=</span> <span class="n">tx_cmd</span><span class="o">-&gt;</span><span class="n">sec_ctl</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sec_ctl</span> <span class="o">&amp;</span> <span class="n">TX_CMD_SEC_MSK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TX_CMD_SEC_CCM</span>:
		<span class="n">len</span> <span class="o">+=</span> <span class="n">CCMP_MIC_LEN</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TX_CMD_SEC_TKIP</span>:
		<span class="n">len</span> <span class="o">+=</span> <span class="n">TKIP_ICV_LEN</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TX_CMD_SEC_WEP</span>:
		<span class="n">len</span> <span class="o">+=</span> <span class="n">WEP_IV_LEN</span> <span class="o">+</span> <span class="n">WEP_ICV_LEN</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bc_ent</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">((</span><span class="n">len</span> <span class="o">&amp;</span> <span class="mh">0xFFF</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">sta_id</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">));</span>

	<span class="n">scd_bc_tbl</span><span class="p">[</span><span class="n">txq_id</span><span class="p">].</span><span class="n">tfd_offset</span><span class="p">[</span><span class="n">write_ptr</span><span class="p">]</span> <span class="o">=</span> <span class="n">bc_ent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">write_ptr</span> <span class="o">&lt;</span> <span class="n">TFD_QUEUE_SIZE_BC_DUP</span><span class="p">)</span>
		<span class="n">scd_bc_tbl</span><span class="p">[</span><span class="n">txq_id</span><span class="p">].</span>
			<span class="n">tfd_offset</span><span class="p">[</span><span class="n">TFD_QUEUE_SIZE_MAX</span> <span class="o">+</span> <span class="n">write_ptr</span><span class="p">]</span> <span class="o">=</span> <span class="n">bc_ent</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iwl_txq_update_write_ptr - Send new write index to hardware</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">iwl_txq_update_write_ptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">txq_id</span> <span class="o">=</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">need_update</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">base_params</span><span class="o">-&gt;</span><span class="n">shadow_reg_enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* shadow register enabled */</span>
		<span class="n">iwl_write32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">HBUS_TARG_WRPTR</span><span class="p">,</span>
			    <span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">write_ptr</span> <span class="o">|</span> <span class="p">(</span><span class="n">txq_id</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span>
			<span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
		<span class="cm">/* if we&#39;re trying to save power */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">STATUS_TPOWER_PMI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* wake up nic if it&#39;s powered down ...</span>
<span class="cm">			 * uCode will wake up, and interrupt us again, so next</span>
<span class="cm">			 * time we&#39;ll skip this part. */</span>
			<span class="n">reg</span> <span class="o">=</span> <span class="n">iwl_read32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_UCODE_DRV_GP1</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">CSR_UCODE_DRV_GP1_BIT_MAC_SLEEP</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">IWL_DEBUG_INFO</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span>
					<span class="s">&quot;Tx queue %d requesting wakeup,&quot;</span>
					<span class="s">&quot; GP1 = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">txq_id</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
				<span class="n">iwl_set_bit</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">CSR_GP_CNTRL</span><span class="p">,</span>
					<span class="n">CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">iwl_write_direct32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">HBUS_TARG_WRPTR</span><span class="p">,</span>
				     <span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">write_ptr</span> <span class="o">|</span> <span class="p">(</span><span class="n">txq_id</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * else not in power-save mode,</span>
<span class="cm">		 * uCode will never sleep when we&#39;re</span>
<span class="cm">		 * trying to tx (during RFKILL, we&#39;re not trying to tx).</span>
<span class="cm">		 */</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">iwl_write32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">HBUS_TARG_WRPTR</span><span class="p">,</span>
				    <span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">write_ptr</span> <span class="o">|</span> <span class="p">(</span><span class="n">txq_id</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">txq</span><span class="o">-&gt;</span><span class="n">need_update</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">dma_addr_t</span> <span class="nf">iwl_tfd_tb_get_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_tfd</span> <span class="o">*</span><span class="n">tfd</span><span class="p">,</span> <span class="n">u8</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_tfd_tb</span> <span class="o">*</span><span class="n">tb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tfd</span><span class="o">-&gt;</span><span class="n">tbs</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>

	<span class="n">dma_addr_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">get_unaligned_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">dma_addr_t</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span>
		<span class="n">addr</span> <span class="o">|=</span>
		<span class="p">((</span><span class="n">dma_addr_t</span><span class="p">)(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">hi_n_len</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">iwl_tfd_tb_get_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_tfd</span> <span class="o">*</span><span class="n">tfd</span><span class="p">,</span> <span class="n">u8</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_tfd_tb</span> <span class="o">*</span><span class="n">tb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tfd</span><span class="o">-&gt;</span><span class="n">tbs</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">hi_n_len</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iwl_tfd_set_tb</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_tfd</span> <span class="o">*</span><span class="n">tfd</span><span class="p">,</span> <span class="n">u8</span> <span class="n">idx</span><span class="p">,</span>
				  <span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u16</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_tfd_tb</span> <span class="o">*</span><span class="n">tb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tfd</span><span class="o">-&gt;</span><span class="n">tbs</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	<span class="n">u16</span> <span class="n">hi_n_len</span> <span class="o">=</span> <span class="n">len</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>

	<span class="n">put_unaligned_le32</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">dma_addr_t</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span>
		<span class="n">hi_n_len</span> <span class="o">|=</span> <span class="p">((</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>

	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">hi_n_len</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">hi_n_len</span><span class="p">);</span>

	<span class="n">tfd</span><span class="o">-&gt;</span><span class="n">num_tbs</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">iwl_tfd_get_num_tbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_tfd</span> <span class="o">*</span><span class="n">tfd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tfd</span><span class="o">-&gt;</span><span class="n">num_tbs</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwlagn_unmap_tfd</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwl_cmd_meta</span> <span class="o">*</span><span class="n">meta</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">iwl_tfd</span> <span class="o">*</span><span class="n">tfd</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dma_dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_tbs</span><span class="p">;</span>

	<span class="cm">/* Sanity check on number of chunks */</span>
	<span class="n">num_tbs</span> <span class="o">=</span> <span class="n">iwl_tfd_get_num_tbs</span><span class="p">(</span><span class="n">tfd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_tbs</span> <span class="o">&gt;=</span> <span class="n">IWL_NUM_OF_TBS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Too many chunks: %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">num_tbs</span><span class="p">);</span>
		<span class="cm">/* @todo issue fatal error, it is quite serious situation */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Unmap tx_cmd */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_tbs</span><span class="p">)</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="n">dma_unmap_addr</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">mapping</span><span class="p">),</span>
				<span class="n">dma_unmap_len</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">len</span><span class="p">),</span>
				<span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>

	<span class="cm">/* Unmap chunks, if any. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_tbs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">iwl_tfd_tb_get_addr</span><span class="p">(</span><span class="n">tfd</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
				<span class="n">iwl_tfd_tb_get_len</span><span class="p">(</span><span class="n">tfd</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">dma_dir</span><span class="p">);</span>

	<span class="n">tfd</span><span class="o">-&gt;</span><span class="n">num_tbs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iwlagn_txq_free_tfd - Free all chunks referenced by TFD [txq-&gt;q.read_ptr]</span>
<span class="cm"> * @trans - transport private data</span>
<span class="cm"> * @txq - tx queue</span>
<span class="cm"> * @dma_dir - the direction of the DMA mapping</span>
<span class="cm"> *</span>
<span class="cm"> * Does NOT advance any TFD circular buffer read/write indexes</span>
<span class="cm"> * Does NOT free the TFD itself (which is within circular buffer)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">iwlagn_txq_free_tfd</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">,</span>
			 <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dma_dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_tfd</span> <span class="o">*</span><span class="n">tfd_tmp</span> <span class="o">=</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">tfds</span><span class="p">;</span>

	<span class="cm">/* rd_ptr is bounded by n_bd and idx is bounded by n_window */</span>
	<span class="kt">int</span> <span class="n">rd_ptr</span> <span class="o">=</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">read_ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">get_cmd_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">,</span> <span class="n">rd_ptr</span><span class="p">);</span>

	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* We have only q-&gt;n_window txq-&gt;entries, but we use q-&gt;n_bd tfds */</span>
	<span class="n">iwlagn_unmap_tfd</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">meta</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">tfd_tmp</span><span class="p">[</span><span class="n">rd_ptr</span><span class="p">],</span> <span class="n">dma_dir</span><span class="p">);</span>

	<span class="cm">/* free SKB */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">skb</span><span class="p">;</span>

		<span class="cm">/* Can be called from irqs-disabled context</span>
<span class="cm">		 * If skb is not NULL, it means that the whole queue is being</span>
<span class="cm">		 * freed and that the queue is not empty - free the skb</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iwl_op_mode_free_skb</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">op_mode</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">iwlagn_txq_attach_buf_to_tfd</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">,</span>
				 <span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u16</span> <span class="n">len</span><span class="p">,</span>
				 <span class="n">u8</span> <span class="n">reset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_tfd</span> <span class="o">*</span><span class="n">tfd</span><span class="p">,</span> <span class="o">*</span><span class="n">tfd_tmp</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num_tbs</span><span class="p">;</span>

	<span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">;</span>
	<span class="n">tfd_tmp</span> <span class="o">=</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">tfds</span><span class="p">;</span>
	<span class="n">tfd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tfd_tmp</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reset</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">tfd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tfd</span><span class="p">));</span>

	<span class="n">num_tbs</span> <span class="o">=</span> <span class="n">iwl_tfd_get_num_tbs</span><span class="p">(</span><span class="n">tfd</span><span class="p">);</span>

	<span class="cm">/* Each TFD can point to a maximum 20 Tx buffers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_tbs</span> <span class="o">&gt;=</span> <span class="n">IWL_NUM_OF_TBS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Error can not send more than %d chunks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">IWL_NUM_OF_TBS</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">36</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">IWL_TX_DMA_MASK</span><span class="p">))</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Unaligned address = %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>

	<span class="n">iwl_tfd_set_tb</span><span class="p">(</span><span class="n">tfd</span><span class="p">,</span> <span class="n">num_tbs</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*************** DMA-QUEUE-GENERAL-FUNCTIONS  *****</span>
<span class="cm"> * DMA services</span>
<span class="cm"> *</span>
<span class="cm"> * Theory of operation</span>
<span class="cm"> *</span>
<span class="cm"> * A Tx or Rx queue resides in host DRAM, and is comprised of a circular buffer</span>
<span class="cm"> * of buffer descriptors, each of which points to one or more data buffers for</span>
<span class="cm"> * the device to read from or fill.  Driver and device exchange status of each</span>
<span class="cm"> * queue via &quot;read&quot; and &quot;write&quot; pointers.  Driver keeps minimum of 2 empty</span>
<span class="cm"> * entries in each circular buffer, to protect against confusing empty and full</span>
<span class="cm"> * queue states.</span>
<span class="cm"> *</span>
<span class="cm"> * The device reads or writes the data in the queues via the device&#39;s several</span>
<span class="cm"> * DMA/FIFO channels.  Each queue is mapped to a single DMA channel.</span>
<span class="cm"> *</span>
<span class="cm"> * For Tx queue, there are low mark and high mark limits. If, after queuing</span>
<span class="cm"> * the packet for Tx, free space become &lt; low mark, Tx queue stopped. When</span>
<span class="cm"> * reclaiming packets (on &#39;tx done IRQ), if free space become &gt; high mark,</span>
<span class="cm"> * Tx queue resumed.</span>
<span class="cm"> *</span>
<span class="cm"> ***************************************************/</span>

<span class="kt">int</span> <span class="nf">iwl_queue_space</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">iwl_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">read_ptr</span> <span class="o">-</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">read_ptr</span> <span class="o">&gt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span><span class="p">)</span>
		<span class="n">s</span> <span class="o">-=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">n_bd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">s</span> <span class="o">+=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">n_window</span><span class="p">;</span>
	<span class="cm">/* keep some reserve to not confuse empty and full situations */</span>
	<span class="n">s</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iwl_queue_init - Initialize queue&#39;s high/low-water and read/write indexes</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iwl_queue_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slots_num</span><span class="p">,</span> <span class="n">u32</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">n_bd</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">n_window</span> <span class="o">=</span> <span class="n">slots_num</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>

	<span class="cm">/* count must be power-of-two size, otherwise iwl_queue_inc_wrap</span>
<span class="cm">	 * and iwl_queue_dec_wrap are broken. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">count</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* slots_num must be power-of-two size, otherwise</span>
<span class="cm">	 * get_cmd_index is broken. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">slots_num</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">low_mark</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">n_window</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">low_mark</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">low_mark</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">high_mark</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">n_window</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">high_mark</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">high_mark</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">read_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwlagn_txq_inval_byte_cnt_tbl</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span>
		<span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwlagn_scd_bc_tbl</span> <span class="o">*</span><span class="n">scd_bc_tbl</span> <span class="o">=</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">scd_bc_tbls</span><span class="p">.</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">txq_id</span> <span class="o">=</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">read_ptr</span> <span class="o">=</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">read_ptr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">sta_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">bc_ent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_tx_cmd</span> <span class="o">*</span><span class="n">tx_cmd</span> <span class="o">=</span>
		<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">read_ptr</span><span class="p">].</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">read_ptr</span> <span class="o">&gt;=</span> <span class="n">TFD_QUEUE_SIZE_MAX</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">txq_id</span> <span class="o">!=</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">cmd_queue</span><span class="p">)</span>
		<span class="n">sta_id</span> <span class="o">=</span> <span class="n">tx_cmd</span><span class="o">-&gt;</span><span class="n">sta_id</span><span class="p">;</span>

	<span class="n">bc_ent</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span> <span class="o">|</span> <span class="p">(</span><span class="n">sta_id</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">));</span>
	<span class="n">scd_bc_tbl</span><span class="p">[</span><span class="n">txq_id</span><span class="p">].</span><span class="n">tfd_offset</span><span class="p">[</span><span class="n">read_ptr</span><span class="p">]</span> <span class="o">=</span> <span class="n">bc_ent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">read_ptr</span> <span class="o">&lt;</span> <span class="n">TFD_QUEUE_SIZE_BC_DUP</span><span class="p">)</span>
		<span class="n">scd_bc_tbl</span><span class="p">[</span><span class="n">txq_id</span><span class="p">].</span>
			<span class="n">tfd_offset</span><span class="p">[</span><span class="n">TFD_QUEUE_SIZE_MAX</span> <span class="o">+</span> <span class="n">read_ptr</span><span class="p">]</span> <span class="o">=</span> <span class="n">bc_ent</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwlagn_tx_queue_set_q2ratid</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">u16</span> <span class="n">ra_tid</span><span class="p">,</span>
					<span class="n">u16</span> <span class="n">txq_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tbl_dw_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tbl_dw</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">scd_q2ratid</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span>
		<span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="n">scd_q2ratid</span> <span class="o">=</span> <span class="n">ra_tid</span> <span class="o">&amp;</span> <span class="n">SCD_QUEUE_RA_TID_MAP_RATID_MSK</span><span class="p">;</span>

	<span class="n">tbl_dw_addr</span> <span class="o">=</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">scd_base_addr</span> <span class="o">+</span>
			<span class="n">SCD_TRANS_TBL_OFFSET_QUEUE</span><span class="p">(</span><span class="n">txq_id</span><span class="p">);</span>

	<span class="n">tbl_dw</span> <span class="o">=</span> <span class="n">iwl_read_targ_mem</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">tbl_dw_addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">txq_id</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>
		<span class="n">tbl_dw</span> <span class="o">=</span> <span class="p">(</span><span class="n">scd_q2ratid</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">tbl_dw</span> <span class="o">&amp;</span> <span class="mh">0x0000FFFF</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">tbl_dw</span> <span class="o">=</span> <span class="n">scd_q2ratid</span> <span class="o">|</span> <span class="p">(</span><span class="n">tbl_dw</span> <span class="o">&amp;</span> <span class="mh">0xFFFF0000</span><span class="p">);</span>

	<span class="n">iwl_write_targ_mem</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">tbl_dw_addr</span><span class="p">,</span> <span class="n">tbl_dw</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwlagn_tx_queue_stop_scheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">u16</span> <span class="n">txq_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Simply stop the queue, but don&#39;t change any configuration;</span>
<span class="cm">	 * the SCD_ACT_EN bit is the write-enable mask for the ACTIVE bit. */</span>
	<span class="n">iwl_write_prph</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span>
		<span class="n">SCD_QUEUE_STATUS_BITS</span><span class="p">(</span><span class="n">txq_id</span><span class="p">),</span>
		<span class="p">(</span><span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="n">SCD_QUEUE_STTS_REG_POS_ACTIVE</span><span class="p">)</span><span class="o">|</span>
		<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">SCD_QUEUE_STTS_REG_POS_SCD_ACT_EN</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">iwl_trans_set_wr_ptrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">txq_id</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IWL_DEBUG_TX_QUEUES</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Q %d  WrPtr: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">txq_id</span><span class="p">,</span> <span class="n">index</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
	<span class="n">iwl_write_direct32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">HBUS_TARG_WRPTR</span><span class="p">,</span>
			<span class="p">(</span><span class="n">index</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">txq_id</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">));</span>
	<span class="n">iwl_write_prph</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">SCD_QUEUE_RDPTR</span><span class="p">(</span><span class="n">txq_id</span><span class="p">),</span> <span class="n">index</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">iwl_trans_tx_queue_set_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">tx_fifo_id</span><span class="p">,</span> <span class="n">bool</span> <span class="n">active</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">txq_id</span> <span class="o">=</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>

	<span class="n">iwl_write_prph</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">SCD_QUEUE_STATUS_BITS</span><span class="p">(</span><span class="n">txq_id</span><span class="p">),</span>
			<span class="p">(</span><span class="n">active</span> <span class="o">&lt;&lt;</span> <span class="n">SCD_QUEUE_STTS_REG_POS_ACTIVE</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">tx_fifo_id</span> <span class="o">&lt;&lt;</span> <span class="n">SCD_QUEUE_STTS_REG_POS_TXF</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">SCD_QUEUE_STTS_REG_POS_WSL</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">SCD_QUEUE_STTS_REG_MSK</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">active</span><span class="p">)</span>
		<span class="n">IWL_DEBUG_TX_QUEUES</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Activate queue %d on FIFO %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">txq_id</span><span class="p">,</span> <span class="n">tx_fifo_id</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">IWL_DEBUG_TX_QUEUES</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Deactivate queue %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">txq_id</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">iwl_trans_pcie_tx_agg_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="kt">int</span> <span class="n">txq_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fifo</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">sta_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">frame_limit</span><span class="p">,</span> <span class="n">u16</span> <span class="n">ssn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ra_tid</span> <span class="o">=</span> <span class="n">BUILD_RAxTID</span><span class="p">(</span><span class="n">sta_id</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">txq_id</span><span class="p">,</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">queue_used</span><span class="p">))</span>
		<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;queue %d already used - expect issues&quot;</span><span class="p">,</span> <span class="n">txq_id</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Stop this Tx queue before configuring it */</span>
	<span class="n">iwlagn_tx_queue_stop_scheduler</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">txq_id</span><span class="p">);</span>

	<span class="cm">/* Map receiver-address / traffic-ID to this queue */</span>
	<span class="n">iwlagn_tx_queue_set_q2ratid</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">ra_tid</span><span class="p">,</span> <span class="n">txq_id</span><span class="p">);</span>

	<span class="cm">/* Set this queue as a chain-building queue */</span>
	<span class="n">iwl_set_bits_prph</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">SCD_QUEUECHAIN_SEL</span><span class="p">,</span> <span class="n">BIT</span><span class="p">(</span><span class="n">txq_id</span><span class="p">));</span>

	<span class="cm">/* enable aggregations for the queue */</span>
	<span class="n">iwl_set_bits_prph</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">SCD_AGGR_SEL</span><span class="p">,</span> <span class="n">BIT</span><span class="p">(</span><span class="n">txq_id</span><span class="p">));</span>

	<span class="cm">/* Place first TFD at index corresponding to start sequence number.</span>
<span class="cm">	 * Assumes that ssn_idx is valid (!= 0xFFF) */</span>
	<span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">txq_id</span><span class="p">].</span><span class="n">q</span><span class="p">.</span><span class="n">read_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">ssn</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
	<span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">txq_id</span><span class="p">].</span><span class="n">q</span><span class="p">.</span><span class="n">write_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">ssn</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
	<span class="n">iwl_trans_set_wr_ptrs</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">txq_id</span><span class="p">,</span> <span class="n">ssn</span><span class="p">);</span>

	<span class="cm">/* Set up Tx window size and frame limit for this queue */</span>
	<span class="n">iwl_write_targ_mem</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">scd_base_addr</span> <span class="o">+</span>
			<span class="n">SCD_CONTEXT_QUEUE_OFFSET</span><span class="p">(</span><span class="n">txq_id</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span>
			<span class="p">((</span><span class="n">frame_limit</span> <span class="o">&lt;&lt;</span> <span class="n">SCD_QUEUE_CTX_REG2_WIN_SIZE_POS</span><span class="p">)</span> <span class="o">&amp;</span>
				<span class="n">SCD_QUEUE_CTX_REG2_WIN_SIZE_MSK</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">((</span><span class="n">frame_limit</span> <span class="o">&lt;&lt;</span> <span class="n">SCD_QUEUE_CTX_REG2_FRAME_LIMIT_POS</span><span class="p">)</span> <span class="o">&amp;</span>
				<span class="n">SCD_QUEUE_CTX_REG2_FRAME_LIMIT_MSK</span><span class="p">));</span>

	<span class="n">iwl_set_bits_prph</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">SCD_INTERRUPT_MASK</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">txq_id</span><span class="p">));</span>

	<span class="cm">/* Set up Status area in SRAM, map to Tx DMA/FIFO, activate the queue */</span>
	<span class="n">iwl_trans_tx_queue_set_status</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">txq_id</span><span class="p">],</span>
				      <span class="n">fifo</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">iwl_trans_pcie_tx_agg_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="kt">int</span> <span class="n">txq_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">txq_id</span><span class="p">,</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">queue_used</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;queue %d not used&quot;</span><span class="p">,</span> <span class="n">txq_id</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iwlagn_tx_queue_stop_scheduler</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">txq_id</span><span class="p">);</span>

	<span class="n">iwl_clear_bits_prph</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">SCD_AGGR_SEL</span><span class="p">,</span> <span class="n">BIT</span><span class="p">(</span><span class="n">txq_id</span><span class="p">));</span>

	<span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">txq_id</span><span class="p">].</span><span class="n">q</span><span class="p">.</span><span class="n">read_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">txq_id</span><span class="p">].</span><span class="n">q</span><span class="p">.</span><span class="n">write_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">iwl_trans_set_wr_ptrs</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">txq_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">iwl_clear_bits_prph</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">SCD_INTERRUPT_MASK</span><span class="p">,</span> <span class="n">BIT</span><span class="p">(</span><span class="n">txq_id</span><span class="p">));</span>

	<span class="n">iwl_trans_tx_queue_set_status</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">txq_id</span><span class="p">],</span>
				      <span class="mi">0</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*************** HOST COMMAND QUEUE FUNCTIONS   *****/</span>

<span class="cm">/**</span>
<span class="cm"> * iwl_enqueue_hcmd - enqueue a uCode command</span>
<span class="cm"> * @priv: device private data point</span>
<span class="cm"> * @cmd: a point to the ucode command structure</span>
<span class="cm"> *</span>
<span class="cm"> * The function returns &lt; 0 values to indicate the operation is</span>
<span class="cm"> * failed. On success, it turns the index (&gt; 0) of command in the</span>
<span class="cm"> * command queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_enqueue_hcmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwl_host_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">cmd_queue</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">iwl_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_device_cmd</span> <span class="o">*</span><span class="n">out_cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_cmd_meta</span> <span class="o">*</span><span class="n">out_meta</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">phys_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">idx</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">copy_size</span><span class="p">,</span> <span class="n">cmd_size</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">had_nocopy</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">cmd_dest</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_IWLWIFI_DEVICE_TRACING</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">trace_bufs</span><span class="p">[</span><span class="n">IWL_MAX_CMD_TFDS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
	<span class="kt">int</span> <span class="n">trace_lens</span><span class="p">[</span><span class="n">IWL_MAX_CMD_TFDS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
	<span class="kt">int</span> <span class="n">trace_idx</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">copy_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out_cmd</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">);</span>
	<span class="n">cmd_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out_cmd</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">);</span>

	<span class="cm">/* need one for the header if the first is NOCOPY */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">IWL_MAX_CMD_TFDS</span> <span class="o">&gt;</span> <span class="n">IWL_NUM_OF_TBS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IWL_MAX_CMD_TFDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">dataflags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">IWL_HCMD_DFL_NOCOPY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">had_nocopy</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* NOCOPY must not be followed by normal! */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">had_nocopy</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">copy_size</span> <span class="o">+=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="n">cmd_size</span> <span class="o">+=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If any of the command structures end up being larger than</span>
<span class="cm">	 * the TFD_MAX_PAYLOAD_SIZE and they aren&#39;t dynamically</span>
<span class="cm">	 * allocated into separate TFDs, then we will need to</span>
<span class="cm">	 * increase the size of the buffers.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">copy_size</span> <span class="o">&gt;</span> <span class="n">TFD_MAX_PAYLOAD_SIZE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iwl_queue_space</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CMD_ASYNC</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;No space in command queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">iwl_op_mode_cmd_queue_full</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">op_mode</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">get_cmd_index</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span><span class="p">);</span>
	<span class="n">out_cmd</span> <span class="o">=</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">cmd</span><span class="p">;</span>
	<span class="n">out_meta</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">meta</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">out_meta</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">out_meta</span><span class="p">));</span>	<span class="cm">/* re-initialize to NULL */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CMD_WANT_SKB</span><span class="p">)</span>
		<span class="n">out_meta</span><span class="o">-&gt;</span><span class="n">source</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>

	<span class="cm">/* set up the header */</span>

	<span class="n">out_cmd</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">out_cmd</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">out_cmd</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span>
		<span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">QUEUE_TO_SEQ</span><span class="p">(</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">cmd_queue</span><span class="p">)</span> <span class="o">|</span>
					 <span class="n">INDEX_TO_SEQ</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span><span class="p">));</span>

	<span class="cm">/* and copy the data that needs to be copied */</span>

	<span class="n">cmd_dest</span> <span class="o">=</span> <span class="n">out_cmd</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IWL_MAX_CMD_TFDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">dataflags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">IWL_HCMD_DFL_NOCOPY</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">cmd_dest</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">cmd_dest</span> <span class="o">+=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="n">IWL_DEBUG_HC</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span>
		<span class="s">&quot;Sending command %s (#%x), seq: 0x%04X, %d bytes at %d[%d]:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">trans_pcie_get_cmd_string</span><span class="p">(</span><span class="n">trans_pcie</span><span class="p">,</span> <span class="n">out_cmd</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd</span><span class="p">),</span>
		<span class="n">out_cmd</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">out_cmd</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">sequence</span><span class="p">),</span> <span class="n">cmd_size</span><span class="p">,</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">cmd_queue</span><span class="p">);</span>

	<span class="n">phys_addr</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">out_cmd</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">,</span> <span class="n">copy_size</span><span class="p">,</span>
				<span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">phys_addr</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dma_unmap_addr_set</span><span class="p">(</span><span class="n">out_meta</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">phys_addr</span><span class="p">);</span>
	<span class="n">dma_unmap_len_set</span><span class="p">(</span><span class="n">out_meta</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">copy_size</span><span class="p">);</span>

	<span class="n">iwlagn_txq_attach_buf_to_tfd</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">txq</span><span class="p">,</span>
					<span class="n">phys_addr</span><span class="p">,</span> <span class="n">copy_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_IWLWIFI_DEVICE_TRACING</span>
	<span class="n">trace_bufs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">out_cmd</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">;</span>
	<span class="n">trace_lens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy_size</span><span class="p">;</span>
	<span class="n">trace_idx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IWL_MAX_CMD_TFDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">dataflags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">IWL_HCMD_DFL_NOCOPY</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">phys_addr</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					   <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					   <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">phys_addr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">iwlagn_unmap_tfd</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">out_meta</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">tfds</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span><span class="p">],</span>
					 <span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">iwlagn_txq_attach_buf_to_tfd</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">txq</span><span class="p">,</span> <span class="n">phys_addr</span><span class="p">,</span>
					     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_IWLWIFI_DEVICE_TRACING</span>
		<span class="n">trace_bufs</span><span class="p">[</span><span class="n">trace_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">trace_lens</span><span class="p">[</span><span class="n">trace_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">trace_idx</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="n">out_meta</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>

	<span class="n">txq</span><span class="o">-&gt;</span><span class="n">need_update</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* check that tracing gets all possible blocks */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">IWL_MAX_CMD_TFDS</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_IWLWIFI_DEVICE_TRACING</span>
	<span class="n">trace_iwlwifi_dev_hcmd</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
			       <span class="n">trace_bufs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">trace_lens</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			       <span class="n">trace_bufs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">trace_lens</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
			       <span class="n">trace_bufs</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">trace_lens</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="cp">#endif</span>

	<span class="cm">/* start timer if queue currently empty */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">read_ptr</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span> <span class="o">&amp;&amp;</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">wd_timeout</span><span class="p">)</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">stuck_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">wd_timeout</span><span class="p">);</span>

	<span class="cm">/* Increment and update queue&#39;s write index */</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span> <span class="o">=</span> <span class="n">iwl_queue_inc_wrap</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">n_bd</span><span class="p">);</span>
	<span class="n">iwl_txq_update_write_ptr</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">txq</span><span class="p">);</span>

 <span class="nl">out:</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">idx</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iwl_queue_progress</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">wd_timeout</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * if empty delete timer, otherwise move timer forward</span>
<span class="cm">	 * since we&#39;re making progress on this queue</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">read_ptr</span> <span class="o">==</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">write_ptr</span><span class="p">)</span>
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">stuck_timer</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">stuck_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">wd_timeout</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iwl_hcmd_queue_reclaim - Reclaim TX command queue entries already Tx&#39;d</span>
<span class="cm"> *</span>
<span class="cm"> * When FW advances &#39;R&#39; index, all entries between old and new &#39;R&#39; index</span>
<span class="cm"> * need to be reclaimed. As result, some free space forms.  If there is</span>
<span class="cm"> * enough free space (&gt; low mark), wake the stack that feeds us.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwl_hcmd_queue_reclaim</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="kt">int</span> <span class="n">txq_id</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">txq_id</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">iwl_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nfreed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">n_bd</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">iwl_queue_used</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;%s: Read index for DMA queue txq id (%d), &quot;</span>
			  <span class="s">&quot;index %d is out of range [0-%d] %d %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			  <span class="n">txq_id</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">n_bd</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">read_ptr</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="n">iwl_queue_inc_wrap</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">n_bd</span><span class="p">);</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">read_ptr</span> <span class="o">!=</span> <span class="n">idx</span><span class="p">;</span>
	     <span class="n">q</span><span class="o">-&gt;</span><span class="n">read_ptr</span> <span class="o">=</span> <span class="n">iwl_queue_inc_wrap</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">read_ptr</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">n_bd</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nfreed</span><span class="o">++</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;HCMD skipped: index (%d) %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span>
					<span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">read_ptr</span><span class="p">);</span>
			<span class="n">iwl_op_mode_nic_error</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">op_mode</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span>

	<span class="n">iwl_queue_progress</span><span class="p">(</span><span class="n">trans_pcie</span><span class="p">,</span> <span class="n">txq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iwl_tx_cmd_complete - Pull unused buffers off the queue and reclaim them</span>
<span class="cm"> * @rxb: Rx buffer to reclaim</span>
<span class="cm"> * @handler_status: return value of the handler of the command</span>
<span class="cm"> *	(put in setup_rx_handlers)</span>
<span class="cm"> *</span>
<span class="cm"> * If an Rx buffer has an async callback associated with it the callback</span>
<span class="cm"> * will be executed.  The attached skb (if present) will only be freed</span>
<span class="cm"> * if the callback returns 1</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">iwl_tx_cmd_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwl_rx_cmd_buffer</span> <span class="o">*</span><span class="n">rxb</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">handler_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_rx_packet</span> <span class="o">*</span><span class="n">pkt</span> <span class="o">=</span> <span class="n">rxb_addr</span><span class="p">(</span><span class="n">rxb</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">sequence</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">sequence</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">txq_id</span> <span class="o">=</span> <span class="n">SEQ_TO_QUEUE</span><span class="p">(</span><span class="n">sequence</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">SEQ_TO_INDEX</span><span class="p">(</span><span class="n">sequence</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">cmd_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_device_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_cmd_meta</span> <span class="o">*</span><span class="n">meta</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">cmd_queue</span><span class="p">];</span>

	<span class="cm">/* If a Tx command is being handled and it isn&#39;t in the actual</span>
<span class="cm">	 * command queue then there a command routing bug has been introduced</span>
<span class="cm">	 * in the queue management code. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN</span><span class="p">(</span><span class="n">txq_id</span> <span class="o">!=</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">cmd_queue</span><span class="p">,</span>
		 <span class="s">&quot;wrong command queue %d (should be %d), sequence 0x%X readp=%d writep=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">txq_id</span><span class="p">,</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">cmd_queue</span><span class="p">,</span> <span class="n">sequence</span><span class="p">,</span>
		  <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">cmd_queue</span><span class="p">].</span><span class="n">q</span><span class="p">.</span><span class="n">read_ptr</span><span class="p">,</span>
		  <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">cmd_queue</span><span class="p">].</span><span class="n">q</span><span class="p">.</span><span class="n">write_ptr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">iwl_print_hex_error</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">pkt</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">cmd_index</span> <span class="o">=</span> <span class="n">get_cmd_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="n">cmd</span> <span class="o">=</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">cmd_index</span><span class="p">].</span><span class="n">cmd</span><span class="p">;</span>
	<span class="n">meta</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">cmd_index</span><span class="p">].</span><span class="n">meta</span><span class="p">;</span>

	<span class="n">iwlagn_unmap_tfd</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">meta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">tfds</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
			 <span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>

	<span class="cm">/* Input error checking is done when commands are added to queue. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">meta</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CMD_WANT_SKB</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">rxb_steal_page</span><span class="p">(</span><span class="n">rxb</span><span class="p">);</span>

		<span class="n">meta</span><span class="o">-&gt;</span><span class="n">source</span><span class="o">-&gt;</span><span class="n">resp_pkt</span> <span class="o">=</span> <span class="n">pkt</span><span class="p">;</span>
		<span class="n">meta</span><span class="o">-&gt;</span><span class="n">source</span><span class="o">-&gt;</span><span class="n">_rx_page_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">meta</span><span class="o">-&gt;</span><span class="n">source</span><span class="o">-&gt;</span><span class="n">_rx_page_order</span> <span class="o">=</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">rx_page_order</span><span class="p">;</span>
		<span class="n">meta</span><span class="o">-&gt;</span><span class="n">source</span><span class="o">-&gt;</span><span class="n">handler_status</span> <span class="o">=</span> <span class="n">handler_status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iwl_hcmd_queue_reclaim</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">txq_id</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">meta</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CMD_ASYNC</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">STATUS_HCMD_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">IWL_WARN</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span>
				 <span class="s">&quot;HCMD_ACTIVE already clear for command %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">trans_pcie_get_cmd_string</span><span class="p">(</span><span class="n">trans_pcie</span><span class="p">,</span>
							   <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">STATUS_HCMD_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="n">IWL_DEBUG_INFO</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Clearing HCMD_ACTIVE for command %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">trans_pcie_get_cmd_string</span><span class="p">(</span><span class="n">trans_pcie</span><span class="p">,</span>
							 <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd</span><span class="p">));</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">wait_command_queue</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">meta</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define HOST_COMPLETE_TIMEOUT (2 * HZ)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_send_cmd_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwl_host_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* An asynchronous command can not expect an SKB to be set. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CMD_WANT_SKB</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>


	<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_enqueue_hcmd</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span>
			<span class="s">&quot;Error sending %s: enqueue_hcmd failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">trans_pcie_get_cmd_string</span><span class="p">(</span><span class="n">trans_pcie</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">),</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_send_cmd_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwl_host_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">cmd_idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">IWL_DEBUG_INFO</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Attempting to send sync command %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">trans_pcie_get_cmd_string</span><span class="p">(</span><span class="n">trans_pcie</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">STATUS_HCMD_ACTIVE</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Command %s: a command is already active!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">trans_pcie_get_cmd_string</span><span class="p">(</span><span class="n">trans_pcie</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">IWL_DEBUG_INFO</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Setting HCMD_ACTIVE for command %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">trans_pcie_get_cmd_string</span><span class="p">(</span><span class="n">trans_pcie</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">));</span>

	<span class="n">cmd_idx</span> <span class="o">=</span> <span class="n">iwl_enqueue_hcmd</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd_idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cmd_idx</span><span class="p">;</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">STATUS_HCMD_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span>
			<span class="s">&quot;Error sending %s: enqueue_hcmd failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">trans_pcie_get_cmd_string</span><span class="p">(</span><span class="n">trans_pcie</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">),</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_event_timeout</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">wait_command_queue</span><span class="p">,</span>
			<span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">STATUS_HCMD_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">),</span>
			<span class="n">HOST_COMPLETE_TIMEOUT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">STATUS_HCMD_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span>
				<span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">cmd_queue</span><span class="p">];</span>
			<span class="k">struct</span> <span class="n">iwl_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">;</span>

			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span>
				<span class="s">&quot;Error sending %s: time out after %dms.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">trans_pcie_get_cmd_string</span><span class="p">(</span><span class="n">trans_pcie</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">),</span>
				<span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">HOST_COMPLETE_TIMEOUT</span><span class="p">));</span>

			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span>
				<span class="s">&quot;Current CMD queue read_ptr %d write_ptr %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">q</span><span class="o">-&gt;</span><span class="n">read_ptr</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span><span class="p">);</span>

			<span class="n">clear_bit</span><span class="p">(</span><span class="n">STATUS_HCMD_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
			<span class="n">IWL_DEBUG_INFO</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span>
				       <span class="s">&quot;Clearing HCMD_ACTIVE for command %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">trans_pcie_get_cmd_string</span><span class="p">(</span><span class="n">trans_pcie</span><span class="p">,</span>
								 <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">));</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">cancel</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CMD_WANT_SKB</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">resp_pkt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;Error: Response NULL in &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">trans_pcie_get_cmd_string</span><span class="p">(</span><span class="n">trans_pcie</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cancel</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">cancel:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CMD_WANT_SKB</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Cancel the CMD_WANT_SKB flag for the cmd in the</span>
<span class="cm">		 * TX cmd queue. Otherwise in case the cmd comes</span>
<span class="cm">		 * in later, it will possibly set an invalid</span>
<span class="cm">		 * address (cmd-&gt;meta.source).</span>
<span class="cm">		 */</span>
		<span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">cmd_queue</span><span class="p">].</span>
			<span class="n">entries</span><span class="p">[</span><span class="n">cmd_idx</span><span class="p">].</span><span class="n">meta</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CMD_WANT_SKB</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">resp_pkt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iwl_free_resp</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">resp_pkt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">iwl_trans_pcie_send_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwl_host_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CMD_ASYNC</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">iwl_send_cmd_async</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">iwl_send_cmd_sync</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Frees buffers until index _not_ inclusive */</span>
<span class="kt">int</span> <span class="nf">iwl_tx_queue_reclaim</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="kt">int</span> <span class="n">txq_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">skbs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans_pcie</span> <span class="o">*</span><span class="n">trans_pcie</span> <span class="o">=</span> <span class="n">IWL_TRANS_GET_PCIE_TRANS</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_tx_queue</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">[</span><span class="n">txq_id</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">iwl_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_to_free</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">freed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* This function is not meant to release cmd queue*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">txq_id</span> <span class="o">==</span> <span class="n">trans_pcie</span><span class="o">-&gt;</span><span class="n">cmd_queue</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*Since we free until index _not_ inclusive, the one before index is</span>
<span class="cm">	 * the last we will free. This one must be used */</span>
	<span class="n">last_to_free</span> <span class="o">=</span> <span class="n">iwl_queue_dec_wrap</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">n_bd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">n_bd</span><span class="p">)</span> <span class="o">||</span>
	   <span class="p">(</span><span class="n">iwl_queue_used</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">last_to_free</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s">&quot;%s: Read index for DMA queue txq id (%d), &quot;</span>
			  <span class="s">&quot;last_to_free %d is out of range [0-%d] %d %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">__func__</span><span class="p">,</span> <span class="n">txq_id</span><span class="p">,</span> <span class="n">last_to_free</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">n_bd</span><span class="p">,</span>
			  <span class="n">q</span><span class="o">-&gt;</span><span class="n">write_ptr</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">read_ptr</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="n">skbs</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span>
	     <span class="n">q</span><span class="o">-&gt;</span><span class="n">read_ptr</span> <span class="o">!=</span> <span class="n">index</span><span class="p">;</span>
	     <span class="n">q</span><span class="o">-&gt;</span><span class="n">read_ptr</span> <span class="o">=</span> <span class="n">iwl_queue_inc_wrap</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">read_ptr</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">n_bd</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">read_ptr</span><span class="p">].</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="n">skbs</span><span class="p">,</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">read_ptr</span><span class="p">].</span><span class="n">skb</span><span class="p">);</span>

		<span class="n">txq</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">read_ptr</span><span class="p">].</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">iwlagn_txq_inval_byte_cnt_tbl</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">txq</span><span class="p">);</span>

		<span class="n">iwlagn_txq_free_tfd</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">txq</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="n">freed</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iwl_queue_progress</span><span class="p">(</span><span class="n">trans_pcie</span><span class="p">,</span> <span class="n">txq</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">freed</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
