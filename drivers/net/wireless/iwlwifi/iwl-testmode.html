<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › iwlwifi › iwl-testmode.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>iwl-testmode.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * This file is provided under a dual BSD/GPLv2 license.  When using or</span>
<span class="cm"> * redistributing this file, you may do so under either license.</span>
<span class="cm"> *</span>
<span class="cm"> * GPL LICENSE SUMMARY</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2010 - 2012 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of version 2 of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,</span>
<span class="cm"> * USA</span>
<span class="cm"> *</span>
<span class="cm"> * The full GNU General Public License is included in this distribution</span>
<span class="cm"> * in the file called LICENSE.GPL.</span>
<span class="cm"> *</span>
<span class="cm"> * Contact Information:</span>
<span class="cm"> *  Intel Linux Wireless &lt;ilw@linux.intel.com&gt;</span>
<span class="cm"> * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>
<span class="cm"> *</span>
<span class="cm"> * BSD LICENSE</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2010 - 2012 Intel Corporation. All rights reserved.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> *</span>
<span class="cm"> *  * Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *  * Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer in</span>
<span class="cm"> *    the documentation and/or other materials provided with the</span>
<span class="cm"> *    distribution.</span>
<span class="cm"> *  * Neither the name Intel Corporation nor the names of its</span>
<span class="cm"> *    contributors may be used to endorse or promote products derived</span>
<span class="cm"> *    from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="cm"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="cm"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="cm"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="cm"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;net/net_namespace.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;net/cfg80211.h&gt;</span>
<span class="cp">#include &lt;net/mac80211.h&gt;</span>
<span class="cp">#include &lt;net/netlink.h&gt;</span>

<span class="cp">#include &quot;iwl-dev.h&quot;</span>
<span class="cp">#include &quot;iwl-debug.h&quot;</span>
<span class="cp">#include &quot;iwl-io.h&quot;</span>
<span class="cp">#include &quot;iwl-agn.h&quot;</span>
<span class="cp">#include &quot;iwl-testmode.h&quot;</span>
<span class="cp">#include &quot;iwl-trans.h&quot;</span>
<span class="cp">#include &quot;iwl-fh.h&quot;</span>
<span class="cp">#include &quot;iwl-prph.h&quot;</span>


<span class="cm">/* Periphery registers absolute lower bound. This is used in order to</span>
<span class="cm"> * differentiate registery access through HBUS_TARG_PRPH_* and</span>
<span class="cm"> * HBUS_TARG_MEM_* accesses.</span>
<span class="cm"> */</span>
<span class="cp">#define IWL_TM_ABS_PRPH_START (0xA00000)</span>

<span class="cm">/* The TLVs used in the gnl message policy between the kernel module and</span>
<span class="cm"> * user space application. iwl_testmode_gnl_msg_policy is to be carried</span>
<span class="cm"> * through the NL80211_CMD_TESTMODE channel regulated by nl80211.</span>
<span class="cm"> * See iwl-testmode.h</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="k">struct</span> <span class="n">nla_policy</span> <span class="n">iwl_testmode_gnl_msg_policy</span><span class="p">[</span><span class="n">IWL_TM_ATTR_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">IWL_TM_ATTR_COMMAND</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_U32</span><span class="p">,</span> <span class="p">},</span>

	<span class="p">[</span><span class="n">IWL_TM_ATTR_UCODE_CMD_ID</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_U8</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">IWL_TM_ATTR_UCODE_CMD_DATA</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_UNSPEC</span><span class="p">,</span> <span class="p">},</span>

	<span class="p">[</span><span class="n">IWL_TM_ATTR_REG_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_U32</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">IWL_TM_ATTR_REG_VALUE8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_U8</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">IWL_TM_ATTR_REG_VALUE32</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_U32</span><span class="p">,</span> <span class="p">},</span>

	<span class="p">[</span><span class="n">IWL_TM_ATTR_SYNC_RSP</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_UNSPEC</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">IWL_TM_ATTR_UCODE_RX_PKT</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_UNSPEC</span><span class="p">,</span> <span class="p">},</span>

	<span class="p">[</span><span class="n">IWL_TM_ATTR_EEPROM</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_UNSPEC</span><span class="p">,</span> <span class="p">},</span>

	<span class="p">[</span><span class="n">IWL_TM_ATTR_TRACE_ADDR</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_UNSPEC</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">IWL_TM_ATTR_TRACE_DUMP</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_UNSPEC</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">IWL_TM_ATTR_TRACE_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_U32</span><span class="p">,</span> <span class="p">},</span>

	<span class="p">[</span><span class="n">IWL_TM_ATTR_FIXRATE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_U32</span><span class="p">,</span> <span class="p">},</span>

	<span class="p">[</span><span class="n">IWL_TM_ATTR_UCODE_OWNER</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_U8</span><span class="p">,</span> <span class="p">},</span>

	<span class="p">[</span><span class="n">IWL_TM_ATTR_MEM_ADDR</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_U32</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">IWL_TM_ATTR_BUFFER_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_U32</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">IWL_TM_ATTR_BUFFER_DUMP</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_UNSPEC</span><span class="p">,</span> <span class="p">},</span>

	<span class="p">[</span><span class="n">IWL_TM_ATTR_FW_VERSION</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_U32</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">IWL_TM_ATTR_DEVICE_ID</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_U32</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">IWL_TM_ATTR_FW_TYPE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_U32</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">IWL_TM_ATTR_FW_INST_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_U32</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">IWL_TM_ATTR_FW_DATA_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_U32</span><span class="p">,</span> <span class="p">},</span>

	<span class="p">[</span><span class="n">IWL_TM_ATTR_ENABLE_NOTIFICATION</span><span class="p">]</span> <span class="o">=</span> <span class="p">{.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_FLAG</span><span class="p">,</span> <span class="p">},</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * See the struct iwl_rx_packet in iwl-commands.h for the format of the</span>
<span class="cm"> * received events from the device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">get_event_length</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_rx_cmd_buffer</span> <span class="o">*</span><span class="n">rxb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_rx_packet</span> <span class="o">*</span><span class="n">pkt</span> <span class="o">=</span> <span class="n">rxb_addr</span><span class="p">(</span><span class="n">rxb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pkt</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">len_n_flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FH_RSCSR_FRAME_SIZE_MSK</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * This function multicasts the spontaneous messages from the device to the</span>
<span class="cm"> * user space. It is invoked whenever there is a received messages</span>
<span class="cm"> * from the device. This function is called within the ISR of the rx handlers</span>
<span class="cm"> * in iwlagn driver.</span>
<span class="cm"> *</span>
<span class="cm"> * The parsing of the message content is left to the user space application,</span>
<span class="cm"> * The message content is treated as unattacked raw data and is encapsulated</span>
<span class="cm"> * with IWL_TM_ATTR_UCODE_RX_PKT multicasting to the user space.</span>
<span class="cm"> *</span>
<span class="cm"> * @priv: the instance of iwlwifi device</span>
<span class="cm"> * @rxb: pointer to rx data content received by the ISR</span>
<span class="cm"> *</span>
<span class="cm"> * See the message policies and TLVs in iwl_testmode_gnl_msg_policy[].</span>
<span class="cm"> * For the messages multicasting to the user application, the mandatory</span>
<span class="cm"> * TLV fields are :</span>
<span class="cm"> *	IWL_TM_ATTR_COMMAND must be IWL_TM_CMD_DEV2APP_UCODE_RX_PKT</span>
<span class="cm"> *	IWL_TM_ATTR_UCODE_RX_PKT for carrying the message content</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwl_testmode_ucode_rx_pkt</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">iwl_rx_cmd_buffer</span> <span class="o">*</span><span class="n">rxb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">length</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">rxb_addr</span><span class="p">(</span><span class="n">rxb</span><span class="p">);</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">get_event_length</span><span class="p">(</span><span class="n">rxb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span> <span class="o">||</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">cfg80211_testmode_alloc_event_skb</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wiphy</span><span class="p">,</span> <span class="mi">20</span> <span class="o">+</span> <span class="n">length</span><span class="p">,</span>
								<span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span>
			 <span class="s">&quot;Run out of memory for messages to user space ?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nla_put_u32</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IWL_TM_ATTR_COMMAND</span><span class="p">,</span> <span class="n">IWL_TM_CMD_DEV2APP_UCODE_RX_PKT</span><span class="p">)</span> <span class="o">||</span>
	    <span class="cm">/* the length doesn&#39;t include len_n_flags field, so add it manually */</span>
	    <span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IWL_TM_ATTR_UCODE_RX_PKT</span><span class="p">,</span> <span class="n">length</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__le32</span><span class="p">),</span> <span class="n">data</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>
	<span class="n">cfg80211_testmode_event</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">nla_put_failure:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Ouch, overran buffer, check allocation!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">iwl_testmode_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">pre_rx_handler</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">trace_enabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_mem</span><span class="p">.</span><span class="n">read_in_progress</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwl_mem_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_mem</span><span class="p">.</span><span class="n">read_in_progress</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_mem</span><span class="p">.</span><span class="n">buff_addr</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_mem</span><span class="p">.</span><span class="n">buff_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_mem</span><span class="p">.</span><span class="n">buff_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_mem</span><span class="p">.</span><span class="n">num_chunks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_mem</span><span class="p">.</span><span class="n">read_in_progress</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwl_trace_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">trace_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">cpu_addr</span> <span class="o">&amp;&amp;</span>
		    <span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">)</span>
			<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">total_size</span><span class="p">,</span>
					<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">cpu_addr</span><span class="p">,</span>
					<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">trace_enabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">cpu_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">trace_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">dma_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">buff_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">total_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">iwl_testmode_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iwl_trace_cleanup</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="n">iwl_mem_cleanup</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * This function handles the user application commands to the ucode.</span>
<span class="cm"> *</span>
<span class="cm"> * It retrieves the mandatory fields IWL_TM_ATTR_UCODE_CMD_ID and</span>
<span class="cm"> * IWL_TM_ATTR_UCODE_CMD_DATA and calls to the handler to send the</span>
<span class="cm"> * host command to the ucode.</span>
<span class="cm"> *</span>
<span class="cm"> * If any mandatory field is missing, -ENOMSG is replied to the user space</span>
<span class="cm"> * application; otherwise, waits for the host command to be sent and checks</span>
<span class="cm"> * the return code. In case or error, it is returned, otherwise a reply is</span>
<span class="cm"> * allocated and the reply RX packet</span>
<span class="cm"> * is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: ieee80211_hw object that represents the device</span>
<span class="cm"> * @tb: gnl message fields from the user space</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_testmode_ucode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">**</span><span class="n">tb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">IWL_MAC80211_GET_DVM</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_host_cmd</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_rx_packet</span> <span class="o">*</span><span class="n">pkt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">reply_buf</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reply_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">cmd_want_skb</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_host_cmd</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_UCODE_CMD_ID</span><span class="p">]</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_UCODE_CMD_DATA</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Missing ucode command mandatory fields</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMSG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cmd</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">CMD_ON_DEMAND</span> <span class="o">|</span> <span class="n">CMD_SYNC</span><span class="p">;</span>
	<span class="n">cmd_want_skb</span> <span class="o">=</span> <span class="n">nla_get_flag</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_UCODE_CMD_SKB</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd_want_skb</span><span class="p">)</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CMD_WANT_SKB</span><span class="p">;</span>

	<span class="n">cmd</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">nla_get_u8</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_UCODE_CMD_ID</span><span class="p">]);</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nla_data</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_UCODE_CMD_DATA</span><span class="p">]);</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">len</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nla_len</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_UCODE_CMD_DATA</span><span class="p">]);</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">dataflags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">IWL_HCMD_DFL_NOCOPY</span><span class="p">;</span>
	<span class="n">IWL_DEBUG_INFO</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;testmode ucode command ID 0x%x, flags 0x%x,&quot;</span>
				<span class="s">&quot; len %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">cmd</span><span class="p">.</span><span class="n">flags</span><span class="p">,</span> <span class="n">cmd</span><span class="p">.</span><span class="n">len</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_dvm_send_cmd</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Failed to send hcmd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd_want_skb</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Handling return of SKB to the user */</span>
	<span class="n">pkt</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">.</span><span class="n">resp_pkt</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pkt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;HCMD received a null response packet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">reply_len</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">len_n_flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FH_RSCSR_FRAME_SIZE_MSK</span><span class="p">;</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">cfg80211_testmode_alloc_reply_skb</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wiphy</span><span class="p">,</span> <span class="n">reply_len</span> <span class="o">+</span> <span class="mi">20</span><span class="p">);</span>
	<span class="n">reply_buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">reply_len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span> <span class="o">||</span> <span class="o">!</span><span class="n">reply_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">reply_buf</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The reply is in a page, that we cannot send to user space. */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">reply_buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">),</span> <span class="n">reply_len</span><span class="p">);</span>
	<span class="n">iwl_free_resp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nla_put_u32</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IWL_TM_ATTR_COMMAND</span><span class="p">,</span> <span class="n">IWL_TM_CMD_DEV2APP_UCODE_RX_PKT</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IWL_TM_ATTR_UCODE_RX_PKT</span><span class="p">,</span> <span class="n">reply_len</span><span class="p">,</span> <span class="n">reply_buf</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cfg80211_testmode_reply</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

<span class="nl">nla_put_failure:</span>
	<span class="n">IWL_DEBUG_INFO</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Failed creating NL attributes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMSG</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * This function handles the user application commands for register access.</span>
<span class="cm"> *</span>
<span class="cm"> * It retrieves command ID carried with IWL_TM_ATTR_COMMAND and calls to the</span>
<span class="cm"> * handlers respectively.</span>
<span class="cm"> *</span>
<span class="cm"> * If it&#39;s an unknown commdn ID, -ENOSYS is returned; or -ENOMSG if the</span>
<span class="cm"> * mandatory fields(IWL_TM_ATTR_REG_OFFSET,IWL_TM_ATTR_REG_VALUE32,</span>
<span class="cm"> * IWL_TM_ATTR_REG_VALUE8) are missing; Otherwise 0 is replied indicating</span>
<span class="cm"> * the success of the command execution.</span>
<span class="cm"> *</span>
<span class="cm"> * If IWL_TM_ATTR_COMMAND is IWL_TM_CMD_APP2DEV_REG_READ32, the register read</span>
<span class="cm"> * value is returned with IWL_TM_ATTR_REG_VALUE32.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: ieee80211_hw object that represents the device</span>
<span class="cm"> * @tb: gnl message fields from the user space</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_testmode_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">**</span><span class="n">tb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">IWL_MAC80211_GET_DVM</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">val32</span><span class="p">,</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">val8</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_REG_OFFSET</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Missing register offset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMSG</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ofs</span> <span class="o">=</span> <span class="n">nla_get_u32</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_REG_OFFSET</span><span class="p">]);</span>
	<span class="n">IWL_INFO</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;testmode register access command offset 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ofs</span><span class="p">);</span>

	<span class="cm">/* Allow access only to FH/CSR/HBUS in direct mode.</span>
<span class="cm">	Since we don&#39;t have the upper bounds for the CSR and HBUS segments,</span>
<span class="cm">	we will use only the upper bound of FH for sanity check. */</span>
	<span class="n">cmd</span> <span class="o">=</span> <span class="n">nla_get_u32</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_COMMAND</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">IWL_TM_CMD_APP2DEV_DIRECT_REG_READ32</span> <span class="o">||</span>
		<span class="n">cmd</span> <span class="o">==</span> <span class="n">IWL_TM_CMD_APP2DEV_DIRECT_REG_WRITE32</span> <span class="o">||</span>
		<span class="n">cmd</span> <span class="o">==</span> <span class="n">IWL_TM_CMD_APP2DEV_DIRECT_REG_WRITE8</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">ofs</span> <span class="o">&gt;=</span> <span class="n">FH_MEM_UPPER_BOUND</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;offset out of segment (0x0 - 0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">FH_MEM_UPPER_BOUND</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_DIRECT_REG_READ32</span>:
		<span class="n">val32</span> <span class="o">=</span> <span class="n">iwl_read_direct32</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">ofs</span><span class="p">);</span>
		<span class="n">IWL_INFO</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;32bit value to read 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val32</span><span class="p">);</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">cfg80211_testmode_alloc_reply_skb</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wiphy</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Memory allocation fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nla_put_u32</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IWL_TM_ATTR_REG_VALUE32</span><span class="p">,</span> <span class="n">val32</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">cfg80211_testmode_reply</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Error sending msg : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_DIRECT_REG_WRITE32</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_REG_VALUE32</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Missing value to write</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMSG</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">val32</span> <span class="o">=</span> <span class="n">nla_get_u32</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_REG_VALUE32</span><span class="p">]);</span>
			<span class="n">IWL_INFO</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;32bit value to write 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val32</span><span class="p">);</span>
			<span class="n">iwl_write_direct32</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">val32</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_DIRECT_REG_WRITE8</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_REG_VALUE8</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Missing value to write</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMSG</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">val8</span> <span class="o">=</span> <span class="n">nla_get_u8</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_REG_VALUE8</span><span class="p">]);</span>
			<span class="n">IWL_INFO</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;8bit value to write 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val8</span><span class="p">);</span>
			<span class="n">iwl_write8</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">val8</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Unknown testmode register command ID</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

<span class="nl">nla_put_failure:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_testmode_cfg_init_calib</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_notification_wait</span> <span class="n">calib_wait</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">calib_complete</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">CALIBRATION_COMPLETE_NOTIFICATION</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">iwl_init_notification_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">notif_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">calib_wait</span><span class="p">,</span>
				   <span class="n">calib_complete</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">calib_complete</span><span class="p">),</span>
				   <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_init_alive_start</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Fail init calibration: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">cfg_init_calib_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_wait_notification</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">notif_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">calib_wait</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Error detecting&quot;</span>
			<span class="s">&quot; CALIBRATION_COMPLETE_NOTIFICATION: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">cfg_init_calib_error:</span>
	<span class="n">iwl_remove_notification</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">notif_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">calib_wait</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function handles the user application commands for driver.</span>
<span class="cm"> *</span>
<span class="cm"> * It retrieves command ID carried with IWL_TM_ATTR_COMMAND and calls to the</span>
<span class="cm"> * handlers respectively.</span>
<span class="cm"> *</span>
<span class="cm"> * If it&#39;s an unknown commdn ID, -ENOSYS is replied; otherwise, the returned</span>
<span class="cm"> * value of the actual command execution is replied to the user application.</span>
<span class="cm"> *</span>
<span class="cm"> * If there&#39;s any message responding to the user space, IWL_TM_ATTR_SYNC_RSP</span>
<span class="cm"> * is used for carry the message while IWL_TM_ATTR_COMMAND must set to</span>
<span class="cm"> * IWL_TM_CMD_DEV2APP_SYNC_RSP.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: ieee80211_hw object that represents the device</span>
<span class="cm"> * @tb: gnl message fields from the user space</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_testmode_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">**</span><span class="n">tb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">IWL_MAC80211_GET_DVM</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">rsp_data_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rsp_data_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">devid</span><span class="p">,</span> <span class="n">inst_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">fw_img</span> <span class="o">*</span><span class="n">img</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">nla_get_u32</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_COMMAND</span><span class="p">]))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_GET_DEVICENAME</span>:
		<span class="n">rsp_data_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
		<span class="n">rsp_data_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">cfg80211_testmode_alloc_reply_skb</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wiphy</span><span class="p">,</span>
							<span class="n">rsp_data_len</span> <span class="o">+</span> <span class="mi">20</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Memory allocation fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nla_put_u32</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IWL_TM_ATTR_COMMAND</span><span class="p">,</span>
				<span class="n">IWL_TM_CMD_DEV2APP_SYNC_RSP</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IWL_TM_ATTR_SYNC_RSP</span><span class="p">,</span>
			    <span class="n">rsp_data_len</span><span class="p">,</span> <span class="n">rsp_data_ptr</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">cfg80211_testmode_reply</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Error sending msg : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_LOAD_INIT_FW</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="n">iwl_load_ucode_wait_alive</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">IWL_UCODE_INIT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Error loading init ucode: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_CFG_INIT_CALIB</span>:
		<span class="n">iwl_testmode_cfg_init_calib</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ucode_loaded</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">iwl_trans_stop_device</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_LOAD_RUNTIME_FW</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="n">iwl_load_ucode_wait_alive</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">IWL_UCODE_REGULAR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span>
				<span class="s">&quot;Error loading runtime ucode: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">iwl_alive_start</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span>
				<span class="s">&quot;Error starting the device: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_LOAD_WOWLAN_FW</span>:
		<span class="n">iwl_scan_cancel_timeout</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="mi">200</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ucode_loaded</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">iwl_trans_stop_device</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">iwl_load_ucode_wait_alive</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">IWL_UCODE_WOWLAN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span>
				<span class="s">&quot;Error loading WOWLAN ucode: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">iwl_alive_start</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span>
				<span class="s">&quot;Error starting the device: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_GET_EEPROM</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">cfg80211_testmode_alloc_reply_skb</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wiphy</span><span class="p">,</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">base_params</span><span class="o">-&gt;</span><span class="n">eeprom_size</span> <span class="o">+</span> <span class="mi">20</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Memory allocation fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nla_put_u32</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IWL_TM_ATTR_COMMAND</span><span class="p">,</span>
					<span class="n">IWL_TM_CMD_DEV2APP_EEPROM_RSP</span><span class="p">)</span> <span class="o">||</span>
			    <span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IWL_TM_ATTR_EEPROM</span><span class="p">,</span>
				    <span class="n">priv</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">base_params</span><span class="o">-&gt;</span><span class="n">eeprom_size</span><span class="p">,</span>
				    <span class="n">priv</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">cfg80211_testmode_reply</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Error sending msg : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">status</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_FIXRATE_REQ</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_FIXRATE</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Missing fixrate setting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMSG</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tm_fixed_rate</span> <span class="o">=</span> <span class="n">nla_get_u32</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_FIXRATE</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_GET_FW_VERSION</span>:
		<span class="n">IWL_INFO</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;uCode version raw: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">priv</span><span class="o">-&gt;</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">ucode_ver</span><span class="p">);</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">cfg80211_testmode_alloc_reply_skb</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wiphy</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Memory allocation fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nla_put_u32</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IWL_TM_ATTR_FW_VERSION</span><span class="p">,</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">ucode_ver</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">cfg80211_testmode_reply</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Error sending msg : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_GET_DEVICE_ID</span>:
		<span class="n">devid</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">hw_id</span><span class="p">;</span>
		<span class="n">IWL_INFO</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;hw version: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">devid</span><span class="p">);</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">cfg80211_testmode_alloc_reply_skb</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wiphy</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Memory allocation fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nla_put_u32</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IWL_TM_ATTR_DEVICE_ID</span><span class="p">,</span> <span class="n">devid</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">cfg80211_testmode_reply</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Error sending msg : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_GET_FW_INFO</span>:
		<span class="n">skb</span> <span class="o">=</span> <span class="n">cfg80211_testmode_alloc_reply_skb</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wiphy</span><span class="p">,</span> <span class="mi">20</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Memory allocation fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ucode_loaded</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;No uCode has not been loaded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">img</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">img</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cur_ucode</span><span class="p">];</span>
			<span class="n">inst_size</span> <span class="o">=</span> <span class="n">img</span><span class="o">-&gt;</span><span class="n">sec</span><span class="p">[</span><span class="n">IWL_UCODE_SECTION_INST</span><span class="p">].</span><span class="n">len</span><span class="p">;</span>
			<span class="n">data_size</span> <span class="o">=</span> <span class="n">img</span><span class="o">-&gt;</span><span class="n">sec</span><span class="p">[</span><span class="n">IWL_UCODE_SECTION_DATA</span><span class="p">].</span><span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nla_put_u32</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IWL_TM_ATTR_FW_TYPE</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">cur_ucode</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">nla_put_u32</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IWL_TM_ATTR_FW_INST_SIZE</span><span class="p">,</span> <span class="n">inst_size</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">nla_put_u32</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IWL_TM_ATTR_FW_DATA_SIZE</span><span class="p">,</span> <span class="n">data_size</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">cfg80211_testmode_reply</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Error sending msg : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Unknown testmode driver command ID</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

<span class="nl">nla_put_failure:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * This function handles the user application commands for uCode trace</span>
<span class="cm"> *</span>
<span class="cm"> * It retrieves command ID carried with IWL_TM_ATTR_COMMAND and calls to the</span>
<span class="cm"> * handlers respectively.</span>
<span class="cm"> *</span>
<span class="cm"> * If it&#39;s an unknown commdn ID, -ENOSYS is replied; otherwise, the returned</span>
<span class="cm"> * value of the actual command execution is replied to the user application.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: ieee80211_hw object that represents the device</span>
<span class="cm"> * @tb: gnl message fields from the user space</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_testmode_trace</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">**</span><span class="n">tb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">IWL_MAC80211_GET_DVM</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">nla_get_u32</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_COMMAND</span><span class="p">]))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_BEGIN_TRACE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">trace_enabled</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_TRACE_SIZE</span><span class="p">])</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">buff_size</span> <span class="o">=</span> <span class="n">TRACE_BUFF_SIZE_DEF</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">buff_size</span> <span class="o">=</span>
				<span class="n">nla_get_u32</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_TRACE_SIZE</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">buff_size</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">buff_size</span> <span class="o">&lt;</span> <span class="n">TRACE_BUFF_SIZE_MIN</span> <span class="o">||</span>
		    <span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">buff_size</span> <span class="o">&gt;</span> <span class="n">TRACE_BUFF_SIZE_MAX</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">total_size</span> <span class="o">=</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">buff_size</span> <span class="o">+</span> <span class="n">TRACE_BUFF_PADD</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">cpu_addr</span> <span class="o">=</span>
			<span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
					   <span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">total_size</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">,</span>
					   <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">cpu_addr</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">trace_enabled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">trace_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">PTR_ALIGN</span><span class="p">(</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">cpu_addr</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">trace_addr</span><span class="p">,</span> <span class="mh">0x03B</span><span class="p">,</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">buff_size</span><span class="p">);</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">cfg80211_testmode_alloc_reply_skb</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wiphy</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">)</span> <span class="o">+</span> <span class="mi">20</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Memory allocation fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">iwl_trace_cleanup</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IWL_TM_ATTR_TRACE_ADDR</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">),</span>
			    <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">cfg80211_testmode_reply</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Error sending msg : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">num_chunks</span> <span class="o">=</span>
			<span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">buff_size</span><span class="p">,</span>
				     <span class="n">DUMP_CHUNK_SIZE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_END_TRACE</span>:
		<span class="n">iwl_trace_cleanup</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Unknown testmode mem command ID</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

<span class="nl">nla_put_failure:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nla_get_u32</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_COMMAND</span><span class="p">])</span> <span class="o">==</span>
	    <span class="n">IWL_TM_CMD_APP2DEV_BEGIN_TRACE</span><span class="p">)</span>
		<span class="n">iwl_trace_cleanup</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_testmode_trace_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">netlink_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">IWL_MAC80211_GET_DVM</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">length</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">trace_enabled</span> <span class="o">&amp;&amp;</span>
	    <span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">trace_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">num_chunks</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">DUMP_CHUNK_SIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">num_chunks</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">buff_size</span> <span class="o">%</span> <span class="n">DUMP_CHUNK_SIZE</span><span class="p">))</span>
			<span class="n">length</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">buff_size</span> <span class="o">%</span>
				<span class="n">DUMP_CHUNK_SIZE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IWL_TM_ATTR_TRACE_DUMP</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span>
			    <span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_trace</span><span class="p">.</span><span class="n">trace_addr</span> <span class="o">+</span>
			    <span class="p">(</span><span class="n">DUMP_CHUNK_SIZE</span> <span class="o">*</span> <span class="n">idx</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>
		<span class="n">idx</span><span class="o">++</span><span class="p">;</span>
		<span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

 <span class="nl">nla_put_failure:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function handles the user application switch ucode ownership.</span>
<span class="cm"> *</span>
<span class="cm"> * It retrieves the mandatory fields IWL_TM_ATTR_UCODE_OWNER and</span>
<span class="cm"> * decide who the current owner of the uCode</span>
<span class="cm"> *</span>
<span class="cm"> * If the current owner is OWNERSHIP_TM, then the only host command</span>
<span class="cm"> * can deliver to uCode is from testmode, all the other host commands</span>
<span class="cm"> * will dropped.</span>
<span class="cm"> *</span>
<span class="cm"> * default driver is the owner of uCode in normal operational mode</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: ieee80211_hw object that represents the device</span>
<span class="cm"> * @tb: gnl message fields from the user space</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_testmode_ownership</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">**</span><span class="n">tb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">IWL_MAC80211_GET_DVM</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">owner</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_UCODE_OWNER</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Missing ucode owner</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMSG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">owner</span> <span class="o">=</span> <span class="n">nla_get_u8</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_UCODE_OWNER</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">owner</span> <span class="o">==</span> <span class="n">IWL_OWNERSHIP_DRIVER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ucode_owner</span> <span class="o">=</span> <span class="n">owner</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">pre_rx_handler</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">owner</span> <span class="o">==</span> <span class="n">IWL_OWNERSHIP_TM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">pre_rx_handler</span> <span class="o">=</span> <span class="n">iwl_testmode_ucode_rx_pkt</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ucode_owner</span> <span class="o">=</span> <span class="n">owner</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Invalid owner</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_testmode_indirect_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_mem</span><span class="p">.</span><span class="n">buff_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_mem</span><span class="p">.</span><span class="n">buff_addr</span> <span class="o">=</span>
		<span class="n">kmalloc</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_mem</span><span class="p">.</span><span class="n">buff_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_mem</span><span class="p">.</span><span class="n">buff_addr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Hard-coded periphery absolute address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IWL_TM_ABS_PRPH_START</span> <span class="o">&lt;=</span> <span class="n">addr</span> <span class="o">&amp;&amp;</span>
		<span class="n">addr</span> <span class="o">&lt;</span> <span class="n">IWL_TM_ABS_PRPH_START</span> <span class="o">+</span> <span class="n">PRPH_END</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">iwl_grab_nic_access</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
			<span class="n">iwl_write32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">HBUS_TARG_PRPH_RADDR</span><span class="p">,</span>
				<span class="n">addr</span> <span class="o">|</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">));</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span>
				<span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_mem</span><span class="p">.</span><span class="n">buff_addr</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span>
					<span class="n">iwl_read32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">HBUS_TARG_PRPH_RDAT</span><span class="p">);</span>
			<span class="n">iwl_release_nic_access</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="cm">/* target memory (SRAM) */</span>
		<span class="n">_iwl_read_targ_mem_words</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_mem</span><span class="p">.</span><span class="n">buff_addr</span><span class="p">,</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_mem</span><span class="p">.</span><span class="n">buff_size</span> <span class="o">/</span> <span class="mi">4</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_mem</span><span class="p">.</span><span class="n">num_chunks</span> <span class="o">=</span>
		<span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_mem</span><span class="p">.</span><span class="n">buff_size</span><span class="p">,</span> <span class="n">DUMP_CHUNK_SIZE</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_mem</span><span class="p">.</span><span class="n">read_in_progress</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_testmode_indirect_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IWL_TM_ABS_PRPH_START</span> <span class="o">&lt;=</span> <span class="n">addr</span> <span class="o">&amp;&amp;</span>
		<span class="n">addr</span> <span class="o">&lt;</span> <span class="n">IWL_TM_ABS_PRPH_START</span> <span class="o">+</span> <span class="n">PRPH_END</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Periphery writes can be 1-3 bytes long, or DWORDs */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="n">iwl_grab_nic_access</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
				<span class="n">iwl_write32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">HBUS_TARG_PRPH_WADDR</span><span class="p">,</span>
					    <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0x0000FFFF</span><span class="p">)</span> <span class="o">|</span>
					    <span class="p">((</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">));</span>
				<span class="n">iwl_write32</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">HBUS_TARG_PRPH_WDAT</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
				<span class="n">iwl_release_nic_access</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
				<span class="cm">/* needed after consecutive writes w/o read */</span>
				<span class="n">mmiowb</span><span class="p">();</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span>
					<span class="n">iwl_write_prph</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">addr</span><span class="o">+</span><span class="n">i</span><span class="p">,</span>
						<span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">buf</span><span class="o">+</span><span class="n">i</span><span class="p">));</span>
			<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">iwlagn_hw_valid_rtc_data_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">IWLAGN_RTC_INST_LOWER_BOUND</span> <span class="o">&lt;=</span> <span class="n">addr</span> <span class="o">&amp;&amp;</span>
		<span class="n">addr</span> <span class="o">&lt;</span> <span class="n">IWLAGN_RTC_INST_UPPER_BOUND</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">_iwl_write_targ_mem_words</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="o">/</span><span class="mi">4</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function handles the user application commands for SRAM data dump</span>
<span class="cm"> *</span>
<span class="cm"> * It retrieves the mandatory fields IWL_TM_ATTR_SRAM_ADDR and</span>
<span class="cm"> * IWL_TM_ATTR_SRAM_SIZE to decide the memory area for SRAM data reading</span>
<span class="cm"> *</span>
<span class="cm"> * Several error will be retured, -EBUSY if the SRAM data retrieved by</span>
<span class="cm"> * previous command has not been delivered to userspace, or -ENOMSG if</span>
<span class="cm"> * the mandatory fields (IWL_TM_ATTR_SRAM_ADDR,IWL_TM_ATTR_SRAM_SIZE)</span>
<span class="cm"> * are missing, or -ENOMEM if the buffer allocation fails.</span>
<span class="cm"> *</span>
<span class="cm"> * Otherwise 0 is replied indicating the success of the SRAM reading.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: ieee80211_hw object that represents the device</span>
<span class="cm"> * @tb: gnl message fields from the user space</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_testmode_indirect_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">nlattr</span> <span class="o">**</span><span class="n">tb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">IWL_MAC80211_GET_DVM</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="cm">/* Both read and write should be blocked, for atomicity */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_mem</span><span class="p">.</span><span class="n">read_in_progress</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">nla_get_u32</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_COMMAND</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_MEM_ADDR</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Error finding memory offset address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMSG</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">nla_get_u32</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_MEM_ADDR</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_BUFFER_SIZE</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Error finding size for memory reading</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMSG</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">nla_get_u32</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_BUFFER_SIZE</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">IWL_TM_CMD_APP2DEV_INDIRECT_BUFFER_READ</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">iwl_testmode_indirect_read</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>  <span class="n">size</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_BUFFER_DUMP</span><span class="p">])</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">nla_data</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_BUFFER_DUMP</span><span class="p">]);</span>
		<span class="k">return</span> <span class="n">iwl_testmode_indirect_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_testmode_buffer_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">netlink_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">IWL_MAC80211_GET_DVM</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">length</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_mem</span><span class="p">.</span><span class="n">read_in_progress</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_mem</span><span class="p">.</span><span class="n">num_chunks</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iwl_mem_cleanup</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">DUMP_CHUNK_SIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_mem</span><span class="p">.</span><span class="n">num_chunks</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_mem</span><span class="p">.</span><span class="n">buff_size</span> <span class="o">%</span> <span class="n">DUMP_CHUNK_SIZE</span><span class="p">))</span>
			<span class="n">length</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_mem</span><span class="p">.</span><span class="n">buff_size</span> <span class="o">%</span>
				<span class="n">DUMP_CHUNK_SIZE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IWL_TM_ATTR_BUFFER_DUMP</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span>
			    <span class="n">priv</span><span class="o">-&gt;</span><span class="n">testmode_mem</span><span class="p">.</span><span class="n">buff_addr</span> <span class="o">+</span>
			    <span class="p">(</span><span class="n">DUMP_CHUNK_SIZE</span> <span class="o">*</span> <span class="n">idx</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>
		<span class="n">idx</span><span class="o">++</span><span class="p">;</span>
		<span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

 <span class="nl">nla_put_failure:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_testmode_notifications</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">nlattr</span> <span class="o">**</span><span class="n">tb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">IWL_MAC80211_GET_DVM</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">enable</span><span class="p">;</span>

	<span class="n">enable</span> <span class="o">=</span> <span class="n">nla_get_flag</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_ENABLE_NOTIFICATION</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">pre_rx_handler</span> <span class="o">=</span> <span class="n">iwl_testmode_ucode_rx_pkt</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">pre_rx_handler</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* The testmode gnl message handler that takes the gnl message from the</span>
<span class="cm"> * user space and parses it per the policy iwl_testmode_gnl_msg_policy, then</span>
<span class="cm"> * invoke the corresponding handlers.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is invoked when there is user space application sending</span>
<span class="cm"> * gnl message through the testmode tunnel NL80211_CMD_TESTMODE regulated</span>
<span class="cm"> * by nl80211.</span>
<span class="cm"> *</span>
<span class="cm"> * It retrieves the mandatory field, IWL_TM_ATTR_COMMAND, before</span>
<span class="cm"> * dispatching it to the corresponding handler.</span>
<span class="cm"> *</span>
<span class="cm"> * If IWL_TM_ATTR_COMMAND is missing, -ENOMSG is replied to user application;</span>
<span class="cm"> * -ENOSYS is replied to the user application if the command is unknown;</span>
<span class="cm"> * Otherwise, the command is dispatched to the respective handler.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: ieee80211_hw object that represents the device</span>
<span class="cm"> * @data: pointer to user space message</span>
<span class="cm"> * @len: length in byte of @data</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iwlagn_mac_testmode_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_MAX</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">IWL_MAC80211_GET_DVM</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">nla_parse</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">IWL_TM_ATTR_MAX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
			<span class="n">iwl_testmode_gnl_msg_policy</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Error parsing the gnl message : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* IWL_TM_ATTR_COMMAND is absolutely mandatory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_COMMAND</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Missing testmode command type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMSG</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* in case multiple accesses to the device happens */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">nla_get_u32</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_COMMAND</span><span class="p">]))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_UCODE</span>:
		<span class="n">IWL_DEBUG_INFO</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;testmode cmd to uCode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">iwl_testmode_ucode</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">tb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_DIRECT_REG_READ32</span>:
	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_DIRECT_REG_WRITE32</span>:
	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_DIRECT_REG_WRITE8</span>:
		<span class="n">IWL_DEBUG_INFO</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;testmode cmd to register</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">iwl_testmode_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">tb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_GET_DEVICENAME</span>:
	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_LOAD_INIT_FW</span>:
	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_CFG_INIT_CALIB</span>:
	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_LOAD_RUNTIME_FW</span>:
	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_GET_EEPROM</span>:
	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_FIXRATE_REQ</span>:
	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_LOAD_WOWLAN_FW</span>:
	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_GET_FW_VERSION</span>:
	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_GET_DEVICE_ID</span>:
	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_GET_FW_INFO</span>:
		<span class="n">IWL_DEBUG_INFO</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;testmode cmd to driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">iwl_testmode_driver</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">tb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_BEGIN_TRACE</span>:
	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_END_TRACE</span>:
	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_READ_TRACE</span>:
		<span class="n">IWL_DEBUG_INFO</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;testmode uCode trace cmd to driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">iwl_testmode_trace</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">tb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_OWNERSHIP</span>:
		<span class="n">IWL_DEBUG_INFO</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;testmode change uCode ownership</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">iwl_testmode_ownership</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">tb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_INDIRECT_BUFFER_READ</span>:
	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_INDIRECT_BUFFER_WRITE</span>:
		<span class="n">IWL_DEBUG_INFO</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;testmode indirect memory cmd &quot;</span>
			<span class="s">&quot;to driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">iwl_testmode_indirect_mem</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">tb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_NOTIFICATIONS</span>:
		<span class="n">IWL_DEBUG_INFO</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;testmode notifications cmd &quot;</span>
			<span class="s">&quot;to driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">iwl_testmode_notifications</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">tb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Unknown testmode command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">iwlagn_mac_testmode_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">netlink_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span>
		      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_MAX</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">IWL_MAC80211_GET_DVM</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cmd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="p">{</span>
		<span class="cm">/* offset by 1 since commands start at 0 */</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">nla_parse</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">IWL_TM_ATTR_MAX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
				<span class="n">iwl_testmode_gnl_msg_policy</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span>
				<span class="s">&quot;Error parsing the gnl message : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* IWL_TM_ATTR_COMMAND is absolutely mandatory */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_COMMAND</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Missing testmode command type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMSG</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">nla_get_u32</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">IWL_TM_ATTR_COMMAND</span><span class="p">]);</span>
		<span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmd</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* in case multiple accesses to the device happens */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_READ_TRACE</span>:
		<span class="n">IWL_DEBUG_INFO</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;uCode trace cmd to driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">iwl_testmode_trace_dump</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IWL_TM_CMD_APP2DEV_INDIRECT_BUFFER_DUMP</span>:
		<span class="n">IWL_DEBUG_INFO</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;testmode sram dump cmd to driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">iwl_testmode_buffer_dump</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
