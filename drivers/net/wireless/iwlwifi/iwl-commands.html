<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › iwlwifi › iwl-commands.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>iwl-commands.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * This file is provided under a dual BSD/GPLv2 license.  When using or</span>
<span class="cm"> * redistributing this file, you may do so under either license.</span>
<span class="cm"> *</span>
<span class="cm"> * GPL LICENSE SUMMARY</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2005 - 2012 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of version 2 of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,</span>
<span class="cm"> * USA</span>
<span class="cm"> *</span>
<span class="cm"> * The full GNU General Public License is included in this distribution</span>
<span class="cm"> * in the file called LICENSE.GPL.</span>
<span class="cm"> *</span>
<span class="cm"> * Contact Information:</span>
<span class="cm"> *  Intel Linux Wireless &lt;ilw@linux.intel.com&gt;</span>
<span class="cm"> * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>
<span class="cm"> *</span>
<span class="cm"> * BSD LICENSE</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2005 - 2012 Intel Corporation. All rights reserved.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> *</span>
<span class="cm"> *  * Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *  * Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer in</span>
<span class="cm"> *    the documentation and/or other materials provided with the</span>
<span class="cm"> *    distribution.</span>
<span class="cm"> *  * Neither the name Intel Corporation nor the names of its</span>
<span class="cm"> *    contributors may be used to endorse or promote products derived</span>
<span class="cm"> *    from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="cm"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="cm"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="cm"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="cm"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>
<span class="cm">/*</span>
<span class="cm"> * Please use this file (iwl-commands.h) only for uCode API definitions.</span>
<span class="cm"> * Please use iwl-xxxx-hw.h for hardware-related definitions.</span>
<span class="cm"> * Please use iwl-dev.h for driver implementation definitions.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __iwl_commands_h__</span>
<span class="cp">#define __iwl_commands_h__</span>

<span class="cp">#include &lt;linux/ieee80211.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>


<span class="k">enum</span> <span class="p">{</span>
	<span class="n">REPLY_ALIVE</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
	<span class="n">REPLY_ERROR</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>
	<span class="n">REPLY_ECHO</span> <span class="o">=</span> <span class="mh">0x3</span><span class="p">,</span>		<span class="cm">/* test command */</span>

	<span class="cm">/* RXON and QOS commands */</span>
	<span class="n">REPLY_RXON</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
	<span class="n">REPLY_RXON_ASSOC</span> <span class="o">=</span> <span class="mh">0x11</span><span class="p">,</span>
	<span class="n">REPLY_QOS_PARAM</span> <span class="o">=</span> <span class="mh">0x13</span><span class="p">,</span>
	<span class="n">REPLY_RXON_TIMING</span> <span class="o">=</span> <span class="mh">0x14</span><span class="p">,</span>

	<span class="cm">/* Multi-Station support */</span>
	<span class="n">REPLY_ADD_STA</span> <span class="o">=</span> <span class="mh">0x18</span><span class="p">,</span>
	<span class="n">REPLY_REMOVE_STA</span> <span class="o">=</span> <span class="mh">0x19</span><span class="p">,</span>
	<span class="n">REPLY_REMOVE_ALL_STA</span> <span class="o">=</span> <span class="mh">0x1a</span><span class="p">,</span>	<span class="cm">/* not used */</span>
	<span class="n">REPLY_TXFIFO_FLUSH</span> <span class="o">=</span> <span class="mh">0x1e</span><span class="p">,</span>

	<span class="cm">/* Security */</span>
	<span class="n">REPLY_WEPKEY</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>

	<span class="cm">/* RX, TX, LEDs */</span>
	<span class="n">REPLY_TX</span> <span class="o">=</span> <span class="mh">0x1c</span><span class="p">,</span>
	<span class="n">REPLY_LEDS_CMD</span> <span class="o">=</span> <span class="mh">0x48</span><span class="p">,</span>
	<span class="n">REPLY_TX_LINK_QUALITY_CMD</span> <span class="o">=</span> <span class="mh">0x4e</span><span class="p">,</span>

	<span class="cm">/* WiMAX coexistence */</span>
	<span class="n">COEX_PRIORITY_TABLE_CMD</span> <span class="o">=</span> <span class="mh">0x5a</span><span class="p">,</span>
	<span class="n">COEX_MEDIUM_NOTIFICATION</span> <span class="o">=</span> <span class="mh">0x5b</span><span class="p">,</span>
	<span class="n">COEX_EVENT_CMD</span> <span class="o">=</span> <span class="mh">0x5c</span><span class="p">,</span>

	<span class="cm">/* Calibration */</span>
	<span class="n">TEMPERATURE_NOTIFICATION</span> <span class="o">=</span> <span class="mh">0x62</span><span class="p">,</span>
	<span class="n">CALIBRATION_CFG_CMD</span> <span class="o">=</span> <span class="mh">0x65</span><span class="p">,</span>
	<span class="n">CALIBRATION_RES_NOTIFICATION</span> <span class="o">=</span> <span class="mh">0x66</span><span class="p">,</span>
	<span class="n">CALIBRATION_COMPLETE_NOTIFICATION</span> <span class="o">=</span> <span class="mh">0x67</span><span class="p">,</span>

	<span class="cm">/* 802.11h related */</span>
	<span class="n">REPLY_QUIET_CMD</span> <span class="o">=</span> <span class="mh">0x71</span><span class="p">,</span>		<span class="cm">/* not used */</span>
	<span class="n">REPLY_CHANNEL_SWITCH</span> <span class="o">=</span> <span class="mh">0x72</span><span class="p">,</span>
	<span class="n">CHANNEL_SWITCH_NOTIFICATION</span> <span class="o">=</span> <span class="mh">0x73</span><span class="p">,</span>
	<span class="n">REPLY_SPECTRUM_MEASUREMENT_CMD</span> <span class="o">=</span> <span class="mh">0x74</span><span class="p">,</span>
	<span class="n">SPECTRUM_MEASURE_NOTIFICATION</span> <span class="o">=</span> <span class="mh">0x75</span><span class="p">,</span>

	<span class="cm">/* Power Management */</span>
	<span class="n">POWER_TABLE_CMD</span> <span class="o">=</span> <span class="mh">0x77</span><span class="p">,</span>
	<span class="n">PM_SLEEP_NOTIFICATION</span> <span class="o">=</span> <span class="mh">0x7A</span><span class="p">,</span>
	<span class="n">PM_DEBUG_STATISTIC_NOTIFIC</span> <span class="o">=</span> <span class="mh">0x7B</span><span class="p">,</span>

	<span class="cm">/* Scan commands and notifications */</span>
	<span class="n">REPLY_SCAN_CMD</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">,</span>
	<span class="n">REPLY_SCAN_ABORT_CMD</span> <span class="o">=</span> <span class="mh">0x81</span><span class="p">,</span>
	<span class="n">SCAN_START_NOTIFICATION</span> <span class="o">=</span> <span class="mh">0x82</span><span class="p">,</span>
	<span class="n">SCAN_RESULTS_NOTIFICATION</span> <span class="o">=</span> <span class="mh">0x83</span><span class="p">,</span>
	<span class="n">SCAN_COMPLETE_NOTIFICATION</span> <span class="o">=</span> <span class="mh">0x84</span><span class="p">,</span>

	<span class="cm">/* IBSS/AP commands */</span>
	<span class="n">BEACON_NOTIFICATION</span> <span class="o">=</span> <span class="mh">0x90</span><span class="p">,</span>
	<span class="n">REPLY_TX_BEACON</span> <span class="o">=</span> <span class="mh">0x91</span><span class="p">,</span>
	<span class="n">WHO_IS_AWAKE_NOTIFICATION</span> <span class="o">=</span> <span class="mh">0x94</span><span class="p">,</span>	<span class="cm">/* not used */</span>

	<span class="cm">/* Miscellaneous commands */</span>
	<span class="n">REPLY_TX_POWER_DBM_CMD</span> <span class="o">=</span> <span class="mh">0x95</span><span class="p">,</span>
	<span class="n">QUIET_NOTIFICATION</span> <span class="o">=</span> <span class="mh">0x96</span><span class="p">,</span>		<span class="cm">/* not used */</span>
	<span class="n">REPLY_TX_PWR_TABLE_CMD</span> <span class="o">=</span> <span class="mh">0x97</span><span class="p">,</span>
	<span class="n">REPLY_TX_POWER_DBM_CMD_V1</span> <span class="o">=</span> <span class="mh">0x98</span><span class="p">,</span>	<span class="cm">/* old version of API */</span>
	<span class="n">TX_ANT_CONFIGURATION_CMD</span> <span class="o">=</span> <span class="mh">0x98</span><span class="p">,</span>
	<span class="n">MEASURE_ABORT_NOTIFICATION</span> <span class="o">=</span> <span class="mh">0x99</span><span class="p">,</span>	<span class="cm">/* not used */</span>

	<span class="cm">/* Bluetooth device coexistence config command */</span>
	<span class="n">REPLY_BT_CONFIG</span> <span class="o">=</span> <span class="mh">0x9b</span><span class="p">,</span>

	<span class="cm">/* Statistics */</span>
	<span class="n">REPLY_STATISTICS_CMD</span> <span class="o">=</span> <span class="mh">0x9c</span><span class="p">,</span>
	<span class="n">STATISTICS_NOTIFICATION</span> <span class="o">=</span> <span class="mh">0x9d</span><span class="p">,</span>

	<span class="cm">/* RF-KILL commands and notifications */</span>
	<span class="n">REPLY_CARD_STATE_CMD</span> <span class="o">=</span> <span class="mh">0xa0</span><span class="p">,</span>
	<span class="n">CARD_STATE_NOTIFICATION</span> <span class="o">=</span> <span class="mh">0xa1</span><span class="p">,</span>

	<span class="cm">/* Missed beacons notification */</span>
	<span class="n">MISSED_BEACONS_NOTIFICATION</span> <span class="o">=</span> <span class="mh">0xa2</span><span class="p">,</span>

	<span class="n">REPLY_CT_KILL_CONFIG_CMD</span> <span class="o">=</span> <span class="mh">0xa4</span><span class="p">,</span>
	<span class="n">SENSITIVITY_CMD</span> <span class="o">=</span> <span class="mh">0xa8</span><span class="p">,</span>
	<span class="n">REPLY_PHY_CALIBRATION_CMD</span> <span class="o">=</span> <span class="mh">0xb0</span><span class="p">,</span>
	<span class="n">REPLY_RX_PHY_CMD</span> <span class="o">=</span> <span class="mh">0xc0</span><span class="p">,</span>
	<span class="n">REPLY_RX_MPDU_CMD</span> <span class="o">=</span> <span class="mh">0xc1</span><span class="p">,</span>
	<span class="n">REPLY_RX</span> <span class="o">=</span> <span class="mh">0xc3</span><span class="p">,</span>
	<span class="n">REPLY_COMPRESSED_BA</span> <span class="o">=</span> <span class="mh">0xc5</span><span class="p">,</span>

	<span class="cm">/* BT Coex */</span>
	<span class="n">REPLY_BT_COEX_PRIO_TABLE</span> <span class="o">=</span> <span class="mh">0xcc</span><span class="p">,</span>
	<span class="n">REPLY_BT_COEX_PROT_ENV</span> <span class="o">=</span> <span class="mh">0xcd</span><span class="p">,</span>
	<span class="n">REPLY_BT_COEX_PROFILE_NOTIF</span> <span class="o">=</span> <span class="mh">0xce</span><span class="p">,</span>

	<span class="cm">/* PAN commands */</span>
	<span class="n">REPLY_WIPAN_PARAMS</span> <span class="o">=</span> <span class="mh">0xb2</span><span class="p">,</span>
	<span class="n">REPLY_WIPAN_RXON</span> <span class="o">=</span> <span class="mh">0xb3</span><span class="p">,</span>	<span class="cm">/* use REPLY_RXON structure */</span>
	<span class="n">REPLY_WIPAN_RXON_TIMING</span> <span class="o">=</span> <span class="mh">0xb4</span><span class="p">,</span>	<span class="cm">/* use REPLY_RXON_TIMING structure */</span>
	<span class="n">REPLY_WIPAN_RXON_ASSOC</span> <span class="o">=</span> <span class="mh">0xb6</span><span class="p">,</span>	<span class="cm">/* use REPLY_RXON_ASSOC structure */</span>
	<span class="n">REPLY_WIPAN_QOS_PARAM</span> <span class="o">=</span> <span class="mh">0xb7</span><span class="p">,</span>	<span class="cm">/* use REPLY_QOS_PARAM structure */</span>
	<span class="n">REPLY_WIPAN_WEPKEY</span> <span class="o">=</span> <span class="mh">0xb8</span><span class="p">,</span>	<span class="cm">/* use REPLY_WEPKEY structure */</span>
	<span class="n">REPLY_WIPAN_P2P_CHANNEL_SWITCH</span> <span class="o">=</span> <span class="mh">0xb9</span><span class="p">,</span>
	<span class="n">REPLY_WIPAN_NOA_NOTIFICATION</span> <span class="o">=</span> <span class="mh">0xbc</span><span class="p">,</span>
	<span class="n">REPLY_WIPAN_DEACTIVATION_COMPLETE</span> <span class="o">=</span> <span class="mh">0xbd</span><span class="p">,</span>

	<span class="n">REPLY_WOWLAN_PATTERNS</span> <span class="o">=</span> <span class="mh">0xe0</span><span class="p">,</span>
	<span class="n">REPLY_WOWLAN_WAKEUP_FILTER</span> <span class="o">=</span> <span class="mh">0xe1</span><span class="p">,</span>
	<span class="n">REPLY_WOWLAN_TSC_RSC_PARAMS</span> <span class="o">=</span> <span class="mh">0xe2</span><span class="p">,</span>
	<span class="n">REPLY_WOWLAN_TKIP_PARAMS</span> <span class="o">=</span> <span class="mh">0xe3</span><span class="p">,</span>
	<span class="n">REPLY_WOWLAN_KEK_KCK_MATERIAL</span> <span class="o">=</span> <span class="mh">0xe4</span><span class="p">,</span>
	<span class="n">REPLY_WOWLAN_GET_STATUS</span> <span class="o">=</span> <span class="mh">0xe5</span><span class="p">,</span>
	<span class="n">REPLY_D3_CONFIG</span> <span class="o">=</span> <span class="mh">0xd3</span><span class="p">,</span>

	<span class="n">REPLY_MAX</span> <span class="o">=</span> <span class="mh">0xff</span>
<span class="p">};</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * (0)</span>
<span class="cm"> * Commonly used structures and definitions:</span>
<span class="cm"> * Command header, rate_n_flags, txpower</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cm">/* iwl_cmd_header flags value */</span>
<span class="cp">#define IWL_CMD_FAILED_MSK 0x40</span>

<span class="cm">/**</span>
<span class="cm"> * iwlagn rate_n_flags bit fields</span>
<span class="cm"> *</span>
<span class="cm"> * rate_n_flags format is used in following iwlagn commands:</span>
<span class="cm"> *  REPLY_RX (response only)</span>
<span class="cm"> *  REPLY_RX_MPDU (response only)</span>
<span class="cm"> *  REPLY_TX (both command and response)</span>
<span class="cm"> *  REPLY_TX_LINK_QUALITY_CMD</span>
<span class="cm"> *</span>
<span class="cm"> * High-throughput (HT) rate format for bits 7:0 (bit 8 must be &quot;1&quot;):</span>
<span class="cm"> *  2-0:  0)   6 Mbps</span>
<span class="cm"> *        1)  12 Mbps</span>
<span class="cm"> *        2)  18 Mbps</span>
<span class="cm"> *        3)  24 Mbps</span>
<span class="cm"> *        4)  36 Mbps</span>
<span class="cm"> *        5)  48 Mbps</span>
<span class="cm"> *        6)  54 Mbps</span>
<span class="cm"> *        7)  60 Mbps</span>
<span class="cm"> *</span>
<span class="cm"> *  4-3:  0)  Single stream (SISO)</span>
<span class="cm"> *        1)  Dual stream (MIMO)</span>
<span class="cm"> *        2)  Triple stream (MIMO)</span>
<span class="cm"> *</span>
<span class="cm"> *    5:  Value of 0x20 in bits 7:0 indicates 6 Mbps HT40 duplicate data</span>
<span class="cm"> *</span>
<span class="cm"> * Legacy OFDM rate format for bits 7:0 (bit 8 must be &quot;0&quot;, bit 9 &quot;0&quot;):</span>
<span class="cm"> *  3-0:  0xD)   6 Mbps</span>
<span class="cm"> *        0xF)   9 Mbps</span>
<span class="cm"> *        0x5)  12 Mbps</span>
<span class="cm"> *        0x7)  18 Mbps</span>
<span class="cm"> *        0x9)  24 Mbps</span>
<span class="cm"> *        0xB)  36 Mbps</span>
<span class="cm"> *        0x1)  48 Mbps</span>
<span class="cm"> *        0x3)  54 Mbps</span>
<span class="cm"> *</span>
<span class="cm"> * Legacy CCK rate format for bits 7:0 (bit 8 must be &quot;0&quot;, bit 9 &quot;1&quot;):</span>
<span class="cm"> *  6-0:   10)  1 Mbps</span>
<span class="cm"> *         20)  2 Mbps</span>
<span class="cm"> *         55)  5.5 Mbps</span>
<span class="cm"> *        110)  11 Mbps</span>
<span class="cm"> */</span>
<span class="cp">#define RATE_MCS_CODE_MSK 0x7</span>
<span class="cp">#define RATE_MCS_SPATIAL_POS 3</span>
<span class="cp">#define RATE_MCS_SPATIAL_MSK 0x18</span>
<span class="cp">#define RATE_MCS_HT_DUP_POS 5</span>
<span class="cp">#define RATE_MCS_HT_DUP_MSK 0x20</span>
<span class="cm">/* Both legacy and HT use bits 7:0 as the CCK/OFDM rate or HT MCS */</span>
<span class="cp">#define RATE_MCS_RATE_MSK 0xff</span>

<span class="cm">/* Bit 8: (1) HT format, (0) legacy format in bits 7:0 */</span>
<span class="cp">#define RATE_MCS_FLAGS_POS 8</span>
<span class="cp">#define RATE_MCS_HT_POS 8</span>
<span class="cp">#define RATE_MCS_HT_MSK 0x100</span>

<span class="cm">/* Bit 9: (1) CCK, (0) OFDM.  HT (bit 8) must be &quot;0&quot; for this bit to be valid */</span>
<span class="cp">#define RATE_MCS_CCK_POS 9</span>
<span class="cp">#define RATE_MCS_CCK_MSK 0x200</span>

<span class="cm">/* Bit 10: (1) Use Green Field preamble */</span>
<span class="cp">#define RATE_MCS_GF_POS 10</span>
<span class="cp">#define RATE_MCS_GF_MSK 0x400</span>

<span class="cm">/* Bit 11: (1) Use 40Mhz HT40 chnl width, (0) use 20 MHz legacy chnl width */</span>
<span class="cp">#define RATE_MCS_HT40_POS 11</span>
<span class="cp">#define RATE_MCS_HT40_MSK 0x800</span>

<span class="cm">/* Bit 12: (1) Duplicate data on both 20MHz chnls. HT40 (bit 11) must be set. */</span>
<span class="cp">#define RATE_MCS_DUP_POS 12</span>
<span class="cp">#define RATE_MCS_DUP_MSK 0x1000</span>

<span class="cm">/* Bit 13: (1) Short guard interval (0.4 usec), (0) normal GI (0.8 usec) */</span>
<span class="cp">#define RATE_MCS_SGI_POS 13</span>
<span class="cp">#define RATE_MCS_SGI_MSK 0x2000</span>

<span class="cm">/**</span>
<span class="cm"> * rate_n_flags Tx antenna masks</span>
<span class="cm"> * 4965 has 2 transmitters</span>
<span class="cm"> * 5100 has 1 transmitter B</span>
<span class="cm"> * 5150 has 1 transmitter A</span>
<span class="cm"> * 5300 has 3 transmitters</span>
<span class="cm"> * 5350 has 3 transmitters</span>
<span class="cm"> * bit14:16</span>
<span class="cm"> */</span>
<span class="cp">#define RATE_MCS_ANT_POS	14</span>
<span class="cp">#define RATE_MCS_ANT_A_MSK	0x04000</span>
<span class="cp">#define RATE_MCS_ANT_B_MSK	0x08000</span>
<span class="cp">#define RATE_MCS_ANT_C_MSK	0x10000</span>
<span class="cp">#define RATE_MCS_ANT_AB_MSK	(RATE_MCS_ANT_A_MSK | RATE_MCS_ANT_B_MSK)</span>
<span class="cp">#define RATE_MCS_ANT_ABC_MSK	(RATE_MCS_ANT_AB_MSK | RATE_MCS_ANT_C_MSK)</span>
<span class="cp">#define RATE_ANT_NUM 3</span>

<span class="cp">#define POWER_TABLE_NUM_ENTRIES			33</span>
<span class="cp">#define POWER_TABLE_NUM_HT_OFDM_ENTRIES		32</span>
<span class="cp">#define POWER_TABLE_CCK_ENTRY			32</span>

<span class="cp">#define IWL_PWR_NUM_HT_OFDM_ENTRIES		24</span>
<span class="cp">#define IWL_PWR_CCK_ENTRIES			2</span>

<span class="cm">/**</span>
<span class="cm"> * struct tx_power_dual_stream</span>
<span class="cm"> *</span>
<span class="cm"> * Table entries in REPLY_TX_PWR_TABLE_CMD, REPLY_CHANNEL_SWITCH</span>
<span class="cm"> *</span>
<span class="cm"> * Same format as iwl_tx_power_dual_stream, but __le32</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tx_power_dual_stream</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">dw</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * Command REPLY_TX_POWER_DBM_CMD = 0x98</span>
<span class="cm"> * struct iwlagn_tx_power_dbm_cmd</span>
<span class="cm"> */</span>
<span class="cp">#define IWLAGN_TX_POWER_AUTO 0x7f</span>
<span class="cp">#define IWLAGN_TX_POWER_NO_CLOSED (0x1 &lt;&lt; 6)</span>

<span class="k">struct</span> <span class="n">iwlagn_tx_power_dbm_cmd</span> <span class="p">{</span>
	<span class="n">s8</span> <span class="n">global_lmt</span><span class="p">;</span> <span class="cm">/*in half-dBm (e.g. 30 = 15 dBm) */</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">s8</span> <span class="n">srv_chan_lmt</span><span class="p">;</span> <span class="cm">/*in half-dBm (e.g. 30 = 15 dBm) */</span>
	<span class="n">u8</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * Command TX_ANT_CONFIGURATION_CMD = 0x98</span>
<span class="cm"> * This command is used to configure valid Tx antenna.</span>
<span class="cm"> * By default uCode concludes the valid antenna according to the radio flavor.</span>
<span class="cm"> * This command enables the driver to override/modify this conclusion.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_tx_ant_config_cmd</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">valid</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * (0a)</span>
<span class="cm"> * Alive and Error Commands &amp; Responses:</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cp">#define UCODE_VALID_OK	cpu_to_le32(0x1)</span>

<span class="cm">/**</span>
<span class="cm"> * REPLY_ALIVE = 0x1 (response only, not a command)</span>
<span class="cm"> *</span>
<span class="cm"> * uCode issues this &quot;alive&quot; notification once the runtime image is ready</span>
<span class="cm"> * to receive commands from the driver.  This is the *second* &quot;alive&quot;</span>
<span class="cm"> * notification that the driver will receive after rebooting uCode;</span>
<span class="cm"> * this &quot;alive&quot; is indicated by subtype field != 9.</span>
<span class="cm"> *</span>
<span class="cm"> * See comments documenting &quot;BSM&quot; (bootstrap state machine).</span>
<span class="cm"> *</span>
<span class="cm"> * This response includes two pointers to structures within the device&#39;s</span>
<span class="cm"> * data SRAM (access via HBUS_TARG_MEM_* regs) that are useful for debugging:</span>
<span class="cm"> *</span>
<span class="cm"> * 1)  log_event_table_ptr indicates base of the event log.  This traces</span>
<span class="cm"> *     a 256-entry history of uCode execution within a circular buffer.</span>
<span class="cm"> *     Its header format is:</span>
<span class="cm"> *</span>
<span class="cm"> *	__le32 log_size;     log capacity (in number of entries)</span>
<span class="cm"> *	__le32 type;         (1) timestamp with each entry, (0) no timestamp</span>
<span class="cm"> *	__le32 wraps;        # times uCode has wrapped to top of circular buffer</span>
<span class="cm"> *      __le32 write_index;  next circular buffer entry that uCode would fill</span>
<span class="cm"> *</span>
<span class="cm"> *     The header is followed by the circular buffer of log entries.  Entries</span>
<span class="cm"> *     with timestamps have the following format:</span>
<span class="cm"> *</span>
<span class="cm"> *	__le32 event_id;     range 0 - 1500</span>
<span class="cm"> *	__le32 timestamp;    low 32 bits of TSF (of network, if associated)</span>
<span class="cm"> *	__le32 data;         event_id-specific data value</span>
<span class="cm"> *</span>
<span class="cm"> *     Entries without timestamps contain only event_id and data.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * 2)  error_event_table_ptr indicates base of the error log.  This contains</span>
<span class="cm"> *     information about any uCode error that occurs.  For agn, the format</span>
<span class="cm"> *     of the error log is defined by struct iwl_error_event_table.</span>
<span class="cm"> *</span>
<span class="cm"> * The Linux driver can print both logs to the system log when a uCode error</span>
<span class="cm"> * occurs.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Note: This structure is read from the device with IO accesses,</span>
<span class="cm"> * and the reading already does the endian conversion. As it is</span>
<span class="cm"> * read with u32-sized accesses, any members with a different size</span>
<span class="cm"> * need to be ordered correctly though!</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_error_event_table</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">valid</span><span class="p">;</span>		<span class="cm">/* (nonzero) valid, (0) log is empty */</span>
	<span class="n">u32</span> <span class="n">error_id</span><span class="p">;</span>		<span class="cm">/* type of error */</span>
	<span class="n">u32</span> <span class="n">pc</span><span class="p">;</span>			<span class="cm">/* program counter */</span>
	<span class="n">u32</span> <span class="n">blink1</span><span class="p">;</span>		<span class="cm">/* branch link */</span>
	<span class="n">u32</span> <span class="n">blink2</span><span class="p">;</span>		<span class="cm">/* branch link */</span>
	<span class="n">u32</span> <span class="n">ilink1</span><span class="p">;</span>		<span class="cm">/* interrupt link */</span>
	<span class="n">u32</span> <span class="n">ilink2</span><span class="p">;</span>		<span class="cm">/* interrupt link */</span>
	<span class="n">u32</span> <span class="n">data1</span><span class="p">;</span>		<span class="cm">/* error-specific data */</span>
	<span class="n">u32</span> <span class="n">data2</span><span class="p">;</span>		<span class="cm">/* error-specific data */</span>
	<span class="n">u32</span> <span class="n">line</span><span class="p">;</span>		<span class="cm">/* source code line of error */</span>
	<span class="n">u32</span> <span class="n">bcon_time</span><span class="p">;</span>		<span class="cm">/* beacon timer */</span>
	<span class="n">u32</span> <span class="n">tsf_low</span><span class="p">;</span>		<span class="cm">/* network timestamp function timer */</span>
	<span class="n">u32</span> <span class="n">tsf_hi</span><span class="p">;</span>		<span class="cm">/* network timestamp function timer */</span>
	<span class="n">u32</span> <span class="n">gp1</span><span class="p">;</span>		<span class="cm">/* GP1 timer register */</span>
	<span class="n">u32</span> <span class="n">gp2</span><span class="p">;</span>		<span class="cm">/* GP2 timer register */</span>
	<span class="n">u32</span> <span class="n">gp3</span><span class="p">;</span>		<span class="cm">/* GP3 timer register */</span>
	<span class="n">u32</span> <span class="n">ucode_ver</span><span class="p">;</span>		<span class="cm">/* uCode version */</span>
	<span class="n">u32</span> <span class="n">hw_ver</span><span class="p">;</span>		<span class="cm">/* HW Silicon version */</span>
	<span class="n">u32</span> <span class="n">brd_ver</span><span class="p">;</span>		<span class="cm">/* HW board version */</span>
	<span class="n">u32</span> <span class="n">log_pc</span><span class="p">;</span>		<span class="cm">/* log program counter */</span>
	<span class="n">u32</span> <span class="n">frame_ptr</span><span class="p">;</span>		<span class="cm">/* frame pointer */</span>
	<span class="n">u32</span> <span class="n">stack_ptr</span><span class="p">;</span>		<span class="cm">/* stack pointer */</span>
	<span class="n">u32</span> <span class="n">hcmd</span><span class="p">;</span>		<span class="cm">/* last host command header */</span>
	<span class="n">u32</span> <span class="n">isr0</span><span class="p">;</span>		<span class="cm">/* isr status register LMPM_NIC_ISR0:</span>
<span class="cm">				 * rxtx_flag */</span>
	<span class="n">u32</span> <span class="n">isr1</span><span class="p">;</span>		<span class="cm">/* isr status register LMPM_NIC_ISR1:</span>
<span class="cm">				 * host_flag */</span>
	<span class="n">u32</span> <span class="n">isr2</span><span class="p">;</span>		<span class="cm">/* isr status register LMPM_NIC_ISR2:</span>
<span class="cm">				 * enc_flag */</span>
	<span class="n">u32</span> <span class="n">isr3</span><span class="p">;</span>		<span class="cm">/* isr status register LMPM_NIC_ISR3:</span>
<span class="cm">				 * time_flag */</span>
	<span class="n">u32</span> <span class="n">isr4</span><span class="p">;</span>		<span class="cm">/* isr status register LMPM_NIC_ISR4:</span>
<span class="cm">				 * wico interrupt */</span>
	<span class="n">u32</span> <span class="n">isr_pref</span><span class="p">;</span>		<span class="cm">/* isr status register LMPM_NIC_PREF_STAT */</span>
	<span class="n">u32</span> <span class="n">wait_event</span><span class="p">;</span>		<span class="cm">/* wait event() caller address */</span>
	<span class="n">u32</span> <span class="n">l2p_control</span><span class="p">;</span>	<span class="cm">/* L2pControlField */</span>
	<span class="n">u32</span> <span class="n">l2p_duration</span><span class="p">;</span>	<span class="cm">/* L2pDurationField */</span>
	<span class="n">u32</span> <span class="n">l2p_mhvalid</span><span class="p">;</span>	<span class="cm">/* L2pMhValidBits */</span>
	<span class="n">u32</span> <span class="n">l2p_addr_match</span><span class="p">;</span>	<span class="cm">/* L2pAddrMatchStat */</span>
	<span class="n">u32</span> <span class="n">lmpm_pmg_sel</span><span class="p">;</span>	<span class="cm">/* indicate which clocks are turned on</span>
<span class="cm">				 * (LMPM_PMG_SEL) */</span>
	<span class="n">u32</span> <span class="n">u_timestamp</span><span class="p">;</span>	<span class="cm">/* indicate when the date and time of the</span>
<span class="cm">				 * compilation */</span>
	<span class="n">u32</span> <span class="n">flow_handler</span><span class="p">;</span>	<span class="cm">/* FH read/write pointers, RX credit */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">iwl_alive_resp</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">ucode_minor</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ucode_major</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">reserved1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">sw_rev</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">ver_type</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ver_subtype</span><span class="p">;</span>			<span class="cm">/* not &quot;9&quot; for runtime alive */</span>
	<span class="n">__le16</span> <span class="n">reserved2</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">log_event_table_ptr</span><span class="p">;</span>	<span class="cm">/* SRAM address for event log */</span>
	<span class="n">__le32</span> <span class="n">error_event_table_ptr</span><span class="p">;</span>	<span class="cm">/* SRAM address for error log */</span>
	<span class="n">__le32</span> <span class="n">timestamp</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">is_valid</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_ERROR = 0x2 (response only, not a command)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_error_resp</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">error_type</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cmd_id</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved1</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">bad_cmd_seq_num</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">error_info</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">timestamp</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * (1)</span>
<span class="cm"> * RXON Commands &amp; Responses:</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Rx config defines &amp; structure</span>
<span class="cm"> */</span>
<span class="cm">/* rx_config device types  */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">RXON_DEV_TYPE_AP</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">RXON_DEV_TYPE_ESS</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">RXON_DEV_TYPE_IBSS</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">RXON_DEV_TYPE_SNIFFER</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">RXON_DEV_TYPE_CP</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
	<span class="n">RXON_DEV_TYPE_2STA</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">RXON_DEV_TYPE_P2P</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
<span class="p">};</span>


<span class="cp">#define RXON_RX_CHAIN_DRIVER_FORCE_MSK		cpu_to_le16(0x1 &lt;&lt; 0)</span>
<span class="cp">#define RXON_RX_CHAIN_DRIVER_FORCE_POS		(0)</span>
<span class="cp">#define RXON_RX_CHAIN_VALID_MSK			cpu_to_le16(0x7 &lt;&lt; 1)</span>
<span class="cp">#define RXON_RX_CHAIN_VALID_POS			(1)</span>
<span class="cp">#define RXON_RX_CHAIN_FORCE_SEL_MSK		cpu_to_le16(0x7 &lt;&lt; 4)</span>
<span class="cp">#define RXON_RX_CHAIN_FORCE_SEL_POS		(4)</span>
<span class="cp">#define RXON_RX_CHAIN_FORCE_MIMO_SEL_MSK	cpu_to_le16(0x7 &lt;&lt; 7)</span>
<span class="cp">#define RXON_RX_CHAIN_FORCE_MIMO_SEL_POS	(7)</span>
<span class="cp">#define RXON_RX_CHAIN_CNT_MSK			cpu_to_le16(0x3 &lt;&lt; 10)</span>
<span class="cp">#define RXON_RX_CHAIN_CNT_POS			(10)</span>
<span class="cp">#define RXON_RX_CHAIN_MIMO_CNT_MSK		cpu_to_le16(0x3 &lt;&lt; 12)</span>
<span class="cp">#define RXON_RX_CHAIN_MIMO_CNT_POS		(12)</span>
<span class="cp">#define RXON_RX_CHAIN_MIMO_FORCE_MSK		cpu_to_le16(0x1 &lt;&lt; 14)</span>
<span class="cp">#define RXON_RX_CHAIN_MIMO_FORCE_POS		(14)</span>

<span class="cm">/* rx_config flags */</span>
<span class="cm">/* band &amp; modulation selection */</span>
<span class="cp">#define RXON_FLG_BAND_24G_MSK           cpu_to_le32(1 &lt;&lt; 0)</span>
<span class="cp">#define RXON_FLG_CCK_MSK                cpu_to_le32(1 &lt;&lt; 1)</span>
<span class="cm">/* auto detection enable */</span>
<span class="cp">#define RXON_FLG_AUTO_DETECT_MSK        cpu_to_le32(1 &lt;&lt; 2)</span>
<span class="cm">/* TGg protection when tx */</span>
<span class="cp">#define RXON_FLG_TGG_PROTECT_MSK        cpu_to_le32(1 &lt;&lt; 3)</span>
<span class="cm">/* cck short slot &amp; preamble */</span>
<span class="cp">#define RXON_FLG_SHORT_SLOT_MSK          cpu_to_le32(1 &lt;&lt; 4)</span>
<span class="cp">#define RXON_FLG_SHORT_PREAMBLE_MSK     cpu_to_le32(1 &lt;&lt; 5)</span>
<span class="cm">/* antenna selection */</span>
<span class="cp">#define RXON_FLG_DIS_DIV_MSK            cpu_to_le32(1 &lt;&lt; 7)</span>
<span class="cp">#define RXON_FLG_ANT_SEL_MSK            cpu_to_le32(0x0f00)</span>
<span class="cp">#define RXON_FLG_ANT_A_MSK              cpu_to_le32(1 &lt;&lt; 8)</span>
<span class="cp">#define RXON_FLG_ANT_B_MSK              cpu_to_le32(1 &lt;&lt; 9)</span>
<span class="cm">/* radar detection enable */</span>
<span class="cp">#define RXON_FLG_RADAR_DETECT_MSK       cpu_to_le32(1 &lt;&lt; 12)</span>
<span class="cp">#define RXON_FLG_TGJ_NARROW_BAND_MSK    cpu_to_le32(1 &lt;&lt; 13)</span>
<span class="cm">/* rx response to host with 8-byte TSF</span>
<span class="cm">* (according to ON_AIR deassertion) */</span>
<span class="cp">#define RXON_FLG_TSF2HOST_MSK           cpu_to_le32(1 &lt;&lt; 15)</span>


<span class="cm">/* HT flags */</span>
<span class="cp">#define RXON_FLG_CTRL_CHANNEL_LOC_POS		(22)</span>
<span class="cp">#define RXON_FLG_CTRL_CHANNEL_LOC_HI_MSK	cpu_to_le32(0x1 &lt;&lt; 22)</span>

<span class="cp">#define RXON_FLG_HT_OPERATING_MODE_POS		(23)</span>

<span class="cp">#define RXON_FLG_HT_PROT_MSK			cpu_to_le32(0x1 &lt;&lt; 23)</span>
<span class="cp">#define RXON_FLG_HT40_PROT_MSK			cpu_to_le32(0x2 &lt;&lt; 23)</span>

<span class="cp">#define RXON_FLG_CHANNEL_MODE_POS		(25)</span>
<span class="cp">#define RXON_FLG_CHANNEL_MODE_MSK		cpu_to_le32(0x3 &lt;&lt; 25)</span>

<span class="cm">/* channel mode */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">CHANNEL_MODE_LEGACY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">CHANNEL_MODE_PURE_40</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">CHANNEL_MODE_MIXED</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">CHANNEL_MODE_RESERVED</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#define RXON_FLG_CHANNEL_MODE_LEGACY	cpu_to_le32(CHANNEL_MODE_LEGACY &lt;&lt; RXON_FLG_CHANNEL_MODE_POS)</span>
<span class="cp">#define RXON_FLG_CHANNEL_MODE_PURE_40	cpu_to_le32(CHANNEL_MODE_PURE_40 &lt;&lt; RXON_FLG_CHANNEL_MODE_POS)</span>
<span class="cp">#define RXON_FLG_CHANNEL_MODE_MIXED	cpu_to_le32(CHANNEL_MODE_MIXED &lt;&lt; RXON_FLG_CHANNEL_MODE_POS)</span>

<span class="cm">/* CTS to self (if spec allows) flag */</span>
<span class="cp">#define RXON_FLG_SELF_CTS_EN			cpu_to_le32(0x1&lt;&lt;30)</span>

<span class="cm">/* rx_config filter flags */</span>
<span class="cm">/* accept all data frames */</span>
<span class="cp">#define RXON_FILTER_PROMISC_MSK         cpu_to_le32(1 &lt;&lt; 0)</span>
<span class="cm">/* pass control &amp; management to host */</span>
<span class="cp">#define RXON_FILTER_CTL2HOST_MSK        cpu_to_le32(1 &lt;&lt; 1)</span>
<span class="cm">/* accept multi-cast */</span>
<span class="cp">#define RXON_FILTER_ACCEPT_GRP_MSK      cpu_to_le32(1 &lt;&lt; 2)</span>
<span class="cm">/* don&#39;t decrypt uni-cast frames */</span>
<span class="cp">#define RXON_FILTER_DIS_DECRYPT_MSK     cpu_to_le32(1 &lt;&lt; 3)</span>
<span class="cm">/* don&#39;t decrypt multi-cast frames */</span>
<span class="cp">#define RXON_FILTER_DIS_GRP_DECRYPT_MSK cpu_to_le32(1 &lt;&lt; 4)</span>
<span class="cm">/* STA is associated */</span>
<span class="cp">#define RXON_FILTER_ASSOC_MSK           cpu_to_le32(1 &lt;&lt; 5)</span>
<span class="cm">/* transfer to host non bssid beacons in associated state */</span>
<span class="cp">#define RXON_FILTER_BCON_AWARE_MSK      cpu_to_le32(1 &lt;&lt; 6)</span>

<span class="cm">/**</span>
<span class="cm"> * REPLY_RXON = 0x10 (command, has simple generic response)</span>
<span class="cm"> *</span>
<span class="cm"> * RXON tunes the radio tuner to a service channel, and sets up a number</span>
<span class="cm"> * of parameters that are used primarily for Rx, but also for Tx operations.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  When tuning to a new channel, driver must set the</span>
<span class="cm"> *        RXON_FILTER_ASSOC_MSK to 0.  This will clear station-dependent</span>
<span class="cm"> *        info within the device, including the station tables, tx retry</span>
<span class="cm"> *        rate tables, and txpower tables.  Driver must build a new station</span>
<span class="cm"> *        table and txpower table before transmitting anything on the RXON</span>
<span class="cm"> *        channel.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  All RXONs wipe clean the internal txpower table.  Driver must</span>
<span class="cm"> *        issue a new REPLY_TX_PWR_TABLE_CMD after each REPLY_RXON (0x10),</span>
<span class="cm"> *        regardless of whether RXON_FILTER_ASSOC_MSK is set.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">iwl_rxon_cmd</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">node_addr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">__le16</span> <span class="n">reserved1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bssid_addr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">__le16</span> <span class="n">reserved2</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">wlap_bssid_addr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">__le16</span> <span class="n">reserved3</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">dev_type</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">air_propagation</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">rx_chain</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ofdm_basic_rates</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cck_basic_rates</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">assoc_id</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">filter_flags</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">channel</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ofdm_ht_single_stream_basic_rates</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ofdm_ht_dual_stream_basic_rates</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ofdm_ht_triple_stream_basic_rates</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved5</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">acquisition_data</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">reserved6</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_RXON_ASSOC = 0x11 (command, has simple generic response)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_rxon_assoc_cmd</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">filter_flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ofdm_basic_rates</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cck_basic_rates</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">reserved1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ofdm_ht_single_stream_basic_rates</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ofdm_ht_dual_stream_basic_rates</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ofdm_ht_triple_stream_basic_rates</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved2</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">rx_chain_select_flags</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">acquisition_data</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">reserved3</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cp">#define IWL_CONN_MAX_LISTEN_INTERVAL	10</span>
<span class="cp">#define IWL_MAX_UCODE_BEACON_INTERVAL	4 </span><span class="cm">/* 4096 */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_RXON_TIMING = 0x14 (command, has simple generic response)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_rxon_time_cmd</span> <span class="p">{</span>
	<span class="n">__le64</span> <span class="n">timestamp</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">beacon_interval</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">atim_window</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">beacon_init_val</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">listen_interval</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">dtim_period</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">delta_cp_bss_tbtts</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_CHANNEL_SWITCH = 0x72 (command, has simple generic response)</span>
<span class="cm"> */</span>
<span class="cm">/**</span>
<span class="cm"> * struct iwl5000_channel_switch_cmd</span>
<span class="cm"> * @band: 0- 5.2GHz, 1- 2.4GHz</span>
<span class="cm"> * @expect_beacon: 0- resume transmits after channel switch</span>
<span class="cm"> *		   1- wait for beacon to resume transmits</span>
<span class="cm"> * @channel: new channel number</span>
<span class="cm"> * @rxon_flags: Rx on flags</span>
<span class="cm"> * @rxon_filter_flags: filtering parameters</span>
<span class="cm"> * @switch_time: switch time in extended beacon format</span>
<span class="cm"> * @reserved: reserved bytes</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl5000_channel_switch_cmd</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">band</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">expect_beacon</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">channel</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">rxon_flags</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">rxon_filter_flags</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">switch_time</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">IWL_PWR_NUM_HT_OFDM_ENTRIES</span> <span class="o">+</span> <span class="n">IWL_PWR_CCK_ENTRIES</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct iwl6000_channel_switch_cmd</span>
<span class="cm"> * @band: 0- 5.2GHz, 1- 2.4GHz</span>
<span class="cm"> * @expect_beacon: 0- resume transmits after channel switch</span>
<span class="cm"> *		   1- wait for beacon to resume transmits</span>
<span class="cm"> * @channel: new channel number</span>
<span class="cm"> * @rxon_flags: Rx on flags</span>
<span class="cm"> * @rxon_filter_flags: filtering parameters</span>
<span class="cm"> * @switch_time: switch time in extended beacon format</span>
<span class="cm"> * @reserved: reserved bytes</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl6000_channel_switch_cmd</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">band</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">expect_beacon</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">channel</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">rxon_flags</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">rxon_filter_flags</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">switch_time</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">IWL_PWR_NUM_HT_OFDM_ENTRIES</span> <span class="o">+</span> <span class="n">IWL_PWR_CCK_ENTRIES</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * CHANNEL_SWITCH_NOTIFICATION = 0x73 (notification only, not a command)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_csa_notification</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">band</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">channel</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">status</span><span class="p">;</span>		<span class="cm">/* 0 - OK, 1 - fail */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * (2)</span>
<span class="cm"> * Quality-of-Service (QOS) Commands &amp; Responses:</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cm">/**</span>
<span class="cm"> * struct iwl_ac_qos -- QOS timing params for REPLY_QOS_PARAM</span>
<span class="cm"> * One for each of 4 EDCA access categories in struct iwl_qosparam_cmd</span>
<span class="cm"> *</span>
<span class="cm"> * @cw_min: Contention window, start value in numbers of slots.</span>
<span class="cm"> *          Should be a power-of-2, minus 1.  Device&#39;s default is 0x0f.</span>
<span class="cm"> * @cw_max: Contention window, max value in numbers of slots.</span>
<span class="cm"> *          Should be a power-of-2, minus 1.  Device&#39;s default is 0x3f.</span>
<span class="cm"> * @aifsn:  Number of slots in Arbitration Interframe Space (before</span>
<span class="cm"> *          performing random backoff timing prior to Tx).  Device default 1.</span>
<span class="cm"> * @edca_txop:  Length of Tx opportunity, in uSecs.  Device default is 0.</span>
<span class="cm"> *</span>
<span class="cm"> * Device will automatically increase contention window by (2*CW) + 1 for each</span>
<span class="cm"> * transmission retry.  Device uses cw_max as a bit mask, ANDed with new CW</span>
<span class="cm"> * value, to cap the CW value.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_ac_qos</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">cw_min</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">cw_max</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">aifsn</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved1</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">edca_txop</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* QoS flags defines */</span>
<span class="cp">#define QOS_PARAM_FLG_UPDATE_EDCA_MSK	cpu_to_le32(0x01)</span>
<span class="cp">#define QOS_PARAM_FLG_TGN_MSK		cpu_to_le32(0x02)</span>
<span class="cp">#define QOS_PARAM_FLG_TXOP_TYPE_MSK	cpu_to_le32(0x10)</span>

<span class="cm">/* Number of Access Categories (AC) (EDCA), queues 0..3 */</span>
<span class="cp">#define AC_NUM                4</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_QOS_PARAM = 0x13 (command, has simple generic response)</span>
<span class="cm"> *</span>
<span class="cm"> * This command sets up timings for each of the 4 prioritized EDCA Tx FIFOs</span>
<span class="cm"> * 0: Background, 1: Best Effort, 2: Video, 3: Voice.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_qosparam_cmd</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">qos_flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_ac_qos</span> <span class="n">ac</span><span class="p">[</span><span class="n">AC_NUM</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * (3)</span>
<span class="cm"> * Add/Modify Stations Commands &amp; Responses:</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>
<span class="cm">/*</span>
<span class="cm"> * Multi station support</span>
<span class="cm"> */</span>

<span class="cm">/* Special, dedicated locations within device&#39;s station table */</span>
<span class="cp">#define	IWL_AP_ID		0</span>
<span class="cp">#define	IWL_AP_ID_PAN		1</span>
<span class="cp">#define	IWL_STA_ID		2</span>
<span class="cp">#define IWLAGN_PAN_BCAST_ID	14</span>
<span class="cp">#define IWLAGN_BROADCAST_ID	15</span>
<span class="cp">#define	IWLAGN_STATION_COUNT	16</span>

<span class="cp">#define	IWL_INVALID_STATION 	255</span>
<span class="cp">#define IWL_MAX_TID_COUNT	8</span>
<span class="cp">#define IWL_TID_NON_QOS IWL_MAX_TID_COUNT</span>

<span class="cp">#define STA_FLG_TX_RATE_MSK		cpu_to_le32(1 &lt;&lt; 2)</span>
<span class="cp">#define STA_FLG_PWR_SAVE_MSK		cpu_to_le32(1 &lt;&lt; 8)</span>
<span class="cp">#define STA_FLG_PAN_STATION		cpu_to_le32(1 &lt;&lt; 13)</span>
<span class="cp">#define STA_FLG_RTS_MIMO_PROT_MSK	cpu_to_le32(1 &lt;&lt; 17)</span>
<span class="cp">#define STA_FLG_AGG_MPDU_8US_MSK	cpu_to_le32(1 &lt;&lt; 18)</span>
<span class="cp">#define STA_FLG_MAX_AGG_SIZE_POS	(19)</span>
<span class="cp">#define STA_FLG_MAX_AGG_SIZE_MSK	cpu_to_le32(3 &lt;&lt; 19)</span>
<span class="cp">#define STA_FLG_HT40_EN_MSK		cpu_to_le32(1 &lt;&lt; 21)</span>
<span class="cp">#define STA_FLG_MIMO_DIS_MSK		cpu_to_le32(1 &lt;&lt; 22)</span>
<span class="cp">#define STA_FLG_AGG_MPDU_DENSITY_POS	(23)</span>
<span class="cp">#define STA_FLG_AGG_MPDU_DENSITY_MSK	cpu_to_le32(7 &lt;&lt; 23)</span>

<span class="cm">/* Use in mode field.  1: modify existing entry, 0: add new station entry */</span>
<span class="cp">#define STA_CONTROL_MODIFY_MSK		0x01</span>

<span class="cm">/* key flags __le16*/</span>
<span class="cp">#define STA_KEY_FLG_ENCRYPT_MSK	cpu_to_le16(0x0007)</span>
<span class="cp">#define STA_KEY_FLG_NO_ENC	cpu_to_le16(0x0000)</span>
<span class="cp">#define STA_KEY_FLG_WEP		cpu_to_le16(0x0001)</span>
<span class="cp">#define STA_KEY_FLG_CCMP	cpu_to_le16(0x0002)</span>
<span class="cp">#define STA_KEY_FLG_TKIP	cpu_to_le16(0x0003)</span>

<span class="cp">#define STA_KEY_FLG_KEYID_POS	8</span>
<span class="cp">#define STA_KEY_FLG_INVALID 	cpu_to_le16(0x0800)</span>
<span class="cm">/* wep key is either from global key (0) or from station info array (1) */</span>
<span class="cp">#define STA_KEY_FLG_MAP_KEY_MSK	cpu_to_le16(0x0008)</span>

<span class="cm">/* wep key in STA: 5-bytes (0) or 13-bytes (1) */</span>
<span class="cp">#define STA_KEY_FLG_KEY_SIZE_MSK     cpu_to_le16(0x1000)</span>
<span class="cp">#define STA_KEY_MULTICAST_MSK        cpu_to_le16(0x4000)</span>
<span class="cp">#define STA_KEY_MAX_NUM		8</span>
<span class="cp">#define STA_KEY_MAX_NUM_PAN	16</span>
<span class="cm">/* must not match WEP_INVALID_OFFSET */</span>
<span class="cp">#define IWLAGN_HW_KEY_DEFAULT	0xfe</span>

<span class="cm">/* Flags indicate whether to modify vs. don&#39;t change various station params */</span>
<span class="cp">#define	STA_MODIFY_KEY_MASK		0x01</span>
<span class="cp">#define	STA_MODIFY_TID_DISABLE_TX	0x02</span>
<span class="cp">#define	STA_MODIFY_TX_RATE_MSK		0x04</span>
<span class="cp">#define STA_MODIFY_ADDBA_TID_MSK	0x08</span>
<span class="cp">#define STA_MODIFY_DELBA_TID_MSK	0x10</span>
<span class="cp">#define STA_MODIFY_SLEEP_TX_COUNT_MSK	0x20</span>

<span class="cm">/* Receiver address (actually, Rx station&#39;s index into station table),</span>
<span class="cm"> * combined with Traffic ID (QOS priority), in format used by Tx Scheduler */</span>
<span class="cp">#define BUILD_RAxTID(sta_id, tid)	(((sta_id) &lt;&lt; 4) + (tid))</span>

<span class="cm">/* agn */</span>
<span class="k">struct</span> <span class="n">iwl_keyinfo</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">key_flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tkip_rx_tsc_byte2</span><span class="p">;</span>	<span class="cm">/* TSC[2] for key mix ph1 detection */</span>
	<span class="n">u8</span> <span class="n">reserved1</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">tkip_rx_ttak</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>	<span class="cm">/* 10-byte unicast TKIP TTAK */</span>
	<span class="n">u8</span> <span class="n">key_offset</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved2</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">key</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>		<span class="cm">/* 16-byte unicast decryption key */</span>
	<span class="n">__le64</span> <span class="n">tx_secur_seq_cnt</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">hw_tkip_mic_rx_key</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">hw_tkip_mic_tx_key</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct sta_id_modify</span>
<span class="cm"> * @addr[ETH_ALEN]: station&#39;s MAC address</span>
<span class="cm"> * @sta_id: index of station in uCode&#39;s station table</span>
<span class="cm"> * @modify_mask: STA_MODIFY_*, 1: modify, 0: don&#39;t change</span>
<span class="cm"> *</span>
<span class="cm"> * Driver selects unused table index when adding new station,</span>
<span class="cm"> * or the index to a pre-existing station entry when modifying that station.</span>
<span class="cm"> * Some indexes have special purposes (IWL_AP_ID, index 0, is for AP).</span>
<span class="cm"> *</span>
<span class="cm"> * modify_mask flags select which parameters to modify vs. leave alone.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sta_id_modify</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">__le16</span> <span class="n">reserved1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">sta_id</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">modify_mask</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">reserved2</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_ADD_STA = 0x18 (command)</span>
<span class="cm"> *</span>
<span class="cm"> * The device contains an internal table of per-station information,</span>
<span class="cm"> * with info on security keys, aggregation parameters, and Tx rates for</span>
<span class="cm"> * initial Tx attempt and any retries (agn devices uses</span>
<span class="cm"> * REPLY_TX_LINK_QUALITY_CMD,</span>
<span class="cm"> *</span>
<span class="cm"> * REPLY_ADD_STA sets up the table entry for one station, either creating</span>
<span class="cm"> * a new entry, or modifying a pre-existing one.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  RXON command (without &quot;associated&quot; bit set) wipes the station table</span>
<span class="cm"> *        clean.  Moving into RF_KILL state does this also.  Driver must set up</span>
<span class="cm"> *        new station table before transmitting anything on the RXON channel</span>
<span class="cm"> *        (except active scans or active measurements; those commands carry</span>
<span class="cm"> *        their own txpower/rate setup data).</span>
<span class="cm"> *</span>
<span class="cm"> *        When getting started on a new channel, driver must set up the</span>
<span class="cm"> *        IWL_BROADCAST_ID entry (last entry in the table).  For a client</span>
<span class="cm"> *        station in a BSS, once an AP is selected, driver sets up the AP STA</span>
<span class="cm"> *        in the IWL_AP_ID entry (1st entry in the table).  BROADCAST and AP</span>
<span class="cm"> *        are all that are needed for a BSS client station.  If the device is</span>
<span class="cm"> *        used as AP, or in an IBSS network, driver must set up station table</span>
<span class="cm"> *        entries for all STAs in network, starting with index IWL_STA_ID.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">iwl_addsta_cmd</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">mode</span><span class="p">;</span>		<span class="cm">/* 1: modify existing, 0: add new station */</span>
	<span class="n">u8</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sta_id_modify</span> <span class="n">sta</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_keyinfo</span> <span class="n">key</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">station_flags</span><span class="p">;</span>		<span class="cm">/* STA_FLG_* */</span>
	<span class="n">__le32</span> <span class="n">station_flags_msk</span><span class="p">;</span>	<span class="cm">/* STA_FLG_* */</span>

	<span class="cm">/* bit field to disable (1) or enable (0) Tx for Traffic ID (TID)</span>
<span class="cm">	 * corresponding to bit (e.g. bit 5 controls TID 5).</span>
<span class="cm">	 * Set modify_mask bit STA_MODIFY_TID_DISABLE_TX to use this field. */</span>
	<span class="n">__le16</span> <span class="n">tid_disable_tx</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">legacy_reserved</span><span class="p">;</span>

	<span class="cm">/* TID for which to add block-ack support.</span>
<span class="cm">	 * Set modify_mask bit STA_MODIFY_ADDBA_TID_MSK to use this field. */</span>
	<span class="n">u8</span> <span class="n">add_immediate_ba_tid</span><span class="p">;</span>

	<span class="cm">/* TID for which to remove block-ack support.</span>
<span class="cm">	 * Set modify_mask bit STA_MODIFY_DELBA_TID_MSK to use this field. */</span>
	<span class="n">u8</span> <span class="n">remove_immediate_ba_tid</span><span class="p">;</span>

	<span class="cm">/* Starting Sequence Number for added block-ack support.</span>
<span class="cm">	 * Set modify_mask bit STA_MODIFY_ADDBA_TID_MSK to use this field. */</span>
	<span class="n">__le16</span> <span class="n">add_immediate_ba_ssn</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Number of packets OK to transmit to station even though</span>
<span class="cm">	 * it is asleep -- used to synchronise PS-poll and u-APSD</span>
<span class="cm">	 * responses while ucode keeps track of STA sleep state.</span>
<span class="cm">	 */</span>
	<span class="n">__le16</span> <span class="n">sleep_tx_count</span><span class="p">;</span>

	<span class="n">__le16</span> <span class="n">reserved2</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>


<span class="cp">#define ADD_STA_SUCCESS_MSK		0x1</span>
<span class="cp">#define ADD_STA_NO_ROOM_IN_TABLE	0x2</span>
<span class="cp">#define ADD_STA_NO_BLOCK_ACK_RESOURCE	0x4</span>
<span class="cp">#define ADD_STA_MODIFY_NON_EXIST_STA	0x8</span>
<span class="cm">/*</span>
<span class="cm"> * REPLY_ADD_STA = 0x18 (response)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_add_sta_resp</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">status</span><span class="p">;</span>	<span class="cm">/* ADD_STA_* */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cp">#define REM_STA_SUCCESS_MSK              0x1</span>
<span class="cm">/*</span>
<span class="cm"> *  REPLY_REM_STA = 0x19 (response)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_rem_sta_resp</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *  REPLY_REM_STA = 0x19 (command)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_rem_sta_cmd</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">num_sta</span><span class="p">;</span>     <span class="cm">/* number of removed stations */</span>
	<span class="n">u8</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span> <span class="cm">/* MAC addr of the first station */</span>
	<span class="n">u8</span> <span class="n">reserved2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>


<span class="cm">/* WiFi queues mask */</span>
<span class="cp">#define IWL_SCD_BK_MSK			cpu_to_le32(BIT(0))</span>
<span class="cp">#define IWL_SCD_BE_MSK			cpu_to_le32(BIT(1))</span>
<span class="cp">#define IWL_SCD_VI_MSK			cpu_to_le32(BIT(2))</span>
<span class="cp">#define IWL_SCD_VO_MSK			cpu_to_le32(BIT(3))</span>
<span class="cp">#define IWL_SCD_MGMT_MSK		cpu_to_le32(BIT(3))</span>

<span class="cm">/* PAN queues mask */</span>
<span class="cp">#define IWL_PAN_SCD_BK_MSK		cpu_to_le32(BIT(4))</span>
<span class="cp">#define IWL_PAN_SCD_BE_MSK		cpu_to_le32(BIT(5))</span>
<span class="cp">#define IWL_PAN_SCD_VI_MSK		cpu_to_le32(BIT(6))</span>
<span class="cp">#define IWL_PAN_SCD_VO_MSK		cpu_to_le32(BIT(7))</span>
<span class="cp">#define IWL_PAN_SCD_MGMT_MSK		cpu_to_le32(BIT(7))</span>
<span class="cp">#define IWL_PAN_SCD_MULTICAST_MSK	cpu_to_le32(BIT(8))</span>

<span class="cp">#define IWL_AGG_TX_QUEUE_MSK		cpu_to_le32(0xffc00)</span>

<span class="cp">#define IWL_DROP_SINGLE		0</span>
<span class="cp">#define IWL_DROP_ALL		(BIT(IWL_RXON_CTX_BSS) | BIT(IWL_RXON_CTX_PAN))</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_TXFIFO_FLUSH = 0x1e(command and response)</span>
<span class="cm"> *</span>
<span class="cm"> * When using full FIFO flush this command checks the scheduler HW block WR/RD</span>
<span class="cm"> * pointers to check if all the frames were transferred by DMA into the</span>
<span class="cm"> * relevant TX FIFO queue. Only when the DMA is finished and the queue is</span>
<span class="cm"> * empty the command can finish.</span>
<span class="cm"> * This command is used to flush the TXFIFO from transmit commands, it may</span>
<span class="cm"> * operate on single or multiple queues, the command queue can&#39;t be flushed by</span>
<span class="cm"> * this command. The command response is returned when all the queue flush</span>
<span class="cm"> * operations are done. Each TX command flushed return response with the FLUSH</span>
<span class="cm"> * status set in the TX response status. When FIFO flush operation is used,</span>
<span class="cm"> * the flush operation ends when both the scheduler DMA done and TXFIFO empty</span>
<span class="cm"> * are set.</span>
<span class="cm"> *</span>
<span class="cm"> * @fifo_control: bit mask for which queues to flush</span>
<span class="cm"> * @flush_control: flush controls</span>
<span class="cm"> *	0: Dump single MSDU</span>
<span class="cm"> *	1: Dump multiple MSDU according to PS, INVALID STA, TTL, TID disable.</span>
<span class="cm"> *	2: Dump all FIFO</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_txfifo_flush_cmd</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">fifo_control</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">flush_control</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_WEP_KEY = 0x20</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_wep_key</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">key_index</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">key_offset</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved1</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">key_size</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved2</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">key</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">iwl_wep_cmd</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">num_keys</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">global_key_type</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_wep_key</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cp">#define WEP_KEY_WEP_TYPE 1</span>
<span class="cp">#define WEP_KEYS_MAX 4</span>
<span class="cp">#define WEP_INVALID_OFFSET 0xff</span>
<span class="cp">#define WEP_KEY_LEN_64 5</span>
<span class="cp">#define WEP_KEY_LEN_128 13</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * (4)</span>
<span class="cm"> * Rx Responses:</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cp">#define RX_RES_STATUS_NO_CRC32_ERROR	cpu_to_le32(1 &lt;&lt; 0)</span>
<span class="cp">#define RX_RES_STATUS_NO_RXE_OVERFLOW	cpu_to_le32(1 &lt;&lt; 1)</span>

<span class="cp">#define RX_RES_PHY_FLAGS_BAND_24_MSK	cpu_to_le16(1 &lt;&lt; 0)</span>
<span class="cp">#define RX_RES_PHY_FLAGS_MOD_CCK_MSK		cpu_to_le16(1 &lt;&lt; 1)</span>
<span class="cp">#define RX_RES_PHY_FLAGS_SHORT_PREAMBLE_MSK	cpu_to_le16(1 &lt;&lt; 2)</span>
<span class="cp">#define RX_RES_PHY_FLAGS_NARROW_BAND_MSK	cpu_to_le16(1 &lt;&lt; 3)</span>
<span class="cp">#define RX_RES_PHY_FLAGS_ANTENNA_MSK		0xf0</span>
<span class="cp">#define RX_RES_PHY_FLAGS_ANTENNA_POS		4</span>

<span class="cp">#define RX_RES_STATUS_SEC_TYPE_MSK	(0x7 &lt;&lt; 8)</span>
<span class="cp">#define RX_RES_STATUS_SEC_TYPE_NONE	(0x0 &lt;&lt; 8)</span>
<span class="cp">#define RX_RES_STATUS_SEC_TYPE_WEP	(0x1 &lt;&lt; 8)</span>
<span class="cp">#define RX_RES_STATUS_SEC_TYPE_CCMP	(0x2 &lt;&lt; 8)</span>
<span class="cp">#define RX_RES_STATUS_SEC_TYPE_TKIP	(0x3 &lt;&lt; 8)</span>
<span class="cp">#define	RX_RES_STATUS_SEC_TYPE_ERR	(0x7 &lt;&lt; 8)</span>

<span class="cp">#define RX_RES_STATUS_STATION_FOUND	(1&lt;&lt;6)</span>
<span class="cp">#define RX_RES_STATUS_NO_STATION_INFO_MISMATCH	(1&lt;&lt;7)</span>

<span class="cp">#define RX_RES_STATUS_DECRYPT_TYPE_MSK	(0x3 &lt;&lt; 11)</span>
<span class="cp">#define RX_RES_STATUS_NOT_DECRYPT	(0x0 &lt;&lt; 11)</span>
<span class="cp">#define RX_RES_STATUS_DECRYPT_OK	(0x3 &lt;&lt; 11)</span>
<span class="cp">#define RX_RES_STATUS_BAD_ICV_MIC	(0x1 &lt;&lt; 11)</span>
<span class="cp">#define RX_RES_STATUS_BAD_KEY_TTAK	(0x2 &lt;&lt; 11)</span>

<span class="cp">#define RX_MPDU_RES_STATUS_ICV_OK	(0x20)</span>
<span class="cp">#define RX_MPDU_RES_STATUS_MIC_OK	(0x40)</span>
<span class="cp">#define RX_MPDU_RES_STATUS_TTAK_OK	(1 &lt;&lt; 7)</span>
<span class="cp">#define RX_MPDU_RES_STATUS_DEC_DONE_MSK	(0x800)</span>


<span class="cp">#define IWLAGN_RX_RES_PHY_CNT 8</span>
<span class="cp">#define IWLAGN_RX_RES_AGC_IDX     1</span>
<span class="cp">#define IWLAGN_RX_RES_RSSI_AB_IDX 2</span>
<span class="cp">#define IWLAGN_RX_RES_RSSI_C_IDX  3</span>
<span class="cp">#define IWLAGN_OFDM_AGC_MSK 0xfe00</span>
<span class="cp">#define IWLAGN_OFDM_AGC_BIT_POS 9</span>
<span class="cp">#define IWLAGN_OFDM_RSSI_INBAND_A_BITMSK 0x00ff</span>
<span class="cp">#define IWLAGN_OFDM_RSSI_ALLBAND_A_BITMSK 0xff00</span>
<span class="cp">#define IWLAGN_OFDM_RSSI_A_BIT_POS 0</span>
<span class="cp">#define IWLAGN_OFDM_RSSI_INBAND_B_BITMSK 0xff0000</span>
<span class="cp">#define IWLAGN_OFDM_RSSI_ALLBAND_B_BITMSK 0xff000000</span>
<span class="cp">#define IWLAGN_OFDM_RSSI_B_BIT_POS 16</span>
<span class="cp">#define IWLAGN_OFDM_RSSI_INBAND_C_BITMSK 0x00ff</span>
<span class="cp">#define IWLAGN_OFDM_RSSI_ALLBAND_C_BITMSK 0xff00</span>
<span class="cp">#define IWLAGN_OFDM_RSSI_C_BIT_POS 0</span>

<span class="k">struct</span> <span class="n">iwlagn_non_cfg_phy</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">non_cfg_phy</span><span class="p">[</span><span class="n">IWLAGN_RX_RES_PHY_CNT</span><span class="p">];</span>  <span class="cm">/* up to 8 phy entries */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * REPLY_RX = 0xc3 (response only, not a command)</span>
<span class="cm"> * Used only for legacy (non 11n) frames.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_rx_phy_res</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">non_cfg_phy_cnt</span><span class="p">;</span>     <span class="cm">/* non configurable DSP phy data byte count */</span>
	<span class="n">u8</span> <span class="n">cfg_phy_cnt</span><span class="p">;</span>		<span class="cm">/* configurable DSP phy data byte count */</span>
	<span class="n">u8</span> <span class="n">stat_id</span><span class="p">;</span>		<span class="cm">/* configurable DSP phy data set ID */</span>
	<span class="n">u8</span> <span class="n">reserved1</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">timestamp</span><span class="p">;</span>	<span class="cm">/* TSF at on air rise */</span>
	<span class="n">__le32</span> <span class="n">beacon_time_stamp</span><span class="p">;</span> <span class="cm">/* beacon at on-air rise */</span>
	<span class="n">__le16</span> <span class="n">phy_flags</span><span class="p">;</span>	<span class="cm">/* general phy flags: band, modulation, ... */</span>
	<span class="n">__le16</span> <span class="n">channel</span><span class="p">;</span>		<span class="cm">/* channel number */</span>
	<span class="n">u8</span> <span class="n">non_cfg_phy_buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span> <span class="cm">/* for various implementations of non_cfg_phy */</span>
	<span class="n">__le32</span> <span class="n">rate_n_flags</span><span class="p">;</span>	<span class="cm">/* RATE_MCS_* */</span>
	<span class="n">__le16</span> <span class="n">byte_count</span><span class="p">;</span>	<span class="cm">/* frame&#39;s byte-count */</span>
	<span class="n">__le16</span> <span class="n">frame_time</span><span class="p">;</span>	<span class="cm">/* frame&#39;s time on the air */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">iwl_rx_mpdu_res_start</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">byte_count</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>


<span class="cm">/******************************************************************************</span>
<span class="cm"> * (5)</span>
<span class="cm"> * Tx Commands &amp; Responses:</span>
<span class="cm"> *</span>
<span class="cm"> * Driver must place each REPLY_TX command into one of the prioritized Tx</span>
<span class="cm"> * queues in host DRAM, shared between driver and device (see comments for</span>
<span class="cm"> * SCD registers and Tx/Rx Queues).  When the device&#39;s Tx scheduler and uCode</span>
<span class="cm"> * are preparing to transmit, the device pulls the Tx command over the PCI</span>
<span class="cm"> * bus via one of the device&#39;s Tx DMA channels, to fill an internal FIFO</span>
<span class="cm"> * from which data will be transmitted.</span>
<span class="cm"> *</span>
<span class="cm"> * uCode handles all timing and protocol related to control frames</span>
<span class="cm"> * (RTS/CTS/ACK), based on flags in the Tx command.  uCode and Tx scheduler</span>
<span class="cm"> * handle reception of block-acks; uCode updates the host driver via</span>
<span class="cm"> * REPLY_COMPRESSED_BA.</span>
<span class="cm"> *</span>
<span class="cm"> * uCode handles retrying Tx when an ACK is expected but not received.</span>
<span class="cm"> * This includes trying lower data rates than the one requested in the Tx</span>
<span class="cm"> * command, as set up by the REPLY_TX_LINK_QUALITY_CMD (agn).</span>
<span class="cm"> *</span>
<span class="cm"> * Driver sets up transmit power for various rates via REPLY_TX_PWR_TABLE_CMD.</span>
<span class="cm"> * This command must be executed after every RXON command, before Tx can occur.</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cm">/* REPLY_TX Tx flags field */</span>

<span class="cm">/*</span>
<span class="cm"> * 1: Use RTS/CTS protocol or CTS-to-self if spec allows it</span>
<span class="cm"> * before this frame. if CTS-to-self required check</span>
<span class="cm"> * RXON_FLG_SELF_CTS_EN status.</span>
<span class="cm"> */</span>
<span class="cp">#define TX_CMD_FLG_PROT_REQUIRE_MSK cpu_to_le32(1 &lt;&lt; 0)</span>

<span class="cm">/* 1: Expect ACK from receiving station</span>
<span class="cm"> * 0: Don&#39;t expect ACK (MAC header&#39;s duration field s/b 0)</span>
<span class="cm"> * Set this for unicast frames, but not broadcast/multicast. */</span>
<span class="cp">#define TX_CMD_FLG_ACK_MSK cpu_to_le32(1 &lt;&lt; 3)</span>

<span class="cm">/* For agn devices:</span>
<span class="cm"> * 1: Use rate scale table (see REPLY_TX_LINK_QUALITY_CMD).</span>
<span class="cm"> *    Tx command&#39;s initial_rate_index indicates first rate to try;</span>
<span class="cm"> *    uCode walks through table for additional Tx attempts.</span>
<span class="cm"> * 0: Use Tx rate/MCS from Tx command&#39;s rate_n_flags field.</span>
<span class="cm"> *    This rate will be used for all Tx attempts; it will not be scaled. */</span>
<span class="cp">#define TX_CMD_FLG_STA_RATE_MSK cpu_to_le32(1 &lt;&lt; 4)</span>

<span class="cm">/* 1: Expect immediate block-ack.</span>
<span class="cm"> * Set when Txing a block-ack request frame.  Also set TX_CMD_FLG_ACK_MSK. */</span>
<span class="cp">#define TX_CMD_FLG_IMM_BA_RSP_MASK  cpu_to_le32(1 &lt;&lt; 6)</span>

<span class="cm">/* Tx antenna selection field; reserved (0) for agn devices. */</span>
<span class="cp">#define TX_CMD_FLG_ANT_SEL_MSK cpu_to_le32(0xf00)</span>

<span class="cm">/* 1: Ignore Bluetooth priority for this frame.</span>
<span class="cm"> * 0: Delay Tx until Bluetooth device is done (normal usage). */</span>
<span class="cp">#define TX_CMD_FLG_IGNORE_BT cpu_to_le32(1 &lt;&lt; 12)</span>

<span class="cm">/* 1: uCode overrides sequence control field in MAC header.</span>
<span class="cm"> * 0: Driver provides sequence control field in MAC header.</span>
<span class="cm"> * Set this for management frames, non-QOS data frames, non-unicast frames,</span>
<span class="cm"> * and also in Tx command embedded in REPLY_SCAN_CMD for active scans. */</span>
<span class="cp">#define TX_CMD_FLG_SEQ_CTL_MSK cpu_to_le32(1 &lt;&lt; 13)</span>

<span class="cm">/* 1: This frame is non-last MPDU; more fragments are coming.</span>
<span class="cm"> * 0: Last fragment, or not using fragmentation. */</span>
<span class="cp">#define TX_CMD_FLG_MORE_FRAG_MSK cpu_to_le32(1 &lt;&lt; 14)</span>

<span class="cm">/* 1: uCode calculates and inserts Timestamp Function (TSF) in outgoing frame.</span>
<span class="cm"> * 0: No TSF required in outgoing frame.</span>
<span class="cm"> * Set this for transmitting beacons and probe responses. */</span>
<span class="cp">#define TX_CMD_FLG_TSF_MSK cpu_to_le32(1 &lt;&lt; 16)</span>

<span class="cm">/* 1: Driver inserted 2 bytes pad after the MAC header, for (required) dword</span>
<span class="cm"> *    alignment of frame&#39;s payload data field.</span>
<span class="cm"> * 0: No pad</span>
<span class="cm"> * Set this for MAC headers with 26 or 30 bytes, i.e. those with QOS or ADDR4</span>
<span class="cm"> * field (but not both).  Driver must align frame data (i.e. data following</span>
<span class="cm"> * MAC header) to DWORD boundary. */</span>
<span class="cp">#define TX_CMD_FLG_MH_PAD_MSK cpu_to_le32(1 &lt;&lt; 20)</span>

<span class="cm">/* accelerate aggregation support</span>
<span class="cm"> * 0 - no CCMP encryption; 1 - CCMP encryption */</span>
<span class="cp">#define TX_CMD_FLG_AGG_CCMP_MSK cpu_to_le32(1 &lt;&lt; 22)</span>

<span class="cm">/* HCCA-AP - disable duration overwriting. */</span>
<span class="cp">#define TX_CMD_FLG_DUR_MSK cpu_to_le32(1 &lt;&lt; 25)</span>


<span class="cm">/*</span>
<span class="cm"> * TX command security control</span>
<span class="cm"> */</span>
<span class="cp">#define TX_CMD_SEC_WEP  	0x01</span>
<span class="cp">#define TX_CMD_SEC_CCM  	0x02</span>
<span class="cp">#define TX_CMD_SEC_TKIP		0x03</span>
<span class="cp">#define TX_CMD_SEC_MSK		0x03</span>
<span class="cp">#define TX_CMD_SEC_SHIFT	6</span>
<span class="cp">#define TX_CMD_SEC_KEY128	0x08</span>

<span class="cm">/*</span>
<span class="cm"> * security overhead sizes</span>
<span class="cm"> */</span>
<span class="cp">#define WEP_IV_LEN 4</span>
<span class="cp">#define WEP_ICV_LEN 4</span>
<span class="cp">#define CCMP_MIC_LEN 8</span>
<span class="cp">#define TKIP_ICV_LEN 4</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_TX = 0x1c (command)</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * 4965 uCode updates these Tx attempt count values in host DRAM.</span>
<span class="cm"> * Used for managing Tx retries when expecting block-acks.</span>
<span class="cm"> * Driver should set these fields to 0.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_dram_scratch</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">try_cnt</span><span class="p">;</span>		<span class="cm">/* Tx attempts */</span>
	<span class="n">u8</span> <span class="n">bt_kill_cnt</span><span class="p">;</span>		<span class="cm">/* Tx attempts blocked by Bluetooth device */</span>
	<span class="n">__le16</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">iwl_tx_cmd</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * MPDU byte count:</span>
<span class="cm">	 * MAC header (24/26/30/32 bytes) + 2 bytes pad if 26/30 header size,</span>
<span class="cm">	 * + 8 byte IV for CCM or TKIP (not used for WEP)</span>
<span class="cm">	 * + Data payload</span>
<span class="cm">	 * + 8-byte MIC (not used for CCM/WEP)</span>
<span class="cm">	 * NOTE:  Does not include Tx command bytes, post-MAC pad bytes,</span>
<span class="cm">	 *        MIC (CCM) 8 bytes, ICV (WEP/TKIP/CKIP) 4 bytes, CRC 4 bytes.i</span>
<span class="cm">	 * Range: 14-2342 bytes.</span>
<span class="cm">	 */</span>
	<span class="n">__le16</span> <span class="n">len</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * MPDU or MSDU byte count for next frame.</span>
<span class="cm">	 * Used for fragmentation and bursting, but not 11n aggregation.</span>
<span class="cm">	 * Same as &quot;len&quot;, but for next frame.  Set to 0 if not applicable.</span>
<span class="cm">	 */</span>
	<span class="n">__le16</span> <span class="n">next_frame_len</span><span class="p">;</span>

	<span class="n">__le32</span> <span class="n">tx_flags</span><span class="p">;</span>	<span class="cm">/* TX_CMD_FLG_* */</span>

	<span class="cm">/* uCode may modify this field of the Tx command (in host DRAM!).</span>
<span class="cm">	 * Driver must also set dram_lsb_ptr and dram_msb_ptr in this cmd. */</span>
	<span class="k">struct</span> <span class="n">iwl_dram_scratch</span> <span class="n">scratch</span><span class="p">;</span>

	<span class="cm">/* Rate for *all* Tx attempts, if TX_CMD_FLG_STA_RATE_MSK is cleared. */</span>
	<span class="n">__le32</span> <span class="n">rate_n_flags</span><span class="p">;</span>	<span class="cm">/* RATE_MCS_* */</span>

	<span class="cm">/* Index of destination station in uCode&#39;s station table */</span>
	<span class="n">u8</span> <span class="n">sta_id</span><span class="p">;</span>

	<span class="cm">/* Type of security encryption:  CCM or TKIP */</span>
	<span class="n">u8</span> <span class="n">sec_ctl</span><span class="p">;</span>		<span class="cm">/* TX_CMD_SEC_* */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Index into rate table (see REPLY_TX_LINK_QUALITY_CMD) for initial</span>
<span class="cm">	 * Tx attempt, if TX_CMD_FLG_STA_RATE_MSK is set.  Normally &quot;0&quot; for</span>
<span class="cm">	 * data frames, this field may be used to selectively reduce initial</span>
<span class="cm">	 * rate (via non-0 value) for special frames (e.g. management), while</span>
<span class="cm">	 * still supporting rate scaling for all frames.</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">initial_rate_index</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">key</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="n">__le16</span> <span class="n">next_frame_flags</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">reserved2</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">__le32</span> <span class="n">life_time</span><span class="p">;</span>
		<span class="n">__le32</span> <span class="n">attempt</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">stop_time</span><span class="p">;</span>

	<span class="cm">/* Host DRAM physical address pointer to &quot;scratch&quot; in this command.</span>
<span class="cm">	 * Must be dword aligned.  &quot;0&quot; in dram_lsb_ptr disables usage. */</span>
	<span class="n">__le32</span> <span class="n">dram_lsb_ptr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">dram_msb_ptr</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">rts_retry_limit</span><span class="p">;</span>	<span class="cm">/*byte 50 */</span>
	<span class="n">u8</span> <span class="n">data_retry_limit</span><span class="p">;</span>	<span class="cm">/*byte 51 */</span>
	<span class="n">u8</span> <span class="n">tid_tspec</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">__le16</span> <span class="n">pm_frame_timeout</span><span class="p">;</span>
		<span class="n">__le16</span> <span class="n">attempt_duration</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Duration of EDCA burst Tx Opportunity, in 32-usec units.</span>
<span class="cm">	 * Set this if txop time is not specified by HCCA protocol (e.g. by AP).</span>
<span class="cm">	 */</span>
	<span class="n">__le16</span> <span class="n">driver_txop</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * MAC header goes here, followed by 2 bytes padding if MAC header</span>
<span class="cm">	 * length is 26 or 30 bytes, followed by payload data</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">payload</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ieee80211_hdr</span> <span class="n">hdr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * TX command response is sent after *agn* transmission attempts.</span>
<span class="cm"> *</span>
<span class="cm"> * both postpone and abort status are expected behavior from uCode. there is</span>
<span class="cm"> * no special operation required from driver; except for RFKILL_FLUSH,</span>
<span class="cm"> * which required tx flush host command to flush all the tx frames in queues</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">TX_STATUS_SUCCESS</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
	<span class="n">TX_STATUS_DIRECT_DONE</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
	<span class="cm">/* postpone TX */</span>
	<span class="n">TX_STATUS_POSTPONE_DELAY</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">,</span>
	<span class="n">TX_STATUS_POSTPONE_FEW_BYTES</span> <span class="o">=</span> <span class="mh">0x41</span><span class="p">,</span>
	<span class="n">TX_STATUS_POSTPONE_BT_PRIO</span> <span class="o">=</span> <span class="mh">0x42</span><span class="p">,</span>
	<span class="n">TX_STATUS_POSTPONE_QUIET_PERIOD</span> <span class="o">=</span> <span class="mh">0x43</span><span class="p">,</span>
	<span class="n">TX_STATUS_POSTPONE_CALC_TTAK</span> <span class="o">=</span> <span class="mh">0x44</span><span class="p">,</span>
	<span class="cm">/* abort TX */</span>
	<span class="n">TX_STATUS_FAIL_INTERNAL_CROSSED_RETRY</span> <span class="o">=</span> <span class="mh">0x81</span><span class="p">,</span>
	<span class="n">TX_STATUS_FAIL_SHORT_LIMIT</span> <span class="o">=</span> <span class="mh">0x82</span><span class="p">,</span>
	<span class="n">TX_STATUS_FAIL_LONG_LIMIT</span> <span class="o">=</span> <span class="mh">0x83</span><span class="p">,</span>
	<span class="n">TX_STATUS_FAIL_FIFO_UNDERRUN</span> <span class="o">=</span> <span class="mh">0x84</span><span class="p">,</span>
	<span class="n">TX_STATUS_FAIL_DRAIN_FLOW</span> <span class="o">=</span> <span class="mh">0x85</span><span class="p">,</span>
	<span class="n">TX_STATUS_FAIL_RFKILL_FLUSH</span> <span class="o">=</span> <span class="mh">0x86</span><span class="p">,</span>
	<span class="n">TX_STATUS_FAIL_LIFE_EXPIRE</span> <span class="o">=</span> <span class="mh">0x87</span><span class="p">,</span>
	<span class="n">TX_STATUS_FAIL_DEST_PS</span> <span class="o">=</span> <span class="mh">0x88</span><span class="p">,</span>
	<span class="n">TX_STATUS_FAIL_HOST_ABORTED</span> <span class="o">=</span> <span class="mh">0x89</span><span class="p">,</span>
	<span class="n">TX_STATUS_FAIL_BT_RETRY</span> <span class="o">=</span> <span class="mh">0x8a</span><span class="p">,</span>
	<span class="n">TX_STATUS_FAIL_STA_INVALID</span> <span class="o">=</span> <span class="mh">0x8b</span><span class="p">,</span>
	<span class="n">TX_STATUS_FAIL_FRAG_DROPPED</span> <span class="o">=</span> <span class="mh">0x8c</span><span class="p">,</span>
	<span class="n">TX_STATUS_FAIL_TID_DISABLE</span> <span class="o">=</span> <span class="mh">0x8d</span><span class="p">,</span>
	<span class="n">TX_STATUS_FAIL_FIFO_FLUSHED</span> <span class="o">=</span> <span class="mh">0x8e</span><span class="p">,</span>
	<span class="n">TX_STATUS_FAIL_INSUFFICIENT_CF_POLL</span> <span class="o">=</span> <span class="mh">0x8f</span><span class="p">,</span>
	<span class="n">TX_STATUS_FAIL_PASSIVE_NO_RX</span> <span class="o">=</span> <span class="mh">0x90</span><span class="p">,</span>
	<span class="n">TX_STATUS_FAIL_NO_BEACON_ON_RADAR</span> <span class="o">=</span> <span class="mh">0x91</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define	TX_PACKET_MODE_REGULAR		0x0000</span>
<span class="cp">#define	TX_PACKET_MODE_BURST_SEQ	0x0100</span>
<span class="cp">#define	TX_PACKET_MODE_BURST_FIRST	0x0200</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">TX_POWER_PA_NOT_ACTIVE</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">TX_STATUS_MSK</span> <span class="o">=</span> <span class="mh">0x000000ff</span><span class="p">,</span>		<span class="cm">/* bits 0:7 */</span>
	<span class="n">TX_STATUS_DELAY_MSK</span> <span class="o">=</span> <span class="mh">0x00000040</span><span class="p">,</span>
	<span class="n">TX_STATUS_ABORT_MSK</span> <span class="o">=</span> <span class="mh">0x00000080</span><span class="p">,</span>
	<span class="n">TX_PACKET_MODE_MSK</span> <span class="o">=</span> <span class="mh">0x0000ff00</span><span class="p">,</span>	<span class="cm">/* bits 8:15 */</span>
	<span class="n">TX_FIFO_NUMBER_MSK</span> <span class="o">=</span> <span class="mh">0x00070000</span><span class="p">,</span>	<span class="cm">/* bits 16:18 */</span>
	<span class="n">TX_RESERVED</span> <span class="o">=</span> <span class="mh">0x00780000</span><span class="p">,</span>		<span class="cm">/* bits 19:22 */</span>
	<span class="n">TX_POWER_PA_DETECT_MSK</span> <span class="o">=</span> <span class="mh">0x7f800000</span><span class="p">,</span>	<span class="cm">/* bits 23:30 */</span>
	<span class="n">TX_ABORT_REQUIRED_MSK</span> <span class="o">=</span> <span class="mh">0x80000000</span><span class="p">,</span>	<span class="cm">/* bits 31:31 */</span>
<span class="p">};</span>

<span class="cm">/* *******************************</span>
<span class="cm"> * TX aggregation status</span>
<span class="cm"> ******************************* */</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">AGG_TX_STATE_TRANSMITTED</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">,</span>
	<span class="n">AGG_TX_STATE_UNDERRUN_MSK</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
	<span class="n">AGG_TX_STATE_BT_PRIO_MSK</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
	<span class="n">AGG_TX_STATE_FEW_BYTES_MSK</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
	<span class="n">AGG_TX_STATE_ABORT_MSK</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>
	<span class="n">AGG_TX_STATE_LAST_SENT_TTL_MSK</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
	<span class="n">AGG_TX_STATE_LAST_SENT_TRY_CNT_MSK</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>
	<span class="n">AGG_TX_STATE_LAST_SENT_BT_KILL_MSK</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">,</span>
	<span class="n">AGG_TX_STATE_SCD_QUERY_MSK</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">,</span>
	<span class="n">AGG_TX_STATE_TEST_BAD_CRC32_MSK</span> <span class="o">=</span> <span class="mh">0x100</span><span class="p">,</span>
	<span class="n">AGG_TX_STATE_RESPONSE_MSK</span> <span class="o">=</span> <span class="mh">0x1ff</span><span class="p">,</span>
	<span class="n">AGG_TX_STATE_DUMP_TX_MSK</span> <span class="o">=</span> <span class="mh">0x200</span><span class="p">,</span>
	<span class="n">AGG_TX_STATE_DELAY_TX_MSK</span> <span class="o">=</span> <span class="mh">0x400</span>
<span class="p">};</span>

<span class="cp">#define AGG_TX_STATUS_MSK	0x00000fff	</span><span class="cm">/* bits 0:11 */</span><span class="cp"></span>
<span class="cp">#define AGG_TX_TRY_MSK		0x0000f000	</span><span class="cm">/* bits 12:15 */</span><span class="cp"></span>

<span class="cp">#define AGG_TX_STATE_LAST_SENT_MSK  (AGG_TX_STATE_LAST_SENT_TTL_MSK | \</span>
<span class="cp">				     AGG_TX_STATE_LAST_SENT_TRY_CNT_MSK | \</span>
<span class="cp">				     AGG_TX_STATE_LAST_SENT_BT_KILL_MSK)</span>

<span class="cm">/* # tx attempts for first frame in aggregation */</span>
<span class="cp">#define AGG_TX_STATE_TRY_CNT_POS 12</span>
<span class="cp">#define AGG_TX_STATE_TRY_CNT_MSK 0xf000</span>

<span class="cm">/* Command ID and sequence number of Tx command for this frame */</span>
<span class="cp">#define AGG_TX_STATE_SEQ_NUM_POS 16</span>
<span class="cp">#define AGG_TX_STATE_SEQ_NUM_MSK 0xffff0000</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_TX = 0x1c (response)</span>
<span class="cm"> *</span>
<span class="cm"> * This response may be in one of two slightly different formats, indicated</span>
<span class="cm"> * by the frame_count field:</span>
<span class="cm"> *</span>
<span class="cm"> * 1)  No aggregation (frame_count == 1).  This reports Tx results for</span>
<span class="cm"> *     a single frame.  Multiple attempts, at various bit rates, may have</span>
<span class="cm"> *     been made for this frame.</span>
<span class="cm"> *</span>
<span class="cm"> * 2)  Aggregation (frame_count &gt; 1).  This reports Tx results for</span>
<span class="cm"> *     2 or more frames that used block-acknowledge.  All frames were</span>
<span class="cm"> *     transmitted at same rate.  Rate scaling may have been used if first</span>
<span class="cm"> *     frame in this new agg block failed in previous agg block(s).</span>
<span class="cm"> *</span>
<span class="cm"> *     Note that, for aggregation, ACK (block-ack) status is not delivered here;</span>
<span class="cm"> *     block-ack has not been received by the time the agn device records</span>
<span class="cm"> *     this status.</span>
<span class="cm"> *     This status relates to reasons the tx might have been blocked or aborted</span>
<span class="cm"> *     within the sending station (this agn device), rather than whether it was</span>
<span class="cm"> *     received successfully by the destination station.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">agg_tx_status</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">sequence</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * definitions for initial rate index field</span>
<span class="cm"> * bits [3:0] initial rate index</span>
<span class="cm"> * bits [6:4] rate table color, used for the initial rate</span>
<span class="cm"> * bit-7 invalid rate indication</span>
<span class="cm"> *   i.e. rate was not chosen from rate table</span>
<span class="cm"> *   or rate table color was changed during frame retries</span>
<span class="cm"> * refer tlc rate info</span>
<span class="cm"> */</span>

<span class="cp">#define IWL50_TX_RES_INIT_RATE_INDEX_POS	0</span>
<span class="cp">#define IWL50_TX_RES_INIT_RATE_INDEX_MSK	0x0f</span>
<span class="cp">#define IWL50_TX_RES_RATE_TABLE_COLOR_POS	4</span>
<span class="cp">#define IWL50_TX_RES_RATE_TABLE_COLOR_MSK	0x70</span>
<span class="cp">#define IWL50_TX_RES_INV_RATE_INDEX_MSK	0x80</span>

<span class="cm">/* refer to ra_tid */</span>
<span class="cp">#define IWLAGN_TX_RES_TID_POS	0</span>
<span class="cp">#define IWLAGN_TX_RES_TID_MSK	0x0f</span>
<span class="cp">#define IWLAGN_TX_RES_RA_POS	4</span>
<span class="cp">#define IWLAGN_TX_RES_RA_MSK	0xf0</span>

<span class="k">struct</span> <span class="n">iwlagn_tx_resp</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">frame_count</span><span class="p">;</span>		<span class="cm">/* 1 no aggregation, &gt;1 aggregation */</span>
	<span class="n">u8</span> <span class="n">bt_kill_count</span><span class="p">;</span>	<span class="cm">/* # blocked by bluetooth (unused for agg) */</span>
	<span class="n">u8</span> <span class="n">failure_rts</span><span class="p">;</span>		<span class="cm">/* # failures due to unsuccessful RTS */</span>
	<span class="n">u8</span> <span class="n">failure_frame</span><span class="p">;</span>	<span class="cm">/* # failures due to no ACK (unused for agg) */</span>

	<span class="cm">/* For non-agg:  Rate at which frame was successful.</span>
<span class="cm">	 * For agg:  Rate at which all frames were transmitted. */</span>
	<span class="n">__le32</span> <span class="n">rate_n_flags</span><span class="p">;</span>	<span class="cm">/* RATE_MCS_*  */</span>

	<span class="cm">/* For non-agg:  RTS + CTS + frame tx attempts time + ACK.</span>
<span class="cm">	 * For agg:  RTS + CTS + aggregation tx time + block-ack time. */</span>
	<span class="n">__le16</span> <span class="n">wireless_media_time</span><span class="p">;</span>	<span class="cm">/* uSecs */</span>

	<span class="n">u8</span> <span class="n">pa_status</span><span class="p">;</span>		<span class="cm">/* RF power amplifier measurement (not used) */</span>
	<span class="n">u8</span> <span class="n">pa_integ_res_a</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">pa_integ_res_b</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">pa_integ_res_C</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

	<span class="n">__le32</span> <span class="n">tfd_info</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">seq_ctl</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">byte_cnt</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tlc_info</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ra_tid</span><span class="p">;</span>		<span class="cm">/* tid (0:3), sta_id (4:7) */</span>
	<span class="n">__le16</span> <span class="n">frame_ctrl</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * For non-agg:  frame status TX_STATUS_*</span>
<span class="cm">	 * For agg:  status of 1st frame, AGG_TX_STATE_*; other frame status</span>
<span class="cm">	 *           fields follow this one, up to frame_count.</span>
<span class="cm">	 *           Bit fields:</span>
<span class="cm">	 *           11- 0:  AGG_TX_STATE_* status code</span>
<span class="cm">	 *           15-12:  Retry count for 1st frame in aggregation (retries</span>
<span class="cm">	 *                   occur if tx failed for this frame when it was a</span>
<span class="cm">	 *                   member of a previous aggregation block).  If rate</span>
<span class="cm">	 *                   scaling is used, retry count indicates the rate</span>
<span class="cm">	 *                   table entry used for all frames in the new agg.</span>
<span class="cm">	 *           31-16:  Sequence # for this frame&#39;s Tx cmd (not SSN!)</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">agg_tx_status</span> <span class="n">status</span><span class="p">;</span>	<span class="cm">/* TX status (in aggregation -</span>
<span class="cm">					 * status of 1st frame) */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * REPLY_COMPRESSED_BA = 0xc5 (response only, not a command)</span>
<span class="cm"> *</span>
<span class="cm"> * Reports Block-Acknowledge from recipient station</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_compressed_ba_resp</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">sta_addr_lo32</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">sta_addr_hi16</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">reserved</span><span class="p">;</span>

	<span class="cm">/* Index of recipient (BA-sending) station in uCode&#39;s station table */</span>
	<span class="n">u8</span> <span class="n">sta_id</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tid</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">seq_ctl</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">bitmap</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">scd_flow</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">scd_ssn</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">txed</span><span class="p">;</span>	<span class="cm">/* number of frames sent */</span>
	<span class="n">u8</span> <span class="n">txed_2_done</span><span class="p">;</span> <span class="cm">/* number of frames acked */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_TX_PWR_TABLE_CMD = 0x97 (command, has simple generic response)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*RS_NEW_API: only TLC_RTS remains and moved to bit 0 */</span>
<span class="cp">#define  LINK_QUAL_FLAGS_SET_STA_TLC_RTS_MSK	(1 &lt;&lt; 0)</span>

<span class="cm">/* # of EDCA prioritized tx fifos */</span>
<span class="cp">#define  LINK_QUAL_AC_NUM AC_NUM</span>

<span class="cm">/* # entries in rate scale table to support Tx retries */</span>
<span class="cp">#define  LINK_QUAL_MAX_RETRY_NUM 16</span>

<span class="cm">/* Tx antenna selection values */</span>
<span class="cp">#define  LINK_QUAL_ANT_A_MSK (1 &lt;&lt; 0)</span>
<span class="cp">#define  LINK_QUAL_ANT_B_MSK (1 &lt;&lt; 1)</span>
<span class="cp">#define  LINK_QUAL_ANT_MSK   (LINK_QUAL_ANT_A_MSK|LINK_QUAL_ANT_B_MSK)</span>


<span class="cm">/**</span>
<span class="cm"> * struct iwl_link_qual_general_params</span>
<span class="cm"> *</span>
<span class="cm"> * Used in REPLY_TX_LINK_QUALITY_CMD</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_link_qual_general_params</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* No entries at or above this (driver chosen) index contain MIMO */</span>
	<span class="n">u8</span> <span class="n">mimo_delimiter</span><span class="p">;</span>

	<span class="cm">/* Best single antenna to use for single stream (legacy, SISO). */</span>
	<span class="n">u8</span> <span class="n">single_stream_ant_msk</span><span class="p">;</span>	<span class="cm">/* LINK_QUAL_ANT_* */</span>

	<span class="cm">/* Best antennas to use for MIMO (unused for 4965, assumes both). */</span>
	<span class="n">u8</span> <span class="n">dual_stream_ant_msk</span><span class="p">;</span>		<span class="cm">/* LINK_QUAL_ANT_* */</span>

	<span class="cm">/*</span>
<span class="cm">	 * If driver needs to use different initial rates for different</span>
<span class="cm">	 * EDCA QOS access categories (as implemented by tx fifos 0-3),</span>
<span class="cm">	 * this table will set that up, by indicating the indexes in the</span>
<span class="cm">	 * rs_table[LINK_QUAL_MAX_RETRY_NUM] rate table at which to start.</span>
<span class="cm">	 * Otherwise, driver should set all entries to 0.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Entry usage:</span>
<span class="cm">	 * 0 = Background, 1 = Best Effort (normal), 2 = Video, 3 = Voice</span>
<span class="cm">	 * TX FIFOs above 3 use same value (typically 0) as TX FIFO 3.</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">start_rate_index</span><span class="p">[</span><span class="n">LINK_QUAL_AC_NUM</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cp">#define LINK_QUAL_AGG_TIME_LIMIT_DEF	(4000) </span><span class="cm">/* 4 milliseconds */</span><span class="cp"></span>
<span class="cp">#define LINK_QUAL_AGG_TIME_LIMIT_MAX	(8000)</span>
<span class="cp">#define LINK_QUAL_AGG_TIME_LIMIT_MIN	(100)</span>

<span class="cp">#define LINK_QUAL_AGG_DISABLE_START_DEF	(3)</span>
<span class="cp">#define LINK_QUAL_AGG_DISABLE_START_MAX	(255)</span>
<span class="cp">#define LINK_QUAL_AGG_DISABLE_START_MIN	(0)</span>

<span class="cp">#define LINK_QUAL_AGG_FRAME_LIMIT_DEF	(63)</span>
<span class="cp">#define LINK_QUAL_AGG_FRAME_LIMIT_MAX	(63)</span>
<span class="cp">#define LINK_QUAL_AGG_FRAME_LIMIT_MIN	(0)</span>

<span class="cm">/**</span>
<span class="cm"> * struct iwl_link_qual_agg_params</span>
<span class="cm"> *</span>
<span class="cm"> * Used in REPLY_TX_LINK_QUALITY_CMD</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_link_qual_agg_params</span> <span class="p">{</span>

	<span class="cm">/*</span>
<span class="cm">	 *Maximum number of uSec in aggregation.</span>
<span class="cm">	 * default set to 4000 (4 milliseconds) if not configured in .cfg</span>
<span class="cm">	 */</span>
	<span class="n">__le16</span> <span class="n">agg_time_limit</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Number of Tx retries allowed for a frame, before that frame will</span>
<span class="cm">	 * no longer be considered for the start of an aggregation sequence</span>
<span class="cm">	 * (scheduler will then try to tx it as single frame).</span>
<span class="cm">	 * Driver should set this to 3.</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">agg_dis_start_th</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Maximum number of frames in aggregation.</span>
<span class="cm">	 * 0 = no limit (default).  1 = no aggregation.</span>
<span class="cm">	 * Other values = max # frames in aggregation.</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">agg_frame_cnt_limit</span><span class="p">;</span>

	<span class="n">__le32</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_TX_LINK_QUALITY_CMD = 0x4e (command, has simple generic response)</span>
<span class="cm"> *</span>
<span class="cm"> * For agn devices</span>
<span class="cm"> *</span>
<span class="cm"> * Each station in the agn device&#39;s internal station table has its own table</span>
<span class="cm"> * of 16</span>
<span class="cm"> * Tx rates and modulation modes (e.g. legacy/SISO/MIMO) for retrying Tx when</span>
<span class="cm"> * an ACK is not received.  This command replaces the entire table for</span>
<span class="cm"> * one station.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  Station must already be in agn device&#39;s station table.</span>
<span class="cm"> *	  Use REPLY_ADD_STA.</span>
<span class="cm"> *</span>
<span class="cm"> * The rate scaling procedures described below work well.  Of course, other</span>
<span class="cm"> * procedures are possible, and may work better for particular environments.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * FILLING THE RATE TABLE</span>
<span class="cm"> *</span>
<span class="cm"> * Given a particular initial rate and mode, as determined by the rate</span>
<span class="cm"> * scaling algorithm described below, the Linux driver uses the following</span>
<span class="cm"> * formula to fill the rs_table[LINK_QUAL_MAX_RETRY_NUM] rate table in the</span>
<span class="cm"> * Link Quality command:</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * 1)  If using High-throughput (HT) (SISO or MIMO) initial rate:</span>
<span class="cm"> *     a) Use this same initial rate for first 3 entries.</span>
<span class="cm"> *     b) Find next lower available rate using same mode (SISO or MIMO),</span>
<span class="cm"> *        use for next 3 entries.  If no lower rate available, switch to</span>
<span class="cm"> *        legacy mode (no HT40 channel, no MIMO, no short guard interval).</span>
<span class="cm"> *     c) If using MIMO, set command&#39;s mimo_delimiter to number of entries</span>
<span class="cm"> *        using MIMO (3 or 6).</span>
<span class="cm"> *     d) After trying 2 HT rates, switch to legacy mode (no HT40 channel,</span>
<span class="cm"> *        no MIMO, no short guard interval), at the next lower bit rate</span>
<span class="cm"> *        (e.g. if second HT bit rate was 54, try 48 legacy), and follow</span>
<span class="cm"> *        legacy procedure for remaining table entries.</span>
<span class="cm"> *</span>
<span class="cm"> * 2)  If using legacy initial rate:</span>
<span class="cm"> *     a) Use the initial rate for only one entry.</span>
<span class="cm"> *     b) For each following entry, reduce the rate to next lower available</span>
<span class="cm"> *        rate, until reaching the lowest available rate.</span>
<span class="cm"> *     c) When reducing rate, also switch antenna selection.</span>
<span class="cm"> *     d) Once lowest available rate is reached, repeat this rate until</span>
<span class="cm"> *        rate table is filled (16 entries), switching antenna each entry.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * ACCUMULATING HISTORY</span>
<span class="cm"> *</span>
<span class="cm"> * The rate scaling algorithm for agn devices, as implemented in Linux driver,</span>
<span class="cm"> * uses two sets of frame Tx success history:  One for the current/active</span>
<span class="cm"> * modulation mode, and one for a speculative/search mode that is being</span>
<span class="cm"> * attempted. If the speculative mode turns out to be more effective (i.e.</span>
<span class="cm"> * actual transfer rate is better), then the driver continues to use the</span>
<span class="cm"> * speculative mode as the new current active mode.</span>
<span class="cm"> *</span>
<span class="cm"> * Each history set contains, separately for each possible rate, data for a</span>
<span class="cm"> * sliding window of the 62 most recent tx attempts at that rate.  The data</span>
<span class="cm"> * includes a shifting bitmap of success(1)/failure(0), and sums of successful</span>
<span class="cm"> * and attempted frames, from which the driver can additionally calculate a</span>
<span class="cm"> * success ratio (success / attempted) and number of failures</span>
<span class="cm"> * (attempted - success), and control the size of the window (attempted).</span>
<span class="cm"> * The driver uses the bit map to remove successes from the success sum, as</span>
<span class="cm"> * the oldest tx attempts fall out of the window.</span>
<span class="cm"> *</span>
<span class="cm"> * When the agn device makes multiple tx attempts for a given frame, each</span>
<span class="cm"> * attempt might be at a different rate, and have different modulation</span>
<span class="cm"> * characteristics (e.g. antenna, fat channel, short guard interval), as set</span>
<span class="cm"> * up in the rate scaling table in the Link Quality command.  The driver must</span>
<span class="cm"> * determine which rate table entry was used for each tx attempt, to determine</span>
<span class="cm"> * which rate-specific history to update, and record only those attempts that</span>
<span class="cm"> * match the modulation characteristics of the history set.</span>
<span class="cm"> *</span>
<span class="cm"> * When using block-ack (aggregation), all frames are transmitted at the same</span>
<span class="cm"> * rate, since there is no per-attempt acknowledgment from the destination</span>
<span class="cm"> * station.  The Tx response struct iwl_tx_resp indicates the Tx rate in</span>
<span class="cm"> * rate_n_flags field.  After receiving a block-ack, the driver can update</span>
<span class="cm"> * history for the entire block all at once.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * FINDING BEST STARTING RATE:</span>
<span class="cm"> *</span>
<span class="cm"> * When working with a selected initial modulation mode (see below), the</span>
<span class="cm"> * driver attempts to find a best initial rate.  The initial rate is the</span>
<span class="cm"> * first entry in the Link Quality command&#39;s rate table.</span>
<span class="cm"> *</span>
<span class="cm"> * 1)  Calculate actual throughput (success ratio * expected throughput, see</span>
<span class="cm"> *     table below) for current initial rate.  Do this only if enough frames</span>
<span class="cm"> *     have been attempted to make the value meaningful:  at least 6 failed</span>
<span class="cm"> *     tx attempts, or at least 8 successes.  If not enough, don&#39;t try rate</span>
<span class="cm"> *     scaling yet.</span>
<span class="cm"> *</span>
<span class="cm"> * 2)  Find available rates adjacent to current initial rate.  Available means:</span>
<span class="cm"> *     a)  supported by hardware &amp;&amp;</span>
<span class="cm"> *     b)  supported by association &amp;&amp;</span>
<span class="cm"> *     c)  within any constraints selected by user</span>
<span class="cm"> *</span>
<span class="cm"> * 3)  Gather measured throughputs for adjacent rates.  These might not have</span>
<span class="cm"> *     enough history to calculate a throughput.  That&#39;s okay, we might try</span>
<span class="cm"> *     using one of them anyway!</span>
<span class="cm"> *</span>
<span class="cm"> * 4)  Try decreasing rate if, for current rate:</span>
<span class="cm"> *     a)  success ratio is &lt; 15% ||</span>
<span class="cm"> *     b)  lower adjacent rate has better measured throughput ||</span>
<span class="cm"> *     c)  higher adjacent rate has worse throughput, and lower is unmeasured</span>
<span class="cm"> *</span>
<span class="cm"> *     As a sanity check, if decrease was determined above, leave rate</span>
<span class="cm"> *     unchanged if:</span>
<span class="cm"> *     a)  lower rate unavailable</span>
<span class="cm"> *     b)  success ratio at current rate &gt; 85% (very good)</span>
<span class="cm"> *     c)  current measured throughput is better than expected throughput</span>
<span class="cm"> *         of lower rate (under perfect 100% tx conditions, see table below)</span>
<span class="cm"> *</span>
<span class="cm"> * 5)  Try increasing rate if, for current rate:</span>
<span class="cm"> *     a)  success ratio is &lt; 15% ||</span>
<span class="cm"> *     b)  both adjacent rates&#39; throughputs are unmeasured (try it!) ||</span>
<span class="cm"> *     b)  higher adjacent rate has better measured throughput ||</span>
<span class="cm"> *     c)  lower adjacent rate has worse throughput, and higher is unmeasured</span>
<span class="cm"> *</span>
<span class="cm"> *     As a sanity check, if increase was determined above, leave rate</span>
<span class="cm"> *     unchanged if:</span>
<span class="cm"> *     a)  success ratio at current rate &lt; 70%.  This is not particularly</span>
<span class="cm"> *         good performance; higher rate is sure to have poorer success.</span>
<span class="cm"> *</span>
<span class="cm"> * 6)  Re-evaluate the rate after each tx frame.  If working with block-</span>
<span class="cm"> *     acknowledge, history and statistics may be calculated for the entire</span>
<span class="cm"> *     block (including prior history that fits within the history windows),</span>
<span class="cm"> *     before re-evaluation.</span>
<span class="cm"> *</span>
<span class="cm"> * FINDING BEST STARTING MODULATION MODE:</span>
<span class="cm"> *</span>
<span class="cm"> * After working with a modulation mode for a &quot;while&quot; (and doing rate scaling),</span>
<span class="cm"> * the driver searches for a new initial mode in an attempt to improve</span>
<span class="cm"> * throughput.  The &quot;while&quot; is measured by numbers of attempted frames:</span>
<span class="cm"> *</span>
<span class="cm"> * For legacy mode, search for new mode after:</span>
<span class="cm"> *   480 successful frames, or 160 failed frames</span>
<span class="cm"> * For high-throughput modes (SISO or MIMO), search for new mode after:</span>
<span class="cm"> *   4500 successful frames, or 400 failed frames</span>
<span class="cm"> *</span>
<span class="cm"> * Mode switch possibilities are (3 for each mode):</span>
<span class="cm"> *</span>
<span class="cm"> * For legacy:</span>
<span class="cm"> *   Change antenna, try SISO (if HT association), try MIMO (if HT association)</span>
<span class="cm"> * For SISO:</span>
<span class="cm"> *   Change antenna, try MIMO, try shortened guard interval (SGI)</span>
<span class="cm"> * For MIMO:</span>
<span class="cm"> *   Try SISO antenna A, SISO antenna B, try shortened guard interval (SGI)</span>
<span class="cm"> *</span>
<span class="cm"> * When trying a new mode, use the same bit rate as the old/current mode when</span>
<span class="cm"> * trying antenna switches and shortened guard interval.  When switching to</span>
<span class="cm"> * SISO from MIMO or legacy, or to MIMO from SISO or legacy, use a rate</span>
<span class="cm"> * for which the expected throughput (under perfect conditions) is about the</span>
<span class="cm"> * same or slightly better than the actual measured throughput delivered by</span>
<span class="cm"> * the old/current mode.</span>
<span class="cm"> *</span>
<span class="cm"> * Actual throughput can be estimated by multiplying the expected throughput</span>
<span class="cm"> * by the success ratio (successful / attempted tx frames).  Frame size is</span>
<span class="cm"> * not considered in this calculation; it assumes that frame size will average</span>
<span class="cm"> * out to be fairly consistent over several samples.  The following are</span>
<span class="cm"> * metric values for expected throughput assuming 100% success ratio.</span>
<span class="cm"> * Only G band has support for CCK rates:</span>
<span class="cm"> *</span>
<span class="cm"> *           RATE:  1    2    5   11    6   9   12   18   24   36   48   54   60</span>
<span class="cm"> *</span>
<span class="cm"> *              G:  7   13   35   58   40  57   72   98  121  154  177  186  186</span>
<span class="cm"> *              A:  0    0    0    0   40  57   72   98  121  154  177  186  186</span>
<span class="cm"> *     SISO 20MHz:  0    0    0    0   42  42   76  102  124  159  183  193  202</span>
<span class="cm"> * SGI SISO 20MHz:  0    0    0    0   46  46   82  110  132  168  192  202  211</span>
<span class="cm"> *     MIMO 20MHz:  0    0    0    0   74  74  123  155  179  214  236  244  251</span>
<span class="cm"> * SGI MIMO 20MHz:  0    0    0    0   81  81  131  164  188  222  243  251  257</span>
<span class="cm"> *     SISO 40MHz:  0    0    0    0   77  77  127  160  184  220  242  250  257</span>
<span class="cm"> * SGI SISO 40MHz:  0    0    0    0   83  83  135  169  193  229  250  257  264</span>
<span class="cm"> *     MIMO 40MHz:  0    0    0    0  123 123  182  214  235  264  279  285  289</span>
<span class="cm"> * SGI MIMO 40MHz:  0    0    0    0  131 131  191  222  242  270  284  289  293</span>
<span class="cm"> *</span>
<span class="cm"> * After the new mode has been tried for a short while (minimum of 6 failed</span>
<span class="cm"> * frames or 8 successful frames), compare success ratio and actual throughput</span>
<span class="cm"> * estimate of the new mode with the old.  If either is better with the new</span>
<span class="cm"> * mode, continue to use the new mode.</span>
<span class="cm"> *</span>
<span class="cm"> * Continue comparing modes until all 3 possibilities have been tried.</span>
<span class="cm"> * If moving from legacy to HT, try all 3 possibilities from the new HT</span>
<span class="cm"> * mode.  After trying all 3, a best mode is found.  Continue to use this mode</span>
<span class="cm"> * for the longer &quot;while&quot; described above (e.g. 480 successful frames for</span>
<span class="cm"> * legacy), and then repeat the search process.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_link_quality_cmd</span> <span class="p">{</span>

	<span class="cm">/* Index of destination/recipient station in uCode&#39;s station table */</span>
	<span class="n">u8</span> <span class="n">sta_id</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved1</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">control</span><span class="p">;</span>		<span class="cm">/* not used */</span>
	<span class="k">struct</span> <span class="n">iwl_link_qual_general_params</span> <span class="n">general_params</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_link_qual_agg_params</span> <span class="n">agg_params</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Rate info; when using rate-scaling, Tx command&#39;s initial_rate_index</span>
<span class="cm">	 * specifies 1st Tx rate attempted, via index into this table.</span>
<span class="cm">	 * agn devices works its way through table when retrying Tx.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">__le32</span> <span class="n">rate_n_flags</span><span class="p">;</span>	<span class="cm">/* RATE_MCS_*, IWL_RATE_* */</span>
	<span class="p">}</span> <span class="n">rs_table</span><span class="p">[</span><span class="n">LINK_QUAL_MAX_RETRY_NUM</span><span class="p">];</span>
	<span class="n">__le32</span> <span class="n">reserved2</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * BT configuration enable flags:</span>
<span class="cm"> *   bit 0 - 1: BT channel announcement enabled</span>
<span class="cm"> *           0: disable</span>
<span class="cm"> *   bit 1 - 1: priority of BT device enabled</span>
<span class="cm"> *           0: disable</span>
<span class="cm"> *   bit 2 - 1: BT 2 wire support enabled</span>
<span class="cm"> *           0: disable</span>
<span class="cm"> */</span>
<span class="cp">#define BT_COEX_DISABLE (0x0)</span>
<span class="cp">#define BT_ENABLE_CHANNEL_ANNOUNCE BIT(0)</span>
<span class="cp">#define BT_ENABLE_PRIORITY	   BIT(1)</span>
<span class="cp">#define BT_ENABLE_2_WIRE	   BIT(2)</span>

<span class="cp">#define BT_COEX_DISABLE (0x0)</span>
<span class="cp">#define BT_COEX_ENABLE  (BT_ENABLE_CHANNEL_ANNOUNCE | BT_ENABLE_PRIORITY)</span>

<span class="cp">#define BT_LEAD_TIME_MIN (0x0)</span>
<span class="cp">#define BT_LEAD_TIME_DEF (0x1E)</span>
<span class="cp">#define BT_LEAD_TIME_MAX (0xFF)</span>

<span class="cp">#define BT_MAX_KILL_MIN (0x1)</span>
<span class="cp">#define BT_MAX_KILL_DEF (0x5)</span>
<span class="cp">#define BT_MAX_KILL_MAX (0xFF)</span>

<span class="cp">#define BT_DURATION_LIMIT_DEF	625</span>
<span class="cp">#define BT_DURATION_LIMIT_MAX	1250</span>
<span class="cp">#define BT_DURATION_LIMIT_MIN	625</span>

<span class="cp">#define BT_ON_THRESHOLD_DEF	4</span>
<span class="cp">#define BT_ON_THRESHOLD_MAX	1000</span>
<span class="cp">#define BT_ON_THRESHOLD_MIN	1</span>

<span class="cp">#define BT_FRAG_THRESHOLD_DEF	0</span>
<span class="cp">#define BT_FRAG_THRESHOLD_MAX	0</span>
<span class="cp">#define BT_FRAG_THRESHOLD_MIN	0</span>

<span class="cp">#define BT_AGG_THRESHOLD_DEF	1200</span>
<span class="cp">#define BT_AGG_THRESHOLD_MAX	8000</span>
<span class="cp">#define BT_AGG_THRESHOLD_MIN	400</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_BT_CONFIG = 0x9b (command, has simple generic response)</span>
<span class="cm"> *</span>
<span class="cm"> * agn devices support hardware handshake with Bluetooth device on</span>
<span class="cm"> * same platform.  Bluetooth device alerts wireless device when it will Tx;</span>
<span class="cm"> * wireless device can delay or kill its own Tx to accommodate.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_bt_cmd</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">lead_time</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">max_kill</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">kill_ack_mask</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">kill_cts_mask</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cp">#define IWLAGN_BT_FLAG_CHANNEL_INHIBITION	BIT(0)</span>

<span class="cp">#define IWLAGN_BT_FLAG_COEX_MODE_MASK		(BIT(3)|BIT(4)|BIT(5))</span>
<span class="cp">#define IWLAGN_BT_FLAG_COEX_MODE_SHIFT		3</span>
<span class="cp">#define IWLAGN_BT_FLAG_COEX_MODE_DISABLED	0</span>
<span class="cp">#define IWLAGN_BT_FLAG_COEX_MODE_LEGACY_2W	1</span>
<span class="cp">#define IWLAGN_BT_FLAG_COEX_MODE_3W		2</span>
<span class="cp">#define IWLAGN_BT_FLAG_COEX_MODE_4W		3</span>

<span class="cp">#define IWLAGN_BT_FLAG_UCODE_DEFAULT		BIT(6)</span>
<span class="cm">/* Disable Sync PSPoll on SCO/eSCO */</span>
<span class="cp">#define IWLAGN_BT_FLAG_SYNC_2_BT_DISABLE	BIT(7)</span>

<span class="cp">#define IWLAGN_BT_PSP_MIN_RSSI_THRESHOLD	-75 </span><span class="cm">/* dBm */</span><span class="cp"></span>
<span class="cp">#define IWLAGN_BT_PSP_MAX_RSSI_THRESHOLD	-65 </span><span class="cm">/* dBm */</span><span class="cp"></span>

<span class="cp">#define IWLAGN_BT_PRIO_BOOST_MAX	0xFF</span>
<span class="cp">#define IWLAGN_BT_PRIO_BOOST_MIN	0x00</span>
<span class="cp">#define IWLAGN_BT_PRIO_BOOST_DEFAULT	0xF0</span>

<span class="cp">#define IWLAGN_BT_MAX_KILL_DEFAULT	5</span>

<span class="cp">#define IWLAGN_BT3_T7_DEFAULT		1</span>

<span class="k">enum</span> <span class="n">iwl_bt_kill_idx</span> <span class="p">{</span>
	<span class="n">IWL_BT_KILL_DEFAULT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IWL_BT_KILL_OVERRIDE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IWL_BT_KILL_REDUCE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define IWLAGN_BT_KILL_ACK_MASK_DEFAULT	cpu_to_le32(0xffff0000)</span>
<span class="cp">#define IWLAGN_BT_KILL_CTS_MASK_DEFAULT	cpu_to_le32(0xffff0000)</span>
<span class="cp">#define IWLAGN_BT_KILL_ACK_CTS_MASK_SCO	cpu_to_le32(0xffffffff)</span>
<span class="cp">#define IWLAGN_BT_KILL_ACK_CTS_MASK_REDUCE	cpu_to_le32(0)</span>

<span class="cp">#define IWLAGN_BT3_PRIO_SAMPLE_DEFAULT	2</span>

<span class="cp">#define IWLAGN_BT3_T2_DEFAULT		0xc</span>

<span class="cp">#define IWLAGN_BT_VALID_ENABLE_FLAGS	cpu_to_le16(BIT(0))</span>
<span class="cp">#define IWLAGN_BT_VALID_BOOST		cpu_to_le16(BIT(1))</span>
<span class="cp">#define IWLAGN_BT_VALID_MAX_KILL	cpu_to_le16(BIT(2))</span>
<span class="cp">#define IWLAGN_BT_VALID_3W_TIMERS	cpu_to_le16(BIT(3))</span>
<span class="cp">#define IWLAGN_BT_VALID_KILL_ACK_MASK	cpu_to_le16(BIT(4))</span>
<span class="cp">#define IWLAGN_BT_VALID_KILL_CTS_MASK	cpu_to_le16(BIT(5))</span>
<span class="cp">#define IWLAGN_BT_VALID_REDUCED_TX_PWR	cpu_to_le16(BIT(6))</span>
<span class="cp">#define IWLAGN_BT_VALID_3W_LUT		cpu_to_le16(BIT(7))</span>

<span class="cp">#define IWLAGN_BT_ALL_VALID_MSK		(IWLAGN_BT_VALID_ENABLE_FLAGS | \</span>
<span class="cp">					IWLAGN_BT_VALID_BOOST | \</span>
<span class="cp">					IWLAGN_BT_VALID_MAX_KILL | \</span>
<span class="cp">					IWLAGN_BT_VALID_3W_TIMERS | \</span>
<span class="cp">					IWLAGN_BT_VALID_KILL_ACK_MASK | \</span>
<span class="cp">					IWLAGN_BT_VALID_KILL_CTS_MASK | \</span>
<span class="cp">					IWLAGN_BT_VALID_REDUCED_TX_PWR | \</span>
<span class="cp">					IWLAGN_BT_VALID_3W_LUT)</span>

<span class="cp">#define IWLAGN_BT_REDUCED_TX_PWR	BIT(0)</span>

<span class="cp">#define IWLAGN_BT_DECISION_LUT_SIZE	12</span>

<span class="k">struct</span> <span class="n">iwl_basic_bt_cmd</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ledtime</span><span class="p">;</span> <span class="cm">/* unused */</span>
	<span class="n">u8</span> <span class="n">max_kill</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bt3_timer_t7_value</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">kill_ack_mask</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">kill_cts_mask</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bt3_prio_sample_time</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bt3_timer_t2_value</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">bt4_reaction_time</span><span class="p">;</span> <span class="cm">/* unused */</span>
	<span class="n">__le32</span> <span class="n">bt3_lookup_table</span><span class="p">[</span><span class="n">IWLAGN_BT_DECISION_LUT_SIZE</span><span class="p">];</span>
	<span class="cm">/*</span>
<span class="cm">	 * bit 0: use reduced tx power for control frame</span>
<span class="cm">	 * bit 1 - 7: reserved</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">reduce_txpower</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">valid</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">iwl_bt_cmd_v1</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_basic_bt_cmd</span> <span class="n">basic</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">prio_boost</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * set IWLAGN_BT_VALID_BOOST to &quot;1&quot; in &quot;valid&quot; bitmask</span>
<span class="cm">	 * if configure the following patterns</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">tx_prio_boost</span><span class="p">;</span>	<span class="cm">/* SW boost of WiFi tx priority */</span>
	<span class="n">__le16</span> <span class="n">rx_prio_boost</span><span class="p">;</span>	<span class="cm">/* SW boost of WiFi rx priority */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">iwl_bt_cmd_v2</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_basic_bt_cmd</span> <span class="n">basic</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">prio_boost</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * set IWLAGN_BT_VALID_BOOST to &quot;1&quot; in &quot;valid&quot; bitmask</span>
<span class="cm">	 * if configure the following patterns</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">reserved</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tx_prio_boost</span><span class="p">;</span>	<span class="cm">/* SW boost of WiFi tx priority */</span>
	<span class="n">__le16</span> <span class="n">rx_prio_boost</span><span class="p">;</span>	<span class="cm">/* SW boost of WiFi rx priority */</span>
<span class="p">};</span>

<span class="cp">#define IWLAGN_BT_SCO_ACTIVE	cpu_to_le32(BIT(0))</span>

<span class="k">struct</span> <span class="n">iwlagn_bt_sco_cmd</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * (6)</span>
<span class="cm"> * Spectrum Management (802.11h) Commands, Responses, Notifications:</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Spectrum Management</span>
<span class="cm"> */</span>
<span class="cp">#define MEASUREMENT_FILTER_FLAG (RXON_FILTER_PROMISC_MSK         | \</span>
<span class="cp">				 RXON_FILTER_CTL2HOST_MSK        | \</span>
<span class="cp">				 RXON_FILTER_ACCEPT_GRP_MSK      | \</span>
<span class="cp">				 RXON_FILTER_DIS_DECRYPT_MSK     | \</span>
<span class="cp">				 RXON_FILTER_DIS_GRP_DECRYPT_MSK | \</span>
<span class="cp">				 RXON_FILTER_ASSOC_MSK           | \</span>
<span class="cp">				 RXON_FILTER_BCON_AWARE_MSK)</span>

<span class="k">struct</span> <span class="n">iwl_measure_channel</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">duration</span><span class="p">;</span>	<span class="cm">/* measurement duration in extended beacon</span>
<span class="cm">				 * format */</span>
	<span class="n">u8</span> <span class="n">channel</span><span class="p">;</span>		<span class="cm">/* channel to measure */</span>
	<span class="n">u8</span> <span class="n">type</span><span class="p">;</span>		<span class="cm">/* see enum iwl_measure_type */</span>
	<span class="n">__le16</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_SPECTRUM_MEASUREMENT_CMD = 0x74 (command)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_spectrum_cmd</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">len</span><span class="p">;</span>		<span class="cm">/* number of bytes starting from token */</span>
	<span class="n">u8</span> <span class="n">token</span><span class="p">;</span>		<span class="cm">/* token id */</span>
	<span class="n">u8</span> <span class="n">id</span><span class="p">;</span>			<span class="cm">/* measurement id -- 0 or 1 */</span>
	<span class="n">u8</span> <span class="n">origin</span><span class="p">;</span>		<span class="cm">/* 0 = TGh, 1 = other, 2 = TGk */</span>
	<span class="n">u8</span> <span class="n">periodic</span><span class="p">;</span>		<span class="cm">/* 1 = periodic */</span>
	<span class="n">__le16</span> <span class="n">path_loss_timeout</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">start_time</span><span class="p">;</span>	<span class="cm">/* start time in extended beacon format */</span>
	<span class="n">__le32</span> <span class="n">reserved2</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* rxon flags */</span>
	<span class="n">__le32</span> <span class="n">filter_flags</span><span class="p">;</span>	<span class="cm">/* rxon filter flags */</span>
	<span class="n">__le16</span> <span class="n">channel_count</span><span class="p">;</span>	<span class="cm">/* minimum 1, maximum 10 */</span>
	<span class="n">__le16</span> <span class="n">reserved3</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_measure_channel</span> <span class="n">channels</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_SPECTRUM_MEASUREMENT_CMD = 0x74 (response)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_spectrum_resp</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">token</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">id</span><span class="p">;</span>			<span class="cm">/* id of the prior command replaced, or 0xff */</span>
	<span class="n">__le16</span> <span class="n">status</span><span class="p">;</span>		<span class="cm">/* 0 - command will be handled</span>
<span class="cm">				 * 1 - cannot handle (conflicts with another</span>
<span class="cm">				 *     measurement) */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">iwl_measurement_state</span> <span class="p">{</span>
	<span class="n">IWL_MEASUREMENT_START</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IWL_MEASUREMENT_STOP</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">iwl_measurement_status</span> <span class="p">{</span>
	<span class="n">IWL_MEASUREMENT_OK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IWL_MEASUREMENT_CONCURRENT</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IWL_MEASUREMENT_CSA_CONFLICT</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">IWL_MEASUREMENT_TGH_CONFLICT</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="cm">/* 4-5 reserved */</span>
	<span class="n">IWL_MEASUREMENT_STOPPED</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">IWL_MEASUREMENT_TIMEOUT</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
	<span class="n">IWL_MEASUREMENT_PERIODIC_FAILED</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define NUM_ELEMENTS_IN_HISTOGRAM 8</span>

<span class="k">struct</span> <span class="n">iwl_measurement_histogram</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">ofdm</span><span class="p">[</span><span class="n">NUM_ELEMENTS_IN_HISTOGRAM</span><span class="p">];</span>	<span class="cm">/* in 0.8usec counts */</span>
	<span class="n">__le32</span> <span class="n">cck</span><span class="p">[</span><span class="n">NUM_ELEMENTS_IN_HISTOGRAM</span><span class="p">];</span>	<span class="cm">/* in 1usec counts */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* clear channel availability counters */</span>
<span class="k">struct</span> <span class="n">iwl_measurement_cca_counters</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">ofdm</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">cck</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">iwl_measure_type</span> <span class="p">{</span>
	<span class="n">IWL_MEASURE_BASIC</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">IWL_MEASURE_CHANNEL_LOAD</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">IWL_MEASURE_HISTOGRAM_RPI</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
	<span class="n">IWL_MEASURE_HISTOGRAM_NOISE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
	<span class="n">IWL_MEASURE_FRAME</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span>
	<span class="cm">/* bits 5:6 are reserved */</span>
	<span class="n">IWL_MEASURE_IDLE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * SPECTRUM_MEASURE_NOTIFICATION = 0x75 (notification only, not a command)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_spectrum_notification</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">id</span><span class="p">;</span>			<span class="cm">/* measurement id -- 0 or 1 */</span>
	<span class="n">u8</span> <span class="n">token</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">channel_index</span><span class="p">;</span>	<span class="cm">/* index in measurement channel list */</span>
	<span class="n">u8</span> <span class="n">state</span><span class="p">;</span>		<span class="cm">/* 0 - start, 1 - stop */</span>
	<span class="n">__le32</span> <span class="n">start_time</span><span class="p">;</span>	<span class="cm">/* lower 32-bits of TSF */</span>
	<span class="n">u8</span> <span class="n">band</span><span class="p">;</span>		<span class="cm">/* 0 - 5.2GHz, 1 - 2.4GHz */</span>
	<span class="n">u8</span> <span class="n">channel</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">type</span><span class="p">;</span>		<span class="cm">/* see enum iwl_measurement_type */</span>
	<span class="n">u8</span> <span class="n">reserved1</span><span class="p">;</span>
	<span class="cm">/* NOTE:  cca_ofdm, cca_cck, basic_type, and histogram are only only</span>
<span class="cm">	 * valid if applicable for measurement type requested. */</span>
	<span class="n">__le32</span> <span class="n">cca_ofdm</span><span class="p">;</span>	<span class="cm">/* cca fraction time in 40Mhz clock periods */</span>
	<span class="n">__le32</span> <span class="n">cca_cck</span><span class="p">;</span>		<span class="cm">/* cca fraction time in 44Mhz clock periods */</span>
	<span class="n">__le32</span> <span class="n">cca_time</span><span class="p">;</span>	<span class="cm">/* channel load time in usecs */</span>
	<span class="n">u8</span> <span class="n">basic_type</span><span class="p">;</span>		<span class="cm">/* 0 - bss, 1 - ofdm preamble, 2 -</span>
<span class="cm">				 * unidentified */</span>
	<span class="n">u8</span> <span class="n">reserved2</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">iwl_measurement_histogram</span> <span class="n">histogram</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">stop_time</span><span class="p">;</span>	<span class="cm">/* lower 32-bits of TSF */</span>
	<span class="n">__le32</span> <span class="n">status</span><span class="p">;</span>		<span class="cm">/* see iwl_measurement_status */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * (7)</span>
<span class="cm"> * Power Management Commands, Responses, Notifications:</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cm">/**</span>
<span class="cm"> * struct iwl_powertable_cmd - Power Table Command</span>
<span class="cm"> * @flags: See below:</span>
<span class="cm"> *</span>
<span class="cm"> * POWER_TABLE_CMD = 0x77 (command, has simple generic response)</span>
<span class="cm"> *</span>
<span class="cm"> * PM allow:</span>
<span class="cm"> *   bit 0 - &#39;0&#39; Driver not allow power management</span>
<span class="cm"> *           &#39;1&#39; Driver allow PM (use rest of parameters)</span>
<span class="cm"> *</span>
<span class="cm"> * uCode send sleep notifications:</span>
<span class="cm"> *   bit 1 - &#39;0&#39; Don&#39;t send sleep notification</span>
<span class="cm"> *           &#39;1&#39; send sleep notification (SEND_PM_NOTIFICATION)</span>
<span class="cm"> *</span>
<span class="cm"> * Sleep over DTIM</span>
<span class="cm"> *   bit 2 - &#39;0&#39; PM have to walk up every DTIM</span>
<span class="cm"> *           &#39;1&#39; PM could sleep over DTIM till listen Interval.</span>
<span class="cm"> *</span>
<span class="cm"> * PCI power managed</span>
<span class="cm"> *   bit 3 - &#39;0&#39; (PCI_CFG_LINK_CTRL &amp; 0x1)</span>
<span class="cm"> *           &#39;1&#39; !(PCI_CFG_LINK_CTRL &amp; 0x1)</span>
<span class="cm"> *</span>
<span class="cm"> * Fast PD</span>
<span class="cm"> *   bit 4 - &#39;1&#39; Put radio to sleep when receiving frame for others</span>
<span class="cm"> *</span>
<span class="cm"> * Force sleep Modes</span>
<span class="cm"> *   bit 31/30- &#39;00&#39; use both mac/xtal sleeps</span>
<span class="cm"> *              &#39;01&#39; force Mac sleep</span>
<span class="cm"> *              &#39;10&#39; force xtal sleep</span>
<span class="cm"> *              &#39;11&#39; Illegal set</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: if sleep_interval[SLEEP_INTRVL_TABLE_SIZE-1] &gt; DTIM period then</span>
<span class="cm"> * ucode assume sleep over DTIM is allowed and we don&#39;t need to wake up</span>
<span class="cm"> * for every DTIM.</span>
<span class="cm"> */</span>
<span class="cp">#define IWL_POWER_VEC_SIZE 5</span>

<span class="cp">#define IWL_POWER_DRIVER_ALLOW_SLEEP_MSK	cpu_to_le16(BIT(0))</span>
<span class="cp">#define IWL_POWER_POWER_SAVE_ENA_MSK		cpu_to_le16(BIT(0))</span>
<span class="cp">#define IWL_POWER_POWER_MANAGEMENT_ENA_MSK	cpu_to_le16(BIT(1))</span>
<span class="cp">#define IWL_POWER_SLEEP_OVER_DTIM_MSK		cpu_to_le16(BIT(2))</span>
<span class="cp">#define IWL_POWER_PCI_PM_MSK			cpu_to_le16(BIT(3))</span>
<span class="cp">#define IWL_POWER_FAST_PD			cpu_to_le16(BIT(4))</span>
<span class="cp">#define IWL_POWER_BEACON_FILTERING		cpu_to_le16(BIT(5))</span>
<span class="cp">#define IWL_POWER_SHADOW_REG_ENA		cpu_to_le16(BIT(6))</span>
<span class="cp">#define IWL_POWER_CT_KILL_SET			cpu_to_le16(BIT(7))</span>
<span class="cp">#define IWL_POWER_BT_SCO_ENA			cpu_to_le16(BIT(8))</span>
<span class="cp">#define IWL_POWER_ADVANCE_PM_ENA_MSK		cpu_to_le16(BIT(9))</span>

<span class="k">struct</span> <span class="n">iwl_powertable_cmd</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">keep_alive_seconds</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">debug_flags</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">rx_data_timeout</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">tx_data_timeout</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">sleep_interval</span><span class="p">[</span><span class="n">IWL_POWER_VEC_SIZE</span><span class="p">];</span>
	<span class="n">__le32</span> <span class="n">keep_alive_beacons</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * PM_SLEEP_NOTIFICATION = 0x7A (notification only, not a command)</span>
<span class="cm"> * all devices identical.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_sleep_notification</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">pm_sleep_mode</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pm_wakeup_src</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">reserved</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">sleep_time</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">tsf_low</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">bcon_timer</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* Sleep states.  all devices identical. */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IWL_PM_NO_SLEEP</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IWL_PM_SLP_MAC</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IWL_PM_SLP_FULL_MAC_UNASSOCIATE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">IWL_PM_SLP_FULL_MAC_CARD_STATE</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">IWL_PM_SLP_PHY</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">IWL_PM_SLP_REPENT</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">IWL_PM_WAKEUP_BY_TIMER</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">IWL_PM_WAKEUP_BY_DRIVER</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
	<span class="n">IWL_PM_WAKEUP_BY_RFKILL</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="cm">/* 3 reserved */</span>
	<span class="n">IWL_PM_NUM_OF_MODES</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_CARD_STATE_CMD = 0xa0 (command, has simple generic response)</span>
<span class="cm"> */</span>
<span class="cp">#define CARD_STATE_CMD_DISABLE 0x00	</span><span class="cm">/* Put card to sleep */</span><span class="cp"></span>
<span class="cp">#define CARD_STATE_CMD_ENABLE  0x01	</span><span class="cm">/* Wake up card */</span><span class="cp"></span>
<span class="cp">#define CARD_STATE_CMD_HALT    0x02	</span><span class="cm">/* Power down permanently */</span><span class="cp"></span>
<span class="k">struct</span> <span class="n">iwl_card_state_cmd</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">status</span><span class="p">;</span>		<span class="cm">/* CARD_STATE_CMD_* request new power state */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * CARD_STATE_NOTIFICATION = 0xa1 (notification only, not a command)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_card_state_notif</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cp">#define HW_CARD_DISABLED   0x01</span>
<span class="cp">#define SW_CARD_DISABLED   0x02</span>
<span class="cp">#define CT_CARD_DISABLED   0x04</span>
<span class="cp">#define RXON_CARD_DISABLED 0x10</span>

<span class="k">struct</span> <span class="n">iwl_ct_kill_config</span> <span class="p">{</span>
	<span class="n">__le32</span>   <span class="n">reserved</span><span class="p">;</span>
	<span class="n">__le32</span>   <span class="n">critical_temperature_M</span><span class="p">;</span>
	<span class="n">__le32</span>   <span class="n">critical_temperature_R</span><span class="p">;</span>
<span class="p">}</span>  <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* 1000, and 6x00 */</span>
<span class="k">struct</span> <span class="n">iwl_ct_kill_throttling_config</span> <span class="p">{</span>
	<span class="n">__le32</span>   <span class="n">critical_temperature_exit</span><span class="p">;</span>
	<span class="n">__le32</span>   <span class="n">reserved</span><span class="p">;</span>
	<span class="n">__le32</span>   <span class="n">critical_temperature_enter</span><span class="p">;</span>
<span class="p">}</span>  <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * (8)</span>
<span class="cm"> * Scan Commands, Responses, Notifications:</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cp">#define SCAN_CHANNEL_TYPE_PASSIVE cpu_to_le32(0)</span>
<span class="cp">#define SCAN_CHANNEL_TYPE_ACTIVE  cpu_to_le32(1)</span>

<span class="cm">/**</span>
<span class="cm"> * struct iwl_scan_channel - entry in REPLY_SCAN_CMD channel table</span>
<span class="cm"> *</span>
<span class="cm"> * One for each channel in the scan list.</span>
<span class="cm"> * Each channel can independently select:</span>
<span class="cm"> * 1)  SSID for directed active scans</span>
<span class="cm"> * 2)  Txpower setting (for rate specified within Tx command)</span>
<span class="cm"> * 3)  How long to stay on-channel (behavior may be modified by quiet_time,</span>
<span class="cm"> *     quiet_plcp_th, good_CRC_th)</span>
<span class="cm"> *</span>
<span class="cm"> * To avoid uCode errors, make sure the following are true (see comments</span>
<span class="cm"> * under struct iwl_scan_cmd about max_out_time and quiet_time):</span>
<span class="cm"> * 1)  If using passive_dwell (i.e. passive_dwell != 0):</span>
<span class="cm"> *     active_dwell &lt;= passive_dwell (&lt; max_out_time if max_out_time != 0)</span>
<span class="cm"> * 2)  quiet_time &lt;= active_dwell</span>
<span class="cm"> * 3)  If restricting off-channel time (i.e. max_out_time !=0):</span>
<span class="cm"> *     passive_dwell &lt; max_out_time</span>
<span class="cm"> *     active_dwell &lt; max_out_time</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">iwl_scan_channel</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * type is defined as:</span>
<span class="cm">	 * 0:0 1 = active, 0 = passive</span>
<span class="cm">	 * 1:20 SSID direct bit map; if a bit is set, then corresponding</span>
<span class="cm">	 *     SSID IE is transmitted in probe request.</span>
<span class="cm">	 * 21:31 reserved</span>
<span class="cm">	 */</span>
	<span class="n">__le32</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">channel</span><span class="p">;</span>	<span class="cm">/* band is selected by iwl_scan_cmd &quot;flags&quot; field */</span>
	<span class="n">u8</span> <span class="n">tx_gain</span><span class="p">;</span>		<span class="cm">/* gain for analog radio */</span>
	<span class="n">u8</span> <span class="n">dsp_atten</span><span class="p">;</span>		<span class="cm">/* gain for DSP */</span>
	<span class="n">__le16</span> <span class="n">active_dwell</span><span class="p">;</span>	<span class="cm">/* in 1024-uSec TU (time units), typ 5-50 */</span>
	<span class="n">__le16</span> <span class="n">passive_dwell</span><span class="p">;</span>	<span class="cm">/* in 1024-uSec TU (time units), typ 20-500 */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* set number of direct probes __le32 type */</span>
<span class="cp">#define IWL_SCAN_PROBE_MASK(n) 	cpu_to_le32((BIT(n) | (BIT(n) - BIT(1))))</span>

<span class="cm">/**</span>
<span class="cm"> * struct iwl_ssid_ie - directed scan network information element</span>
<span class="cm"> *</span>
<span class="cm"> * Up to 20 of these may appear in REPLY_SCAN_CMD,</span>
<span class="cm"> * selected by &quot;type&quot; bit field in struct iwl_scan_channel;</span>
<span class="cm"> * each channel may select different ssids from among the 20 entries.</span>
<span class="cm"> * SSID IEs get transmitted in reverse order of entry.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_ssid_ie</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ssid</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cp">#define PROBE_OPTION_MAX		20</span>
<span class="cp">#define TX_CMD_LIFE_TIME_INFINITE	cpu_to_le32(0xFFFFFFFF)</span>
<span class="cp">#define IWL_GOOD_CRC_TH_DISABLED	0</span>
<span class="cp">#define IWL_GOOD_CRC_TH_DEFAULT		cpu_to_le16(1)</span>
<span class="cp">#define IWL_GOOD_CRC_TH_NEVER		cpu_to_le16(0xffff)</span>
<span class="cp">#define IWL_MAX_CMD_SIZE 4096</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_SCAN_CMD = 0x80 (command)</span>
<span class="cm"> *</span>
<span class="cm"> * The hardware scan command is very powerful; the driver can set it up to</span>
<span class="cm"> * maintain (relatively) normal network traffic while doing a scan in the</span>
<span class="cm"> * background.  The max_out_time and suspend_time control the ratio of how</span>
<span class="cm"> * long the device stays on an associated network channel (&quot;service channel&quot;)</span>
<span class="cm"> * vs. how long it&#39;s away from the service channel, i.e. tuned to other channels</span>
<span class="cm"> * for scanning.</span>
<span class="cm"> *</span>
<span class="cm"> * max_out_time is the max time off-channel (in usec), and suspend_time</span>
<span class="cm"> * is how long (in &quot;extended beacon&quot; format) that the scan is &quot;suspended&quot;</span>
<span class="cm"> * after returning to the service channel.  That is, suspend_time is the</span>
<span class="cm"> * time that we stay on the service channel, doing normal work, between</span>
<span class="cm"> * scan segments.  The driver may set these parameters differently to support</span>
<span class="cm"> * scanning when associated vs. not associated, and light vs. heavy traffic</span>
<span class="cm"> * loads when associated.</span>
<span class="cm"> *</span>
<span class="cm"> * After receiving this command, the device&#39;s scan engine does the following;</span>
<span class="cm"> *</span>
<span class="cm"> * 1)  Sends SCAN_START notification to driver</span>
<span class="cm"> * 2)  Checks to see if it has time to do scan for one channel</span>
<span class="cm"> * 3)  Sends NULL packet, with power-save (PS) bit set to 1,</span>
<span class="cm"> *     to tell AP that we&#39;re going off-channel</span>
<span class="cm"> * 4)  Tunes to first channel in scan list, does active or passive scan</span>
<span class="cm"> * 5)  Sends SCAN_RESULT notification to driver</span>
<span class="cm"> * 6)  Checks to see if it has time to do scan on *next* channel in list</span>
<span class="cm"> * 7)  Repeats 4-6 until it no longer has time to scan the next channel</span>
<span class="cm"> *     before max_out_time expires</span>
<span class="cm"> * 8)  Returns to service channel</span>
<span class="cm"> * 9)  Sends NULL packet with PS=0 to tell AP that we&#39;re back</span>
<span class="cm"> * 10) Stays on service channel until suspend_time expires</span>
<span class="cm"> * 11) Repeats entire process 2-10 until list is complete</span>
<span class="cm"> * 12) Sends SCAN_COMPLETE notification</span>
<span class="cm"> *</span>
<span class="cm"> * For fast, efficient scans, the scan command also has support for staying on</span>
<span class="cm"> * a channel for just a short time, if doing active scanning and getting no</span>
<span class="cm"> * responses to the transmitted probe request.  This time is controlled by</span>
<span class="cm"> * quiet_time, and the number of received packets below which a channel is</span>
<span class="cm"> * considered &quot;quiet&quot; is controlled by quiet_plcp_threshold.</span>
<span class="cm"> *</span>
<span class="cm"> * For active scanning on channels that have regulatory restrictions against</span>
<span class="cm"> * blindly transmitting, the scan can listen before transmitting, to make sure</span>
<span class="cm"> * that there is already legitimate activity on the channel.  If enough</span>
<span class="cm"> * packets are cleanly received on the channel (controlled by good_CRC_th,</span>
<span class="cm"> * typical value 1), the scan engine starts transmitting probe requests.</span>
<span class="cm"> *</span>
<span class="cm"> * Driver must use separate scan commands for 2.4 vs. 5 GHz bands.</span>
<span class="cm"> *</span>
<span class="cm"> * To avoid uCode errors, see timing restrictions described under</span>
<span class="cm"> * struct iwl_scan_channel.</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">iwl_scan_flags</span> <span class="p">{</span>
	<span class="cm">/* BIT(0) currently unused */</span>
	<span class="n">IWL_SCAN_FLAGS_ACTION_FRAME_TX</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
	<span class="cm">/* bits 2-7 reserved */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">iwl_scan_cmd</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">scan_flags</span><span class="p">;</span>		<span class="cm">/* scan flags: see enum iwl_scan_flags */</span>
	<span class="n">u8</span> <span class="n">channel_count</span><span class="p">;</span>	<span class="cm">/* # channels in channel list */</span>
	<span class="n">__le16</span> <span class="n">quiet_time</span><span class="p">;</span>	<span class="cm">/* dwell only this # millisecs on quiet channel</span>
<span class="cm">				 * (only for active scan) */</span>
	<span class="n">__le16</span> <span class="n">quiet_plcp_th</span><span class="p">;</span>	<span class="cm">/* quiet chnl is &lt; this # pkts (typ. 1) */</span>
	<span class="n">__le16</span> <span class="n">good_CRC_th</span><span class="p">;</span>	<span class="cm">/* passive -&gt; active promotion threshold */</span>
	<span class="n">__le16</span> <span class="n">rx_chain</span><span class="p">;</span>	<span class="cm">/* RXON_RX_CHAIN_* */</span>
	<span class="n">__le32</span> <span class="n">max_out_time</span><span class="p">;</span>	<span class="cm">/* max usec to be away from associated (service)</span>
<span class="cm">				 * channel */</span>
	<span class="n">__le32</span> <span class="n">suspend_time</span><span class="p">;</span>	<span class="cm">/* pause scan this long (in &quot;extended beacon</span>
<span class="cm">				 * format&quot;) when returning to service chnl:</span>
<span class="cm">				 */</span>
	<span class="n">__le32</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* RXON_FLG_* */</span>
	<span class="n">__le32</span> <span class="n">filter_flags</span><span class="p">;</span>	<span class="cm">/* RXON_FILTER_* */</span>

	<span class="cm">/* For active scans (set to all-0s for passive scans).</span>
<span class="cm">	 * Does not include payload.  Must specify Tx rate; no rate scaling. */</span>
	<span class="k">struct</span> <span class="n">iwl_tx_cmd</span> <span class="n">tx_cmd</span><span class="p">;</span>

	<span class="cm">/* For directed active scans (set to all-0s otherwise) */</span>
	<span class="k">struct</span> <span class="n">iwl_ssid_ie</span> <span class="n">direct_scan</span><span class="p">[</span><span class="n">PROBE_OPTION_MAX</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Probe request frame, followed by channel list.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Size of probe request frame is specified by byte count in tx_cmd.</span>
<span class="cm">	 * Channel list follows immediately after probe request frame.</span>
<span class="cm">	 * Number of channels in list is specified by channel_count.</span>
<span class="cm">	 * Each channel in list is of type:</span>
<span class="cm">	 *</span>
<span class="cm">	 * struct iwl_scan_channel channels[0];</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE:  Only one band of channels can be scanned per pass.  You</span>
<span class="cm">	 * must not mix 2.4GHz channels and 5.2GHz channels, and you must wait</span>
<span class="cm">	 * for one scan to complete (i.e. receive SCAN_COMPLETE_NOTIFICATION)</span>
<span class="cm">	 * before requesting another scan.</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* Can abort will notify by complete notification with abort status. */</span>
<span class="cp">#define CAN_ABORT_STATUS	cpu_to_le32(0x1)</span>
<span class="cm">/* complete notification statuses */</span>
<span class="cp">#define ABORT_STATUS            0x2</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_SCAN_CMD = 0x80 (response)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_scanreq_notification</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">status</span><span class="p">;</span>		<span class="cm">/* 1: okay, 2: cannot fulfill request */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * SCAN_START_NOTIFICATION = 0x82 (notification only, not a command)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_scanstart_notification</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">tsf_low</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">tsf_high</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">beacon_timer</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">channel</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">band</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">__le32</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cp">#define  SCAN_OWNER_STATUS 0x1</span>
<span class="cp">#define  MEASURE_OWNER_STATUS 0x2</span>

<span class="cp">#define IWL_PROBE_STATUS_OK		0</span>
<span class="cp">#define IWL_PROBE_STATUS_TX_FAILED	BIT(0)</span>
<span class="cm">/* error statuses combined with TX_FAILED */</span>
<span class="cp">#define IWL_PROBE_STATUS_FAIL_TTL	BIT(1)</span>
<span class="cp">#define IWL_PROBE_STATUS_FAIL_BT	BIT(2)</span>

<span class="cp">#define NUMBER_OF_STATISTICS 1	</span><span class="cm">/* first __le32 is good CRC */</span><span class="cp"></span>
<span class="cm">/*</span>
<span class="cm"> * SCAN_RESULTS_NOTIFICATION = 0x83 (notification only, not a command)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_scanresults_notification</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">channel</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">band</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">probe_status</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">num_probe_not_sent</span><span class="p">;</span> <span class="cm">/* not enough time to send */</span>
	<span class="n">__le32</span> <span class="n">tsf_low</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">tsf_high</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">statistics</span><span class="p">[</span><span class="n">NUMBER_OF_STATISTICS</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * SCAN_COMPLETE_NOTIFICATION = 0x84 (notification only, not a command)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_scancomplete_notification</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">scanned_channels</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bt_status</span><span class="p">;</span>	<span class="cm">/* BT On/Off status */</span>
	<span class="n">u8</span> <span class="n">last_channel</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">tsf_low</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">tsf_high</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>


<span class="cm">/******************************************************************************</span>
<span class="cm"> * (9)</span>
<span class="cm"> * IBSS/AP Commands and Notifications:</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="k">enum</span> <span class="n">iwl_ibss_manager</span> <span class="p">{</span>
	<span class="n">IWL_NOT_IBSS_MANAGER</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IWL_IBSS_MANAGER</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * BEACON_NOTIFICATION = 0x90 (notification only, not a command)</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">iwlagn_beacon_notif</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwlagn_tx_resp</span> <span class="n">beacon_notify_hdr</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">low_tsf</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">high_tsf</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ibss_mgr_status</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_TX_BEACON = 0x91 (command, has simple generic response)</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">iwl_tx_beacon_cmd</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_tx_cmd</span> <span class="n">tx</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">tim_idx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tim_size</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_hdr</span> <span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* beacon frame */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * (10)</span>
<span class="cm"> * Statistics Commands and Notifications:</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cp">#define IWL_TEMP_CONVERT 260</span>

<span class="cp">#define SUP_RATE_11A_MAX_NUM_CHANNELS  8</span>
<span class="cp">#define SUP_RATE_11B_MAX_NUM_CHANNELS  4</span>
<span class="cp">#define SUP_RATE_11G_MAX_NUM_CHANNELS  12</span>

<span class="cm">/* Used for passing to driver number of successes and failures per rate */</span>
<span class="k">struct</span> <span class="n">rate_histogram</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">__le32</span> <span class="n">a</span><span class="p">[</span><span class="n">SUP_RATE_11A_MAX_NUM_CHANNELS</span><span class="p">];</span>
		<span class="n">__le32</span> <span class="n">b</span><span class="p">[</span><span class="n">SUP_RATE_11B_MAX_NUM_CHANNELS</span><span class="p">];</span>
		<span class="n">__le32</span> <span class="n">g</span><span class="p">[</span><span class="n">SUP_RATE_11G_MAX_NUM_CHANNELS</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">success</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">__le32</span> <span class="n">a</span><span class="p">[</span><span class="n">SUP_RATE_11A_MAX_NUM_CHANNELS</span><span class="p">];</span>
		<span class="n">__le32</span> <span class="n">b</span><span class="p">[</span><span class="n">SUP_RATE_11B_MAX_NUM_CHANNELS</span><span class="p">];</span>
		<span class="n">__le32</span> <span class="n">g</span><span class="p">[</span><span class="n">SUP_RATE_11G_MAX_NUM_CHANNELS</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">failed</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* statistics command response */</span>

<span class="k">struct</span> <span class="n">statistics_dbg</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">burst_check</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">burst_count</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">wait_for_silence_timeout_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">statistics_rx_phy</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">ina_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">fina_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">plcp_err</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">crc32_err</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">overrun_err</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">early_overrun_err</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">crc32_good</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">false_alarm_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">fina_sync_err_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">sfd_timeout</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">fina_timeout</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">unresponded_rts</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">rxe_frame_limit_overrun</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">sent_ack_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">sent_cts_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">sent_ba_rsp_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">dsp_self_kill</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">mh_format_err</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">re_acq_main_rssi_sum</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">reserved3</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">statistics_rx_ht_phy</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">plcp_err</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">overrun_err</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">early_overrun_err</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">crc32_good</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">crc32_err</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">mh_format_err</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">agg_crc32_good</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">agg_mpdu_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">agg_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">unsupport_mcs</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cp">#define INTERFERENCE_DATA_AVAILABLE      cpu_to_le32(1)</span>

<span class="k">struct</span> <span class="n">statistics_rx_non_phy</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">bogus_cts</span><span class="p">;</span>	<span class="cm">/* CTS received when not expecting CTS */</span>
	<span class="n">__le32</span> <span class="n">bogus_ack</span><span class="p">;</span>	<span class="cm">/* ACK received when not expecting ACK */</span>
	<span class="n">__le32</span> <span class="n">non_bssid_frames</span><span class="p">;</span>	<span class="cm">/* number of frames with BSSID that</span>
<span class="cm">					 * doesn&#39;t belong to the STA BSSID */</span>
	<span class="n">__le32</span> <span class="n">filtered_frames</span><span class="p">;</span>	<span class="cm">/* count frames that were dumped in the</span>
<span class="cm">				 * filtering process */</span>
	<span class="n">__le32</span> <span class="n">non_channel_beacons</span><span class="p">;</span>	<span class="cm">/* beacons with our bss id but not on</span>
<span class="cm">					 * our serving channel */</span>
	<span class="n">__le32</span> <span class="n">channel_beacons</span><span class="p">;</span>	<span class="cm">/* beacons with our bss id and in our</span>
<span class="cm">				 * serving channel */</span>
	<span class="n">__le32</span> <span class="n">num_missed_bcon</span><span class="p">;</span>	<span class="cm">/* number of missed beacons */</span>
	<span class="n">__le32</span> <span class="n">adc_rx_saturation_time</span><span class="p">;</span>	<span class="cm">/* count in 0.8us units the time the</span>
<span class="cm">					 * ADC was in saturation */</span>
	<span class="n">__le32</span> <span class="n">ina_detection_search_time</span><span class="p">;</span><span class="cm">/* total time (in 0.8us) searched</span>
<span class="cm">					  * for INA */</span>
	<span class="n">__le32</span> <span class="n">beacon_silence_rssi_a</span><span class="p">;</span>	<span class="cm">/* RSSI silence after beacon frame */</span>
	<span class="n">__le32</span> <span class="n">beacon_silence_rssi_b</span><span class="p">;</span>	<span class="cm">/* RSSI silence after beacon frame */</span>
	<span class="n">__le32</span> <span class="n">beacon_silence_rssi_c</span><span class="p">;</span>	<span class="cm">/* RSSI silence after beacon frame */</span>
	<span class="n">__le32</span> <span class="n">interference_data_flag</span><span class="p">;</span>	<span class="cm">/* flag for interference data</span>
<span class="cm">					 * availability. 1 when data is</span>
<span class="cm">					 * available. */</span>
	<span class="n">__le32</span> <span class="n">channel_load</span><span class="p">;</span>		<span class="cm">/* counts RX Enable time in uSec */</span>
	<span class="n">__le32</span> <span class="n">dsp_false_alarms</span><span class="p">;</span>	<span class="cm">/* DSP false alarm (both OFDM</span>
<span class="cm">					 * and CCK) counter */</span>
	<span class="n">__le32</span> <span class="n">beacon_rssi_a</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">beacon_rssi_b</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">beacon_rssi_c</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">beacon_energy_a</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">beacon_energy_b</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">beacon_energy_c</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">statistics_rx_non_phy_bt</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">statistics_rx_non_phy</span> <span class="n">common</span><span class="p">;</span>
	<span class="cm">/* additional stats for bt */</span>
	<span class="n">__le32</span> <span class="n">num_bt_kills</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">statistics_rx</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">statistics_rx_phy</span> <span class="n">ofdm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">statistics_rx_phy</span> <span class="n">cck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">statistics_rx_non_phy</span> <span class="n">general</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">statistics_rx_ht_phy</span> <span class="n">ofdm_ht</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">statistics_rx_bt</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">statistics_rx_phy</span> <span class="n">ofdm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">statistics_rx_phy</span> <span class="n">cck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">statistics_rx_non_phy_bt</span> <span class="n">general</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">statistics_rx_ht_phy</span> <span class="n">ofdm_ht</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct statistics_tx_power - current tx power</span>
<span class="cm"> *</span>
<span class="cm"> * @ant_a: current tx power on chain a in 1/2 dB step</span>
<span class="cm"> * @ant_b: current tx power on chain b in 1/2 dB step</span>
<span class="cm"> * @ant_c: current tx power on chain c in 1/2 dB step</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">statistics_tx_power</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">ant_a</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ant_b</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ant_c</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">statistics_tx_non_phy_agg</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">ba_timeout</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ba_reschedule_frames</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">scd_query_agg_frame_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">scd_query_no_agg</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">scd_query_agg</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">scd_query_mismatch</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">frame_not_ready</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">underrun</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">bt_prio_kill</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">rx_ba_rsp_cnt</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">statistics_tx</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">preamble_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">rx_detected_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">bt_prio_defer_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">bt_prio_kill_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">few_bytes_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">cts_timeout</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ack_timeout</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">expected_ack_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">actual_ack_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">dump_msdu_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">burst_abort_next_frame_mismatch_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">burst_abort_missing_next_frame_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">cts_timeout_collision</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ack_or_ba_timeout_collision</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">statistics_tx_non_phy_agg</span> <span class="n">agg</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * &quot;tx_power&quot; are optional parameters provided by uCode,</span>
<span class="cm">	 * 6000 series is the only device provide the information,</span>
<span class="cm">	 * Those are reserved fields for all the other devices</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">statistics_tx_power</span> <span class="n">tx_power</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">reserved1</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>


<span class="k">struct</span> <span class="n">statistics_div</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">tx_on_a</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">tx_on_b</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">exec_time</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">probe_time</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">reserved1</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">reserved2</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">statistics_general_common</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">temperature</span><span class="p">;</span>   <span class="cm">/* radio temperature */</span>
	<span class="n">__le32</span> <span class="n">temperature_m</span><span class="p">;</span> <span class="cm">/* radio voltage */</span>
	<span class="k">struct</span> <span class="n">statistics_dbg</span> <span class="n">dbg</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">sleep_time</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">slots_out</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">slots_idle</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ttl_timestamp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">statistics_div</span> <span class="n">div</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">rx_enable_counter</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * num_of_sos_states:</span>
<span class="cm">	 *  count the number of times we have to re-tune</span>
<span class="cm">	 *  in order to get out of bad PHY status</span>
<span class="cm">	 */</span>
	<span class="n">__le32</span> <span class="n">num_of_sos_states</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">statistics_bt_activity</span> <span class="p">{</span>
	<span class="cm">/* Tx statistics */</span>
	<span class="n">__le32</span> <span class="n">hi_priority_tx_req_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">hi_priority_tx_denied_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">lo_priority_tx_req_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">lo_priority_tx_denied_cnt</span><span class="p">;</span>
	<span class="cm">/* Rx statistics */</span>
	<span class="n">__le32</span> <span class="n">hi_priority_rx_req_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">hi_priority_rx_denied_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">lo_priority_rx_req_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">lo_priority_rx_denied_cnt</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">statistics_general</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">statistics_general_common</span> <span class="n">common</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">reserved2</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">reserved3</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">statistics_general_bt</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">statistics_general_common</span> <span class="n">common</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">statistics_bt_activity</span> <span class="n">activity</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">reserved2</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">reserved3</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cp">#define UCODE_STATISTICS_CLEAR_MSK		(0x1 &lt;&lt; 0)</span>
<span class="cp">#define UCODE_STATISTICS_FREQUENCY_MSK		(0x1 &lt;&lt; 1)</span>
<span class="cp">#define UCODE_STATISTICS_NARROW_BAND_MSK	(0x1 &lt;&lt; 2)</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_STATISTICS_CMD = 0x9c,</span>
<span class="cm"> * all devices identical.</span>
<span class="cm"> *</span>
<span class="cm"> * This command triggers an immediate response containing uCode statistics.</span>
<span class="cm"> * The response is in the same format as STATISTICS_NOTIFICATION 0x9d, below.</span>
<span class="cm"> *</span>
<span class="cm"> * If the CLEAR_STATS configuration flag is set, uCode will clear its</span>
<span class="cm"> * internal copy of the statistics (counters) after issuing the response.</span>
<span class="cm"> * This flag does not affect STATISTICS_NOTIFICATIONs after beacons (see below).</span>
<span class="cm"> *</span>
<span class="cm"> * If the DISABLE_NOTIF configuration flag is set, uCode will not issue</span>
<span class="cm"> * STATISTICS_NOTIFICATIONs after received beacons (see below).  This flag</span>
<span class="cm"> * does not affect the response to the REPLY_STATISTICS_CMD 0x9c itself.</span>
<span class="cm"> */</span>
<span class="cp">#define IWL_STATS_CONF_CLEAR_STATS cpu_to_le32(0x1)	</span><span class="cm">/* see above */</span><span class="cp"></span>
<span class="cp">#define IWL_STATS_CONF_DISABLE_NOTIF cpu_to_le32(0x2)</span><span class="cm">/* see above */</span><span class="cp"></span>
<span class="k">struct</span> <span class="n">iwl_statistics_cmd</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">configuration_flags</span><span class="p">;</span>	<span class="cm">/* IWL_STATS_CONF_* */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * STATISTICS_NOTIFICATION = 0x9d (notification only, not a command)</span>
<span class="cm"> *</span>
<span class="cm"> * By default, uCode issues this notification after receiving a beacon</span>
<span class="cm"> * while associated.  To disable this behavior, set DISABLE_NOTIF flag in the</span>
<span class="cm"> * REPLY_STATISTICS_CMD 0x9c, above.</span>
<span class="cm"> *</span>
<span class="cm"> * Statistics counters continue to increment beacon after beacon, but are</span>
<span class="cm"> * cleared when changing channels or when driver issues REPLY_STATISTICS_CMD</span>
<span class="cm"> * 0x9c with CLEAR_STATS bit set (see above).</span>
<span class="cm"> *</span>
<span class="cm"> * uCode also issues this notification during scans.  uCode clears statistics</span>
<span class="cm"> * appropriately so that each notification contains statistics for only the</span>
<span class="cm"> * one channel that has just been scanned.</span>
<span class="cm"> */</span>
<span class="cp">#define STATISTICS_REPLY_FLG_BAND_24G_MSK         cpu_to_le32(0x2)</span>
<span class="cp">#define STATISTICS_REPLY_FLG_HT40_MODE_MSK        cpu_to_le32(0x8)</span>

<span class="k">struct</span> <span class="n">iwl_notif_statistics</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">flag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">statistics_rx</span> <span class="n">rx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">statistics_tx</span> <span class="n">tx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">statistics_general</span> <span class="n">general</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">iwl_bt_notif_statistics</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">flag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">statistics_rx_bt</span> <span class="n">rx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">statistics_tx</span> <span class="n">tx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">statistics_general_bt</span> <span class="n">general</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * MISSED_BEACONS_NOTIFICATION = 0xa2 (notification only, not a command)</span>
<span class="cm"> *</span>
<span class="cm"> * uCode send MISSED_BEACONS_NOTIFICATION to driver when detect beacon missed</span>
<span class="cm"> * in regardless of how many missed beacons, which mean when driver receive the</span>
<span class="cm"> * notification, inside the command, it can find all the beacons information</span>
<span class="cm"> * which include number of total missed beacons, number of consecutive missed</span>
<span class="cm"> * beacons, number of beacons received and number of beacons expected to</span>
<span class="cm"> * receive.</span>
<span class="cm"> *</span>
<span class="cm"> * If uCode detected consecutive_missed_beacons &gt; 5, it will reset the radio</span>
<span class="cm"> * in order to bring the radio/PHY back to working state; which has no relation</span>
<span class="cm"> * to when driver will perform sensitivity calibration.</span>
<span class="cm"> *</span>
<span class="cm"> * Driver should set it own missed_beacon_threshold to decide when to perform</span>
<span class="cm"> * sensitivity calibration based on number of consecutive missed beacons in</span>
<span class="cm"> * order to improve overall performance, especially in noisy environment.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#define IWL_MISSED_BEACON_THRESHOLD_MIN	(1)</span>
<span class="cp">#define IWL_MISSED_BEACON_THRESHOLD_DEF	(5)</span>
<span class="cp">#define IWL_MISSED_BEACON_THRESHOLD_MAX	IWL_MISSED_BEACON_THRESHOLD_DEF</span>

<span class="k">struct</span> <span class="n">iwl_missed_beacon_notif</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">consecutive_missed_beacons</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">total_missed_becons</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">num_expected_beacons</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">num_recvd_beacons</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>


<span class="cm">/******************************************************************************</span>
<span class="cm"> * (11)</span>
<span class="cm"> * Rx Calibration Commands:</span>
<span class="cm"> *</span>
<span class="cm"> * With the uCode used for open source drivers, most Tx calibration (except</span>
<span class="cm"> * for Tx Power) and most Rx calibration is done by uCode during the</span>
<span class="cm"> * &quot;initialize&quot; phase of uCode boot.  Driver must calibrate only:</span>
<span class="cm"> *</span>
<span class="cm"> * 1)  Tx power (depends on temperature), described elsewhere</span>
<span class="cm"> * 2)  Receiver gain balance (optimize MIMO, and detect disconnected antennas)</span>
<span class="cm"> * 3)  Receiver sensitivity (to optimize signal detection)</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cm">/**</span>
<span class="cm"> * SENSITIVITY_CMD = 0xa8 (command, has simple generic response)</span>
<span class="cm"> *</span>
<span class="cm"> * This command sets up the Rx signal detector for a sensitivity level that</span>
<span class="cm"> * is high enough to lock onto all signals within the associated network,</span>
<span class="cm"> * but low enough to ignore signals that are below a certain threshold, so as</span>
<span class="cm"> * not to have too many &quot;false alarms&quot;.  False alarms are signals that the</span>
<span class="cm"> * Rx DSP tries to lock onto, but then discards after determining that they</span>
<span class="cm"> * are noise.</span>
<span class="cm"> *</span>
<span class="cm"> * The optimum number of false alarms is between 5 and 50 per 200 TUs</span>
<span class="cm"> * (200 * 1024 uSecs, i.e. 204.8 milliseconds) of actual Rx time (i.e.</span>
<span class="cm"> * time listening, not transmitting).  Driver must adjust sensitivity so that</span>
<span class="cm"> * the ratio of actual false alarms to actual Rx time falls within this range.</span>
<span class="cm"> *</span>
<span class="cm"> * While associated, uCode delivers STATISTICS_NOTIFICATIONs after each</span>
<span class="cm"> * received beacon.  These provide information to the driver to analyze the</span>
<span class="cm"> * sensitivity.  Don&#39;t analyze statistics that come in from scanning, or any</span>
<span class="cm"> * other non-associated-network source.  Pertinent statistics include:</span>
<span class="cm"> *</span>
<span class="cm"> * From &quot;general&quot; statistics (struct statistics_rx_non_phy):</span>
<span class="cm"> *</span>
<span class="cm"> * (beacon_energy_[abc] &amp; 0x0FF00) &gt;&gt; 8 (unsigned, higher value is lower level)</span>
<span class="cm"> *   Measure of energy of desired signal.  Used for establishing a level</span>
<span class="cm"> *   below which the device does not detect signals.</span>
<span class="cm"> *</span>
<span class="cm"> * (beacon_silence_rssi_[abc] &amp; 0x0FF00) &gt;&gt; 8 (unsigned, units in dB)</span>
<span class="cm"> *   Measure of background noise in silent period after beacon.</span>
<span class="cm"> *</span>
<span class="cm"> * channel_load</span>
<span class="cm"> *   uSecs of actual Rx time during beacon period (varies according to</span>
<span class="cm"> *   how much time was spent transmitting).</span>
<span class="cm"> *</span>
<span class="cm"> * From &quot;cck&quot; and &quot;ofdm&quot; statistics (struct statistics_rx_phy), separately:</span>
<span class="cm"> *</span>
<span class="cm"> * false_alarm_cnt</span>
<span class="cm"> *   Signal locks abandoned early (before phy-level header).</span>
<span class="cm"> *</span>
<span class="cm"> * plcp_err</span>
<span class="cm"> *   Signal locks abandoned late (during phy-level header).</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  Both false_alarm_cnt and plcp_err increment monotonically from</span>
<span class="cm"> *        beacon to beacon, i.e. each value is an accumulation of all errors</span>
<span class="cm"> *        before and including the latest beacon.  Values will wrap around to 0</span>
<span class="cm"> *        after counting up to 2^32 - 1.  Driver must differentiate vs.</span>
<span class="cm"> *        previous beacon&#39;s values to determine # false alarms in the current</span>
<span class="cm"> *        beacon period.</span>
<span class="cm"> *</span>
<span class="cm"> * Total number of false alarms = false_alarms + plcp_errs</span>
<span class="cm"> *</span>
<span class="cm"> * For OFDM, adjust the following table entries in struct iwl_sensitivity_cmd</span>
<span class="cm"> * (notice that the start points for OFDM are at or close to settings for</span>
<span class="cm"> * maximum sensitivity):</span>
<span class="cm"> *</span>
<span class="cm"> *                                             START  /  MIN  /  MAX</span>
<span class="cm"> *   HD_AUTO_CORR32_X1_TH_ADD_MIN_INDEX          90   /   85  /  120</span>
<span class="cm"> *   HD_AUTO_CORR32_X1_TH_ADD_MIN_MRC_INDEX     170   /  170  /  210</span>
<span class="cm"> *   HD_AUTO_CORR32_X4_TH_ADD_MIN_INDEX         105   /  105  /  140</span>
<span class="cm"> *   HD_AUTO_CORR32_X4_TH_ADD_MIN_MRC_INDEX     220   /  220  /  270</span>
<span class="cm"> *</span>
<span class="cm"> *   If actual rate of OFDM false alarms (+ plcp_errors) is too high</span>
<span class="cm"> *   (greater than 50 for each 204.8 msecs listening), reduce sensitivity</span>
<span class="cm"> *   by *adding* 1 to all 4 of the table entries above, up to the max for</span>
<span class="cm"> *   each entry.  Conversely, if false alarm rate is too low (less than 5</span>
<span class="cm"> *   for each 204.8 msecs listening), *subtract* 1 from each entry to</span>
<span class="cm"> *   increase sensitivity.</span>
<span class="cm"> *</span>
<span class="cm"> * For CCK sensitivity, keep track of the following:</span>
<span class="cm"> *</span>
<span class="cm"> *   1).  20-beacon history of maximum background noise, indicated by</span>
<span class="cm"> *        (beacon_silence_rssi_[abc] &amp; 0x0FF00), units in dB, across the</span>
<span class="cm"> *        3 receivers.  For any given beacon, the &quot;silence reference&quot; is</span>
<span class="cm"> *        the maximum of last 60 samples (20 beacons * 3 receivers).</span>
<span class="cm"> *</span>
<span class="cm"> *   2).  10-beacon history of strongest signal level, as indicated</span>
<span class="cm"> *        by (beacon_energy_[abc] &amp; 0x0FF00) &gt;&gt; 8, across the 3 receivers,</span>
<span class="cm"> *        i.e. the strength of the signal through the best receiver at the</span>
<span class="cm"> *        moment.  These measurements are &quot;upside down&quot;, with lower values</span>
<span class="cm"> *        for stronger signals, so max energy will be *minimum* value.</span>
<span class="cm"> *</span>
<span class="cm"> *        Then for any given beacon, the driver must determine the *weakest*</span>
<span class="cm"> *        of the strongest signals; this is the minimum level that needs to be</span>
<span class="cm"> *        successfully detected, when using the best receiver at the moment.</span>
<span class="cm"> *        &quot;Max cck energy&quot; is the maximum (higher value means lower energy!)</span>
<span class="cm"> *        of the last 10 minima.  Once this is determined, driver must add</span>
<span class="cm"> *        a little margin by adding &quot;6&quot; to it.</span>
<span class="cm"> *</span>
<span class="cm"> *   3).  Number of consecutive beacon periods with too few false alarms.</span>
<span class="cm"> *        Reset this to 0 at the first beacon period that falls within the</span>
<span class="cm"> *        &quot;good&quot; range (5 to 50 false alarms per 204.8 milliseconds rx).</span>
<span class="cm"> *</span>
<span class="cm"> * Then, adjust the following CCK table entries in struct iwl_sensitivity_cmd</span>
<span class="cm"> * (notice that the start points for CCK are at maximum sensitivity):</span>
<span class="cm"> *</span>
<span class="cm"> *                                             START  /  MIN  /  MAX</span>
<span class="cm"> *   HD_AUTO_CORR40_X4_TH_ADD_MIN_INDEX         125   /  125  /  200</span>
<span class="cm"> *   HD_AUTO_CORR40_X4_TH_ADD_MIN_MRC_INDEX     200   /  200  /  400</span>
<span class="cm"> *   HD_MIN_ENERGY_CCK_DET_INDEX                100   /    0  /  100</span>
<span class="cm"> *</span>
<span class="cm"> *   If actual rate of CCK false alarms (+ plcp_errors) is too high</span>
<span class="cm"> *   (greater than 50 for each 204.8 msecs listening), method for reducing</span>
<span class="cm"> *   sensitivity is:</span>
<span class="cm"> *</span>
<span class="cm"> *   1)  *Add* 3 to value in HD_AUTO_CORR40_X4_TH_ADD_MIN_MRC_INDEX,</span>
<span class="cm"> *       up to max 400.</span>
<span class="cm"> *</span>
<span class="cm"> *   2)  If current value in HD_AUTO_CORR40_X4_TH_ADD_MIN_INDEX is &lt; 160,</span>
<span class="cm"> *       sensitivity has been reduced a significant amount; bring it up to</span>
<span class="cm"> *       a moderate 161.  Otherwise, *add* 3, up to max 200.</span>
<span class="cm"> *</span>
<span class="cm"> *   3)  a)  If current value in HD_AUTO_CORR40_X4_TH_ADD_MIN_INDEX is &gt; 160,</span>
<span class="cm"> *       sensitivity has been reduced only a moderate or small amount;</span>
<span class="cm"> *       *subtract* 2 from value in HD_MIN_ENERGY_CCK_DET_INDEX,</span>
<span class="cm"> *       down to min 0.  Otherwise (if gain has been significantly reduced),</span>
<span class="cm"> *       don&#39;t change the HD_MIN_ENERGY_CCK_DET_INDEX value.</span>
<span class="cm"> *</span>
<span class="cm"> *       b)  Save a snapshot of the &quot;silence reference&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> *   If actual rate of CCK false alarms (+ plcp_errors) is too low</span>
<span class="cm"> *   (less than 5 for each 204.8 msecs listening), method for increasing</span>
<span class="cm"> *   sensitivity is used only if:</span>
<span class="cm"> *</span>
<span class="cm"> *   1a)  Previous beacon did not have too many false alarms</span>
<span class="cm"> *   1b)  AND difference between previous &quot;silence reference&quot; and current</span>
<span class="cm"> *        &quot;silence reference&quot; (prev - current) is 2 or more,</span>
<span class="cm"> *   OR 2)  100 or more consecutive beacon periods have had rate of</span>
<span class="cm"> *          less than 5 false alarms per 204.8 milliseconds rx time.</span>
<span class="cm"> *</span>
<span class="cm"> *   Method for increasing sensitivity:</span>
<span class="cm"> *</span>
<span class="cm"> *   1)  *Subtract* 3 from value in HD_AUTO_CORR40_X4_TH_ADD_MIN_INDEX,</span>
<span class="cm"> *       down to min 125.</span>
<span class="cm"> *</span>
<span class="cm"> *   2)  *Subtract* 3 from value in HD_AUTO_CORR40_X4_TH_ADD_MIN_MRC_INDEX,</span>
<span class="cm"> *       down to min 200.</span>
<span class="cm"> *</span>
<span class="cm"> *   3)  *Add* 2 to value in HD_MIN_ENERGY_CCK_DET_INDEX, up to max 100.</span>
<span class="cm"> *</span>
<span class="cm"> *   If actual rate of CCK false alarms (+ plcp_errors) is within good range</span>
<span class="cm"> *   (between 5 and 50 for each 204.8 msecs listening):</span>
<span class="cm"> *</span>
<span class="cm"> *   1)  Save a snapshot of the silence reference.</span>
<span class="cm"> *</span>
<span class="cm"> *   2)  If previous beacon had too many CCK false alarms (+ plcp_errors),</span>
<span class="cm"> *       give some extra margin to energy threshold by *subtracting* 8</span>
<span class="cm"> *       from value in HD_MIN_ENERGY_CCK_DET_INDEX.</span>
<span class="cm"> *</span>
<span class="cm"> *   For all cases (too few, too many, good range), make sure that the CCK</span>
<span class="cm"> *   detection threshold (energy) is below the energy level for robust</span>
<span class="cm"> *   detection over the past 10 beacon periods, the &quot;Max cck energy&quot;.</span>
<span class="cm"> *   Lower values mean higher energy; this means making sure that the value</span>
<span class="cm"> *   in HD_MIN_ENERGY_CCK_DET_INDEX is at or *above* &quot;Max cck energy&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Table entries in SENSITIVITY_CMD (struct iwl_sensitivity_cmd)</span>
<span class="cm"> */</span>
<span class="cp">#define HD_TABLE_SIZE  (11)	</span><span class="cm">/* number of entries */</span><span class="cp"></span>
<span class="cp">#define HD_MIN_ENERGY_CCK_DET_INDEX                 (0)	</span><span class="cm">/* table indexes */</span><span class="cp"></span>
<span class="cp">#define HD_MIN_ENERGY_OFDM_DET_INDEX                (1)</span>
<span class="cp">#define HD_AUTO_CORR32_X1_TH_ADD_MIN_INDEX          (2)</span>
<span class="cp">#define HD_AUTO_CORR32_X1_TH_ADD_MIN_MRC_INDEX      (3)</span>
<span class="cp">#define HD_AUTO_CORR40_X4_TH_ADD_MIN_MRC_INDEX      (4)</span>
<span class="cp">#define HD_AUTO_CORR32_X4_TH_ADD_MIN_INDEX          (5)</span>
<span class="cp">#define HD_AUTO_CORR32_X4_TH_ADD_MIN_MRC_INDEX      (6)</span>
<span class="cp">#define HD_BARKER_CORR_TH_ADD_MIN_INDEX             (7)</span>
<span class="cp">#define HD_BARKER_CORR_TH_ADD_MIN_MRC_INDEX         (8)</span>
<span class="cp">#define HD_AUTO_CORR40_X4_TH_ADD_MIN_INDEX          (9)</span>
<span class="cp">#define HD_OFDM_ENERGY_TH_IN_INDEX                  (10)</span>

<span class="cm">/*</span>
<span class="cm"> * Additional table entries in enhance SENSITIVITY_CMD</span>
<span class="cm"> */</span>
<span class="cp">#define HD_INA_NON_SQUARE_DET_OFDM_INDEX		(11)</span>
<span class="cp">#define HD_INA_NON_SQUARE_DET_CCK_INDEX			(12)</span>
<span class="cp">#define HD_CORR_11_INSTEAD_OF_CORR_9_EN_INDEX		(13)</span>
<span class="cp">#define HD_OFDM_NON_SQUARE_DET_SLOPE_MRC_INDEX		(14)</span>
<span class="cp">#define HD_OFDM_NON_SQUARE_DET_INTERCEPT_MRC_INDEX	(15)</span>
<span class="cp">#define HD_OFDM_NON_SQUARE_DET_SLOPE_INDEX		(16)</span>
<span class="cp">#define HD_OFDM_NON_SQUARE_DET_INTERCEPT_INDEX		(17)</span>
<span class="cp">#define HD_CCK_NON_SQUARE_DET_SLOPE_MRC_INDEX		(18)</span>
<span class="cp">#define HD_CCK_NON_SQUARE_DET_INTERCEPT_MRC_INDEX	(19)</span>
<span class="cp">#define HD_CCK_NON_SQUARE_DET_SLOPE_INDEX		(20)</span>
<span class="cp">#define HD_CCK_NON_SQUARE_DET_INTERCEPT_INDEX		(21)</span>
<span class="cp">#define HD_RESERVED					(22)</span>

<span class="cm">/* number of entries for enhanced tbl */</span>
<span class="cp">#define ENHANCE_HD_TABLE_SIZE  (23)</span>

<span class="cm">/* number of additional entries for enhanced tbl */</span>
<span class="cp">#define ENHANCE_HD_TABLE_ENTRIES  (ENHANCE_HD_TABLE_SIZE - HD_TABLE_SIZE)</span>

<span class="cp">#define HD_INA_NON_SQUARE_DET_OFDM_DATA_V1		cpu_to_le16(0)</span>
<span class="cp">#define HD_INA_NON_SQUARE_DET_CCK_DATA_V1		cpu_to_le16(0)</span>
<span class="cp">#define HD_CORR_11_INSTEAD_OF_CORR_9_EN_DATA_V1		cpu_to_le16(0)</span>
<span class="cp">#define HD_OFDM_NON_SQUARE_DET_SLOPE_MRC_DATA_V1	cpu_to_le16(668)</span>
<span class="cp">#define HD_OFDM_NON_SQUARE_DET_INTERCEPT_MRC_DATA_V1	cpu_to_le16(4)</span>
<span class="cp">#define HD_OFDM_NON_SQUARE_DET_SLOPE_DATA_V1		cpu_to_le16(486)</span>
<span class="cp">#define HD_OFDM_NON_SQUARE_DET_INTERCEPT_DATA_V1	cpu_to_le16(37)</span>
<span class="cp">#define HD_CCK_NON_SQUARE_DET_SLOPE_MRC_DATA_V1		cpu_to_le16(853)</span>
<span class="cp">#define HD_CCK_NON_SQUARE_DET_INTERCEPT_MRC_DATA_V1	cpu_to_le16(4)</span>
<span class="cp">#define HD_CCK_NON_SQUARE_DET_SLOPE_DATA_V1		cpu_to_le16(476)</span>
<span class="cp">#define HD_CCK_NON_SQUARE_DET_INTERCEPT_DATA_V1		cpu_to_le16(99)</span>

<span class="cp">#define HD_INA_NON_SQUARE_DET_OFDM_DATA_V2		cpu_to_le16(1)</span>
<span class="cp">#define HD_INA_NON_SQUARE_DET_CCK_DATA_V2		cpu_to_le16(1)</span>
<span class="cp">#define HD_CORR_11_INSTEAD_OF_CORR_9_EN_DATA_V2		cpu_to_le16(1)</span>
<span class="cp">#define HD_OFDM_NON_SQUARE_DET_SLOPE_MRC_DATA_V2	cpu_to_le16(600)</span>
<span class="cp">#define HD_OFDM_NON_SQUARE_DET_INTERCEPT_MRC_DATA_V2	cpu_to_le16(40)</span>
<span class="cp">#define HD_OFDM_NON_SQUARE_DET_SLOPE_DATA_V2		cpu_to_le16(486)</span>
<span class="cp">#define HD_OFDM_NON_SQUARE_DET_INTERCEPT_DATA_V2	cpu_to_le16(45)</span>
<span class="cp">#define HD_CCK_NON_SQUARE_DET_SLOPE_MRC_DATA_V2		cpu_to_le16(853)</span>
<span class="cp">#define HD_CCK_NON_SQUARE_DET_INTERCEPT_MRC_DATA_V2	cpu_to_le16(60)</span>
<span class="cp">#define HD_CCK_NON_SQUARE_DET_SLOPE_DATA_V2		cpu_to_le16(476)</span>
<span class="cp">#define HD_CCK_NON_SQUARE_DET_INTERCEPT_DATA_V2		cpu_to_le16(99)</span>


<span class="cm">/* Control field in struct iwl_sensitivity_cmd */</span>
<span class="cp">#define SENSITIVITY_CMD_CONTROL_DEFAULT_TABLE	cpu_to_le16(0)</span>
<span class="cp">#define SENSITIVITY_CMD_CONTROL_WORK_TABLE	cpu_to_le16(1)</span>

<span class="cm">/**</span>
<span class="cm"> * struct iwl_sensitivity_cmd</span>
<span class="cm"> * @control:  (1) updates working table, (0) updates default table</span>
<span class="cm"> * @table:  energy threshold values, use HD_* as index into table</span>
<span class="cm"> *</span>
<span class="cm"> * Always use &quot;1&quot; in &quot;control&quot; to update uCode&#39;s working table and DSP.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_sensitivity_cmd</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">control</span><span class="p">;</span>			<span class="cm">/* always use &quot;1&quot; */</span>
	<span class="n">__le16</span> <span class="n">table</span><span class="p">[</span><span class="n">HD_TABLE_SIZE</span><span class="p">];</span>	<span class="cm">/* use HD_* as index */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_enhance_sensitivity_cmd</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">control</span><span class="p">;</span>			<span class="cm">/* always use &quot;1&quot; */</span>
	<span class="n">__le16</span> <span class="n">enhance_table</span><span class="p">[</span><span class="n">ENHANCE_HD_TABLE_SIZE</span><span class="p">];</span>	<span class="cm">/* use HD_* as index */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * REPLY_PHY_CALIBRATION_CMD = 0xb0 (command, has simple generic response)</span>
<span class="cm"> *</span>
<span class="cm"> * This command sets the relative gains of agn device&#39;s 3 radio receiver chains.</span>
<span class="cm"> *</span>
<span class="cm"> * After the first association, driver should accumulate signal and noise</span>
<span class="cm"> * statistics from the STATISTICS_NOTIFICATIONs that follow the first 20</span>
<span class="cm"> * beacons from the associated network (don&#39;t collect statistics that come</span>
<span class="cm"> * in from scanning, or any other non-network source).</span>
<span class="cm"> *</span>
<span class="cm"> * DISCONNECTED ANTENNA:</span>
<span class="cm"> *</span>
<span class="cm"> * Driver should determine which antennas are actually connected, by comparing</span>
<span class="cm"> * average beacon signal levels for the 3 Rx chains.  Accumulate (add) the</span>
<span class="cm"> * following values over 20 beacons, one accumulator for each of the chains</span>
<span class="cm"> * a/b/c, from struct statistics_rx_non_phy:</span>
<span class="cm"> *</span>
<span class="cm"> * beacon_rssi_[abc] &amp; 0x0FF (unsigned, units in dB)</span>
<span class="cm"> *</span>
<span class="cm"> * Find the strongest signal from among a/b/c.  Compare the other two to the</span>
<span class="cm"> * strongest.  If any signal is more than 15 dB (times 20, unless you</span>
<span class="cm"> * divide the accumulated values by 20) below the strongest, the driver</span>
<span class="cm"> * considers that antenna to be disconnected, and should not try to use that</span>
<span class="cm"> * antenna/chain for Rx or Tx.  If both A and B seem to be disconnected,</span>
<span class="cm"> * driver should declare the stronger one as connected, and attempt to use it</span>
<span class="cm"> * (A and B are the only 2 Tx chains!).</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * RX BALANCE:</span>
<span class="cm"> *</span>
<span class="cm"> * Driver should balance the 3 receivers (but just the ones that are connected</span>
<span class="cm"> * to antennas, see above) for gain, by comparing the average signal levels</span>
<span class="cm"> * detected during the silence after each beacon (background noise).</span>
<span class="cm"> * Accumulate (add) the following values over 20 beacons, one accumulator for</span>
<span class="cm"> * each of the chains a/b/c, from struct statistics_rx_non_phy:</span>
<span class="cm"> *</span>
<span class="cm"> * beacon_silence_rssi_[abc] &amp; 0x0FF (unsigned, units in dB)</span>
<span class="cm"> *</span>
<span class="cm"> * Find the weakest background noise level from among a/b/c.  This Rx chain</span>
<span class="cm"> * will be the reference, with 0 gain adjustment.  Attenuate other channels by</span>
<span class="cm"> * finding noise difference:</span>
<span class="cm"> *</span>
<span class="cm"> * (accum_noise[i] - accum_noise[reference]) / 30</span>
<span class="cm"> *</span>
<span class="cm"> * The &quot;30&quot; adjusts the dB in the 20 accumulated samples to units of 1.5 dB.</span>
<span class="cm"> * For use in diff_gain_[abc] fields of struct iwl_calibration_cmd, the</span>
<span class="cm"> * driver should limit the difference results to a range of 0-3 (0-4.5 dB),</span>
<span class="cm"> * and set bit 2 to indicate &quot;reduce gain&quot;.  The value for the reference</span>
<span class="cm"> * (weakest) chain should be &quot;0&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * diff_gain_[abc] bit fields:</span>
<span class="cm"> *   2: (1) reduce gain, (0) increase gain</span>
<span class="cm"> * 1-0: amount of gain, units of 1.5 dB</span>
<span class="cm"> */</span>

<span class="cm">/* Phy calibration command for series */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IWL_PHY_CALIBRATE_DC_CMD</span>		<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">IWL_PHY_CALIBRATE_LO_CMD</span>		<span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
	<span class="n">IWL_PHY_CALIBRATE_TX_IQ_CMD</span>		<span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
	<span class="n">IWL_PHY_CALIBRATE_CRYSTAL_FRQ_CMD</span>	<span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
	<span class="n">IWL_PHY_CALIBRATE_BASE_BAND_CMD</span>		<span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
	<span class="n">IWL_PHY_CALIBRATE_TX_IQ_PERD_CMD</span>	<span class="o">=</span> <span class="mi">17</span><span class="p">,</span>
	<span class="n">IWL_PHY_CALIBRATE_TEMP_OFFSET_CMD</span>	<span class="o">=</span> <span class="mi">18</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* This enum defines the bitmap of various calibrations to enable in both</span>
<span class="cm"> * init ucode and runtime ucode through CALIBRATION_CFG_CMD.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">iwl_ucode_calib_cfg</span> <span class="p">{</span>
	<span class="n">IWL_CALIB_CFG_RX_BB_IDX</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="n">IWL_CALIB_CFG_DC_IDX</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
	<span class="n">IWL_CALIB_CFG_LO_IDX</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
	<span class="n">IWL_CALIB_CFG_TX_IQ_IDX</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
	<span class="n">IWL_CALIB_CFG_RX_IQ_IDX</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
	<span class="n">IWL_CALIB_CFG_NOISE_IDX</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
	<span class="n">IWL_CALIB_CFG_CRYSTAL_IDX</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>
	<span class="n">IWL_CALIB_CFG_TEMPERATURE_IDX</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span>
	<span class="n">IWL_CALIB_CFG_PAPD_IDX</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span>
	<span class="n">IWL_CALIB_CFG_SENSITIVITY_IDX</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">9</span><span class="p">),</span>
	<span class="n">IWL_CALIB_CFG_TX_PWR_IDX</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
<span class="p">};</span>

<span class="cp">#define IWL_CALIB_INIT_CFG_ALL	cpu_to_le32(IWL_CALIB_CFG_RX_BB_IDX |	\</span>
<span class="cp">					IWL_CALIB_CFG_DC_IDX |		\</span>
<span class="cp">					IWL_CALIB_CFG_LO_IDX |		\</span>
<span class="cp">					IWL_CALIB_CFG_TX_IQ_IDX |	\</span>
<span class="cp">					IWL_CALIB_CFG_RX_IQ_IDX |	\</span>
<span class="cp">					IWL_CALIB_CFG_CRYSTAL_IDX)</span>

<span class="cp">#define IWL_CALIB_RT_CFG_ALL	cpu_to_le32(IWL_CALIB_CFG_RX_BB_IDX |	\</span>
<span class="cp">					IWL_CALIB_CFG_DC_IDX |		\</span>
<span class="cp">					IWL_CALIB_CFG_LO_IDX |		\</span>
<span class="cp">					IWL_CALIB_CFG_TX_IQ_IDX |	\</span>
<span class="cp">					IWL_CALIB_CFG_RX_IQ_IDX |	\</span>
<span class="cp">					IWL_CALIB_CFG_TEMPERATURE_IDX |	\</span>
<span class="cp">					IWL_CALIB_CFG_PAPD_IDX |	\</span>
<span class="cp">					IWL_CALIB_CFG_TX_PWR_IDX |	\</span>
<span class="cp">					IWL_CALIB_CFG_CRYSTAL_IDX)</span>

<span class="cp">#define IWL_CALIB_CFG_FLAG_SEND_COMPLETE_NTFY_MSK	cpu_to_le32(BIT(0))</span>

<span class="k">struct</span> <span class="n">iwl_calib_cfg_elmnt_s</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">is_enable</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">send_res</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">apply_res</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">iwl_calib_cfg_status_s</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_calib_cfg_elmnt_s</span> <span class="n">once</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_calib_cfg_elmnt_s</span> <span class="n">perd</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">iwl_calib_cfg_cmd</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_calib_cfg_status_s</span> <span class="n">ucd_calib_cfg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_calib_cfg_status_s</span> <span class="n">drv_calib_cfg</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">reserved1</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">iwl_calib_hdr</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">op_code</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">first_group</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">groups_num</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">data_valid</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">iwl_calib_cmd</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_calib_hdr</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">iwl_calib_xtal_freq_cmd</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_calib_hdr</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cap_pin1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cap_pin2</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pad</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cp">#define DEFAULT_RADIO_SENSOR_OFFSET    cpu_to_le16(2700)</span>
<span class="k">struct</span> <span class="n">iwl_calib_temperature_offset_cmd</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_calib_hdr</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">radio_sensor_offset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">iwl_calib_temperature_offset_v2_cmd</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_calib_hdr</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">radio_sensor_offset_high</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">radio_sensor_offset_low</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">burntVoltageRef</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* IWL_PHY_CALIBRATE_CHAIN_NOISE_RESET_CMD */</span>
<span class="k">struct</span> <span class="n">iwl_calib_chain_noise_reset_cmd</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_calib_hdr</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* IWL_PHY_CALIBRATE_CHAIN_NOISE_GAIN_CMD */</span>
<span class="k">struct</span> <span class="n">iwl_calib_chain_noise_gain_cmd</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_calib_hdr</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">delta_gain_1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">delta_gain_2</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pad</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * (12)</span>
<span class="cm"> * Miscellaneous Commands:</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * LEDs Command &amp; Response</span>
<span class="cm"> * REPLY_LEDS_CMD = 0x48 (command, has simple generic response)</span>
<span class="cm"> *</span>
<span class="cm"> * For each of 3 possible LEDs (Activity/Link/Tech, selected by &quot;id&quot; field),</span>
<span class="cm"> * this command turns it on or off, or sets up a periodic blinking cycle.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_led_cmd</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">interval</span><span class="p">;</span>	<span class="cm">/* &quot;interval&quot; in uSec */</span>
	<span class="n">u8</span> <span class="n">id</span><span class="p">;</span>			<span class="cm">/* 1: Activity, 2: Link, 3: Tech */</span>
	<span class="n">u8</span> <span class="n">off</span><span class="p">;</span>			<span class="cm">/* # intervals off while blinking;</span>
<span class="cm">				 * &quot;0&quot;, with &gt;0 &quot;on&quot; value, turns LED on */</span>
	<span class="n">u8</span> <span class="n">on</span><span class="p">;</span>			<span class="cm">/* # intervals on while blinking;</span>
<span class="cm">				 * &quot;0&quot;, regardless of &quot;off&quot;, turns LED off */</span>
	<span class="n">u8</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * station priority table entries</span>
<span class="cm"> * also used as potential &quot;events&quot; value for both</span>
<span class="cm"> * COEX_MEDIUM_NOTIFICATION and COEX_EVENT_CMD</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * COEX events entry flag masks</span>
<span class="cm"> * RP - Requested Priority</span>
<span class="cm"> * WP - Win Medium Priority: priority assigned when the contention has been won</span>
<span class="cm"> */</span>
<span class="cp">#define COEX_EVT_FLAG_MEDIUM_FREE_NTFY_FLG        (0x1)</span>
<span class="cp">#define COEX_EVT_FLAG_MEDIUM_ACTV_NTFY_FLG        (0x2)</span>
<span class="cp">#define COEX_EVT_FLAG_DELAY_MEDIUM_FREE_NTFY_FLG  (0x4)</span>

<span class="cp">#define COEX_CU_UNASSOC_IDLE_RP               4</span>
<span class="cp">#define COEX_CU_UNASSOC_MANUAL_SCAN_RP        4</span>
<span class="cp">#define COEX_CU_UNASSOC_AUTO_SCAN_RP          4</span>
<span class="cp">#define COEX_CU_CALIBRATION_RP                4</span>
<span class="cp">#define COEX_CU_PERIODIC_CALIBRATION_RP       4</span>
<span class="cp">#define COEX_CU_CONNECTION_ESTAB_RP           4</span>
<span class="cp">#define COEX_CU_ASSOCIATED_IDLE_RP            4</span>
<span class="cp">#define COEX_CU_ASSOC_MANUAL_SCAN_RP          4</span>
<span class="cp">#define COEX_CU_ASSOC_AUTO_SCAN_RP            4</span>
<span class="cp">#define COEX_CU_ASSOC_ACTIVE_LEVEL_RP         4</span>
<span class="cp">#define COEX_CU_RF_ON_RP                      6</span>
<span class="cp">#define COEX_CU_RF_OFF_RP                     4</span>
<span class="cp">#define COEX_CU_STAND_ALONE_DEBUG_RP          6</span>
<span class="cp">#define COEX_CU_IPAN_ASSOC_LEVEL_RP           4</span>
<span class="cp">#define COEX_CU_RSRVD1_RP                     4</span>
<span class="cp">#define COEX_CU_RSRVD2_RP                     4</span>

<span class="cp">#define COEX_CU_UNASSOC_IDLE_WP               3</span>
<span class="cp">#define COEX_CU_UNASSOC_MANUAL_SCAN_WP        3</span>
<span class="cp">#define COEX_CU_UNASSOC_AUTO_SCAN_WP          3</span>
<span class="cp">#define COEX_CU_CALIBRATION_WP                3</span>
<span class="cp">#define COEX_CU_PERIODIC_CALIBRATION_WP       3</span>
<span class="cp">#define COEX_CU_CONNECTION_ESTAB_WP           3</span>
<span class="cp">#define COEX_CU_ASSOCIATED_IDLE_WP            3</span>
<span class="cp">#define COEX_CU_ASSOC_MANUAL_SCAN_WP          3</span>
<span class="cp">#define COEX_CU_ASSOC_AUTO_SCAN_WP            3</span>
<span class="cp">#define COEX_CU_ASSOC_ACTIVE_LEVEL_WP         3</span>
<span class="cp">#define COEX_CU_RF_ON_WP                      3</span>
<span class="cp">#define COEX_CU_RF_OFF_WP                     3</span>
<span class="cp">#define COEX_CU_STAND_ALONE_DEBUG_WP          6</span>
<span class="cp">#define COEX_CU_IPAN_ASSOC_LEVEL_WP           3</span>
<span class="cp">#define COEX_CU_RSRVD1_WP                     3</span>
<span class="cp">#define COEX_CU_RSRVD2_WP                     3</span>

<span class="cp">#define COEX_UNASSOC_IDLE_FLAGS                     0</span>
<span class="cp">#define COEX_UNASSOC_MANUAL_SCAN_FLAGS		\</span>
<span class="cp">	(COEX_EVT_FLAG_MEDIUM_FREE_NTFY_FLG |	\</span>
<span class="cp">	COEX_EVT_FLAG_MEDIUM_ACTV_NTFY_FLG)</span>
<span class="cp">#define COEX_UNASSOC_AUTO_SCAN_FLAGS		\</span>
<span class="cp">	(COEX_EVT_FLAG_MEDIUM_FREE_NTFY_FLG |	\</span>
<span class="cp">	COEX_EVT_FLAG_MEDIUM_ACTV_NTFY_FLG)</span>
<span class="cp">#define COEX_CALIBRATION_FLAGS			\</span>
<span class="cp">	(COEX_EVT_FLAG_MEDIUM_FREE_NTFY_FLG |	\</span>
<span class="cp">	COEX_EVT_FLAG_MEDIUM_ACTV_NTFY_FLG)</span>
<span class="cp">#define COEX_PERIODIC_CALIBRATION_FLAGS             0</span>
<span class="cm">/*</span>
<span class="cm"> * COEX_CONNECTION_ESTAB:</span>
<span class="cm"> * we need DELAY_MEDIUM_FREE_NTFY to let WiMAX disconnect from network.</span>
<span class="cm"> */</span>
<span class="cp">#define COEX_CONNECTION_ESTAB_FLAGS		\</span>
<span class="cp">	(COEX_EVT_FLAG_MEDIUM_FREE_NTFY_FLG |	\</span>
<span class="cp">	COEX_EVT_FLAG_MEDIUM_ACTV_NTFY_FLG |	\</span>
<span class="cp">	COEX_EVT_FLAG_DELAY_MEDIUM_FREE_NTFY_FLG)</span>
<span class="cp">#define COEX_ASSOCIATED_IDLE_FLAGS                  0</span>
<span class="cp">#define COEX_ASSOC_MANUAL_SCAN_FLAGS		\</span>
<span class="cp">	(COEX_EVT_FLAG_MEDIUM_FREE_NTFY_FLG |	\</span>
<span class="cp">	COEX_EVT_FLAG_MEDIUM_ACTV_NTFY_FLG)</span>
<span class="cp">#define COEX_ASSOC_AUTO_SCAN_FLAGS		\</span>
<span class="cp">	(COEX_EVT_FLAG_MEDIUM_FREE_NTFY_FLG |	\</span>
<span class="cp">	 COEX_EVT_FLAG_MEDIUM_ACTV_NTFY_FLG)</span>
<span class="cp">#define COEX_ASSOC_ACTIVE_LEVEL_FLAGS               0</span>
<span class="cp">#define COEX_RF_ON_FLAGS                            0</span>
<span class="cp">#define COEX_RF_OFF_FLAGS                           0</span>
<span class="cp">#define COEX_STAND_ALONE_DEBUG_FLAGS		\</span>
<span class="cp">	(COEX_EVT_FLAG_MEDIUM_FREE_NTFY_FLG |	\</span>
<span class="cp">	 COEX_EVT_FLAG_MEDIUM_ACTV_NTFY_FLG)</span>
<span class="cp">#define COEX_IPAN_ASSOC_LEVEL_FLAGS		\</span>
<span class="cp">	(COEX_EVT_FLAG_MEDIUM_FREE_NTFY_FLG |	\</span>
<span class="cp">	 COEX_EVT_FLAG_MEDIUM_ACTV_NTFY_FLG |	\</span>
<span class="cp">	 COEX_EVT_FLAG_DELAY_MEDIUM_FREE_NTFY_FLG)</span>
<span class="cp">#define COEX_RSRVD1_FLAGS                           0</span>
<span class="cp">#define COEX_RSRVD2_FLAGS                           0</span>
<span class="cm">/*</span>
<span class="cm"> * COEX_CU_RF_ON is the event wrapping all radio ownership.</span>
<span class="cm"> * We need DELAY_MEDIUM_FREE_NTFY to let WiMAX disconnect from network.</span>
<span class="cm"> */</span>
<span class="cp">#define COEX_CU_RF_ON_FLAGS			\</span>
<span class="cp">	(COEX_EVT_FLAG_MEDIUM_FREE_NTFY_FLG |	\</span>
<span class="cp">	 COEX_EVT_FLAG_MEDIUM_ACTV_NTFY_FLG |	\</span>
<span class="cp">	 COEX_EVT_FLAG_DELAY_MEDIUM_FREE_NTFY_FLG)</span>


<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* un-association part */</span>
	<span class="n">COEX_UNASSOC_IDLE</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">COEX_UNASSOC_MANUAL_SCAN</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">COEX_UNASSOC_AUTO_SCAN</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="cm">/* calibration */</span>
	<span class="n">COEX_CALIBRATION</span>		<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">COEX_PERIODIC_CALIBRATION</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="cm">/* connection */</span>
	<span class="n">COEX_CONNECTION_ESTAB</span>		<span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="cm">/* association part */</span>
	<span class="n">COEX_ASSOCIATED_IDLE</span>		<span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">COEX_ASSOC_MANUAL_SCAN</span>		<span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
	<span class="n">COEX_ASSOC_AUTO_SCAN</span>		<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">COEX_ASSOC_ACTIVE_LEVEL</span>		<span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
	<span class="cm">/* RF ON/OFF */</span>
	<span class="n">COEX_RF_ON</span>			<span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
	<span class="n">COEX_RF_OFF</span>			<span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
	<span class="n">COEX_STAND_ALONE_DEBUG</span>		<span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
	<span class="cm">/* IPAN */</span>
	<span class="n">COEX_IPAN_ASSOC_LEVEL</span>		<span class="o">=</span> <span class="mi">13</span><span class="p">,</span>
	<span class="cm">/* reserved */</span>
	<span class="n">COEX_RSRVD1</span>			<span class="o">=</span> <span class="mi">14</span><span class="p">,</span>
	<span class="n">COEX_RSRVD2</span>			<span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
	<span class="n">COEX_NUM_OF_EVENTS</span>		<span class="o">=</span> <span class="mi">16</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Coexistence WIFI/WIMAX  Command</span>
<span class="cm"> * COEX_PRIORITY_TABLE_CMD = 0x5a</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_wimax_coex_event_entry</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">request_prio</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">win_medium_prio</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* COEX flag masks */</span>

<span class="cm">/* Station table is valid */</span>
<span class="cp">#define COEX_FLAGS_STA_TABLE_VALID_MSK      (0x1)</span>
<span class="cm">/* UnMask wake up src at unassociated sleep */</span>
<span class="cp">#define COEX_FLAGS_UNASSOC_WA_UNMASK_MSK    (0x4)</span>
<span class="cm">/* UnMask wake up src at associated sleep */</span>
<span class="cp">#define COEX_FLAGS_ASSOC_WA_UNMASK_MSK      (0x8)</span>
<span class="cm">/* Enable CoEx feature. */</span>
<span class="cp">#define COEX_FLAGS_COEX_ENABLE_MSK          (0x80)</span>

<span class="k">struct</span> <span class="n">iwl_wimax_coex_cmd</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">iwl_wimax_coex_event_entry</span> <span class="n">sta_prio</span><span class="p">[</span><span class="n">COEX_NUM_OF_EVENTS</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Coexistence MEDIUM NOTIFICATION</span>
<span class="cm"> * COEX_MEDIUM_NOTIFICATION = 0x5b</span>
<span class="cm"> *</span>
<span class="cm"> * notification from uCode to host to indicate medium changes</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * status field</span>
<span class="cm"> * bit 0 - 2: medium status</span>
<span class="cm"> * bit 3: medium change indication</span>
<span class="cm"> * bit 4 - 31: reserved</span>
<span class="cm"> */</span>
<span class="cm">/* status option values, (0 - 2 bits) */</span>
<span class="cp">#define COEX_MEDIUM_BUSY	(0x0) </span><span class="cm">/* radio belongs to WiMAX */</span><span class="cp"></span>
<span class="cp">#define COEX_MEDIUM_ACTIVE	(0x1) </span><span class="cm">/* radio belongs to WiFi */</span><span class="cp"></span>
<span class="cp">#define COEX_MEDIUM_PRE_RELEASE	(0x2) </span><span class="cm">/* received radio release */</span><span class="cp"></span>
<span class="cp">#define COEX_MEDIUM_MSK		(0x7)</span>

<span class="cm">/* send notification status (1 bit) */</span>
<span class="cp">#define COEX_MEDIUM_CHANGED	(0x8)</span>
<span class="cp">#define COEX_MEDIUM_CHANGED_MSK	(0x8)</span>
<span class="cp">#define COEX_MEDIUM_SHIFT	(3)</span>

<span class="k">struct</span> <span class="n">iwl_coex_medium_notification</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">events</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Coexistence EVENT  Command</span>
<span class="cm"> * COEX_EVENT_CMD = 0x5c</span>
<span class="cm"> *</span>
<span class="cm"> * send from host to uCode for coex event request.</span>
<span class="cm"> */</span>
<span class="cm">/* flags options */</span>
<span class="cp">#define COEX_EVENT_REQUEST_MSK	(0x1)</span>

<span class="k">struct</span> <span class="n">iwl_coex_event_cmd</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">event</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">iwl_coex_event_resp</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>


<span class="cm">/******************************************************************************</span>
<span class="cm"> * Bluetooth Coexistence commands</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * BT Status notification</span>
<span class="cm"> * REPLY_BT_COEX_PROFILE_NOTIF = 0xce</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">iwl_bt_coex_profile_traffic_load</span> <span class="p">{</span>
	<span class="n">IWL_BT_COEX_TRAFFIC_LOAD_NONE</span> <span class="o">=</span> 	<span class="mi">0</span><span class="p">,</span>
	<span class="n">IWL_BT_COEX_TRAFFIC_LOAD_LOW</span> <span class="o">=</span>		<span class="mi">1</span><span class="p">,</span>
	<span class="n">IWL_BT_COEX_TRAFFIC_LOAD_HIGH</span> <span class="o">=</span> 	<span class="mi">2</span><span class="p">,</span>
	<span class="n">IWL_BT_COEX_TRAFFIC_LOAD_CONTINUOUS</span> <span class="o">=</span>	<span class="mi">3</span><span class="p">,</span>
<span class="cm">/*</span>
<span class="cm"> * There are no more even though below is a u8, the</span>
<span class="cm"> * indication from the BT device only has two bits.</span>
<span class="cm"> */</span>
<span class="p">};</span>

<span class="cp">#define BT_SESSION_ACTIVITY_1_UART_MSG		0x1</span>
<span class="cp">#define BT_SESSION_ACTIVITY_2_UART_MSG		0x2</span>

<span class="cm">/* BT UART message - Share Part (BT -&gt; WiFi) */</span>
<span class="cp">#define BT_UART_MSG_FRAME1MSGTYPE_POS		(0)</span>
<span class="cp">#define BT_UART_MSG_FRAME1MSGTYPE_MSK		\</span>
<span class="cp">		(0x7 &lt;&lt; BT_UART_MSG_FRAME1MSGTYPE_POS)</span>
<span class="cp">#define BT_UART_MSG_FRAME1SSN_POS		(3)</span>
<span class="cp">#define BT_UART_MSG_FRAME1SSN_MSK		\</span>
<span class="cp">		(0x3 &lt;&lt; BT_UART_MSG_FRAME1SSN_POS)</span>
<span class="cp">#define BT_UART_MSG_FRAME1UPDATEREQ_POS		(5)</span>
<span class="cp">#define BT_UART_MSG_FRAME1UPDATEREQ_MSK		\</span>
<span class="cp">		(0x1 &lt;&lt; BT_UART_MSG_FRAME1UPDATEREQ_POS)</span>
<span class="cp">#define BT_UART_MSG_FRAME1RESERVED_POS		(6)</span>
<span class="cp">#define BT_UART_MSG_FRAME1RESERVED_MSK		\</span>
<span class="cp">		(0x3 &lt;&lt; BT_UART_MSG_FRAME1RESERVED_POS)</span>

<span class="cp">#define BT_UART_MSG_FRAME2OPENCONNECTIONS_POS	(0)</span>
<span class="cp">#define BT_UART_MSG_FRAME2OPENCONNECTIONS_MSK	\</span>
<span class="cp">		(0x3 &lt;&lt; BT_UART_MSG_FRAME2OPENCONNECTIONS_POS)</span>
<span class="cp">#define BT_UART_MSG_FRAME2TRAFFICLOAD_POS	(2)</span>
<span class="cp">#define BT_UART_MSG_FRAME2TRAFFICLOAD_MSK	\</span>
<span class="cp">		(0x3 &lt;&lt; BT_UART_MSG_FRAME2TRAFFICLOAD_POS)</span>
<span class="cp">#define BT_UART_MSG_FRAME2CHLSEQN_POS		(4)</span>
<span class="cp">#define BT_UART_MSG_FRAME2CHLSEQN_MSK		\</span>
<span class="cp">		(0x1 &lt;&lt; BT_UART_MSG_FRAME2CHLSEQN_POS)</span>
<span class="cp">#define BT_UART_MSG_FRAME2INBAND_POS		(5)</span>
<span class="cp">#define BT_UART_MSG_FRAME2INBAND_MSK		\</span>
<span class="cp">		(0x1 &lt;&lt; BT_UART_MSG_FRAME2INBAND_POS)</span>
<span class="cp">#define BT_UART_MSG_FRAME2RESERVED_POS		(6)</span>
<span class="cp">#define BT_UART_MSG_FRAME2RESERVED_MSK		\</span>
<span class="cp">		(0x3 &lt;&lt; BT_UART_MSG_FRAME2RESERVED_POS)</span>

<span class="cp">#define BT_UART_MSG_FRAME3SCOESCO_POS		(0)</span>
<span class="cp">#define BT_UART_MSG_FRAME3SCOESCO_MSK		\</span>
<span class="cp">		(0x1 &lt;&lt; BT_UART_MSG_FRAME3SCOESCO_POS)</span>
<span class="cp">#define BT_UART_MSG_FRAME3SNIFF_POS		(1)</span>
<span class="cp">#define BT_UART_MSG_FRAME3SNIFF_MSK		\</span>
<span class="cp">		(0x1 &lt;&lt; BT_UART_MSG_FRAME3SNIFF_POS)</span>
<span class="cp">#define BT_UART_MSG_FRAME3A2DP_POS		(2)</span>
<span class="cp">#define BT_UART_MSG_FRAME3A2DP_MSK		\</span>
<span class="cp">		(0x1 &lt;&lt; BT_UART_MSG_FRAME3A2DP_POS)</span>
<span class="cp">#define BT_UART_MSG_FRAME3ACL_POS		(3)</span>
<span class="cp">#define BT_UART_MSG_FRAME3ACL_MSK		\</span>
<span class="cp">		(0x1 &lt;&lt; BT_UART_MSG_FRAME3ACL_POS)</span>
<span class="cp">#define BT_UART_MSG_FRAME3MASTER_POS		(4)</span>
<span class="cp">#define BT_UART_MSG_FRAME3MASTER_MSK		\</span>
<span class="cp">		(0x1 &lt;&lt; BT_UART_MSG_FRAME3MASTER_POS)</span>
<span class="cp">#define BT_UART_MSG_FRAME3OBEX_POS		(5)</span>
<span class="cp">#define BT_UART_MSG_FRAME3OBEX_MSK		\</span>
<span class="cp">		(0x1 &lt;&lt; BT_UART_MSG_FRAME3OBEX_POS)</span>
<span class="cp">#define BT_UART_MSG_FRAME3RESERVED_POS		(6)</span>
<span class="cp">#define BT_UART_MSG_FRAME3RESERVED_MSK		\</span>
<span class="cp">		(0x3 &lt;&lt; BT_UART_MSG_FRAME3RESERVED_POS)</span>

<span class="cp">#define BT_UART_MSG_FRAME4IDLEDURATION_POS	(0)</span>
<span class="cp">#define BT_UART_MSG_FRAME4IDLEDURATION_MSK	\</span>
<span class="cp">		(0x3F &lt;&lt; BT_UART_MSG_FRAME4IDLEDURATION_POS)</span>
<span class="cp">#define BT_UART_MSG_FRAME4RESERVED_POS		(6)</span>
<span class="cp">#define BT_UART_MSG_FRAME4RESERVED_MSK		\</span>
<span class="cp">		(0x3 &lt;&lt; BT_UART_MSG_FRAME4RESERVED_POS)</span>

<span class="cp">#define BT_UART_MSG_FRAME5TXACTIVITY_POS	(0)</span>
<span class="cp">#define BT_UART_MSG_FRAME5TXACTIVITY_MSK	\</span>
<span class="cp">		(0x3 &lt;&lt; BT_UART_MSG_FRAME5TXACTIVITY_POS)</span>
<span class="cp">#define BT_UART_MSG_FRAME5RXACTIVITY_POS	(2)</span>
<span class="cp">#define BT_UART_MSG_FRAME5RXACTIVITY_MSK	\</span>
<span class="cp">		(0x3 &lt;&lt; BT_UART_MSG_FRAME5RXACTIVITY_POS)</span>
<span class="cp">#define BT_UART_MSG_FRAME5ESCORETRANSMIT_POS	(4)</span>
<span class="cp">#define BT_UART_MSG_FRAME5ESCORETRANSMIT_MSK	\</span>
<span class="cp">		(0x3 &lt;&lt; BT_UART_MSG_FRAME5ESCORETRANSMIT_POS)</span>
<span class="cp">#define BT_UART_MSG_FRAME5RESERVED_POS		(6)</span>
<span class="cp">#define BT_UART_MSG_FRAME5RESERVED_MSK		\</span>
<span class="cp">		(0x3 &lt;&lt; BT_UART_MSG_FRAME5RESERVED_POS)</span>

<span class="cp">#define BT_UART_MSG_FRAME6SNIFFINTERVAL_POS	(0)</span>
<span class="cp">#define BT_UART_MSG_FRAME6SNIFFINTERVAL_MSK	\</span>
<span class="cp">		(0x1F &lt;&lt; BT_UART_MSG_FRAME6SNIFFINTERVAL_POS)</span>
<span class="cp">#define BT_UART_MSG_FRAME6DISCOVERABLE_POS	(5)</span>
<span class="cp">#define BT_UART_MSG_FRAME6DISCOVERABLE_MSK	\</span>
<span class="cp">		(0x1 &lt;&lt; BT_UART_MSG_FRAME6DISCOVERABLE_POS)</span>
<span class="cp">#define BT_UART_MSG_FRAME6RESERVED_POS		(6)</span>
<span class="cp">#define BT_UART_MSG_FRAME6RESERVED_MSK		\</span>
<span class="cp">		(0x3 &lt;&lt; BT_UART_MSG_FRAME6RESERVED_POS)</span>

<span class="cp">#define BT_UART_MSG_FRAME7SNIFFACTIVITY_POS	(0)</span>
<span class="cp">#define BT_UART_MSG_FRAME7SNIFFACTIVITY_MSK	\</span>
<span class="cp">		(0x7 &lt;&lt; BT_UART_MSG_FRAME7SNIFFACTIVITY_POS)</span>
<span class="cp">#define BT_UART_MSG_FRAME7PAGE_POS		(3)</span>
<span class="cp">#define BT_UART_MSG_FRAME7PAGE_MSK		\</span>
<span class="cp">		(0x1 &lt;&lt; BT_UART_MSG_FRAME7PAGE_POS)</span>
<span class="cp">#define BT_UART_MSG_FRAME7INQUIRY_POS		(4)</span>
<span class="cp">#define BT_UART_MSG_FRAME7INQUIRY_MSK		\</span>
<span class="cp">		(0x1 &lt;&lt; BT_UART_MSG_FRAME7INQUIRY_POS)</span>
<span class="cp">#define BT_UART_MSG_FRAME7CONNECTABLE_POS	(5)</span>
<span class="cp">#define BT_UART_MSG_FRAME7CONNECTABLE_MSK	\</span>
<span class="cp">		(0x1 &lt;&lt; BT_UART_MSG_FRAME7CONNECTABLE_POS)</span>
<span class="cp">#define BT_UART_MSG_FRAME7RESERVED_POS		(6)</span>
<span class="cp">#define BT_UART_MSG_FRAME7RESERVED_MSK		\</span>
<span class="cp">		(0x3 &lt;&lt; BT_UART_MSG_FRAME7RESERVED_POS)</span>

<span class="cm">/* BT Session Activity 2 UART message (BT -&gt; WiFi) */</span>
<span class="cp">#define BT_UART_MSG_2_FRAME1RESERVED1_POS	(5)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME1RESERVED1_MSK	\</span>
<span class="cp">		(0x1&lt;&lt;BT_UART_MSG_2_FRAME1RESERVED1_POS)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME1RESERVED2_POS	(6)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME1RESERVED2_MSK	\</span>
<span class="cp">		(0x3&lt;&lt;BT_UART_MSG_2_FRAME1RESERVED2_POS)</span>

<span class="cp">#define BT_UART_MSG_2_FRAME2AGGTRAFFICLOAD_POS	(0)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME2AGGTRAFFICLOAD_MSK	\</span>
<span class="cp">		(0x3F&lt;&lt;BT_UART_MSG_2_FRAME2AGGTRAFFICLOAD_POS)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME2RESERVED_POS	(6)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME2RESERVED_MSK	\</span>
<span class="cp">		(0x3&lt;&lt;BT_UART_MSG_2_FRAME2RESERVED_POS)</span>

<span class="cp">#define BT_UART_MSG_2_FRAME3BRLASTTXPOWER_POS	(0)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME3BRLASTTXPOWER_MSK	\</span>
<span class="cp">		(0xF&lt;&lt;BT_UART_MSG_2_FRAME3BRLASTTXPOWER_POS)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME3INQPAGESRMODE_POS	(4)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME3INQPAGESRMODE_MSK	\</span>
<span class="cp">		(0x1&lt;&lt;BT_UART_MSG_2_FRAME3INQPAGESRMODE_POS)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME3LEMASTER_POS	(5)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME3LEMASTER_MSK	\</span>
<span class="cp">		(0x1&lt;&lt;BT_UART_MSG_2_FRAME3LEMASTER_POS)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME3RESERVED_POS	(6)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME3RESERVED_MSK	\</span>
<span class="cp">		(0x3&lt;&lt;BT_UART_MSG_2_FRAME3RESERVED_POS)</span>

<span class="cp">#define BT_UART_MSG_2_FRAME4LELASTTXPOWER_POS	(0)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME4LELASTTXPOWER_MSK	\</span>
<span class="cp">		(0xF&lt;&lt;BT_UART_MSG_2_FRAME4LELASTTXPOWER_POS)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME4NUMLECONN_POS	(4)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME4NUMLECONN_MSK	\</span>
<span class="cp">		(0x3&lt;&lt;BT_UART_MSG_2_FRAME4NUMLECONN_POS)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME4RESERVED_POS	(6)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME4RESERVED_MSK	\</span>
<span class="cp">		(0x3&lt;&lt;BT_UART_MSG_2_FRAME4RESERVED_POS)</span>

<span class="cp">#define BT_UART_MSG_2_FRAME5BTMINRSSI_POS	(0)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME5BTMINRSSI_MSK	\</span>
<span class="cp">		(0xF&lt;&lt;BT_UART_MSG_2_FRAME5BTMINRSSI_POS)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME5LESCANINITMODE_POS	(4)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME5LESCANINITMODE_MSK	\</span>
<span class="cp">		(0x1&lt;&lt;BT_UART_MSG_2_FRAME5LESCANINITMODE_POS)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME5LEADVERMODE_POS	(5)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME5LEADVERMODE_MSK	\</span>
<span class="cp">		(0x1&lt;&lt;BT_UART_MSG_2_FRAME5LEADVERMODE_POS)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME5RESERVED_POS	(6)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME5RESERVED_MSK	\</span>
<span class="cp">		(0x3&lt;&lt;BT_UART_MSG_2_FRAME5RESERVED_POS)</span>

<span class="cp">#define BT_UART_MSG_2_FRAME6LECONNINTERVAL_POS	(0)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME6LECONNINTERVAL_MSK	\</span>
<span class="cp">		(0x1F&lt;&lt;BT_UART_MSG_2_FRAME6LECONNINTERVAL_POS)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME6RFU_POS		(5)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME6RFU_MSK		\</span>
<span class="cp">		(0x1&lt;&lt;BT_UART_MSG_2_FRAME6RFU_POS)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME6RESERVED_POS	(6)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME6RESERVED_MSK	\</span>
<span class="cp">		(0x3&lt;&lt;BT_UART_MSG_2_FRAME6RESERVED_POS)</span>

<span class="cp">#define BT_UART_MSG_2_FRAME7LECONNSLAVELAT_POS	(0)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME7LECONNSLAVELAT_MSK	\</span>
<span class="cp">		(0x7&lt;&lt;BT_UART_MSG_2_FRAME7LECONNSLAVELAT_POS)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME7LEPROFILE1_POS	(3)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME7LEPROFILE1_MSK	\</span>
<span class="cp">		(0x1&lt;&lt;BT_UART_MSG_2_FRAME7LEPROFILE1_POS)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME7LEPROFILE2_POS	(4)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME7LEPROFILE2_MSK	\</span>
<span class="cp">		(0x1&lt;&lt;BT_UART_MSG_2_FRAME7LEPROFILE2_POS)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME7LEPROFILEOTHER_POS	(5)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME7LEPROFILEOTHER_MSK	\</span>
<span class="cp">		(0x1&lt;&lt;BT_UART_MSG_2_FRAME7LEPROFILEOTHER_POS)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME7RESERVED_POS	(6)</span>
<span class="cp">#define BT_UART_MSG_2_FRAME7RESERVED_MSK	\</span>
<span class="cp">		(0x3&lt;&lt;BT_UART_MSG_2_FRAME7RESERVED_POS)</span>


<span class="cp">#define BT_ENABLE_REDUCED_TXPOWER_THRESHOLD	(-62)</span>
<span class="cp">#define BT_DISABLE_REDUCED_TXPOWER_THRESHOLD	(-65)</span>

<span class="k">struct</span> <span class="n">iwl_bt_uart_msg</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">header</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">frame1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">frame2</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">frame3</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">frame4</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">frame5</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">frame6</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">frame7</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">iwl_bt_coex_profile_notif</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_bt_uart_msg</span> <span class="n">last_bt_uart_msg</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bt_status</span><span class="p">;</span> <span class="cm">/* 0 - off, 1 - on */</span>
	<span class="n">u8</span> <span class="n">bt_traffic_load</span><span class="p">;</span> <span class="cm">/* 0 .. 3? */</span>
	<span class="n">u8</span> <span class="n">bt_ci_compliance</span><span class="p">;</span> <span class="cm">/* 0 - not complied, 1 - complied */</span>
	<span class="n">u8</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cp">#define IWL_BT_COEX_PRIO_TBL_SHARED_ANTENNA_POS	0</span>
<span class="cp">#define IWL_BT_COEX_PRIO_TBL_SHARED_ANTENNA_MSK	0x1</span>
<span class="cp">#define IWL_BT_COEX_PRIO_TBL_PRIO_POS		1</span>
<span class="cp">#define IWL_BT_COEX_PRIO_TBL_PRIO_MASK		0x0e</span>
<span class="cp">#define IWL_BT_COEX_PRIO_TBL_RESERVED_POS	4</span>
<span class="cp">#define IWL_BT_COEX_PRIO_TBL_RESERVED_MASK	0xf0</span>
<span class="cp">#define IWL_BT_COEX_PRIO_TBL_PRIO_SHIFT		1</span>

<span class="cm">/*</span>
<span class="cm"> * BT Coexistence Priority table</span>
<span class="cm"> * REPLY_BT_COEX_PRIO_TABLE = 0xcc</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">bt_coex_prio_table_events</span> <span class="p">{</span>
	<span class="n">BT_COEX_PRIO_TBL_EVT_INIT_CALIB1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">BT_COEX_PRIO_TBL_EVT_INIT_CALIB2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">BT_COEX_PRIO_TBL_EVT_PERIODIC_CALIB_LOW1</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">BT_COEX_PRIO_TBL_EVT_PERIODIC_CALIB_LOW2</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="cm">/* DC calib */</span>
	<span class="n">BT_COEX_PRIO_TBL_EVT_PERIODIC_CALIB_HIGH1</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">BT_COEX_PRIO_TBL_EVT_PERIODIC_CALIB_HIGH2</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">BT_COEX_PRIO_TBL_EVT_DTIM</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">BT_COEX_PRIO_TBL_EVT_SCAN52</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
	<span class="n">BT_COEX_PRIO_TBL_EVT_SCAN24</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">BT_COEX_PRIO_TBL_EVT_RESERVED0</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
	<span class="n">BT_COEX_PRIO_TBL_EVT_RESERVED1</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
	<span class="n">BT_COEX_PRIO_TBL_EVT_RESERVED2</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
	<span class="n">BT_COEX_PRIO_TBL_EVT_RESERVED3</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
	<span class="n">BT_COEX_PRIO_TBL_EVT_RESERVED4</span> <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>
	<span class="n">BT_COEX_PRIO_TBL_EVT_RESERVED5</span> <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>
	<span class="n">BT_COEX_PRIO_TBL_EVT_RESERVED6</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
	<span class="cm">/* BT_COEX_PRIO_TBL_EVT_MAX should always be last */</span>
	<span class="n">BT_COEX_PRIO_TBL_EVT_MAX</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">bt_coex_prio_table_priorities</span> <span class="p">{</span>
	<span class="n">BT_COEX_PRIO_TBL_DISABLED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">BT_COEX_PRIO_TBL_PRIO_LOW</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">BT_COEX_PRIO_TBL_PRIO_HIGH</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">BT_COEX_PRIO_TBL_PRIO_BYPASS</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">BT_COEX_PRIO_TBL_PRIO_COEX_OFF</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">BT_COEX_PRIO_TBL_PRIO_COEX_ON</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">BT_COEX_PRIO_TBL_PRIO_RSRVD1</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">BT_COEX_PRIO_TBL_PRIO_RSRVD2</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
	<span class="n">BT_COEX_PRIO_TBL_MAX</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">iwl_bt_coex_prio_table_cmd</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">prio_tbl</span><span class="p">[</span><span class="n">BT_COEX_PRIO_TBL_EVT_MAX</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cp">#define IWL_BT_COEX_ENV_CLOSE	0</span>
<span class="cp">#define IWL_BT_COEX_ENV_OPEN	1</span>
<span class="cm">/*</span>
<span class="cm"> * BT Protection Envelope</span>
<span class="cm"> * REPLY_BT_COEX_PROT_ENV = 0xcd</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_bt_coex_prot_env_cmd</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">action</span><span class="p">;</span> <span class="cm">/* 0 = closed, 1 = open */</span>
	<span class="n">u8</span> <span class="n">type</span><span class="p">;</span> <span class="cm">/* 0 .. 15 */</span>
	<span class="n">u8</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_D3_CONFIG</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">iwlagn_d3_wakeup_filters</span> <span class="p">{</span>
	<span class="n">IWLAGN_D3_WAKEUP_RFKILL</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="n">IWLAGN_D3_WAKEUP_SYSASSERT</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">iwlagn_d3_config_cmd</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">min_sleep_time</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">wakeup_flags</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_WOWLAN_PATTERNS</span>
<span class="cm"> */</span>
<span class="cp">#define IWLAGN_WOWLAN_MIN_PATTERN_LEN	16</span>
<span class="cp">#define IWLAGN_WOWLAN_MAX_PATTERN_LEN	128</span>

<span class="k">struct</span> <span class="n">iwlagn_wowlan_pattern</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">mask</span><span class="p">[</span><span class="n">IWLAGN_WOWLAN_MAX_PATTERN_LEN</span> <span class="o">/</span> <span class="mi">8</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">pattern</span><span class="p">[</span><span class="n">IWLAGN_WOWLAN_MAX_PATTERN_LEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">mask_size</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pattern_size</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cp">#define IWLAGN_WOWLAN_MAX_PATTERNS	20</span>

<span class="k">struct</span> <span class="n">iwlagn_wowlan_patterns_cmd</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">n_patterns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwlagn_wowlan_pattern</span> <span class="n">patterns</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_WOWLAN_WAKEUP_FILTER</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">iwlagn_wowlan_wakeup_filters</span> <span class="p">{</span>
	<span class="n">IWLAGN_WOWLAN_WAKEUP_MAGIC_PACKET</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="n">IWLAGN_WOWLAN_WAKEUP_PATTERN_MATCH</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
	<span class="n">IWLAGN_WOWLAN_WAKEUP_BEACON_MISS</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
	<span class="n">IWLAGN_WOWLAN_WAKEUP_LINK_CHANGE</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
	<span class="n">IWLAGN_WOWLAN_WAKEUP_GTK_REKEY_FAIL</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
	<span class="n">IWLAGN_WOWLAN_WAKEUP_EAP_IDENT_REQ</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
	<span class="n">IWLAGN_WOWLAN_WAKEUP_4WAY_HANDSHAKE</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>
	<span class="n">IWLAGN_WOWLAN_WAKEUP_ALWAYS</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span>
	<span class="n">IWLAGN_WOWLAN_WAKEUP_ENABLE_NET_DETECT</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">iwlagn_wowlan_wakeup_filter_cmd</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">enabled</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">non_qos_seq</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">reserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">qos_seq</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_WOWLAN_TSC_RSC_PARAMS</span>
<span class="cm"> */</span>
<span class="cp">#define IWLAGN_NUM_RSC	16</span>

<span class="k">struct</span> <span class="n">tkip_sc</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">iv16</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">pad</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">iv32</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">iwlagn_tkip_rsc_tsc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">tkip_sc</span> <span class="n">unicast_rsc</span><span class="p">[</span><span class="n">IWLAGN_NUM_RSC</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">tkip_sc</span> <span class="n">multicast_rsc</span><span class="p">[</span><span class="n">IWLAGN_NUM_RSC</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">tkip_sc</span> <span class="n">tsc</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">aes_sc</span> <span class="p">{</span>
	<span class="n">__le64</span> <span class="n">pn</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">iwlagn_aes_rsc_tsc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">aes_sc</span> <span class="n">unicast_rsc</span><span class="p">[</span><span class="n">IWLAGN_NUM_RSC</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">aes_sc</span> <span class="n">multicast_rsc</span><span class="p">[</span><span class="n">IWLAGN_NUM_RSC</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">aes_sc</span> <span class="n">tsc</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">union</span> <span class="n">iwlagn_all_tsc_rsc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwlagn_tkip_rsc_tsc</span> <span class="n">tkip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwlagn_aes_rsc_tsc</span> <span class="n">aes</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">iwlagn_wowlan_rsc_tsc_params_cmd</span> <span class="p">{</span>
	<span class="k">union</span> <span class="n">iwlagn_all_tsc_rsc</span> <span class="n">all_tsc_rsc</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_WOWLAN_TKIP_PARAMS</span>
<span class="cm"> */</span>
<span class="cp">#define IWLAGN_MIC_KEY_SIZE	8</span>
<span class="cp">#define IWLAGN_P1K_SIZE		5</span>
<span class="k">struct</span> <span class="n">iwlagn_mic_keys</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">tx</span><span class="p">[</span><span class="n">IWLAGN_MIC_KEY_SIZE</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">rx_unicast</span><span class="p">[</span><span class="n">IWLAGN_MIC_KEY_SIZE</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">rx_mcast</span><span class="p">[</span><span class="n">IWLAGN_MIC_KEY_SIZE</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">iwlagn_p1k_cache</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">p1k</span><span class="p">[</span><span class="n">IWLAGN_P1K_SIZE</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cp">#define IWLAGN_NUM_RX_P1K_CACHE	2</span>

<span class="k">struct</span> <span class="n">iwlagn_wowlan_tkip_params_cmd</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwlagn_mic_keys</span> <span class="n">mic_keys</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwlagn_p1k_cache</span> <span class="n">tx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwlagn_p1k_cache</span> <span class="n">rx_uni</span><span class="p">[</span><span class="n">IWLAGN_NUM_RX_P1K_CACHE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">iwlagn_p1k_cache</span> <span class="n">rx_multi</span><span class="p">[</span><span class="n">IWLAGN_NUM_RX_P1K_CACHE</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_WOWLAN_KEK_KCK_MATERIAL</span>
<span class="cm"> */</span>

<span class="cp">#define IWLAGN_KCK_MAX_SIZE	32</span>
<span class="cp">#define IWLAGN_KEK_MAX_SIZE	32</span>

<span class="k">struct</span> <span class="n">iwlagn_wowlan_kek_kck_material_cmd</span> <span class="p">{</span>
	<span class="n">u8</span>	<span class="n">kck</span><span class="p">[</span><span class="n">IWLAGN_KCK_MAX_SIZE</span><span class="p">];</span>
	<span class="n">u8</span>	<span class="n">kek</span><span class="p">[</span><span class="n">IWLAGN_KEK_MAX_SIZE</span><span class="p">];</span>
	<span class="n">__le16</span>	<span class="n">kck_len</span><span class="p">;</span>
	<span class="n">__le16</span>	<span class="n">kek_len</span><span class="p">;</span>
	<span class="n">__le64</span>	<span class="n">replay_ctr</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_WIPAN_PARAMS = 0xb2 (Commands and Notification)</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Minimum slot time in TU</span>
<span class="cm"> */</span>
<span class="cp">#define IWL_MIN_SLOT_TIME	20</span>

<span class="cm">/**</span>
<span class="cm"> * struct iwl_wipan_slot</span>
<span class="cm"> * @width: Time in TU</span>
<span class="cm"> * @type:</span>
<span class="cm"> *   0 - BSS</span>
<span class="cm"> *   1 - PAN</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_wipan_slot</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">width</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cp">#define IWL_WIPAN_PARAMS_FLG_LEAVE_CHANNEL_CTS		BIT(1)	</span><span class="cm">/* reserved */</span><span class="cp"></span>
<span class="cp">#define IWL_WIPAN_PARAMS_FLG_LEAVE_CHANNEL_QUIET	BIT(2)	</span><span class="cm">/* reserved */</span><span class="cp"></span>
<span class="cp">#define IWL_WIPAN_PARAMS_FLG_SLOTTED_MODE		BIT(3)	</span><span class="cm">/* reserved */</span><span class="cp"></span>
<span class="cp">#define IWL_WIPAN_PARAMS_FLG_FILTER_BEACON_NOTIF	BIT(4)</span>
<span class="cp">#define IWL_WIPAN_PARAMS_FLG_FULL_SLOTTED_MODE		BIT(5)</span>

<span class="cm">/**</span>
<span class="cm"> * struct iwl_wipan_params_cmd</span>
<span class="cm"> * @flags:</span>
<span class="cm"> *   bit0: reserved</span>
<span class="cm"> *   bit1: CP leave channel with CTS</span>
<span class="cm"> *   bit2: CP leave channel qith Quiet</span>
<span class="cm"> *   bit3: slotted mode</span>
<span class="cm"> *     1 - work in slotted mode</span>
<span class="cm"> *     0 - work in non slotted mode</span>
<span class="cm"> *   bit4: filter beacon notification</span>
<span class="cm"> *   bit5: full tx slotted mode. if this flag is set,</span>
<span class="cm"> *         uCode will perform leaving channel methods in context switch</span>
<span class="cm"> *         also when working in same channel mode</span>
<span class="cm"> * @num_slots: 1 - 10</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_wipan_params_cmd</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">num_slots</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_wipan_slot</span> <span class="n">slots</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_WIPAN_P2P_CHANNEL_SWITCH = 0xb9</span>
<span class="cm"> *</span>
<span class="cm"> * TODO: Figure out what this is used for,</span>
<span class="cm"> *	 it can only switch between 2.4 GHz</span>
<span class="cm"> *	 channels!!</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">iwl_wipan_p2p_channel_switch_cmd</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">channel</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * REPLY_WIPAN_NOA_NOTIFICATION = 0xbc</span>
<span class="cm"> *</span>
<span class="cm"> * This is used by the device to notify us of the</span>
<span class="cm"> * NoA schedule it determined so we can forward it</span>
<span class="cm"> * to userspace for inclusion in probe responses.</span>
<span class="cm"> *</span>
<span class="cm"> * In beacons, the NoA schedule is simply appended</span>
<span class="cm"> * to the frame we give the device.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">iwl_wipan_noa_descriptor</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">duration</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">interval</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">starttime</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">iwl_wipan_noa_attribute</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ct_window</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_wipan_noa_descriptor</span> <span class="n">descr0</span><span class="p">,</span> <span class="n">descr1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">iwl_wipan_noa_notification</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">noa_active</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_wipan_noa_attribute</span> <span class="n">noa_attribute</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cp">#endif				</span><span class="cm">/* __iwl_commands_h__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
