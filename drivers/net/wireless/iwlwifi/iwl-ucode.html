<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › iwlwifi › iwl-ucode.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>iwl-ucode.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * GPL LICENSE SUMMARY</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2008 - 2012 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of version 2 of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,</span>
<span class="cm"> * USA</span>
<span class="cm"> *</span>
<span class="cm"> * The full GNU General Public License is included in this distribution</span>
<span class="cm"> * in the file called LICENSE.GPL.</span>
<span class="cm"> *</span>
<span class="cm"> * Contact Information:</span>
<span class="cm"> *  Intel Linux Wireless &lt;ilw@linux.intel.com&gt;</span>
<span class="cm"> * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>

<span class="cp">#include &quot;iwl-dev.h&quot;</span>
<span class="cp">#include &quot;iwl-io.h&quot;</span>
<span class="cp">#include &quot;iwl-agn-hw.h&quot;</span>
<span class="cp">#include &quot;iwl-agn.h&quot;</span>
<span class="cp">#include &quot;iwl-agn-calib.h&quot;</span>
<span class="cp">#include &quot;iwl-trans.h&quot;</span>
<span class="cp">#include &quot;iwl-fh.h&quot;</span>
<span class="cp">#include &quot;iwl-op-mode.h&quot;</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * uCode download functions</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">fw_img</span> <span class="o">*</span>
<span class="nf">iwl_get_ucode_image</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">enum</span> <span class="n">iwl_ucode_type</span> <span class="n">ucode_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ucode_type</span> <span class="o">&gt;=</span> <span class="n">IWL_UCODE_TYPE_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">img</span><span class="p">[</span><span class="n">ucode_type</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Calibration</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_set_Xtal_calib</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_calib_xtal_freq_cmd</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="o">*</span><span class="n">xtal_calib</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="n">iwl_eeprom_query_addr</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">EEPROM_XTAL</span><span class="p">);</span>

	<span class="n">iwl_set_calib_hdr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">.</span><span class="n">hdr</span><span class="p">,</span> <span class="n">IWL_PHY_CALIBRATE_CRYSTAL_FRQ_CMD</span><span class="p">);</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">cap_pin1</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">xtal_calib</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">cap_pin2</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">xtal_calib</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="k">return</span> <span class="n">iwl_calib_set</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_set_temperature_offset_calib</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_calib_temperature_offset_cmd</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="o">*</span><span class="n">offset_calib</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="n">iwl_eeprom_query_addr</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">EEPROM_RAW_TEMPERATURE</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
	<span class="n">iwl_set_calib_hdr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">.</span><span class="n">hdr</span><span class="p">,</span> <span class="n">IWL_PHY_CALIBRATE_TEMP_OFFSET_CMD</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">.</span><span class="n">radio_sensor_offset</span><span class="p">,</span> <span class="n">offset_calib</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">offset_calib</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">radio_sensor_offset</span><span class="p">))</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">radio_sensor_offset</span> <span class="o">=</span> <span class="n">DEFAULT_RADIO_SENSOR_OFFSET</span><span class="p">;</span>

	<span class="n">IWL_DEBUG_CALIB</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Radio sensor offset: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">radio_sensor_offset</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">iwl_calib_set</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_set_temperature_offset_calib_v2</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_calib_temperature_offset_v2_cmd</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="o">*</span><span class="n">offset_calib_high</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="n">iwl_eeprom_query_addr</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span>
				     <span class="n">EEPROM_KELVIN_TEMPERATURE</span><span class="p">);</span>
	<span class="n">__le16</span> <span class="o">*</span><span class="n">offset_calib_low</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="n">iwl_eeprom_query_addr</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">EEPROM_RAW_TEMPERATURE</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_eeprom_calib_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
	<span class="n">iwl_set_calib_hdr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">.</span><span class="n">hdr</span><span class="p">,</span> <span class="n">IWL_PHY_CALIBRATE_TEMP_OFFSET_CMD</span><span class="p">);</span>
	<span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iwl_eeprom_calib_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">iwl_eeprom_query_addr</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span>
							<span class="n">EEPROM_CALIB_ALL</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">.</span><span class="n">radio_sensor_offset_high</span><span class="p">,</span> <span class="n">offset_calib_high</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">offset_calib_high</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">.</span><span class="n">radio_sensor_offset_low</span><span class="p">,</span> <span class="n">offset_calib_low</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">offset_calib_low</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">radio_sensor_offset_low</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IWL_DEBUG_CALIB</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;no info in EEPROM, use default</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">radio_sensor_offset_low</span> <span class="o">=</span> <span class="n">DEFAULT_RADIO_SENSOR_OFFSET</span><span class="p">;</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">radio_sensor_offset_high</span> <span class="o">=</span> <span class="n">DEFAULT_RADIO_SENSOR_OFFSET</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">.</span><span class="n">burntVoltageRef</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">voltage</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">voltage</span><span class="p">));</span>

	<span class="n">IWL_DEBUG_CALIB</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Radio sensor offset high: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">radio_sensor_offset_high</span><span class="p">));</span>
	<span class="n">IWL_DEBUG_CALIB</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Radio sensor offset low: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">radio_sensor_offset_low</span><span class="p">));</span>
	<span class="n">IWL_DEBUG_CALIB</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Voltage Ref: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">burntVoltageRef</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">iwl_calib_set</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_send_calib_cfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_calib_cfg_cmd</span> <span class="n">calib_cfg_cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_host_cmd</span> <span class="n">cmd</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">CALIBRATION_CFG_CMD</span><span class="p">,</span>
		<span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="p">{</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_calib_cfg_cmd</span><span class="p">),</span> <span class="p">},</span>
		<span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span> <span class="o">&amp;</span><span class="n">calib_cfg_cmd</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">};</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">calib_cfg_cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">calib_cfg_cmd</span><span class="p">));</span>
	<span class="n">calib_cfg_cmd</span><span class="p">.</span><span class="n">ucd_calib_cfg</span><span class="p">.</span><span class="n">once</span><span class="p">.</span><span class="n">is_enable</span> <span class="o">=</span> <span class="n">IWL_CALIB_INIT_CFG_ALL</span><span class="p">;</span>
	<span class="n">calib_cfg_cmd</span><span class="p">.</span><span class="n">ucd_calib_cfg</span><span class="p">.</span><span class="n">once</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">IWL_CALIB_INIT_CFG_ALL</span><span class="p">;</span>
	<span class="n">calib_cfg_cmd</span><span class="p">.</span><span class="n">ucd_calib_cfg</span><span class="p">.</span><span class="n">once</span><span class="p">.</span><span class="n">send_res</span> <span class="o">=</span> <span class="n">IWL_CALIB_INIT_CFG_ALL</span><span class="p">;</span>
	<span class="n">calib_cfg_cmd</span><span class="p">.</span><span class="n">ucd_calib_cfg</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span>
		<span class="n">IWL_CALIB_CFG_FLAG_SEND_COMPLETE_NTFY_MSK</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">iwl_dvm_send_cmd</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">iwl_init_alive_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">bt_params</span> <span class="o">&amp;&amp;</span>
	    <span class="n">priv</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">bt_params</span><span class="o">-&gt;</span><span class="n">advanced_bt_coexist</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Tell uCode we are ready to perform calibration</span>
<span class="cm">		 * need to perform this before any calibration</span>
<span class="cm">		 * no need to close the envlope since we are going</span>
<span class="cm">		 * to load the runtime uCode later.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_send_bt_env</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">IWL_BT_COEX_ENV_OPEN</span><span class="p">,</span>
			<span class="n">BT_COEX_PRIO_TBL_EVT_INIT_CALIB2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_send_calib_cfg</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * temperature offset calibration is only needed for runtime ucode,</span>
<span class="cm">	 * so prepare the value now.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">need_temp_offset_calib</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">temp_offset_v2</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">iwl_set_temperature_offset_calib_v2</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">iwl_set_temperature_offset_calib</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">iwl_send_wimax_coex</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_wimax_coex_cmd</span> <span class="n">coex_cmd</span><span class="p">;</span>

	<span class="cm">/* coexistence is disabled */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">coex_cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">coex_cmd</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">iwl_dvm_send_cmd_pdu</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span>
				<span class="n">COEX_PRIORITY_TABLE_CMD</span><span class="p">,</span> <span class="n">CMD_SYNC</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">coex_cmd</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">coex_cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">iwl_bt_prio_tbl</span><span class="p">[</span><span class="n">BT_COEX_PRIO_TBL_EVT_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">((</span><span class="n">BT_COEX_PRIO_TBL_PRIO_BYPASS</span> <span class="o">&lt;&lt;</span> <span class="n">IWL_BT_COEX_PRIO_TBL_PRIO_POS</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="n">IWL_BT_COEX_PRIO_TBL_SHARED_ANTENNA_POS</span><span class="p">)),</span>
	<span class="p">((</span><span class="n">BT_COEX_PRIO_TBL_PRIO_BYPASS</span> <span class="o">&lt;&lt;</span> <span class="n">IWL_BT_COEX_PRIO_TBL_PRIO_POS</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IWL_BT_COEX_PRIO_TBL_SHARED_ANTENNA_POS</span><span class="p">)),</span>
	<span class="p">((</span><span class="n">BT_COEX_PRIO_TBL_PRIO_LOW</span> <span class="o">&lt;&lt;</span> <span class="n">IWL_BT_COEX_PRIO_TBL_PRIO_POS</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="n">IWL_BT_COEX_PRIO_TBL_SHARED_ANTENNA_POS</span><span class="p">)),</span>
	<span class="p">((</span><span class="n">BT_COEX_PRIO_TBL_PRIO_LOW</span> <span class="o">&lt;&lt;</span> <span class="n">IWL_BT_COEX_PRIO_TBL_PRIO_POS</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IWL_BT_COEX_PRIO_TBL_SHARED_ANTENNA_POS</span><span class="p">)),</span>
	<span class="p">((</span><span class="n">BT_COEX_PRIO_TBL_PRIO_HIGH</span> <span class="o">&lt;&lt;</span> <span class="n">IWL_BT_COEX_PRIO_TBL_PRIO_POS</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="n">IWL_BT_COEX_PRIO_TBL_SHARED_ANTENNA_POS</span><span class="p">)),</span>
	<span class="p">((</span><span class="n">BT_COEX_PRIO_TBL_PRIO_HIGH</span> <span class="o">&lt;&lt;</span> <span class="n">IWL_BT_COEX_PRIO_TBL_PRIO_POS</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IWL_BT_COEX_PRIO_TBL_SHARED_ANTENNA_POS</span><span class="p">)),</span>
	<span class="p">((</span><span class="n">BT_COEX_PRIO_TBL_PRIO_BYPASS</span> <span class="o">&lt;&lt;</span> <span class="n">IWL_BT_COEX_PRIO_TBL_PRIO_POS</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="n">IWL_BT_COEX_PRIO_TBL_SHARED_ANTENNA_POS</span><span class="p">)),</span>
	<span class="p">((</span><span class="n">BT_COEX_PRIO_TBL_PRIO_COEX_OFF</span> <span class="o">&lt;&lt;</span> <span class="n">IWL_BT_COEX_PRIO_TBL_PRIO_POS</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="n">IWL_BT_COEX_PRIO_TBL_SHARED_ANTENNA_POS</span><span class="p">)),</span>
	<span class="p">((</span><span class="n">BT_COEX_PRIO_TBL_PRIO_COEX_ON</span> <span class="o">&lt;&lt;</span> <span class="n">IWL_BT_COEX_PRIO_TBL_PRIO_POS</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="n">IWL_BT_COEX_PRIO_TBL_SHARED_ANTENNA_POS</span><span class="p">)),</span>
	<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">iwl_send_prio_tbl</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_bt_coex_prio_table_cmd</span> <span class="n">prio_tbl_cmd</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">prio_tbl_cmd</span><span class="p">.</span><span class="n">prio_tbl</span><span class="p">,</span> <span class="n">iwl_bt_prio_tbl</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">iwl_bt_prio_tbl</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iwl_dvm_send_cmd_pdu</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span>
				<span class="n">REPLY_BT_COEX_PRIO_TABLE</span><span class="p">,</span> <span class="n">CMD_SYNC</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">prio_tbl_cmd</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">prio_tbl_cmd</span><span class="p">))</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;failed to send BT prio tbl command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">iwl_send_bt_env</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="n">u8</span> <span class="n">action</span><span class="p">,</span> <span class="n">u8</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_bt_coex_prot_env_cmd</span> <span class="n">env_cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">env_cmd</span><span class="p">.</span><span class="n">action</span> <span class="o">=</span> <span class="n">action</span><span class="p">;</span>
	<span class="n">env_cmd</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_dvm_send_cmd_pdu</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span>
			       <span class="n">REPLY_BT_COEX_PROT_ENV</span><span class="p">,</span> <span class="n">CMD_SYNC</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="n">env_cmd</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">env_cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;failed to send BT env command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_alive_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">iwl_trans_fw_alive</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">passive_no_rx</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">transport_queue_stop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_send_wimax_coex</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">no_xtal_calib</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_set_Xtal_calib</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">iwl_send_calib_results</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * iwl_verify_inst_sparse - verify runtime uCode image in card vs. host,</span>
<span class="cm"> *   using sample data 100 bytes apart.  If these sample points are good,</span>
<span class="cm"> *   it&#39;s a pretty good bet that everything between them is good, too.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_verify_sec_sparse</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">fw_desc</span> <span class="o">*</span><span class="n">fw_desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">fw_desc</span><span class="o">-&gt;</span><span class="n">v_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span> <span class="o">=</span> <span class="n">fw_desc</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">IWL_DEBUG_FW</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;ucode inst image size is %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">image</span> <span class="o">+=</span> <span class="mi">100</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* read data comes through single port, auto-incr addr */</span>
		<span class="cm">/* NOTE: Use the debugless read so we don&#39;t flood kernel log</span>
<span class="cm">		 * if IWL_DL_IO is set */</span>
		<span class="n">iwl_write_direct32</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">HBUS_TARG_MEM_RADDR</span><span class="p">,</span>
			<span class="n">i</span> <span class="o">+</span> <span class="n">fw_desc</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">iwl_read32</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">HBUS_TARG_MEM_RDAT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">image</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iwl_print_mismatch_sec</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">fw_desc</span> <span class="o">*</span><span class="n">fw_desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">fw_desc</span><span class="o">-&gt;</span><span class="n">v_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span> <span class="o">=</span> <span class="n">fw_desc</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">offs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">errors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IWL_DEBUG_FW</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;ucode inst image size is %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">iwl_write_direct32</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">HBUS_TARG_MEM_RADDR</span><span class="p">,</span>
				<span class="n">fw_desc</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">offs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	     <span class="n">offs</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">errors</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span>
	     <span class="n">offs</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="n">image</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* read data comes through single port, auto-incr addr */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">iwl_read32</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">HBUS_TARG_MEM_RDAT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">image</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;uCode INST section at &quot;</span>
				<span class="s">&quot;offset 0x%x, is 0x%x, s/b 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">offs</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">image</span><span class="p">));</span>
			<span class="n">errors</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iwl_verify_ucode - determine which instruction image is in SRAM,</span>
<span class="cm"> *    and verify its contents</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwl_verify_ucode</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
			    <span class="k">enum</span> <span class="n">iwl_ucode_type</span> <span class="n">ucode_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">fw_img</span> <span class="o">*</span><span class="n">img</span> <span class="o">=</span> <span class="n">iwl_get_ucode_image</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">ucode_type</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">img</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Invalid ucode requested (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ucode_type</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iwl_verify_sec_sparse</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">img</span><span class="o">-&gt;</span><span class="n">sec</span><span class="p">[</span><span class="n">IWL_UCODE_SECTION_INST</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">IWL_DEBUG_FW</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;uCode is good in inst SRAM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;UCODE IMAGE IN INSTRUCTION SRAM NOT VALID!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">iwl_print_mismatch_sec</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">img</span><span class="o">-&gt;</span><span class="n">sec</span><span class="p">[</span><span class="n">IWL_UCODE_SECTION_INST</span><span class="p">]);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">iwl_alive_data</span> <span class="p">{</span>
	<span class="n">bool</span> <span class="n">valid</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">subtype</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">iwl_alive_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_notif_wait_data</span> <span class="o">*</span><span class="n">notif_wait</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">iwl_rx_packet</span> <span class="o">*</span><span class="n">pkt</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">notif_wait</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwl_priv</span><span class="p">,</span> <span class="n">notif_wait</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iwl_alive_data</span> <span class="o">*</span><span class="n">alive_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_alive_resp</span> <span class="o">*</span><span class="n">palive</span><span class="p">;</span>

	<span class="n">palive</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="n">IWL_DEBUG_FW</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Alive ucode status 0x%08X revision &quot;</span>
		       <span class="s">&quot;0x%01X 0x%01X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">palive</span><span class="o">-&gt;</span><span class="n">is_valid</span><span class="p">,</span> <span class="n">palive</span><span class="o">-&gt;</span><span class="n">ver_type</span><span class="p">,</span>
		       <span class="n">palive</span><span class="o">-&gt;</span><span class="n">ver_subtype</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_pointers</span><span class="p">.</span><span class="n">error_event_table</span> <span class="o">=</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">palive</span><span class="o">-&gt;</span><span class="n">error_event_table_ptr</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_pointers</span><span class="p">.</span><span class="n">log_event_table</span> <span class="o">=</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">palive</span><span class="o">-&gt;</span><span class="n">log_event_table_ptr</span><span class="p">);</span>

	<span class="n">alive_data</span><span class="o">-&gt;</span><span class="n">subtype</span> <span class="o">=</span> <span class="n">palive</span><span class="o">-&gt;</span><span class="n">ver_subtype</span><span class="p">;</span>
	<span class="n">alive_data</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="n">palive</span><span class="o">-&gt;</span><span class="n">is_valid</span> <span class="o">==</span> <span class="n">UCODE_VALID_OK</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define UCODE_ALIVE_TIMEOUT	HZ</span>
<span class="cp">#define UCODE_CALIB_TIMEOUT	(2*HZ)</span>

<span class="kt">int</span> <span class="nf">iwl_load_ucode_wait_alive</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
				 <span class="k">enum</span> <span class="n">iwl_ucode_type</span> <span class="n">ucode_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_notification_wait</span> <span class="n">alive_wait</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_alive_data</span> <span class="n">alive_data</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">fw_img</span> <span class="o">*</span><span class="n">fw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">iwl_ucode_type</span> <span class="n">old_type</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">alive_cmd</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">REPLY_ALIVE</span> <span class="p">};</span>

	<span class="n">old_type</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">cur_ucode</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">cur_ucode</span> <span class="o">=</span> <span class="n">ucode_type</span><span class="p">;</span>
	<span class="n">fw</span> <span class="o">=</span> <span class="n">iwl_get_ucode_image</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">ucode_type</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ucode_loaded</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fw</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">iwl_init_notification_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">notif_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alive_wait</span><span class="p">,</span>
				   <span class="n">alive_cmd</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">alive_cmd</span><span class="p">),</span>
				   <span class="n">iwl_alive_fn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alive_data</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_trans_start_fw</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">fw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">cur_ucode</span> <span class="o">=</span> <span class="n">old_type</span><span class="p">;</span>
		<span class="n">iwl_remove_notification</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">notif_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alive_wait</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some things may run in the background now, but we</span>
<span class="cm">	 * just wait for the ALIVE notification here.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_wait_notification</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">notif_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alive_wait</span><span class="p">,</span>
					<span class="n">UCODE_ALIVE_TIMEOUT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">cur_ucode</span> <span class="o">=</span> <span class="n">old_type</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alive_data</span><span class="p">.</span><span class="n">valid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Loaded ucode is not valid!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">cur_ucode</span> <span class="o">=</span> <span class="n">old_type</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This step takes a long time (60-80ms!!) and</span>
<span class="cm">	 * WoWLAN image should be loaded quickly, so</span>
<span class="cm">	 * skip it for WoWLAN.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ucode_type</span> <span class="o">!=</span> <span class="n">IWL_UCODE_WOWLAN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_verify_ucode</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">ucode_type</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">cur_ucode</span> <span class="o">=</span> <span class="n">old_type</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* delay a bit to give rfkill time to run */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_alive_notify</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWL_WARN</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span>
			<span class="s">&quot;Could not complete ALIVE transition: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">cur_ucode</span> <span class="o">=</span> <span class="n">old_type</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ucode_loaded</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">iwlagn_wait_calib</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_notif_wait_data</span> <span class="o">*</span><span class="n">notif_wait</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">iwl_rx_packet</span> <span class="o">*</span><span class="n">pkt</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_calib_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd</span> <span class="o">!=</span> <span class="n">CALIBRATION_RES_NOTIFICATION</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd</span> <span class="o">!=</span> <span class="n">CALIBRATION_COMPLETE_NOTIFICATION</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iwl_calib_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">len_n_flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FH_RSCSR_FRAME_SIZE_MSK</span><span class="p">;</span>

	<span class="cm">/* reduce the size by the length field itself */</span>
	<span class="n">len</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__le32</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iwl_calib_set</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="n">IWL_ERR</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="s">&quot;Failed to record calibration data %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">op_code</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">iwl_run_init_ucode</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_notification_wait</span> <span class="n">calib_wait</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">calib_complete</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">CALIBRATION_RES_NOTIFICATION</span><span class="p">,</span>
		<span class="n">CALIBRATION_COMPLETE_NOTIFICATION</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="cm">/* No init ucode required? Curious, but maybe ok */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">img</span><span class="p">[</span><span class="n">IWL_UCODE_INIT</span><span class="p">].</span><span class="n">sec</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">init_ucode_run</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">iwl_init_notification_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">notif_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">calib_wait</span><span class="p">,</span>
				   <span class="n">calib_complete</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">calib_complete</span><span class="p">),</span>
				   <span class="n">iwlagn_wait_calib</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>

	<span class="cm">/* Will also start the device */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_load_ucode_wait_alive</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">IWL_UCODE_INIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_init_alive_start</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some things may run in the background now, but we</span>
<span class="cm">	 * just wait for the calibration complete notification.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">iwl_wait_notification</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">notif_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">calib_wait</span><span class="p">,</span>
					<span class="n">UCODE_CALIB_TIMEOUT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">init_ucode_run</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

 <span class="nl">error:</span>
	<span class="n">iwl_remove_notification</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">notif_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">calib_wait</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="cm">/* Whatever happened, stop the device */</span>
	<span class="n">iwl_trans_stop_device</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ucode_loaded</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
