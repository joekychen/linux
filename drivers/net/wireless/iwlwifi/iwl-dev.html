<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wireless › iwlwifi › iwl-dev.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>iwl-dev.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2003 - 2012 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of version 2 of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA</span>
<span class="cm"> *</span>
<span class="cm"> * The full GNU General Public License is included in this distribution in the</span>
<span class="cm"> * file called LICENSE.</span>
<span class="cm"> *</span>
<span class="cm"> * Contact Information:</span>
<span class="cm"> *  Intel Linux Wireless &lt;ilw@linux.intel.com&gt;</span>
<span class="cm"> * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>
<span class="cm">/*</span>
<span class="cm"> * Please use this file (iwl-dev.h) for driver implementation definitions.</span>
<span class="cm"> * Please use iwl-commands.h for uCode API definitions.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __iwl_dev_h__</span>
<span class="cp">#define __iwl_dev_h__</span>

<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/leds.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>

<span class="cp">#include &quot;iwl-fw.h&quot;</span>
<span class="cp">#include &quot;iwl-eeprom.h&quot;</span>
<span class="cp">#include &quot;iwl-csr.h&quot;</span>
<span class="cp">#include &quot;iwl-debug.h&quot;</span>
<span class="cp">#include &quot;iwl-agn-hw.h&quot;</span>
<span class="cp">#include &quot;iwl-led.h&quot;</span>
<span class="cp">#include &quot;iwl-power.h&quot;</span>
<span class="cp">#include &quot;iwl-agn-rs.h&quot;</span>
<span class="cp">#include &quot;iwl-agn-tt.h&quot;</span>
<span class="cp">#include &quot;iwl-trans.h&quot;</span>
<span class="cp">#include &quot;iwl-op-mode.h&quot;</span>
<span class="cp">#include &quot;iwl-notif-wait.h&quot;</span>

<span class="cm">/* CT-KILL constants */</span>
<span class="cp">#define CT_KILL_THRESHOLD_LEGACY   110 </span><span class="cm">/* in Celsius */</span><span class="cp"></span>
<span class="cp">#define CT_KILL_THRESHOLD	   114 </span><span class="cm">/* in Celsius */</span><span class="cp"></span>
<span class="cp">#define CT_KILL_EXIT_THRESHOLD     95  </span><span class="cm">/* in Celsius */</span><span class="cp"></span>

<span class="cm">/* Default noise level to report when noise measurement is not available.</span>
<span class="cm"> *   This may be because we&#39;re:</span>
<span class="cm"> *   1)  Not associated  no beacon statistics being sent to driver)</span>
<span class="cm"> *   2)  Scanning (noise measurement does not apply to associated channel)</span>
<span class="cm"> * Use default noise value of -127 ... this is below the range of measurable</span>
<span class="cm"> *   Rx dBm for all agn devices, so it can indicate &quot;unmeasurable&quot; to user.</span>
<span class="cm"> *   Also, -127 works better than 0 when averaging frames with/without</span>
<span class="cm"> *   noise info (e.g. averaging might be done in app); measured dBm values are</span>
<span class="cm"> *   always negative ... using a negative value as the default keeps all</span>
<span class="cm"> *   averages within an s8&#39;s (used in some apps) range of negative values. */</span>
<span class="cp">#define IWL_NOISE_MEAS_NOT_AVAILABLE (-127)</span>

<span class="cm">/*</span>
<span class="cm"> * RTS threshold here is total size [2347] minus 4 FCS bytes</span>
<span class="cm"> * Per spec:</span>
<span class="cm"> *   a value of 0 means RTS on all data/management packets</span>
<span class="cm"> *   a value &gt; max MSDU size means no RTS</span>
<span class="cm"> * else RTS for data/management frames where MPDU is larger</span>
<span class="cm"> *   than RTS value.</span>
<span class="cm"> */</span>
<span class="cp">#define DEFAULT_RTS_THRESHOLD     2347U</span>
<span class="cp">#define MIN_RTS_THRESHOLD         0U</span>
<span class="cp">#define MAX_RTS_THRESHOLD         2347U</span>
<span class="cp">#define MAX_MSDU_SIZE		  2304U</span>
<span class="cp">#define MAX_MPDU_SIZE		  2346U</span>
<span class="cp">#define DEFAULT_BEACON_INTERVAL   200U</span>
<span class="cp">#define	DEFAULT_SHORT_RETRY_LIMIT 7U</span>
<span class="cp">#define	DEFAULT_LONG_RETRY_LIMIT  4U</span>

<span class="cp">#define IWL_NUM_SCAN_RATES         (2)</span>

<span class="cm">/*</span>
<span class="cm"> * One for each channel, holds all channel setup data</span>
<span class="cm"> * Some of the fields (e.g. eeprom and flags/max_power_avg) are redundant</span>
<span class="cm"> *     with one another!</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_channel_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_eeprom_channel</span> <span class="n">eeprom</span><span class="p">;</span>	<span class="cm">/* EEPROM regulatory limit */</span>
	<span class="k">struct</span> <span class="n">iwl_eeprom_channel</span> <span class="n">ht40_eeprom</span><span class="p">;</span>	<span class="cm">/* EEPROM regulatory limit for</span>
<span class="cm">						 * HT40 channel */</span>

	<span class="n">u8</span> <span class="n">channel</span><span class="p">;</span>	  <span class="cm">/* channel number */</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>	  <span class="cm">/* flags copied from EEPROM */</span>
	<span class="n">s8</span> <span class="n">max_power_avg</span><span class="p">;</span> <span class="cm">/* (dBm) regul. eeprom, normal Tx, any rate */</span>
	<span class="n">s8</span> <span class="n">curr_txpow</span><span class="p">;</span>	  <span class="cm">/* (dBm) regulatory/spectrum/user (not h/w) limit */</span>
	<span class="n">s8</span> <span class="n">min_power</span><span class="p">;</span>	  <span class="cm">/* always 0 */</span>
	<span class="n">s8</span> <span class="n">scan_power</span><span class="p">;</span>	  <span class="cm">/* (dBm) regul. eeprom, direct scans, any rate */</span>

	<span class="n">u8</span> <span class="n">group_index</span><span class="p">;</span>	  <span class="cm">/* 0-4, maps channel to group1/2/3/4/5 */</span>
	<span class="n">u8</span> <span class="n">band_index</span><span class="p">;</span>	  <span class="cm">/* 0-4, maps channel to band1/2/3/4/5 */</span>
	<span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">;</span>

	<span class="cm">/* HT40 channel info */</span>
	<span class="n">s8</span> <span class="n">ht40_max_power_avg</span><span class="p">;</span>	<span class="cm">/* (dBm) regul. eeprom, normal Tx, any rate */</span>
	<span class="n">u8</span> <span class="n">ht40_flags</span><span class="p">;</span>		<span class="cm">/* flags copied from EEPROM */</span>
	<span class="n">u8</span> <span class="n">ht40_extension_channel</span><span class="p">;</span> <span class="cm">/* HT_IE_EXT_CHANNEL_* */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Minimum number of queues. MAX_NUM is defined in hw specific files.</span>
<span class="cm"> * Set the minimum to accommodate</span>
<span class="cm"> *  - 4 standard TX queues</span>
<span class="cm"> *  - the command queue</span>
<span class="cm"> *  - 4 PAN TX queues</span>
<span class="cm"> *  - the PAN multicast queue, and</span>
<span class="cm"> *  - the AUX (TX during scan dwell) queue.</span>
<span class="cm"> */</span>
<span class="cp">#define IWL_MIN_NUM_QUEUES	11</span>

<span class="cm">/*</span>
<span class="cm"> * Command queue depends on iPAN support.</span>
<span class="cm"> */</span>
<span class="cp">#define IWL_DEFAULT_CMD_QUEUE_NUM	4</span>
<span class="cp">#define IWL_IPAN_CMD_QUEUE_NUM		9</span>

<span class="cp">#define IEEE80211_DATA_LEN              2304</span>
<span class="cp">#define IEEE80211_4ADDR_LEN             30</span>
<span class="cp">#define IEEE80211_HLEN                  (IEEE80211_4ADDR_LEN)</span>
<span class="cp">#define IEEE80211_FRAME_LEN             (IEEE80211_DATA_LEN + IEEE80211_HLEN)</span>

<span class="cp">#define SUP_RATE_11A_MAX_NUM_CHANNELS  8</span>
<span class="cp">#define SUP_RATE_11B_MAX_NUM_CHANNELS  4</span>
<span class="cp">#define SUP_RATE_11G_MAX_NUM_CHANNELS  12</span>

<span class="cp">#define IWL_SUPPORTED_RATES_IE_LEN         8</span>

<span class="cp">#define IWL_INVALID_RATE     0xFF</span>
<span class="cp">#define IWL_INVALID_VALUE    -1</span>

<span class="k">union</span> <span class="n">iwl_ht_rate_supp</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">rates</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">siso_rate</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">mimo_rate</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="cp">#define CFG_HT_RX_AMPDU_FACTOR_8K   (0x0)</span>
<span class="cp">#define CFG_HT_RX_AMPDU_FACTOR_16K  (0x1)</span>
<span class="cp">#define CFG_HT_RX_AMPDU_FACTOR_32K  (0x2)</span>
<span class="cp">#define CFG_HT_RX_AMPDU_FACTOR_64K  (0x3)</span>
<span class="cp">#define CFG_HT_RX_AMPDU_FACTOR_DEF  CFG_HT_RX_AMPDU_FACTOR_64K</span>
<span class="cp">#define CFG_HT_RX_AMPDU_FACTOR_MAX  CFG_HT_RX_AMPDU_FACTOR_64K</span>
<span class="cp">#define CFG_HT_RX_AMPDU_FACTOR_MIN  CFG_HT_RX_AMPDU_FACTOR_8K</span>

<span class="cm">/*</span>
<span class="cm"> * Maximal MPDU density for TX aggregation</span>
<span class="cm"> * 4 - 2us density</span>
<span class="cm"> * 5 - 4us density</span>
<span class="cm"> * 6 - 8us density</span>
<span class="cm"> * 7 - 16us density</span>
<span class="cm"> */</span>
<span class="cp">#define CFG_HT_MPDU_DENSITY_2USEC   (0x4)</span>
<span class="cp">#define CFG_HT_MPDU_DENSITY_4USEC   (0x5)</span>
<span class="cp">#define CFG_HT_MPDU_DENSITY_8USEC   (0x6)</span>
<span class="cp">#define CFG_HT_MPDU_DENSITY_16USEC  (0x7)</span>
<span class="cp">#define CFG_HT_MPDU_DENSITY_DEF CFG_HT_MPDU_DENSITY_4USEC</span>
<span class="cp">#define CFG_HT_MPDU_DENSITY_MAX CFG_HT_MPDU_DENSITY_16USEC</span>
<span class="cp">#define CFG_HT_MPDU_DENSITY_MIN     (0x1)</span>

<span class="k">struct</span> <span class="n">iwl_ht_config</span> <span class="p">{</span>
	<span class="n">bool</span> <span class="n">single_chain_sufficient</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ieee80211_smps_mode</span> <span class="n">smps</span><span class="p">;</span> <span class="cm">/* current smps mode */</span>
<span class="p">};</span>

<span class="cm">/* QoS structures */</span>
<span class="k">struct</span> <span class="n">iwl_qos_info</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">qos_active</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_qosparam_cmd</span> <span class="n">def_qos_parm</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum iwl_agg_state</span>
<span class="cm"> *</span>
<span class="cm"> * The state machine of the BA agreement establishment / tear down.</span>
<span class="cm"> * These states relate to a specific RA / TID.</span>
<span class="cm"> *</span>
<span class="cm"> * @IWL_AGG_OFF: aggregation is not used</span>
<span class="cm"> * @IWL_AGG_STARTING: aggregation are starting (between start and oper)</span>
<span class="cm"> * @IWL_AGG_ON: aggregation session is up</span>
<span class="cm"> * @IWL_EMPTYING_HW_QUEUE_ADDBA: establishing a BA session - waiting for the</span>
<span class="cm"> *	HW queue to be empty from packets for this RA /TID.</span>
<span class="cm"> * @IWL_EMPTYING_HW_QUEUE_DELBA: tearing down a BA session - waiting for the</span>
<span class="cm"> *	HW queue to be empty from packets for this RA /TID.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">iwl_agg_state</span> <span class="p">{</span>
	<span class="n">IWL_AGG_OFF</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IWL_AGG_STARTING</span><span class="p">,</span>
	<span class="n">IWL_AGG_ON</span><span class="p">,</span>
	<span class="n">IWL_EMPTYING_HW_QUEUE_ADDBA</span><span class="p">,</span>
	<span class="n">IWL_EMPTYING_HW_QUEUE_DELBA</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct iwl_ht_agg - aggregation state machine</span>

<span class="cm"> * This structs holds the states for the BA agreement establishment and tear</span>
<span class="cm"> * down. It also holds the state during the BA session itself. This struct is</span>
<span class="cm"> * duplicated for each RA / TID.</span>

<span class="cm"> * @rate_n_flags: Rate at which Tx was attempted. Holds the data between the</span>
<span class="cm"> *	Tx response (REPLY_TX), and the block ack notification</span>
<span class="cm"> *	(REPLY_COMPRESSED_BA).</span>
<span class="cm"> * @state: state of the BA agreement establishment / tear down.</span>
<span class="cm"> * @txq_id: Tx queue used by the BA session</span>
<span class="cm"> * @ssn: the first packet to be sent in AGG HW queue in Tx AGG start flow, or</span>
<span class="cm"> *	the first packet to be sent in legacy HW queue in Tx AGG stop flow.</span>
<span class="cm"> *	Basically when next_reclaimed reaches ssn, we can tell mac80211 that</span>
<span class="cm"> *	we are ready to finish the Tx AGG stop / start flow.</span>
<span class="cm"> * @wait_for_ba: Expect block-ack before next Tx reply</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_ht_agg</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">rate_n_flags</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">iwl_agg_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">txq_id</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ssn</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">wait_for_ba</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct iwl_tid_data - one for each RA / TID</span>

<span class="cm"> * This structs holds the states for each RA / TID.</span>

<span class="cm"> * @seq_number: the next WiFi sequence number to use</span>
<span class="cm"> * @next_reclaimed: the WiFi sequence number of the next packet to be acked.</span>
<span class="cm"> *	This is basically (last acked packet++).</span>
<span class="cm"> * @agg: aggregation state machine</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_tid_data</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">seq_number</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">next_reclaimed</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_ht_agg</span> <span class="n">agg</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Structure should be accessed with sta_lock held. When station addition</span>
<span class="cm"> * is in progress (IWL_STA_UCODE_INPROGRESS) it is possible to access only</span>
<span class="cm"> * the commands (iwl_addsta_cmd and iwl_link_quality_cmd) without sta_lock</span>
<span class="cm"> * held.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_station_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_addsta_cmd</span> <span class="n">sta</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">used</span><span class="p">,</span> <span class="n">ctxid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_link_quality_cmd</span> <span class="o">*</span><span class="n">lq</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * iwl_station_priv: Driver&#39;s private station information</span>
<span class="cm"> *</span>
<span class="cm"> * When mac80211 creates a station it reserves some space (hw-&gt;sta_data_size)</span>
<span class="cm"> * in the structure for use by driver. This structure is places in that</span>
<span class="cm"> * space.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_station_priv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_rxon_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_lq_sta</span> <span class="n">lq_sta</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">pending_frames</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">client</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">asleep</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">max_agg_bufsize</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">sta_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct iwl_vif_priv - driver&#39;s private per-interface information</span>
<span class="cm"> *</span>
<span class="cm"> * When mac80211 allocates a virtual interface, it can allocate</span>
<span class="cm"> * space for us to put data into.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_vif_priv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_rxon_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ibss_bssid_sta_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">iwl_sensitivity_ranges</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">min_nrg_cck</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">nrg_th_cck</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">nrg_th_ofdm</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">auto_corr_min_ofdm</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">auto_corr_min_ofdm_mrc</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">auto_corr_min_ofdm_x1</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">auto_corr_min_ofdm_mrc_x1</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">auto_corr_max_ofdm</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">auto_corr_max_ofdm_mrc</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">auto_corr_max_ofdm_x1</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">auto_corr_max_ofdm_mrc_x1</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">auto_corr_max_cck</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">auto_corr_max_cck_mrc</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">auto_corr_min_cck</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">auto_corr_min_cck_mrc</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">barker_corr_th_min</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">barker_corr_th_min_mrc</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">nrg_th_cca</span><span class="p">;</span>
<span class="p">};</span>


<span class="cp">#define KELVIN_TO_CELSIUS(x) ((x)-273)</span>
<span class="cp">#define CELSIUS_TO_KELVIN(x) ((x)+273)</span>


<span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Functions implemented in core module which are forward declared here</span>
<span class="cm"> * for use by iwl-[4-5].c</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  The implementation of these functions are not hardware specific</span>
<span class="cm"> * which is why they are in the core module files.</span>
<span class="cm"> *</span>
<span class="cm"> * Naming convention --</span>
<span class="cm"> * iwl_         &lt;-- Is part of iwlwifi</span>
<span class="cm"> * iwlXXXX_     &lt;-- Hardware specific (implemented in iwl-XXXX.c for XXXX)</span>
<span class="cm"> *</span>
<span class="cm"> ****************************************************************************/</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">iwl_update_chain_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">iwl_bcast_addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>

<span class="cp">#define IWL_OPERATION_MODE_AUTO     0</span>
<span class="cp">#define IWL_OPERATION_MODE_HT_ONLY  1</span>
<span class="cp">#define IWL_OPERATION_MODE_MIXED    2</span>
<span class="cp">#define IWL_OPERATION_MODE_20MHZ    3</span>

<span class="cp">#define TX_POWER_IWL_ILLEGAL_VOLTAGE -10000</span>

<span class="cm">/* Sensitivity and chain noise calibration */</span>
<span class="cp">#define INITIALIZATION_VALUE		0xFFFF</span>
<span class="cp">#define IWL_CAL_NUM_BEACONS		16</span>
<span class="cp">#define MAXIMUM_ALLOWED_PATHLOSS	15</span>

<span class="cp">#define CHAIN_NOISE_MAX_DELTA_GAIN_CODE 3</span>

<span class="cp">#define MAX_FA_OFDM  50</span>
<span class="cp">#define MIN_FA_OFDM  5</span>
<span class="cp">#define MAX_FA_CCK   50</span>
<span class="cp">#define MIN_FA_CCK   5</span>

<span class="cp">#define AUTO_CORR_STEP_OFDM       1</span>

<span class="cp">#define AUTO_CORR_STEP_CCK     3</span>
<span class="cp">#define AUTO_CORR_MAX_TH_CCK   160</span>

<span class="cp">#define NRG_DIFF               2</span>
<span class="cp">#define NRG_STEP_CCK           2</span>
<span class="cp">#define NRG_MARGIN             8</span>
<span class="cp">#define MAX_NUMBER_CCK_NO_FA 100</span>

<span class="cp">#define AUTO_CORR_CCK_MIN_VAL_DEF    (125)</span>

<span class="cp">#define CHAIN_A             0</span>
<span class="cp">#define CHAIN_B             1</span>
<span class="cp">#define CHAIN_C             2</span>
<span class="cp">#define CHAIN_NOISE_DELTA_GAIN_INIT_VAL 4</span>
<span class="cp">#define ALL_BAND_FILTER			0xFF00</span>
<span class="cp">#define IN_BAND_FILTER			0xFF</span>
<span class="cp">#define MIN_AVERAGE_NOISE_MAX_VALUE	0xFFFFFFFF</span>

<span class="cp">#define NRG_NUM_PREV_STAT_L     20</span>
<span class="cp">#define NUM_RX_CHAINS           3</span>

<span class="k">enum</span> <span class="n">iwlagn_false_alarm_state</span> <span class="p">{</span>
	<span class="n">IWL_FA_TOO_MANY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IWL_FA_TOO_FEW</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IWL_FA_GOOD_RANGE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">iwlagn_chain_noise_state</span> <span class="p">{</span>
	<span class="n">IWL_CHAIN_NOISE_ALIVE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>  <span class="cm">/* must be 0 */</span>
	<span class="n">IWL_CHAIN_NOISE_ACCUMULATE</span><span class="p">,</span>
	<span class="n">IWL_CHAIN_NOISE_CALIBRATED</span><span class="p">,</span>
	<span class="n">IWL_CHAIN_NOISE_DONE</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Sensitivity calib data */</span>
<span class="k">struct</span> <span class="n">iwl_sensitivity_data</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">auto_corr_ofdm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">auto_corr_ofdm_mrc</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">auto_corr_ofdm_x1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">auto_corr_ofdm_mrc_x1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">auto_corr_cck</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">auto_corr_cck_mrc</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">last_bad_plcp_cnt_ofdm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">last_fa_cnt_ofdm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">last_bad_plcp_cnt_cck</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">last_fa_cnt_cck</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">nrg_curr_state</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nrg_prev_state</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nrg_value</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
	<span class="n">u8</span>  <span class="n">nrg_silence_rssi</span><span class="p">[</span><span class="n">NRG_NUM_PREV_STAT_L</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">nrg_silence_ref</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nrg_energy_idx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nrg_silence_idx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nrg_th_cck</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">nrg_auto_corr_silence_diff</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num_in_cck_no_fa</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nrg_th_ofdm</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">barker_corr_th_min</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">barker_corr_th_min_mrc</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">nrg_th_cca</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Chain noise (differential Rx gain) calib data */</span>
<span class="k">struct</span> <span class="n">iwl_chain_noise_data</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">active_chains</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chain_noise_a</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chain_noise_b</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chain_noise_c</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chain_signal_a</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chain_signal_b</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chain_signal_c</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">beacon_count</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">disconn_array</span><span class="p">[</span><span class="n">NUM_RX_CHAINS</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">delta_gain_code</span><span class="p">[</span><span class="n">NUM_RX_CHAINS</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">radio_write</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">state</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">MEASUREMENT_READY</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">MEASUREMENT_ACTIVE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">iwl_nvm_type</span> <span class="p">{</span>
	<span class="n">NVM_DEVICE_TYPE_EEPROM</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">NVM_DEVICE_TYPE_OTP</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Two types of OTP memory access modes</span>
<span class="cm"> *   IWL_OTP_ACCESS_ABSOLUTE - absolute address mode,</span>
<span class="cm"> * 			        based on physical memory addressing</span>
<span class="cm"> *   IWL_OTP_ACCESS_RELATIVE - relative address mode,</span>
<span class="cm"> * 			       based on logical memory addressing</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">iwl_access_mode</span> <span class="p">{</span>
	<span class="n">IWL_OTP_ACCESS_ABSOLUTE</span><span class="p">,</span>
	<span class="n">IWL_OTP_ACCESS_RELATIVE</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* reply_tx_statistics (for _agn devices) */</span>
<span class="k">struct</span> <span class="n">reply_tx_error_statistics</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">pp_delay</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pp_few_bytes</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pp_bt_prio</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pp_quiet_period</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pp_calc_ttak</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">int_crossed_retry</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">short_limit</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">long_limit</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fifo_underrun</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">drain_flow</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rfkill_flush</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">life_expire</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dest_ps</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">host_abort</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bt_retry</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sta_invalid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">frag_drop</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tid_disable</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fifo_flush</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">insuff_cf_poll</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fail_hw_drop</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sta_color_mismatch</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">unknown</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* reply_agg_tx_statistics (for _agn devices) */</span>
<span class="k">struct</span> <span class="n">reply_agg_tx_error_statistics</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">underrun</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bt_prio</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">few_bytes</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">abort</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">last_sent_ttl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">last_sent_try</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">last_sent_bt_kill</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">scd_query</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bad_crc32</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">response</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dump_tx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">delay_tx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">unknown</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * schedule the timer to wake up every UCODE_TRACE_PERIOD milliseconds</span>
<span class="cm"> * to perform continuous uCode event logging operation if enabled</span>
<span class="cm"> */</span>
<span class="cp">#define UCODE_TRACE_PERIOD (10)</span>

<span class="cm">/*</span>
<span class="cm"> * iwl_event_log: current uCode event log position</span>
<span class="cm"> *</span>
<span class="cm"> * @ucode_trace: enable/disable ucode continuous trace timer</span>
<span class="cm"> * @num_wraps: how many times the event buffer wraps</span>
<span class="cm"> * @next_entry:  the entry just before the next one that uCode would fill</span>
<span class="cm"> * @non_wraps_count: counter for no wrap detected when dump ucode events</span>
<span class="cm"> * @wraps_once_count: counter for wrap once detected when dump ucode events</span>
<span class="cm"> * @wraps_more_count: counter for wrap more than once detected</span>
<span class="cm"> *		      when dump ucode events</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_event_log</span> <span class="p">{</span>
	<span class="n">bool</span> <span class="n">ucode_trace</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num_wraps</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">next_entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">non_wraps_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wraps_once_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wraps_more_count</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define IWL_DELAY_NEXT_FORCE_RF_RESET  (HZ*3)</span>

<span class="cm">/* BT Antenna Coupling Threshold (dB) */</span>
<span class="cp">#define IWL_BT_ANTENNA_COUPLING_THRESHOLD	(35)</span>

<span class="cm">/* Firmware reload counter and Timestamp */</span>
<span class="cp">#define IWL_MIN_RELOAD_DURATION		1000 </span><span class="cm">/* 1000 ms */</span><span class="cp"></span>
<span class="cp">#define IWL_MAX_CONTINUE_RELOAD_CNT	4</span>


<span class="k">struct</span> <span class="n">iwl_rf_reset</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">reset_request_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reset_success_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reset_reject_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_reset_jiffies</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">iwl_rxon_context_id</span> <span class="p">{</span>
	<span class="n">IWL_RXON_CTX_BSS</span><span class="p">,</span>
	<span class="n">IWL_RXON_CTX_PAN</span><span class="p">,</span>

	<span class="n">NUM_IWL_RXON_CTX</span>
<span class="p">};</span>

<span class="cm">/* extend beacon time format bit shifting  */</span>
<span class="cm">/*</span>
<span class="cm"> * for _agn devices</span>
<span class="cm"> * bits 31:22 - extended</span>
<span class="cm"> * bits 21:0  - interval</span>
<span class="cm"> */</span>
<span class="cp">#define IWLAGN_EXT_BEACON_TIME_POS	22</span>

<span class="k">struct</span> <span class="n">iwl_rxon_context</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">mcast_queue</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ac_to_queue</span><span class="p">[</span><span class="n">IEEE80211_NUM_ACS</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">ac_to_fifo</span><span class="p">[</span><span class="n">IEEE80211_NUM_ACS</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * We could use the vif to indicate active, but we</span>
<span class="cm">	 * also need it to be active during disabling when</span>
<span class="cm">	 * we already removed the vif for type setting.</span>
<span class="cm">	 */</span>
	<span class="n">bool</span> <span class="n">always_active</span><span class="p">,</span> <span class="n">is_active</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">ht_need_multiple_chains</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">iwl_rxon_context_id</span> <span class="n">ctxid</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">interface_modes</span><span class="p">,</span> <span class="n">exclusive_interface_modes</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">unused_devtype</span><span class="p">,</span> <span class="n">ap_devtype</span><span class="p">,</span> <span class="n">ibss_devtype</span><span class="p">,</span> <span class="n">station_devtype</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We declare this const so it can only be</span>
<span class="cm">	 * changed via explicit cast within the</span>
<span class="cm">	 * routines that actually update the physical</span>
<span class="cm">	 * hardware.</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">iwl_rxon_cmd</span> <span class="n">active</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_rxon_cmd</span> <span class="n">staging</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">iwl_rxon_time_cmd</span> <span class="n">timing</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">iwl_qos_info</span> <span class="n">qos_data</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">bcast_sta_id</span><span class="p">,</span> <span class="n">ap_sta_id</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">rxon_cmd</span><span class="p">,</span> <span class="n">rxon_assoc_cmd</span><span class="p">,</span> <span class="n">rxon_timing_cmd</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">qos_cmd</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">wep_key_cmd</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">iwl_wep_key</span> <span class="n">wep_keys</span><span class="p">[</span><span class="n">WEP_KEYS_MAX</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">key_mapping_keys</span><span class="p">;</span>

	<span class="n">__le32</span> <span class="n">station_flags</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">beacon_int</span><span class="p">;</span>

	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">bool</span> <span class="n">non_gf_sta_present</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">protection</span><span class="p">;</span>
		<span class="n">bool</span> <span class="n">enabled</span><span class="p">,</span> <span class="n">is_40mhz</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">extension_chan_offset</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ht</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">iwl_scan_type</span> <span class="p">{</span>
	<span class="n">IWL_SCAN_NORMAL</span><span class="p">,</span>
	<span class="n">IWL_SCAN_RADIO_RESET</span><span class="p">,</span>
	<span class="n">IWL_SCAN_ROC</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct iwl_hw_params</span>
<span class="cm"> *</span>
<span class="cm"> * Holds the module parameters</span>
<span class="cm"> *</span>
<span class="cm"> * @tx_chains_num: Number of TX chains</span>
<span class="cm"> * @rx_chains_num: Number of RX chains</span>
<span class="cm"> * @valid_tx_ant: usable antennas for TX</span>
<span class="cm"> * @valid_rx_ant: usable antennas for RX</span>
<span class="cm"> * @ht40_channel: is 40MHz width possible: BIT(IEEE80211_BAND_XXX)</span>
<span class="cm"> * @sku: sku read from EEPROM</span>
<span class="cm"> * @ct_kill_threshold: temperature threshold - in hw dependent unit</span>
<span class="cm"> * @ct_kill_exit_threshold: when to reeable the device - in hw dependent unit</span>
<span class="cm"> *	relevant for 1000, 6000 and up</span>
<span class="cm"> * @struct iwl_sensitivity_ranges: range of sensitivity values</span>
<span class="cm"> * @use_rts_for_aggregation: use rts/cts protection for HT traffic</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iwl_hw_params</span> <span class="p">{</span>
	<span class="n">u8</span>  <span class="n">tx_chains_num</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">rx_chains_num</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">valid_tx_ant</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">valid_rx_ant</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">ht40_channel</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">use_rts_for_aggregation</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">sku</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ct_kill_threshold</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ct_kill_exit_threshold</span><span class="p">;</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">iwl_sensitivity_ranges</span> <span class="o">*</span><span class="n">sens</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">iwl_lib_ops</span> <span class="p">{</span>
	<span class="cm">/* set hw dependent parameters */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_hw_params</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_channel_switch</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ieee80211_channel_switch</span> <span class="o">*</span><span class="n">ch_switch</span><span class="p">);</span>
	<span class="cm">/* device specific configuration */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">nic_config</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>

	<span class="cm">/* eeprom operations (as defined in iwl-eeprom.h) */</span>
	<span class="k">struct</span> <span class="n">iwl_eeprom_ops</span> <span class="n">eeprom_ops</span><span class="p">;</span>

	<span class="cm">/* temperature */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">temperature</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_IWLWIFI_DEVICE_TESTMODE</span>
<span class="k">struct</span> <span class="n">iwl_testmode_trace</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">buff_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">total_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num_chunks</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">cpu_addr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">trace_addr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">trace_enabled</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">iwl_testmode_mem</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">buff_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num_chunks</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">buff_addr</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">read_in_progress</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">iwl_wipan_noa_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu_head</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">[];</span>
<span class="p">};</span>

<span class="cm">/* Calibration disabling bit mask */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IWL_CALIB_ENABLE_ALL</span>			<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>

	<span class="n">IWL_SENSITIVITY_CALIB_DISABLED</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="n">IWL_CHAIN_NOISE_CALIB_DISABLED</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
	<span class="n">IWL_TX_POWER_CALIB_DISABLED</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>

	<span class="n">IWL_CALIB_DISABLE_ALL</span>			<span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define IWL_OP_MODE_GET_DVM(_iwl_op_mode) \</span>
<span class="cp">	((struct iwl_priv *) ((_iwl_op_mode)-&gt;op_mode_specific))</span>

<span class="cp">#define IWL_MAC80211_GET_DVM(_hw) \</span>
<span class="cp">	((struct iwl_priv *) ((struct iwl_op_mode *) \</span>
<span class="cp">	(_hw)-&gt;priv)-&gt;op_mode_specific)</span>

<span class="k">struct</span> <span class="n">iwl_priv</span> <span class="p">{</span>

	<span class="k">struct</span> <span class="n">iwl_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>		<span class="cm">/* for debug prints only */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">iwl_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">iwl_fw</span> <span class="o">*</span><span class="n">fw</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">iwl_lib_ops</span> <span class="o">*</span><span class="n">lib</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">spinlock_t</span> <span class="n">sta_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">transport_queue_stop</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">passive_no_rx</span><span class="p">;</span>
<span class="cp">#define IWL_INVALID_MAC80211_QUEUE	0xff</span>
	<span class="n">u8</span> <span class="n">queue_to_mac80211</span><span class="p">[</span><span class="n">IWL_MAX_HW_QUEUES</span><span class="p">];</span>
	<span class="n">atomic_t</span> <span class="n">queue_stop_count</span><span class="p">[</span><span class="n">IWL_MAX_HW_QUEUES</span><span class="p">];</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">agg_q_alloc</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">IWL_MAX_HW_QUEUES</span><span class="p">)];</span>

	<span class="cm">/* ieee device used by generic ieee processing code */</span>
	<span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">ieee_channels</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_rate</span> <span class="o">*</span><span class="n">ieee_rates</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">calib_results</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">workqueue</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">iwl_hw_params</span> <span class="n">hw_params</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">valid_contexts</span><span class="p">;</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pre_rx_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">iwl_rx_cmd_buffer</span> <span class="o">*</span><span class="n">rxb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rx_handlers</span><span class="p">[</span><span class="n">REPLY_MAX</span><span class="p">])(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">iwl_rx_cmd_buffer</span> <span class="o">*</span><span class="n">rxb</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">iwl_device_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">iwl_notif_wait_data</span> <span class="n">notif_wait</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ieee80211_supported_band</span> <span class="n">bands</span><span class="p">[</span><span class="n">IEEE80211_NUM_BANDS</span><span class="p">];</span>

	<span class="cm">/* spectrum measurement report caching */</span>
	<span class="k">struct</span> <span class="n">iwl_spectrum_notification</span> <span class="n">measure_report</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">measurement_status</span><span class="p">;</span>

<span class="cp">#define IWL_OWNERSHIP_DRIVER	0</span>
<span class="cp">#define IWL_OWNERSHIP_TM	1</span>
	<span class="n">u8</span> <span class="n">ucode_owner</span><span class="p">;</span>

	<span class="cm">/* ucode beacon time */</span>
	<span class="n">u32</span> <span class="n">ucode_beacon_time</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">missed_beacon_threshold</span><span class="p">;</span>

	<span class="cm">/* track IBSS manager (last beacon) status */</span>
	<span class="n">u32</span> <span class="n">ibss_manager</span><span class="p">;</span>

	<span class="cm">/* jiffies when last recovery from statistics was performed */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rx_statistics_jiffies</span><span class="p">;</span>

	<span class="cm">/*counters */</span>
	<span class="n">u32</span> <span class="n">rx_handlers_stats</span><span class="p">[</span><span class="n">REPLY_MAX</span><span class="p">];</span>

	<span class="cm">/* rf reset */</span>
	<span class="k">struct</span> <span class="n">iwl_rf_reset</span> <span class="n">rf_reset</span><span class="p">;</span>

	<span class="cm">/* firmware reload counter and timestamp */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reload_jiffies</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reload_count</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ucode_loaded</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">init_ucode_run</span><span class="p">;</span>		<span class="cm">/* Don&#39;t run init uCode again */</span>

	<span class="cm">/* we allocate array of iwl_channel_info for NIC&#39;s valid channels.</span>
<span class="cm">	 *    Access via channel # using indirect index array */</span>
	<span class="k">struct</span> <span class="n">iwl_channel_info</span> <span class="o">*</span><span class="n">channel_info</span><span class="p">;</span>	<span class="cm">/* channel info array */</span>
	<span class="n">u8</span> <span class="n">channel_count</span><span class="p">;</span>	<span class="cm">/* # of channels */</span>

	<span class="n">u8</span> <span class="n">plcp_delta_threshold</span><span class="p">;</span>

	<span class="cm">/* thermal calibration */</span>
	<span class="n">s32</span> <span class="n">temperature</span><span class="p">;</span>	<span class="cm">/* Celsius */</span>
	<span class="n">s32</span> <span class="n">last_temperature</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">iwl_wipan_noa_data</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">noa_data</span><span class="p">;</span>

	<span class="cm">/* Scan related variables */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">scan_start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">scan_start_tsf</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">scan_cmd</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">scan_band</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfg80211_scan_request</span> <span class="o">*</span><span class="n">scan_request</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">scan_vif</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">iwl_scan_type</span> <span class="n">scan_type</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">scan_tx_ant</span><span class="p">[</span><span class="n">IEEE80211_NUM_BANDS</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">mgmt_tx_ant</span><span class="p">;</span>

	<span class="cm">/* max number of station keys */</span>
	<span class="n">u8</span> <span class="n">sta_key_max_num</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">new_scan_threshold_behaviour</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">wowlan</span><span class="p">;</span>

	<span class="cm">/* EEPROM MAC addresses */</span>
	<span class="k">struct</span> <span class="n">mac_address</span> <span class="n">addresses</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">iwl_rxon_context</span> <span class="n">contexts</span><span class="p">[</span><span class="n">NUM_IWL_RXON_CTX</span><span class="p">];</span>

	<span class="n">__le16</span> <span class="n">switch_channel</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">start_calib</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_sensitivity_data</span> <span class="n">sensitivity_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_chain_noise_data</span> <span class="n">chain_noise_data</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">sensitivity_tbl</span><span class="p">[</span><span class="n">HD_TABLE_SIZE</span><span class="p">];</span>
	<span class="n">__le16</span> <span class="n">enhance_sensitivity_tbl</span><span class="p">[</span><span class="n">ENHANCE_HD_TABLE_ENTRIES</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">iwl_ht_config</span> <span class="n">current_ht_config</span><span class="p">;</span>

	<span class="cm">/* Rate scaling data */</span>
	<span class="n">u8</span> <span class="n">retry_rate</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">activity_timer_active</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">iwl_power_mgr</span> <span class="n">power_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_tt_mgmt</span> <span class="n">thermal_throttle</span><span class="p">;</span>

	<span class="cm">/* station table variables */</span>
	<span class="kt">int</span> <span class="n">num_stations</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_station_entry</span> <span class="n">stations</span><span class="p">[</span><span class="n">IWLAGN_STATION_COUNT</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ucode_key_table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_tid_data</span> <span class="n">tid_data</span><span class="p">[</span><span class="n">IWLAGN_STATION_COUNT</span><span class="p">][</span><span class="n">IWL_MAX_TID_COUNT</span><span class="p">];</span>

	<span class="n">u8</span> <span class="n">mac80211_registered</span><span class="p">;</span>

	<span class="cm">/* Indication if ieee80211_ops-&gt;open has been called */</span>
	<span class="n">u8</span> <span class="n">is_open</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">nl80211_iftype</span> <span class="n">iw_mode</span><span class="p">;</span>

	<span class="cm">/* Last Rx&#39;d beacon timestamp */</span>
	<span class="n">u64</span> <span class="n">timestamp</span><span class="p">;</span>

	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">__le32</span> <span class="n">flag</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">statistics_general_common</span> <span class="n">common</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">statistics_rx_non_phy</span> <span class="n">rx_non_phy</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">statistics_rx_phy</span> <span class="n">rx_ofdm</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">statistics_rx_ht_phy</span> <span class="n">rx_ofdm_ht</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">statistics_rx_phy</span> <span class="n">rx_cck</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">statistics_tx</span> <span class="n">tx</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_IWLWIFI_DEBUGFS</span>
		<span class="k">struct</span> <span class="n">statistics_bt_activity</span> <span class="n">bt_activity</span><span class="p">;</span>
		<span class="n">__le32</span> <span class="n">num_bt_kills</span><span class="p">,</span> <span class="n">accum_num_bt_kills</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">statistics</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_IWLWIFI_DEBUGFS</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">statistics_general_common</span> <span class="n">common</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">statistics_rx_non_phy</span> <span class="n">rx_non_phy</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">statistics_rx_phy</span> <span class="n">rx_ofdm</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">statistics_rx_ht_phy</span> <span class="n">rx_ofdm_ht</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">statistics_rx_phy</span> <span class="n">rx_cck</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">statistics_tx</span> <span class="n">tx</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">statistics_bt_activity</span> <span class="n">bt_activity</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">accum_stats</span><span class="p">,</span> <span class="n">delta_stats</span><span class="p">,</span> <span class="n">max_delta_stats</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * reporting the number of tids has AGG on. 0 means</span>
<span class="cm">	 * no AGGREGATION</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">agg_tids_count</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">iwl_rx_phy_res</span> <span class="n">last_phy_res</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">last_phy_res_valid</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * chain noise reset and gain commands are the</span>
<span class="cm">	 * two extra calibration commands follows the standard</span>
<span class="cm">	 * phy calibration commands</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">phy_calib_chain_noise_reset_cmd</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">phy_calib_chain_noise_gain_cmd</span><span class="p">;</span>

	<span class="cm">/* counts reply_tx error */</span>
	<span class="k">struct</span> <span class="n">reply_tx_error_statistics</span> <span class="n">reply_tx_stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reply_agg_tx_error_statistics</span> <span class="n">reply_agg_tx_stats</span><span class="p">;</span>

	<span class="cm">/* remain-on-channel offload support */</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">hw_roc_channel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">hw_roc_disable_work</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">nl80211_channel_type</span> <span class="n">hw_roc_chantype</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hw_roc_duration</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">hw_roc_setup</span><span class="p">,</span> <span class="n">hw_roc_start_notified</span><span class="p">;</span>

	<span class="cm">/* bt coex */</span>
	<span class="n">u8</span> <span class="n">bt_enable_flag</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bt_status</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bt_traffic_load</span><span class="p">,</span> <span class="n">last_bt_traffic_load</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">bt_ch_announce</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">bt_full_concurrent</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">bt_ant_couple_ok</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">kill_ack_mask</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">kill_cts_mask</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">bt_valid</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">reduced_txpower</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">bt_on_thresh</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">bt_duration</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">dynamic_frag_thresh</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bt_ci_compliance</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">bt_traffic_change_work</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">bt_enable_pspoll</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_rxon_context</span> <span class="o">*</span><span class="n">cur_rssi_ctx</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">bt_is_sco</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">restart</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">scan_completed</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">abort_scan</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">beacon_update</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_rxon_context</span> <span class="o">*</span><span class="n">beacon_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">beacon_skb</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">beacon_cmd</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">tt_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">ct_enter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">ct_exit</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">start_internal_scan</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">tx_flush</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">bt_full_concurrency</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">bt_runtime_config</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">scan_check</span><span class="p">;</span>

	<span class="cm">/* TX Power */</span>
	<span class="n">s8</span> <span class="n">tx_power_user_lmt</span><span class="p">;</span>
	<span class="n">s8</span> <span class="n">tx_power_device_lmt</span><span class="p">;</span>
	<span class="n">s8</span> <span class="n">tx_power_lmt_in_half_dbm</span><span class="p">;</span> <span class="cm">/* max tx power in half-dBm format */</span>
	<span class="n">s8</span> <span class="n">tx_power_next</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_IWLWIFI_DEBUGFS</span>
	<span class="cm">/* debugfs */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfs_dir</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dbgfs_sram_offset</span><span class="p">,</span> <span class="n">dbgfs_sram_len</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">disable_ht40</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">wowlan_sram</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IWLWIFI_DEBUGFS */</span><span class="cp"></span>

	<span class="cm">/* eeprom -- this is in the card&#39;s little endian byte order */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">eeprom</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">iwl_nvm_type</span> <span class="n">nvm_device_type</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">txpower_work</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">calib_disabled</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">run_time_calib_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">statistics_periodic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">ucode_trace</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">iwl_event_log</span> <span class="n">event_log</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">led_classdev</span> <span class="n">led</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">blink_on</span><span class="p">,</span> <span class="n">blink_off</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">led_registered</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_IWLWIFI_DEVICE_TESTMODE</span>
	<span class="k">struct</span> <span class="n">iwl_testmode_trace</span> <span class="n">testmode_trace</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwl_testmode_mem</span> <span class="n">testmode_mem</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tm_fixed_rate</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* WoWLAN GTK rekey data */</span>
	<span class="n">u8</span> <span class="n">kck</span><span class="p">[</span><span class="n">NL80211_KCK_LEN</span><span class="p">],</span> <span class="n">kek</span><span class="p">[</span><span class="n">NL80211_KEK_LEN</span><span class="p">];</span>
	<span class="n">__le64</span> <span class="n">replay_ctr</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">last_seq_ctl</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">have_rekey_data</span><span class="p">;</span>

	<span class="cm">/* device_pointers: pointers to ucode event tables */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">error_event_table</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">log_event_table</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">device_pointers</span><span class="p">;</span>

	<span class="cm">/* indicator of loaded ucode image */</span>
	<span class="k">enum</span> <span class="n">iwl_ucode_type</span> <span class="n">cur_ucode</span><span class="p">;</span>
<span class="p">};</span> <span class="cm">/*iwl_priv */</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">iwl_tx_cmd_pool</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">iwl_rxon_context</span> <span class="o">*</span>
<span class="nf">iwl_rxon_ctx_from_vif</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_vif_priv</span> <span class="o">*</span><span class="n">vif_priv</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">vif</span><span class="o">-&gt;</span><span class="n">drv_priv</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">vif_priv</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define for_each_context(priv, ctx)				\</span>
<span class="cp">	for (ctx = &amp;priv-&gt;contexts[IWL_RXON_CTX_BSS];		\</span>
<span class="cp">	     ctx &lt; &amp;priv-&gt;contexts[NUM_IWL_RXON_CTX]; ctx++)	\</span>
<span class="cp">		if (priv-&gt;valid_contexts &amp; BIT(ctx-&gt;ctxid))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">iwl_is_associated_ctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_rxon_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">.</span><span class="n">filter_flags</span> <span class="o">&amp;</span> <span class="n">RXON_FILTER_ASSOC_MSK</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">iwl_is_associated</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
				    <span class="k">enum</span> <span class="n">iwl_rxon_context_id</span> <span class="n">ctxid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">iwl_is_associated_ctx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">contexts</span><span class="p">[</span><span class="n">ctxid</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">iwl_is_any_associated</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwl_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwl_rxon_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="n">for_each_context</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iwl_is_associated_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_channel_valid</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">iwl_channel_info</span> <span class="o">*</span><span class="n">ch_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ch_info</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ch_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EEPROM_CHANNEL_VALID</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_channel_radar</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">iwl_channel_info</span> <span class="o">*</span><span class="n">ch_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ch_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EEPROM_CHANNEL_RADAR</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">is_channel_a_band</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">iwl_channel_info</span> <span class="o">*</span><span class="n">ch_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ch_info</span><span class="o">-&gt;</span><span class="n">band</span> <span class="o">==</span> <span class="n">IEEE80211_BAND_5GHZ</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">is_channel_bg_band</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">iwl_channel_info</span> <span class="o">*</span><span class="n">ch_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ch_info</span><span class="o">-&gt;</span><span class="n">band</span> <span class="o">==</span> <span class="n">IEEE80211_BAND_2GHZ</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_channel_passive</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">iwl_channel_info</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EEPROM_CHANNEL_ACTIVE</span><span class="p">))</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_channel_ibss</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">iwl_channel_info</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EEPROM_CHANNEL_IBSS</span><span class="p">))</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif				</span><span class="cm">/* __iwl_dev_h__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
