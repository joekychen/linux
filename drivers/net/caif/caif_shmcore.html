<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › caif › caif_shmcore.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>caif_shmcore.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) ST-Ericsson AB 2010</span>
<span class="cm"> * Contact: Sjur Brendeland / sjur.brandeland@stericsson.com</span>
<span class="cm"> * Authors:  Amarnath Revanna / amarnath.bangalore.revanna@stericsson.com,</span>
<span class="cm"> *           Daniel Martensson / daniel.martensson@stericsson.com</span>
<span class="cm"> * License terms: GNU General Public License (GPL) version 2</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;:&quot; fmt</span>

<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/if_arp.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>

<span class="cp">#include &lt;net/caif/caif_device.h&gt;</span>
<span class="cp">#include &lt;net/caif/caif_shm.h&gt;</span>

<span class="cp">#define NR_TX_BUF		6</span>
<span class="cp">#define NR_RX_BUF		6</span>
<span class="cp">#define TX_BUF_SZ		0x2000</span>
<span class="cp">#define RX_BUF_SZ		0x2000</span>

<span class="cp">#define CAIF_NEEDED_HEADROOM	32</span>

<span class="cp">#define CAIF_FLOW_ON		1</span>
<span class="cp">#define CAIF_FLOW_OFF		0</span>

<span class="cp">#define LOW_WATERMARK		3</span>
<span class="cp">#define HIGH_WATERMARK		4</span>

<span class="cm">/* Maximum number of CAIF buffers per shared memory buffer. */</span>
<span class="cp">#define SHM_MAX_FRMS_PER_BUF	10</span>

<span class="cm">/*</span>
<span class="cm"> * Size in bytes of the descriptor area</span>
<span class="cm"> * (With end of descriptor signalling)</span>
<span class="cm"> */</span>
<span class="cp">#define SHM_CAIF_DESC_SIZE	((SHM_MAX_FRMS_PER_BUF + 1) * \</span>
<span class="cp">					sizeof(struct shm_pck_desc))</span>

<span class="cm">/*</span>
<span class="cm"> * Offset to the first CAIF frame within a shared memory buffer.</span>
<span class="cm"> * Aligned on 32 bytes.</span>
<span class="cm"> */</span>
<span class="cp">#define SHM_CAIF_FRM_OFS	(SHM_CAIF_DESC_SIZE + (SHM_CAIF_DESC_SIZE % 32))</span>

<span class="cm">/* Number of bytes for CAIF shared memory header. */</span>
<span class="cp">#define SHM_HDR_LEN		1</span>

<span class="cm">/* Number of padding bytes for the complete CAIF frame. */</span>
<span class="cp">#define SHM_FRM_PAD_LEN		4</span>

<span class="cp">#define CAIF_MAX_MTU		4096</span>

<span class="cp">#define SHM_SET_FULL(x)	(((x+1) &amp; 0x0F) &lt;&lt; 0)</span>
<span class="cp">#define SHM_GET_FULL(x)	(((x &gt;&gt; 0) &amp; 0x0F) - 1)</span>

<span class="cp">#define SHM_SET_EMPTY(x)	(((x+1) &amp; 0x0F) &lt;&lt; 4)</span>
<span class="cp">#define SHM_GET_EMPTY(x)	(((x &gt;&gt; 4) &amp; 0x0F) - 1)</span>

<span class="cp">#define SHM_FULL_MASK		(0x0F &lt;&lt; 0)</span>
<span class="cp">#define SHM_EMPTY_MASK		(0x0F &lt;&lt; 4)</span>

<span class="k">struct</span> <span class="n">shm_pck_desc</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Offset from start of shared memory area to start of</span>
<span class="cm">	 * shared memory CAIF frame.</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">frm_ofs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">frm_len</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">buf_list</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">desc_vptr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">phy_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">frames</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">frm_ofs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">shm_caif_frm</span> <span class="p">{</span>
	<span class="cm">/* Number of bytes of padding before the CAIF frame. */</span>
	<span class="n">u8</span> <span class="n">hdr_ofs</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">shmdrv_layer</span> <span class="p">{</span>
	<span class="cm">/* caif_dev_common must always be first in the structure*/</span>
	<span class="k">struct</span> <span class="n">caif_dev_common</span> <span class="n">cfdev</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">shm_tx_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">shm_rx_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">shm_base_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx_empty_available</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tx_empty_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tx_pend_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tx_full_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rx_empty_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rx_pend_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rx_full_list</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">pshm_tx_workqueue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">pshm_rx_workqueue</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">shm_tx_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">shm_rx_work</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">sk_qhead</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shmdev_layer</span> <span class="o">*</span><span class="n">pshm_dev</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">shm_netdev_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">shm_netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">shm_netdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">shm_netdev_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">shm_netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">shm_netdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">caif_shmdrv_rx_cb</span><span class="p">(</span><span class="n">u32</span> <span class="n">mbx_msg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buf_list</span> <span class="o">*</span><span class="n">pbuf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shmdrv_layer</span> <span class="o">*</span><span class="n">pshm_drv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">avail_emptybuff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pshm_drv</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>

	<span class="cm">/* Check for received buffers. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mbx_msg</span> <span class="o">&amp;</span> <span class="n">SHM_FULL_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* Check whether we have any outstanding buffers. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">rx_empty_list</span><span class="p">))</span> <span class="p">{</span>

			<span class="cm">/* Release spin lock. */</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="cm">/* We print even in IRQ context... */</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;No empty Rx buffers to fill: &quot;</span>
					<span class="s">&quot;mbx_msg:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mbx_msg</span><span class="p">);</span>

			<span class="cm">/* Bail out. */</span>
			<span class="k">goto</span> <span class="n">err_sync</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pbuf</span> <span class="o">=</span>
			<span class="n">list_entry</span><span class="p">(</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">rx_empty_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">buf_list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>

		<span class="cm">/* Check buffer synchronization. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">!=</span> <span class="n">SHM_GET_FULL</span><span class="p">(</span><span class="n">mbx_msg</span><span class="p">))</span> <span class="p">{</span>

			<span class="cm">/* We print even in IRQ context... */</span>
			<span class="n">pr_warn</span><span class="p">(</span>
			<span class="s">&quot;phyif_shm_mbx_msg_cb: RX full out of sync:&quot;</span>
			<span class="s">&quot; idx:%d, msg:%x SHM_GET_FULL(mbx_msg):%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">idx</span><span class="p">,</span> <span class="n">mbx_msg</span><span class="p">,</span> <span class="n">SHM_GET_FULL</span><span class="p">(</span><span class="n">mbx_msg</span><span class="p">));</span>

			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="cm">/* Bail out. */</span>
			<span class="k">goto</span> <span class="n">err_sync</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">rx_full_list</span><span class="p">);</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* Schedule RX work queue. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">work_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">shm_rx_work</span><span class="p">))</span>
			<span class="n">queue_work</span><span class="p">(</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">pshm_rx_workqueue</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">shm_rx_work</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Check for emptied buffers. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mbx_msg</span> <span class="o">&amp;</span> <span class="n">SHM_EMPTY_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* Check whether we have any outstanding buffers. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">tx_full_list</span><span class="p">))</span> <span class="p">{</span>

			<span class="cm">/* We print even in IRQ context... */</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;No TX to empty: msg:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mbx_msg</span><span class="p">);</span>

			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="cm">/* Bail out. */</span>
			<span class="k">goto</span> <span class="n">err_sync</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pbuf</span> <span class="o">=</span>
			<span class="n">list_entry</span><span class="p">(</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">tx_full_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">buf_list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>

		<span class="cm">/* Check buffer synchronization. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">!=</span> <span class="n">SHM_GET_EMPTY</span><span class="p">(</span><span class="n">mbx_msg</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="cm">/* We print even in IRQ context... */</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;TX empty &quot;</span>
				<span class="s">&quot;out of sync:idx:%d, msg:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">mbx_msg</span><span class="p">);</span>

			<span class="cm">/* Bail out. */</span>
			<span class="k">goto</span> <span class="n">err_sync</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

		<span class="cm">/* Reset buffer parameters. */</span>
		<span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">frames</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">frm_ofs</span> <span class="o">=</span> <span class="n">SHM_CAIF_FRM_OFS</span><span class="p">;</span>

		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">tx_empty_list</span><span class="p">);</span>

		<span class="cm">/* Check the available no. of buffers in the empty list */</span>
		<span class="n">list_for_each</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">tx_empty_list</span><span class="p">)</span>
			<span class="n">avail_emptybuff</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* Check whether we have to wake up the transmitter. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">avail_emptybuff</span> <span class="o">&gt;</span> <span class="n">HIGH_WATERMARK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="p">(</span><span class="o">!</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">tx_empty_available</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">tx_empty_available</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">cfdev</span><span class="p">.</span><span class="n">flowctrl</span>
					<span class="p">(</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">pshm_dev</span><span class="o">-&gt;</span><span class="n">pshm_netdev</span><span class="p">,</span>
								<span class="n">CAIF_FLOW_ON</span><span class="p">);</span>


			<span class="cm">/* Schedule the work queue. if required */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">work_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">shm_tx_work</span><span class="p">))</span>
				<span class="n">queue_work</span><span class="p">(</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">pshm_tx_workqueue</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">shm_tx_work</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_sync:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">shm_rx_work_func</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">rx_work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">shmdrv_layer</span> <span class="o">*</span><span class="n">pshm_drv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buf_list</span> <span class="o">*</span><span class="n">pbuf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pshm_drv</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">rx_work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">shmdrv_layer</span><span class="p">,</span> <span class="n">shm_rx_work</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">struct</span> <span class="n">shm_pck_desc</span> <span class="o">*</span><span class="n">pck_desc</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* Check for received buffers. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">rx_full_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pbuf</span> <span class="o">=</span>
			<span class="n">list_entry</span><span class="p">(</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">rx_full_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buf_list</span><span class="p">,</span>
					<span class="n">list</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* Retrieve pointer to start of the packet descriptor area. */</span>
		<span class="n">pck_desc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">shm_pck_desc</span> <span class="o">*</span><span class="p">)</span> <span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">desc_vptr</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check whether descriptor contains a CAIF shared memory</span>
<span class="cm">		 * frame.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">pck_desc</span><span class="o">-&gt;</span><span class="n">frm_ofs</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frm_buf_ofs</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frm_pck_ofs</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frm_pck_len</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Check whether offset is within buffer limits</span>
<span class="cm">			 * (lower).</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pck_desc</span><span class="o">-&gt;</span><span class="n">frm_ofs</span> <span class="o">&lt;</span>
				<span class="p">(</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">phy_addr</span> <span class="o">-</span> <span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">shm_base_addr</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Check whether offset is within buffer limits</span>
<span class="cm">			 * (higher).</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pck_desc</span><span class="o">-&gt;</span><span class="n">frm_ofs</span> <span class="o">&gt;</span>
				<span class="p">((</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">phy_addr</span> <span class="o">-</span> <span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">shm_base_addr</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="cm">/* Calculate offset from start of buffer. */</span>
			<span class="n">frm_buf_ofs</span> <span class="o">=</span>
				<span class="n">pck_desc</span><span class="o">-&gt;</span><span class="n">frm_ofs</span> <span class="o">-</span> <span class="p">(</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">phy_addr</span> <span class="o">-</span>
						<span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">shm_base_addr</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Calculate offset and length of CAIF packet while</span>
<span class="cm">			 * taking care of the shared memory header.</span>
<span class="cm">			 */</span>
			<span class="n">frm_pck_ofs</span> <span class="o">=</span>
				<span class="n">frm_buf_ofs</span> <span class="o">+</span> <span class="n">SHM_HDR_LEN</span> <span class="o">+</span>
				<span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">desc_vptr</span> <span class="o">+</span> <span class="n">frm_buf_ofs</span><span class="p">));</span>
			<span class="n">frm_pck_len</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">pck_desc</span><span class="o">-&gt;</span><span class="n">frm_len</span> <span class="o">-</span> <span class="n">SHM_HDR_LEN</span> <span class="o">-</span>
				<span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">desc_vptr</span> <span class="o">+</span> <span class="n">frm_buf_ofs</span><span class="p">)));</span>

			<span class="cm">/* Check whether CAIF packet is within buffer limits */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">frm_pck_ofs</span> <span class="o">+</span> <span class="n">pck_desc</span><span class="o">-&gt;</span><span class="n">frm_len</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="cm">/* Get a suitable CAIF packet and copy in data. */</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">pshm_dev</span><span class="o">-&gt;</span><span class="n">pshm_netdev</span><span class="p">,</span>
							<span class="n">frm_pck_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;OOM: Try next frame in descriptor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">p</span> <span class="o">=</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">frm_pck_len</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">desc_vptr</span> <span class="o">+</span> <span class="n">frm_pck_ofs</span><span class="p">,</span> <span class="n">frm_pck_len</span><span class="p">);</span>

			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_CAIF</span><span class="p">);</span>
			<span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">pshm_dev</span><span class="o">-&gt;</span><span class="n">pshm_netdev</span><span class="p">;</span>

			<span class="cm">/* Push received packet up the stack. */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">netif_rx_ni</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">pshm_dev</span><span class="o">-&gt;</span><span class="n">pshm_netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span>
								<span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
				<span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">pshm_dev</span><span class="o">-&gt;</span><span class="n">pshm_netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span>
						<span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">pck_desc</span><span class="o">-&gt;</span><span class="n">frm_len</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="o">++</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">pshm_dev</span><span class="o">-&gt;</span><span class="n">pshm_netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span>
								<span class="n">rx_dropped</span><span class="p">;</span>
			<span class="cm">/* Move to next packet descriptor. */</span>
			<span class="n">pck_desc</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">rx_pend_list</span><span class="p">);</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="cm">/* Schedule the work queue. if required */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">work_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">shm_tx_work</span><span class="p">))</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">pshm_tx_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">shm_tx_work</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">shm_tx_work_func</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">tx_work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mbox_msg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frmlen</span><span class="p">,</span> <span class="n">avail_emptybuff</span><span class="p">,</span> <span class="n">append</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buf_list</span> <span class="o">*</span><span class="n">pbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shmdrv_layer</span> <span class="o">*</span><span class="n">pshm_drv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shm_caif_frm</span> <span class="o">*</span><span class="n">frm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shm_pck_desc</span> <span class="o">*</span><span class="n">pck_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

	<span class="n">pshm_drv</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">tx_work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">shmdrv_layer</span><span class="p">,</span> <span class="n">shm_tx_work</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* Initialize mailbox message. */</span>
		<span class="n">mbox_msg</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
		<span class="n">avail_emptybuff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* Check for pending receive buffers. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">rx_pend_list</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">pbuf</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">rx_pend_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">buf_list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">rx_empty_list</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Value index is never changed,</span>
<span class="cm">			 * so read access should be safe.</span>
<span class="cm">			 */</span>
			<span class="n">mbox_msg</span> <span class="o">|=</span> <span class="n">SHM_SET_EMPTY</span><span class="p">(</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">sk_qhead</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">send_msg</span><span class="p">;</span>
		<span class="cm">/* Check the available no. of buffers in the empty list */</span>
		<span class="n">list_for_each</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">tx_empty_list</span><span class="p">)</span>
			<span class="n">avail_emptybuff</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">avail_emptybuff</span> <span class="o">&lt;</span> <span class="n">LOW_WATERMARK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">tx_empty_available</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Update blocking condition. */</span>
			<span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">tx_empty_available</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">cfdev</span><span class="p">.</span><span class="n">flowctrl</span>
					<span class="p">(</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">pshm_dev</span><span class="o">-&gt;</span><span class="n">pshm_netdev</span><span class="p">,</span>
					<span class="n">CAIF_FLOW_OFF</span><span class="p">);</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * We simply return back to the caller if we do not have space</span>
<span class="cm">		 * either in Tx pending list or Tx empty list. In this case,</span>
<span class="cm">		 * we hold the received skb in the skb list, waiting to</span>
<span class="cm">		 * be transmitted once Tx buffers become available</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">tx_empty_list</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">send_msg</span><span class="p">;</span>

		<span class="cm">/* Get the first free Tx buffer. */</span>
		<span class="n">pbuf</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">tx_empty_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">buf_list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">append</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">sk_qhead</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">frm</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">shm_caif_frm</span> <span class="o">*</span><span class="p">)</span>
					<span class="p">(</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">desc_vptr</span> <span class="o">+</span> <span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">frm_ofs</span><span class="p">);</span>

			<span class="n">frm</span><span class="o">-&gt;</span><span class="n">hdr_ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">frmlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">frmlen</span> <span class="o">+=</span> <span class="n">SHM_HDR_LEN</span> <span class="o">+</span> <span class="n">frm</span><span class="o">-&gt;</span><span class="n">hdr_ofs</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

			<span class="cm">/* Add tail padding if needed. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">frmlen</span> <span class="o">%</span> <span class="n">SHM_FRM_PAD_LEN</span><span class="p">)</span>
				<span class="n">frmlen</span> <span class="o">+=</span> <span class="n">SHM_FRM_PAD_LEN</span> <span class="o">-</span>
						<span class="p">(</span><span class="n">frmlen</span> <span class="o">%</span> <span class="n">SHM_FRM_PAD_LEN</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Verify that packet, header and additional padding</span>
<span class="cm">			 * can fit within the buffer frame area.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">frmlen</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">frm_ofs</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">append</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
				<span class="n">append</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">sk_qhead</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* Copy in CAIF frame. */</span>
			<span class="n">skb_copy_bits</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">desc_vptr</span> <span class="o">+</span>
					<span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">frm_ofs</span> <span class="o">+</span> <span class="n">SHM_HDR_LEN</span> <span class="o">+</span>
						<span class="n">frm</span><span class="o">-&gt;</span><span class="n">hdr_ofs</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

			<span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">pshm_dev</span><span class="o">-&gt;</span><span class="n">pshm_netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
			<span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">pshm_dev</span><span class="o">-&gt;</span><span class="n">pshm_netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span>
									<span class="n">frmlen</span><span class="p">;</span>
			<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

			<span class="cm">/* Fill in the shared memory packet descriptor area. */</span>
			<span class="n">pck_desc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">shm_pck_desc</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">desc_vptr</span><span class="p">);</span>
			<span class="cm">/* Forward to current frame. */</span>
			<span class="n">pck_desc</span> <span class="o">+=</span> <span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">;</span>
			<span class="n">pck_desc</span><span class="o">-&gt;</span><span class="n">frm_ofs</span> <span class="o">=</span> <span class="p">(</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">phy_addr</span> <span class="o">-</span>
						<span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">shm_base_addr</span><span class="p">)</span> <span class="o">+</span>
								<span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">frm_ofs</span><span class="p">;</span>
			<span class="n">pck_desc</span><span class="o">-&gt;</span><span class="n">frm_len</span> <span class="o">=</span> <span class="n">frmlen</span><span class="p">;</span>
			<span class="cm">/* Terminate packet descriptor area. */</span>
			<span class="n">pck_desc</span><span class="o">++</span><span class="p">;</span>
			<span class="n">pck_desc</span><span class="o">-&gt;</span><span class="n">frm_ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* Update buffer parameters. */</span>
			<span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">frames</span><span class="o">++</span><span class="p">;</span>
			<span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">frm_ofs</span> <span class="o">+=</span> <span class="n">frmlen</span> <span class="o">+</span> <span class="p">(</span><span class="n">frmlen</span> <span class="o">%</span> <span class="mi">32</span><span class="p">);</span>

		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">frames</span> <span class="o">&lt;</span> <span class="n">SHM_MAX_FRMS_PER_BUF</span><span class="p">);</span>

		<span class="cm">/* Assign buffer as full. */</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">tx_full_list</span><span class="p">);</span>
		<span class="n">append</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mbox_msg</span> <span class="o">|=</span> <span class="n">SHM_SET_FULL</span><span class="p">(</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
<span class="nl">send_msg:</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mbox_msg</span><span class="p">)</span>
			<span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">pshm_dev</span><span class="o">-&gt;</span><span class="n">pshmdev_mbxsend</span>
					<span class="p">(</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">pshm_dev</span><span class="o">-&gt;</span><span class="n">shm_id</span><span class="p">,</span> <span class="n">mbox_msg</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">mbox_msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">shm_netdev_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">shm_netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">shmdrv_layer</span> <span class="o">*</span><span class="n">pshm_drv</span><span class="p">;</span>

	<span class="n">pshm_drv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">shm_netdev</span><span class="p">);</span>

	<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">sk_qhead</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Schedule Tx work queue. for deferred processing of skbs*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">work_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">shm_tx_work</span><span class="p">))</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">pshm_tx_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">shm_tx_work</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span> <span class="o">=</span> <span class="n">shm_netdev_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span> <span class="o">=</span> <span class="n">shm_netdev_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span> <span class="o">=</span> <span class="n">shm_netdev_tx</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">shm_netdev_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">pshm_netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">shmdrv_layer</span> <span class="o">*</span><span class="n">pshm_drv</span><span class="p">;</span>
	<span class="n">pshm_netdev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">netdev_ops</span><span class="p">;</span>

	<span class="n">pshm_netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">CAIF_MAX_MTU</span><span class="p">;</span>
	<span class="n">pshm_netdev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">ARPHRD_CAIF</span><span class="p">;</span>
	<span class="n">pshm_netdev</span><span class="o">-&gt;</span><span class="n">hard_header_len</span> <span class="o">=</span> <span class="n">CAIF_NEEDED_HEADROOM</span><span class="p">;</span>
	<span class="n">pshm_netdev</span><span class="o">-&gt;</span><span class="n">tx_queue_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pshm_netdev</span><span class="o">-&gt;</span><span class="n">destructor</span> <span class="o">=</span> <span class="n">free_netdev</span><span class="p">;</span>

	<span class="n">pshm_drv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">pshm_netdev</span><span class="p">);</span>

	<span class="cm">/* Initialize structures in a clean state. */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pshm_drv</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmdrv_layer</span><span class="p">));</span>

	<span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">cfdev</span><span class="p">.</span><span class="n">link_select</span> <span class="o">=</span> <span class="n">CAIF_LINK_LOW_LATENCY</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">caif_shmcore_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmdev_layer</span> <span class="o">*</span><span class="n">pshm_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shmdrv_layer</span> <span class="o">*</span><span class="n">pshm_drv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">pshm_dev</span><span class="o">-&gt;</span><span class="n">pshm_netdev</span> <span class="o">=</span> <span class="n">alloc_netdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmdrv_layer</span><span class="p">),</span>
						<span class="s">&quot;cfshm%d&quot;</span><span class="p">,</span> <span class="n">shm_netdev_setup</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pshm_dev</span><span class="o">-&gt;</span><span class="n">pshm_netdev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">pshm_drv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">pshm_dev</span><span class="o">-&gt;</span><span class="n">pshm_netdev</span><span class="p">);</span>
	<span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">pshm_dev</span> <span class="o">=</span> <span class="n">pshm_dev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialization starts with the verification of the</span>
<span class="cm">	 * availability of MBX driver by calling its setup function.</span>
<span class="cm">	 * MBX driver must be available by this time for proper</span>
<span class="cm">	 * functioning of SHM driver.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pshm_dev</span><span class="o">-&gt;</span><span class="n">pshmdev_mbxsetup</span>
				<span class="p">(</span><span class="n">caif_shmdrv_rx_cb</span><span class="p">,</span> <span class="n">pshm_dev</span><span class="p">,</span> <span class="n">pshm_drv</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Could not config. SHM Mailbox,&quot;</span>
				<span class="s">&quot; Bailing out.....</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">free_netdev</span><span class="p">(</span><span class="n">pshm_dev</span><span class="o">-&gt;</span><span class="n">pshm_netdev</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">sk_qhead</span><span class="p">);</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;SHM DEVICE[%d] PROBED BY DRIVER, NEW SHM DRIVER&quot;</span>
			<span class="s">&quot; INSTANCE AT pshm_drv =0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">pshm_dev</span><span class="o">-&gt;</span><span class="n">shm_id</span><span class="p">,</span> <span class="n">pshm_drv</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pshm_dev</span><span class="o">-&gt;</span><span class="n">shm_total_sz</span> <span class="o">&lt;</span>
			<span class="p">(</span><span class="n">NR_TX_BUF</span> <span class="o">*</span> <span class="n">TX_BUF_SZ</span> <span class="o">+</span> <span class="n">NR_RX_BUF</span> <span class="o">*</span> <span class="n">RX_BUF_SZ</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;ERROR, Amount of available&quot;</span>
				<span class="s">&quot; Phys. SHM cannot accommodate current SHM &quot;</span>
				<span class="s">&quot;driver configuration, Bailing out ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">free_netdev</span><span class="p">(</span><span class="n">pshm_dev</span><span class="o">-&gt;</span><span class="n">pshm_netdev</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">shm_base_addr</span> <span class="o">=</span> <span class="n">pshm_dev</span><span class="o">-&gt;</span><span class="n">shm_base_addr</span><span class="p">;</span>
	<span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">shm_tx_addr</span> <span class="o">=</span> <span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">shm_base_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pshm_dev</span><span class="o">-&gt;</span><span class="n">shm_loopback</span><span class="p">)</span>
		<span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">shm_rx_addr</span> <span class="o">=</span> <span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">shm_tx_addr</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">shm_rx_addr</span> <span class="o">=</span> <span class="n">pshm_dev</span><span class="o">-&gt;</span><span class="n">shm_base_addr</span> <span class="o">+</span>
						<span class="p">(</span><span class="n">NR_TX_BUF</span> <span class="o">*</span> <span class="n">TX_BUF_SZ</span><span class="p">);</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">tx_empty_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">tx_pend_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">tx_full_list</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">rx_empty_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">rx_pend_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">rx_full_list</span><span class="p">);</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">shm_tx_work</span><span class="p">,</span> <span class="n">shm_tx_work_func</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">shm_rx_work</span><span class="p">,</span> <span class="n">shm_rx_work_func</span><span class="p">);</span>

	<span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">pshm_tx_workqueue</span> <span class="o">=</span>
				<span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="s">&quot;shm_tx_work&quot;</span><span class="p">);</span>
	<span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">pshm_rx_workqueue</span> <span class="o">=</span>
				<span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="s">&quot;shm_rx_work&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">NR_TX_BUF</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buf_list</span> <span class="o">*</span><span class="n">tx_buf</span> <span class="o">=</span>
				<span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">buf_list</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tx_buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;ERROR, Could not&quot;</span>
					<span class="s">&quot; allocate dynamic mem. for tx_buf,&quot;</span>
					<span class="s">&quot; Bailing out ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">free_netdev</span><span class="p">(</span><span class="n">pshm_dev</span><span class="o">-&gt;</span><span class="n">pshm_netdev</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tx_buf</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
		<span class="n">tx_buf</span><span class="o">-&gt;</span><span class="n">phy_addr</span> <span class="o">=</span> <span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">shm_tx_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">TX_BUF_SZ</span> <span class="o">*</span> <span class="n">j</span><span class="p">);</span>
		<span class="n">tx_buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">TX_BUF_SZ</span><span class="p">;</span>
		<span class="n">tx_buf</span><span class="o">-&gt;</span><span class="n">frames</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tx_buf</span><span class="o">-&gt;</span><span class="n">frm_ofs</span> <span class="o">=</span> <span class="n">SHM_CAIF_FRM_OFS</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pshm_dev</span><span class="o">-&gt;</span><span class="n">shm_loopback</span><span class="p">)</span>
			<span class="n">tx_buf</span><span class="o">-&gt;</span><span class="n">desc_vptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">tx_buf</span><span class="o">-&gt;</span><span class="n">phy_addr</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="cm">/*</span>
<span class="cm">			 * FIXME: the result of ioremap is not a pointer - arnd</span>
<span class="cm">			 */</span>
			<span class="n">tx_buf</span><span class="o">-&gt;</span><span class="n">desc_vptr</span> <span class="o">=</span>
					<span class="n">ioremap</span><span class="p">(</span><span class="n">tx_buf</span><span class="o">-&gt;</span><span class="n">phy_addr</span><span class="p">,</span> <span class="n">TX_BUF_SZ</span><span class="p">);</span>

		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_buf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">tx_empty_list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">NR_RX_BUF</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buf_list</span> <span class="o">*</span><span class="n">rx_buf</span> <span class="o">=</span>
				<span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">buf_list</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rx_buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;ERROR, Could not&quot;</span>
					<span class="s">&quot; allocate dynamic mem.for rx_buf,&quot;</span>
					<span class="s">&quot; Bailing out ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">free_netdev</span><span class="p">(</span><span class="n">pshm_dev</span><span class="o">-&gt;</span><span class="n">pshm_netdev</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rx_buf</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
		<span class="n">rx_buf</span><span class="o">-&gt;</span><span class="n">phy_addr</span> <span class="o">=</span> <span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">shm_rx_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">RX_BUF_SZ</span> <span class="o">*</span> <span class="n">j</span><span class="p">);</span>
		<span class="n">rx_buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">RX_BUF_SZ</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pshm_dev</span><span class="o">-&gt;</span><span class="n">shm_loopback</span><span class="p">)</span>
			<span class="n">rx_buf</span><span class="o">-&gt;</span><span class="n">desc_vptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">rx_buf</span><span class="o">-&gt;</span><span class="n">phy_addr</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">rx_buf</span><span class="o">-&gt;</span><span class="n">desc_vptr</span> <span class="o">=</span>
					<span class="n">ioremap</span><span class="p">(</span><span class="n">rx_buf</span><span class="o">-&gt;</span><span class="n">phy_addr</span><span class="p">,</span> <span class="n">RX_BUF_SZ</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx_buf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">rx_empty_list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">tx_empty_available</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">pshm_dev</span><span class="o">-&gt;</span><span class="n">pshm_netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;ERROR[%d], SHM could not, &quot;</span>
			<span class="s">&quot;register with NW FRMWK Bailing out ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">caif_shmcore_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">pshm_netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buf_list</span> <span class="o">*</span><span class="n">pbuf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shmdrv_layer</span> <span class="o">*</span><span class="n">pshm_drv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">pshm_drv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">pshm_netdev</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">tx_pend_list</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">pbuf</span> <span class="o">=</span>
			<span class="n">list_entry</span><span class="p">(</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">tx_pend_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">buf_list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pbuf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">tx_full_list</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">pbuf</span> <span class="o">=</span>
			<span class="n">list_entry</span><span class="p">(</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">tx_full_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">buf_list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pbuf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">tx_empty_list</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">pbuf</span> <span class="o">=</span>
			<span class="n">list_entry</span><span class="p">(</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">tx_empty_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">buf_list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pbuf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">rx_full_list</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">pbuf</span> <span class="o">=</span>
			<span class="n">list_entry</span><span class="p">(</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">tx_full_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">buf_list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pbuf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">rx_pend_list</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">pbuf</span> <span class="o">=</span>
			<span class="n">list_entry</span><span class="p">(</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">tx_pend_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">buf_list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pbuf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">rx_empty_list</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">pbuf</span> <span class="o">=</span>
			<span class="n">list_entry</span><span class="p">(</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">rx_empty_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">buf_list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pbuf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pbuf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Destroy work queues. */</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">pshm_tx_workqueue</span><span class="p">);</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">pshm_drv</span><span class="o">-&gt;</span><span class="n">pshm_rx_workqueue</span><span class="p">);</span>

	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">pshm_netdev</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
