<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › vmxnet3 › vmxnet3_int.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>vmxnet3_int.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Linux driver for VMware&#39;s vmxnet3 ethernet NIC.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008-2009, VMware, Inc. All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the</span>
<span class="cm"> * Free Software Foundation; version 2 of the License and no later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> * NON INFRINGEMENT.  See the GNU General Public License for more</span>
<span class="cm"> * details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.</span>
<span class="cm"> *</span>
<span class="cm"> * The full GNU General Public License is included in this distribution in</span>
<span class="cm"> * the file called &quot;COPYING&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * Maintained by: Shreyas Bhatewara &lt;pv-drivers@vmware.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _VMXNET3_INT_H</span>
<span class="cp">#define _VMXNET3_INT_H</span>

<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/dma.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>

<span class="cp">#include &lt;linux/tcp.h&gt;</span>
<span class="cp">#include &lt;linux/udp.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/ipv6.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;asm/checksum.h&gt;</span>
<span class="cp">#include &lt;linux/if_vlan.h&gt;</span>
<span class="cp">#include &lt;linux/if_arp.h&gt;</span>
<span class="cp">#include &lt;linux/inetdevice.h&gt;</span>
<span class="cp">#include &lt;linux/log2.h&gt;</span>

<span class="cp">#include &quot;vmxnet3_defs.h&quot;</span>

<span class="cp">#ifdef DEBUG</span>
<span class="cp"># define VMXNET3_DRIVER_VERSION_REPORT VMXNET3_DRIVER_VERSION_STRING&quot;-NAPI(debug)&quot;</span>
<span class="cp">#else</span>
<span class="cp"># define VMXNET3_DRIVER_VERSION_REPORT VMXNET3_DRIVER_VERSION_STRING&quot;-NAPI&quot;</span>
<span class="cp">#endif</span>


<span class="cm">/*</span>
<span class="cm"> * Version numbers</span>
<span class="cm"> */</span>
<span class="cp">#define VMXNET3_DRIVER_VERSION_STRING   &quot;1.1.29.0-k&quot;</span>

<span class="cm">/* a 32-bit int, each byte encode a verion number in VMXNET3_DRIVER_VERSION */</span>
<span class="cp">#define VMXNET3_DRIVER_VERSION_NUM      0x01011D00</span>

<span class="cp">#if defined(CONFIG_PCI_MSI)</span>
	<span class="cm">/* RSS only makes sense if MSI-X is supported. */</span>
	<span class="cp">#define VMXNET3_RSS</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Capabilities</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">VMNET_CAP_SG</span>	        <span class="o">=</span> <span class="mh">0x0001</span><span class="p">,</span> <span class="cm">/* Can do scatter-gather transmits. */</span>
	<span class="n">VMNET_CAP_IP4_CSUM</span>      <span class="o">=</span> <span class="mh">0x0002</span><span class="p">,</span> <span class="cm">/* Can checksum only TCP/UDP over</span>
<span class="cm">					   * IPv4 */</span>
	<span class="n">VMNET_CAP_HW_CSUM</span>       <span class="o">=</span> <span class="mh">0x0004</span><span class="p">,</span> <span class="cm">/* Can checksum all packets. */</span>
	<span class="n">VMNET_CAP_HIGH_DMA</span>      <span class="o">=</span> <span class="mh">0x0008</span><span class="p">,</span> <span class="cm">/* Can DMA to high memory. */</span>
	<span class="n">VMNET_CAP_TOE</span>	        <span class="o">=</span> <span class="mh">0x0010</span><span class="p">,</span> <span class="cm">/* Supports TCP/IP offload. */</span>
	<span class="n">VMNET_CAP_TSO</span>	        <span class="o">=</span> <span class="mh">0x0020</span><span class="p">,</span> <span class="cm">/* Supports TCP Segmentation</span>
<span class="cm">					   * offload */</span>
	<span class="n">VMNET_CAP_SW_TSO</span>        <span class="o">=</span> <span class="mh">0x0040</span><span class="p">,</span> <span class="cm">/* Supports SW TCP Segmentation */</span>
	<span class="n">VMNET_CAP_VMXNET_APROM</span>  <span class="o">=</span> <span class="mh">0x0080</span><span class="p">,</span> <span class="cm">/* Vmxnet APROM support */</span>
	<span class="n">VMNET_CAP_HW_TX_VLAN</span>    <span class="o">=</span> <span class="mh">0x0100</span><span class="p">,</span> <span class="cm">/* Can we do VLAN tagging in HW */</span>
	<span class="n">VMNET_CAP_HW_RX_VLAN</span>    <span class="o">=</span> <span class="mh">0x0200</span><span class="p">,</span> <span class="cm">/* Can we do VLAN untagging in HW */</span>
	<span class="n">VMNET_CAP_SW_VLAN</span>       <span class="o">=</span> <span class="mh">0x0400</span><span class="p">,</span> <span class="cm">/* VLAN tagging/untagging in SW */</span>
	<span class="n">VMNET_CAP_WAKE_PCKT_RCV</span> <span class="o">=</span> <span class="mh">0x0800</span><span class="p">,</span> <span class="cm">/* Can wake on network packet recv? */</span>
	<span class="n">VMNET_CAP_ENABLE_INT_INLINE</span> <span class="o">=</span> <span class="mh">0x1000</span><span class="p">,</span>  <span class="cm">/* Enable Interrupt Inline */</span>
	<span class="n">VMNET_CAP_ENABLE_HEADER_COPY</span> <span class="o">=</span> <span class="mh">0x2000</span><span class="p">,</span>  <span class="cm">/* copy header for vmkernel */</span>
	<span class="n">VMNET_CAP_TX_CHAIN</span>      <span class="o">=</span> <span class="mh">0x4000</span><span class="p">,</span> <span class="cm">/* Guest can use multiple tx entries</span>
<span class="cm">					  * for a pkt */</span>
	<span class="n">VMNET_CAP_RX_CHAIN</span>      <span class="o">=</span> <span class="mh">0x8000</span><span class="p">,</span> <span class="cm">/* pkt can span multiple rx entries */</span>
	<span class="n">VMNET_CAP_LPD</span>           <span class="o">=</span> <span class="mh">0x10000</span><span class="p">,</span> <span class="cm">/* large pkt delivery */</span>
	<span class="n">VMNET_CAP_BPF</span>           <span class="o">=</span> <span class="mh">0x20000</span><span class="p">,</span> <span class="cm">/* BPF Support in VMXNET Virtual HW*/</span>
	<span class="n">VMNET_CAP_SG_SPAN_PAGES</span> <span class="o">=</span> <span class="mh">0x40000</span><span class="p">,</span> <span class="cm">/* Scatter-gather can span multiple*/</span>
					   <span class="cm">/* pages transmits */</span>
	<span class="n">VMNET_CAP_IP6_CSUM</span>      <span class="o">=</span> <span class="mh">0x80000</span><span class="p">,</span> <span class="cm">/* Can do IPv6 csum offload. */</span>
	<span class="n">VMNET_CAP_TSO6</span>         <span class="o">=</span> <span class="mh">0x100000</span><span class="p">,</span> <span class="cm">/* TSO seg. offload for IPv6 pkts. */</span>
	<span class="n">VMNET_CAP_TSO256k</span>      <span class="o">=</span> <span class="mh">0x200000</span><span class="p">,</span> <span class="cm">/* Can do TSO seg offload for */</span>
					   <span class="cm">/* pkts up to 256kB. */</span>
	<span class="n">VMNET_CAP_UPT</span>          <span class="o">=</span> <span class="mh">0x400000</span>  <span class="cm">/* Support UPT */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * PCI vendor and device IDs.</span>
<span class="cm"> */</span>
<span class="cp">#define PCI_VENDOR_ID_VMWARE            0x15AD</span>
<span class="cp">#define PCI_DEVICE_ID_VMWARE_VMXNET3    0x07B0</span>
<span class="cp">#define MAX_ETHERNET_CARDS		10</span>
<span class="cp">#define MAX_PCI_PASSTHRU_DEVICE		6</span>

<span class="k">struct</span> <span class="n">vmxnet3_cmd_ring</span> <span class="p">{</span>
	<span class="k">union</span> <span class="n">Vmxnet3_GenericDesc</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">size</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">next2fill</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">next2comp</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">gen</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>	<span class="n">basePA</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">vmxnet3_cmd_ring_adv_next2fill</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_cmd_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">next2fill</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">next2fill</span> <span class="o">==</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">next2fill</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">VMXNET3_FLIP_RING_GEN</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">gen</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">vmxnet3_cmd_ring_adv_next2comp</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_cmd_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VMXNET3_INC_RING_IDX_ONLY</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">next2comp</span><span class="p">,</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">vmxnet3_cmd_ring_desc_avail</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_cmd_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">next2comp</span> <span class="o">&gt;</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">next2fill</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">next2comp</span> <span class="o">-</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">next2fill</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">vmxnet3_comp_ring</span> <span class="p">{</span>
	<span class="k">union</span> <span class="n">Vmxnet3_GenericDesc</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="n">u32</span>               <span class="n">size</span><span class="p">;</span>
	<span class="n">u32</span>               <span class="n">next2proc</span><span class="p">;</span>
	<span class="n">u8</span>                <span class="n">gen</span><span class="p">;</span>
	<span class="n">u8</span>                <span class="n">intr_idx</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>           <span class="n">basePA</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">vmxnet3_comp_ring_adv_next2proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_comp_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">next2proc</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">next2proc</span> <span class="o">==</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">next2proc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">VMXNET3_FLIP_RING_GEN</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">gen</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">vmxnet3_tx_data_ring</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">Vmxnet3_TxDataDesc</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="n">u32</span>              <span class="n">size</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>          <span class="n">basePA</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">vmxnet3_buf_map_type</span> <span class="p">{</span>
	<span class="n">VMXNET3_MAP_INVALID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">VMXNET3_MAP_NONE</span><span class="p">,</span>
	<span class="n">VMXNET3_MAP_SINGLE</span><span class="p">,</span>
	<span class="n">VMXNET3_MAP_PAGE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vmxnet3_tx_buf_info</span> <span class="p">{</span>
	<span class="n">u32</span>      <span class="n">map_type</span><span class="p">;</span>
	<span class="n">u16</span>      <span class="n">len</span><span class="p">;</span>
	<span class="n">u16</span>      <span class="n">sop_idx</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>  <span class="n">dma_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vmxnet3_tq_driver_stats</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">drop_total</span><span class="p">;</span>     <span class="cm">/* # of pkts dropped by the driver, the</span>
<span class="cm">				* counters below track droppings due to</span>
<span class="cm">				* different reasons</span>
<span class="cm">				*/</span>
	<span class="n">u64</span> <span class="n">drop_too_many_frags</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">drop_oversized_hdr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">drop_hdr_inspect_err</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">drop_tso</span><span class="p">;</span>

	<span class="n">u64</span> <span class="n">tx_ring_full</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">linearized</span><span class="p">;</span>         <span class="cm">/* # of pkts linearized */</span>
	<span class="n">u64</span> <span class="n">copy_skb_header</span><span class="p">;</span>    <span class="cm">/* # of times we have to copy skb header */</span>
	<span class="n">u64</span> <span class="n">oversized_hdr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vmxnet3_tx_ctx</span> <span class="p">{</span>
	<span class="n">bool</span>   <span class="n">ipv4</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">mss</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">eth_ip_hdr_size</span><span class="p">;</span> <span class="cm">/* only valid for pkts requesting tso or csum</span>
<span class="cm">				 * offloading</span>
<span class="cm">				 */</span>
	<span class="n">u32</span> <span class="n">l4_hdr_size</span><span class="p">;</span>     <span class="cm">/* only valid if mss != 0 */</span>
	<span class="n">u32</span> <span class="n">copy_size</span><span class="p">;</span>       <span class="cm">/* # of bytes copied into the data ring */</span>
	<span class="k">union</span> <span class="n">Vmxnet3_GenericDesc</span> <span class="o">*</span><span class="n">sop_txd</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">Vmxnet3_GenericDesc</span> <span class="o">*</span><span class="n">eop_txd</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vmxnet3_tx_queue</span> <span class="p">{</span>
	<span class="kt">char</span>			<span class="n">name</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="o">+</span><span class="mi">8</span><span class="p">];</span> <span class="cm">/* To identify interrupt */</span>
	<span class="k">struct</span> <span class="n">vmxnet3_adapter</span>		<span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="n">spinlock_t</span>                      <span class="n">tx_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmxnet3_cmd_ring</span>         <span class="n">tx_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmxnet3_tx_buf_info</span>      <span class="o">*</span><span class="n">buf_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmxnet3_tx_data_ring</span>     <span class="n">data_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmxnet3_comp_ring</span>        <span class="n">comp_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Vmxnet3_TxQueueCtrl</span>      <span class="o">*</span><span class="n">shared</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmxnet3_tq_driver_stats</span>  <span class="n">stats</span><span class="p">;</span>
	<span class="n">bool</span>                            <span class="n">stopped</span><span class="p">;</span>
	<span class="kt">int</span>                             <span class="n">num_stop</span><span class="p">;</span>  <span class="cm">/* # of times the queue is</span>
<span class="cm">						    * stopped */</span>
	<span class="kt">int</span>				<span class="n">qid</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">__aligned__</span><span class="p">(</span><span class="n">SMP_CACHE_BYTES</span><span class="p">)));</span>

<span class="k">enum</span> <span class="n">vmxnet3_rx_buf_type</span> <span class="p">{</span>
	<span class="n">VMXNET3_RX_BUF_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">VMXNET3_RX_BUF_SKB</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">VMXNET3_RX_BUF_PAGE</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vmxnet3_rx_buf_info</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">vmxnet3_rx_buf_type</span> <span class="n">buf_type</span><span class="p">;</span>
	<span class="n">u16</span>     <span class="n">len</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span>    <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vmxnet3_rx_ctx</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sop_idx</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vmxnet3_rq_driver_stats</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">drop_total</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">drop_err</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">drop_fcs</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_buf_alloc_failure</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vmxnet3_rx_queue</span> <span class="p">{</span>
	<span class="kt">char</span>			<span class="n">name</span><span class="p">[</span><span class="n">IFNAMSIZ</span> <span class="o">+</span> <span class="mi">8</span><span class="p">];</span> <span class="cm">/* To identify interrupt */</span>
	<span class="k">struct</span> <span class="n">vmxnet3_adapter</span>	  <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">napi_struct</span>        <span class="n">napi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmxnet3_cmd_ring</span>   <span class="n">rx_ring</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">vmxnet3_comp_ring</span>  <span class="n">comp_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmxnet3_rx_ctx</span>     <span class="n">rx_ctx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">qid</span><span class="p">;</span>            <span class="cm">/* rqID in RCD for buffer from 1st ring */</span>
	<span class="n">u32</span> <span class="n">qid2</span><span class="p">;</span>           <span class="cm">/* rqID in RCD for buffer from 2nd ring */</span>
	<span class="n">u32</span> <span class="n">uncommitted</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="cm">/* # of buffers allocated since last RXPROD</span>
<span class="cm">				* update */</span>
	<span class="k">struct</span> <span class="n">vmxnet3_rx_buf_info</span>     <span class="o">*</span><span class="n">buf_info</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">Vmxnet3_RxQueueCtrl</span>            <span class="o">*</span><span class="n">shared</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmxnet3_rq_driver_stats</span>  <span class="n">stats</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">__aligned__</span><span class="p">(</span><span class="n">SMP_CACHE_BYTES</span><span class="p">)));</span>

<span class="cp">#define VMXNET3_DEVICE_MAX_TX_QUEUES 8</span>
<span class="cp">#define VMXNET3_DEVICE_MAX_RX_QUEUES 8   </span><span class="cm">/* Keep this value as a power of 2 */</span><span class="cp"></span>

<span class="cm">/* Should be less than UPT1_RSS_MAX_IND_TABLE_SIZE */</span>
<span class="cp">#define VMXNET3_RSS_IND_TABLE_SIZE (VMXNET3_DEVICE_MAX_RX_QUEUES * 4)</span>

<span class="cp">#define VMXNET3_LINUX_MAX_MSIX_VECT     (VMXNET3_DEVICE_MAX_TX_QUEUES + \</span>
<span class="cp">					 VMXNET3_DEVICE_MAX_RX_QUEUES + 1)</span>
<span class="cp">#define VMXNET3_LINUX_MIN_MSIX_VECT     2 </span><span class="cm">/* 1 for tx-rx pair and 1 for event */</span><span class="cp"></span>


<span class="k">struct</span> <span class="n">vmxnet3_intr</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">vmxnet3_intr_mask_mode</span>  <span class="n">mask_mode</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">vmxnet3_intr_type</span>       <span class="n">type</span><span class="p">;</span>	<span class="cm">/* MSI-X, MSI, or INTx? */</span>
	<span class="n">u8</span>  <span class="n">num_intrs</span><span class="p">;</span>			<span class="cm">/* # of intr vectors */</span>
	<span class="n">u8</span>  <span class="n">event_intr_idx</span><span class="p">;</span>		<span class="cm">/* idx of the intr vector for event */</span>
	<span class="n">u8</span>  <span class="n">mod_levels</span><span class="p">[</span><span class="n">VMXNET3_LINUX_MAX_MSIX_VECT</span><span class="p">];</span> <span class="cm">/* moderation level */</span>
	<span class="kt">char</span>	<span class="n">event_msi_vector_name</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="o">+</span><span class="mi">11</span><span class="p">];</span>
<span class="cp">#ifdef CONFIG_PCI_MSI</span>
	<span class="k">struct</span> <span class="n">msix_entry</span> <span class="n">msix_entries</span><span class="p">[</span><span class="n">VMXNET3_LINUX_MAX_MSIX_VECT</span><span class="p">];</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/* Interrupt sharing schemes, share_intr */</span>
<span class="cp">#define VMXNET3_INTR_BUDDYSHARE 0    </span><span class="cm">/* Corresponding tx,rx queues share irq */</span><span class="cp"></span>
<span class="cp">#define VMXNET3_INTR_TXSHARE 1	     </span><span class="cm">/* All tx queues share one irq */</span><span class="cp"></span>
<span class="cp">#define VMXNET3_INTR_DONTSHARE 2     </span><span class="cm">/* each queue has its own irq */</span><span class="cp"></span>


<span class="cp">#define VMXNET3_STATE_BIT_RESETTING   0</span>
<span class="cp">#define VMXNET3_STATE_BIT_QUIESCED    1</span>
<span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmxnet3_tx_queue</span>		<span class="n">tx_queue</span><span class="p">[</span><span class="n">VMXNET3_DEVICE_MAX_TX_QUEUES</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">vmxnet3_rx_queue</span>		<span class="n">rx_queue</span><span class="p">[</span><span class="n">VMXNET3_DEVICE_MAX_RX_QUEUES</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">active_vlans</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">VLAN_N_VID</span><span class="p">)];</span>
	<span class="k">struct</span> <span class="n">vmxnet3_intr</span>		<span class="n">intr</span><span class="p">;</span>
	<span class="n">spinlock_t</span>			<span class="n">cmd_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Vmxnet3_DriverShared</span>	<span class="o">*</span><span class="n">shared</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Vmxnet3_PMConf</span>		<span class="o">*</span><span class="n">pm_conf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Vmxnet3_TxQueueDesc</span>	<span class="o">*</span><span class="n">tqd_start</span><span class="p">;</span>     <span class="cm">/* all tx queue desc */</span>
	<span class="k">struct</span> <span class="n">Vmxnet3_RxQueueDesc</span>	<span class="o">*</span><span class="n">rqd_start</span><span class="p">;</span>	<span class="cm">/* all rx queue desc */</span>
	<span class="k">struct</span> <span class="n">net_device</span>		<span class="o">*</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span>			<span class="o">*</span><span class="n">pdev</span><span class="p">;</span>

	<span class="n">u8</span>			<span class="n">__iomem</span> <span class="o">*</span><span class="n">hw_addr0</span><span class="p">;</span> <span class="cm">/* for BAR 0 */</span>
	<span class="n">u8</span>			<span class="n">__iomem</span> <span class="o">*</span><span class="n">hw_addr1</span><span class="p">;</span> <span class="cm">/* for BAR 1 */</span>

<span class="cp">#ifdef VMXNET3_RSS</span>
	<span class="k">struct</span> <span class="n">UPT1_RSSConf</span>		<span class="o">*</span><span class="n">rss_conf</span><span class="p">;</span>
	<span class="n">bool</span>				<span class="n">rss</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">u32</span>				<span class="n">num_rx_queues</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">num_tx_queues</span><span class="p">;</span>

	<span class="cm">/* rx buffer related */</span>
	<span class="kt">unsigned</span>			<span class="n">skb_buf_size</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">rx_buf_per_pkt</span><span class="p">;</span>  <span class="cm">/* only apply to the 1st ring */</span>
	<span class="n">dma_addr_t</span>			<span class="n">shared_pa</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">queue_desc_pa</span><span class="p">;</span>

	<span class="cm">/* Wake-on-LAN */</span>
	<span class="n">u32</span>     <span class="n">wol</span><span class="p">;</span>

	<span class="cm">/* Link speed */</span>
	<span class="n">u32</span>     <span class="n">link_speed</span><span class="p">;</span> <span class="cm">/* in mbps */</span>

	<span class="n">u64</span>     <span class="n">tx_timeout_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">work</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">state</span><span class="p">;</span>    <span class="cm">/* VMXNET3_STATE_BIT_xxx */</span>

	<span class="kt">int</span> <span class="n">dev_number</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">share_intr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define VMXNET3_WRITE_BAR0_REG(adapter, reg, val)  \</span>
<span class="cp">	writel((val), (adapter)-&gt;hw_addr0 + (reg))</span>
<span class="cp">#define VMXNET3_READ_BAR0_REG(adapter, reg)        \</span>
<span class="cp">	readl((adapter)-&gt;hw_addr0 + (reg))</span>

<span class="cp">#define VMXNET3_WRITE_BAR1_REG(adapter, reg, val)  \</span>
<span class="cp">	writel((val), (adapter)-&gt;hw_addr1 + (reg))</span>
<span class="cp">#define VMXNET3_READ_BAR1_REG(adapter, reg)        \</span>
<span class="cp">	readl((adapter)-&gt;hw_addr1 + (reg))</span>

<span class="cp">#define VMXNET3_WAKE_QUEUE_THRESHOLD(tq)  (5)</span>
<span class="cp">#define VMXNET3_RX_ALLOC_THRESHOLD(rq, ring_idx, adapter) \</span>
<span class="cp">	((rq)-&gt;rx_ring[ring_idx].size &gt;&gt; 3)</span>

<span class="cp">#define VMXNET3_GET_ADDR_LO(dma)   ((u32)(dma))</span>
<span class="cp">#define VMXNET3_GET_ADDR_HI(dma)   ((u32)(((u64)(dma)) &gt;&gt; 32))</span>

<span class="cm">/* must be a multiple of VMXNET3_RING_SIZE_ALIGN */</span>
<span class="cp">#define VMXNET3_DEF_TX_RING_SIZE    512</span>
<span class="cp">#define VMXNET3_DEF_RX_RING_SIZE    256</span>

<span class="cp">#define VMXNET3_MAX_ETH_HDR_SIZE    22</span>
<span class="cp">#define VMXNET3_MAX_SKB_BUF_SIZE    (3*1024)</span>

<span class="kt">int</span>
<span class="n">vmxnet3_quiesce_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>

<span class="kt">int</span>
<span class="n">vmxnet3_activate_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>

<span class="kt">void</span>
<span class="n">vmxnet3_force_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>

<span class="kt">void</span>
<span class="n">vmxnet3_reset_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>

<span class="kt">void</span>
<span class="n">vmxnet3_tq_destroy_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>

<span class="kt">void</span>
<span class="n">vmxnet3_rq_destroy_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>

<span class="kt">int</span>
<span class="n">vmxnet3_set_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">);</span>

<span class="kt">int</span>
<span class="n">vmxnet3_create_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
		      <span class="n">u32</span> <span class="n">tx_ring_size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">rx_ring_size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">rx_ring2_size</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">vmxnet3_set_ethtool_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span>
<span class="n">vmxnet3_get_stats64</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="n">stats</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">char</span> <span class="n">vmxnet3_driver_name</span><span class="p">[];</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
