<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › vmxnet3 › vmxnet3_drv.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>vmxnet3_drv.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Linux driver for VMware&#39;s vmxnet3 ethernet NIC.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008-2009, VMware, Inc. All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the</span>
<span class="cm"> * Free Software Foundation; version 2 of the License and no later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> * NON INFRINGEMENT. See the GNU General Public License for more</span>
<span class="cm"> * details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.</span>
<span class="cm"> *</span>
<span class="cm"> * The full GNU General Public License is included in this distribution in</span>
<span class="cm"> * the file called &quot;COPYING&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * Maintained by: Shreyas Bhatewara &lt;pv-drivers@vmware.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;net/ip6_checksum.h&gt;</span>

<span class="cp">#include &quot;vmxnet3_int.h&quot;</span>

<span class="kt">char</span> <span class="n">vmxnet3_driver_name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;vmxnet3&quot;</span><span class="p">;</span>
<span class="cp">#define VMXNET3_DRIVER_DESC &quot;VMware vmxnet3 virtual NIC driver&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * PCI Device ID Table</span>
<span class="cm"> * Last entry must be all 0s</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">vmxnet3_pciid_table</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">VMWARE</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_VMWARE_VMXNET3</span><span class="p">)},</span>
	<span class="p">{</span><span class="mi">0</span><span class="p">}</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">vmxnet3_pciid_table</span><span class="p">);</span>

<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">devices_found</span><span class="p">;</span>

<span class="cp">#define VMXNET3_MAX_DEVICES 10</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">enable_mq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irq_share_mode</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="n">vmxnet3_write_mac_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *    Enable/Disable the given intr</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_enable_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">intr_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VMXNET3_WRITE_BAR0_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_IMR</span> <span class="o">+</span> <span class="n">intr_idx</span> <span class="o">*</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_disable_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">intr_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VMXNET3_WRITE_BAR0_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_IMR</span> <span class="o">+</span> <span class="n">intr_idx</span> <span class="o">*</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *    Enable/Disable all intrs used by the device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_enable_all_intrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">num_intrs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">vmxnet3_enable_intr</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">devRead</span><span class="p">.</span><span class="n">intrConf</span><span class="p">.</span><span class="n">intrCtrl</span> <span class="o">&amp;=</span>
					<span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="n">VMXNET3_IC_DISABLE_ALL</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_disable_all_intrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">devRead</span><span class="p">.</span><span class="n">intrConf</span><span class="p">.</span><span class="n">intrCtrl</span> <span class="o">|=</span>
					<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">VMXNET3_IC_DISABLE_ALL</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">num_intrs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">vmxnet3_disable_intr</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_ack_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">events</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VMXNET3_WRITE_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_ECR</span><span class="p">,</span> <span class="n">events</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">bool</span>
<span class="nf">vmxnet3_tq_stopped</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_tx_queue</span> <span class="o">*</span><span class="n">tq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">stopped</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_tq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_tx_queue</span> <span class="o">*</span><span class="n">tq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tq</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">netif_start_subqueue</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="n">tq</span> <span class="o">-</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_tq_wake</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_tx_queue</span> <span class="o">*</span><span class="n">tq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tq</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">netif_wake_subqueue</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="p">(</span><span class="n">tq</span> <span class="o">-</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">));</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_tq_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_tx_queue</span> <span class="o">*</span><span class="n">tq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tq</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">tq</span><span class="o">-&gt;</span><span class="n">num_stop</span><span class="o">++</span><span class="p">;</span>
	<span class="n">netif_stop_subqueue</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="p">(</span><span class="n">tq</span> <span class="o">-</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Check the link state. This may start or stop the tx queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_check_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">bool</span> <span class="n">affectTxQueue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">VMXNET3_WRITE_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_CMD</span><span class="p">,</span> <span class="n">VMXNET3_CMD_GET_LINK</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">VMXNET3_READ_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_CMD</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Link is up. */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: NIC Link is Up %d Mbps</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">))</span>
			<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">affectTxQueue</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">vmxnet3_tq_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						 <span class="n">adapter</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: NIC Link is Down</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">))</span>
			<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">affectTxQueue</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">vmxnet3_tq_stop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">adapter</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_process_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">events</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">ecr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">events</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">vmxnet3_ack_events</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">events</span><span class="p">);</span>

	<span class="cm">/* Check if link state has changed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">VMXNET3_ECR_LINK</span><span class="p">)</span>
		<span class="n">vmxnet3_check_link</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="cm">/* Check if there is an error on xmit/recv queues */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VMXNET3_ECR_TQERR</span> <span class="o">|</span> <span class="n">VMXNET3_ECR_RQERR</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">VMXNET3_WRITE_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_CMD</span><span class="p">,</span>
				       <span class="n">VMXNET3_CMD_GET_QUEUE_STATUS</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tqd_start</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status</span><span class="p">.</span><span class="n">stopped</span><span class="p">)</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;%s: tq[%d] error 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tqd_start</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status</span><span class="p">.</span><span class="n">error</span><span class="p">));</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rqd_start</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status</span><span class="p">.</span><span class="n">stopped</span><span class="p">)</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;%s: rq[%d] error 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rqd_start</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status</span><span class="p">.</span><span class="n">error</span><span class="p">);</span>

		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef __BIG_ENDIAN_BITFIELD</span>
<span class="cm">/*</span>
<span class="cm"> * The device expects the bitfields in shared structures to be written in</span>
<span class="cm"> * little endian. When CPU is big endian, the following routines are used to</span>
<span class="cm"> * correctly read and write into ABI.</span>
<span class="cm"> * The general technique used here is : double word bitfields are defined in</span>
<span class="cm"> * opposite order for big endian architecture. Then before reading them in</span>
<span class="cm"> * driver the complete double word is translated using le32_to_cpu. Similarly</span>
<span class="cm"> * After the driver writes into bitfields, cpu_to_le32 is used to translate the</span>
<span class="cm"> * double words into required format.</span>
<span class="cm"> * In order to avoid touching bits in shared structure more than once, temporary</span>
<span class="cm"> * descriptors are used. These are passed as srcDesc to following functions.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmxnet3_RxDescToCPU</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">Vmxnet3_RxDesc</span> <span class="o">*</span><span class="n">srcDesc</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">Vmxnet3_RxDesc</span> <span class="o">*</span><span class="n">dstDesc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">srcDesc</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">dstDesc</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">dstDesc</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">srcDesc</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">src</span><span class="p">);</span>
	<span class="n">dstDesc</span><span class="o">-&gt;</span><span class="n">ext1</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">srcDesc</span><span class="o">-&gt;</span><span class="n">ext1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmxnet3_TxDescToLe</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">Vmxnet3_TxDesc</span> <span class="o">*</span><span class="n">srcDesc</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">Vmxnet3_TxDesc</span> <span class="o">*</span><span class="n">dstDesc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">srcDesc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">dstDesc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Working backwards so that the gen bit is set at the end. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">src</span><span class="o">--</span><span class="p">;</span>
		<span class="n">dst</span><span class="o">--</span><span class="p">;</span>
		<span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">*</span><span class="n">src</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmxnet3_RxCompToCPU</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">Vmxnet3_RxCompDesc</span> <span class="o">*</span><span class="n">srcDesc</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">Vmxnet3_RxCompDesc</span> <span class="o">*</span><span class="n">dstDesc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">srcDesc</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">dstDesc</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_RxCompDesc</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">src</span><span class="p">);</span>
		<span class="n">src</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dst</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/* Used to read bitfield values from double words. */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">get_bitfield32</span><span class="p">(</span><span class="k">const</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">bitfield</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pos</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">bitfield</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">pos</span><span class="p">;</span>
	<span class="n">temp</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">temp</span> <span class="o">&gt;&gt;=</span> <span class="n">pos</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>



<span class="cp">#endif  </span><span class="cm">/* __BIG_ENDIAN_BITFIELD */</span><span class="cp"></span>

<span class="cp">#ifdef __BIG_ENDIAN_BITFIELD</span>

<span class="cp">#   define VMXNET3_TXDESC_GET_GEN(txdesc) get_bitfield32(((const __le32 *) \</span>
<span class="cp">			txdesc) + VMXNET3_TXD_GEN_DWORD_SHIFT, \</span>
<span class="cp">			VMXNET3_TXD_GEN_SHIFT, VMXNET3_TXD_GEN_SIZE)</span>
<span class="cp">#   define VMXNET3_TXDESC_GET_EOP(txdesc) get_bitfield32(((const __le32 *) \</span>
<span class="cp">			txdesc) + VMXNET3_TXD_EOP_DWORD_SHIFT, \</span>
<span class="cp">			VMXNET3_TXD_EOP_SHIFT, VMXNET3_TXD_EOP_SIZE)</span>
<span class="cp">#   define VMXNET3_TCD_GET_GEN(tcd) get_bitfield32(((const __le32 *)tcd) + \</span>
<span class="cp">			VMXNET3_TCD_GEN_DWORD_SHIFT, VMXNET3_TCD_GEN_SHIFT, \</span>
<span class="cp">			VMXNET3_TCD_GEN_SIZE)</span>
<span class="cp">#   define VMXNET3_TCD_GET_TXIDX(tcd) get_bitfield32((const __le32 *)tcd, \</span>
<span class="cp">			VMXNET3_TCD_TXIDX_SHIFT, VMXNET3_TCD_TXIDX_SIZE)</span>
<span class="cp">#   define vmxnet3_getRxComp(dstrcd, rcd, tmp) do { \</span>
<span class="cp">			(dstrcd) = (tmp); \</span>
<span class="cp">			vmxnet3_RxCompToCPU((rcd), (tmp)); \</span>
<span class="cp">		} while (0)</span>
<span class="cp">#   define vmxnet3_getRxDesc(dstrxd, rxd, tmp) do { \</span>
<span class="cp">			(dstrxd) = (tmp); \</span>
<span class="cp">			vmxnet3_RxDescToCPU((rxd), (tmp)); \</span>
<span class="cp">		} while (0)</span>

<span class="cp">#else</span>

<span class="cp">#   define VMXNET3_TXDESC_GET_GEN(txdesc) ((txdesc)-&gt;gen)</span>
<span class="cp">#   define VMXNET3_TXDESC_GET_EOP(txdesc) ((txdesc)-&gt;eop)</span>
<span class="cp">#   define VMXNET3_TCD_GET_GEN(tcd) ((tcd)-&gt;gen)</span>
<span class="cp">#   define VMXNET3_TCD_GET_TXIDX(tcd) ((tcd)-&gt;txdIdx)</span>
<span class="cp">#   define vmxnet3_getRxComp(dstrcd, rcd, tmp) (dstrcd) = (rcd)</span>
<span class="cp">#   define vmxnet3_getRxDesc(dstrxd, rxd, tmp) (dstrxd) = (rxd)</span>

<span class="cp">#endif </span><span class="cm">/* __BIG_ENDIAN_BITFIELD  */</span><span class="cp"></span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_unmap_tx_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_tx_buf_info</span> <span class="o">*</span><span class="n">tbi</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tbi</span><span class="o">-&gt;</span><span class="n">map_type</span> <span class="o">==</span> <span class="n">VMXNET3_MAP_SINGLE</span><span class="p">)</span>
		<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">tbi</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">,</span> <span class="n">tbi</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
				 <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tbi</span><span class="o">-&gt;</span><span class="n">map_type</span> <span class="o">==</span> <span class="n">VMXNET3_MAP_PAGE</span><span class="p">)</span>
		<span class="n">pci_unmap_page</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">tbi</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">,</span> <span class="n">tbi</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
			       <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">tbi</span><span class="o">-&gt;</span><span class="n">map_type</span> <span class="o">!=</span> <span class="n">VMXNET3_MAP_NONE</span><span class="p">);</span>

	<span class="n">tbi</span><span class="o">-&gt;</span><span class="n">map_type</span> <span class="o">=</span> <span class="n">VMXNET3_MAP_NONE</span><span class="p">;</span> <span class="cm">/* to help debugging */</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">vmxnet3_unmap_pkt</span><span class="p">(</span><span class="n">u32</span> <span class="n">eop_idx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmxnet3_tx_queue</span> <span class="o">*</span><span class="n">tq</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>	<span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* no out of order completion */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="n">eop_idx</span><span class="p">].</span><span class="n">sop_idx</span> <span class="o">!=</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">next2comp</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">VMXNET3_TXDESC_GET_EOP</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">base</span><span class="p">[</span><span class="n">eop_idx</span><span class="p">].</span><span class="n">txd</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="n">eop_idx</span><span class="p">].</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">tq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="n">eop_idx</span><span class="p">].</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">VMXNET3_INC_RING_IDX_ONLY</span><span class="p">(</span><span class="n">eop_idx</span><span class="p">,</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">next2comp</span> <span class="o">!=</span> <span class="n">eop_idx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vmxnet3_unmap_tx_buf</span><span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">buf_info</span> <span class="o">+</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">next2comp</span><span class="p">,</span>
				     <span class="n">pdev</span><span class="p">);</span>

		<span class="cm">/* update next2comp w/o tx_lock. Since we are marking more,</span>
<span class="cm">		 * instead of less, tx ring entries avail, the worst case is</span>
<span class="cm">		 * that the tx routine incorrectly re-queues a pkt due to</span>
<span class="cm">		 * insufficient tx ring entries.</span>
<span class="cm">		 */</span>
		<span class="n">vmxnet3_cmd_ring_adv_next2comp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">);</span>
		<span class="n">entries</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">entries</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">vmxnet3_tq_tx_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_tx_queue</span> <span class="o">*</span><span class="n">tq</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">completed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">Vmxnet3_GenericDesc</span> <span class="o">*</span><span class="n">gdesc</span><span class="p">;</span>

	<span class="n">gdesc</span> <span class="o">=</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">base</span> <span class="o">+</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">next2proc</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">VMXNET3_TCD_GET_GEN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">tcd</span><span class="p">)</span> <span class="o">==</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">gen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">completed</span> <span class="o">+=</span> <span class="n">vmxnet3_unmap_pkt</span><span class="p">(</span><span class="n">VMXNET3_TCD_GET_TXIDX</span><span class="p">(</span>
					       <span class="o">&amp;</span><span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">tcd</span><span class="p">),</span> <span class="n">tq</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
					       <span class="n">adapter</span><span class="p">);</span>

		<span class="n">vmxnet3_comp_ring_adv_next2proc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">);</span>
		<span class="n">gdesc</span> <span class="o">=</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">base</span> <span class="o">+</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">next2proc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">completed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vmxnet3_tq_stopped</span><span class="p">(</span><span class="n">tq</span><span class="p">,</span> <span class="n">adapter</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			     <span class="n">vmxnet3_cmd_ring_desc_avail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">)</span> <span class="o">&gt;</span>
			     <span class="n">VMXNET3_WAKE_QUEUE_THRESHOLD</span><span class="p">(</span><span class="n">tq</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			     <span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">vmxnet3_tq_wake</span><span class="p">(</span><span class="n">tq</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">completed</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_tq_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_tx_queue</span> <span class="o">*</span><span class="n">tq</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">next2comp</span> <span class="o">!=</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">next2fill</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vmxnet3_tx_buf_info</span> <span class="o">*</span><span class="n">tbi</span><span class="p">;</span>

		<span class="n">tbi</span> <span class="o">=</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">buf_info</span> <span class="o">+</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">next2comp</span><span class="p">;</span>

		<span class="n">vmxnet3_unmap_tx_buf</span><span class="p">(</span><span class="n">tbi</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tbi</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">tbi</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">tbi</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">vmxnet3_cmd_ring_adv_next2comp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* sanity check, verify all buffers are indeed unmapped and freed */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">||</span>
		       <span class="n">tq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">map_type</span> <span class="o">!=</span> <span class="n">VMXNET3_MAP_NONE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">gen</span> <span class="o">=</span> <span class="n">VMXNET3_INIT_GEN</span><span class="p">;</span>
	<span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">next2fill</span> <span class="o">=</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">next2comp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">gen</span> <span class="o">=</span> <span class="n">VMXNET3_INIT_GEN</span><span class="p">;</span>
	<span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">next2proc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_tq_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_tx_queue</span> <span class="o">*</span><span class="n">tq</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">size</span> <span class="o">*</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_TxDesc</span><span class="p">),</span>
				    <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">base</span><span class="p">,</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">basePA</span><span class="p">);</span>
		<span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">data_ring</span><span class="p">.</span><span class="n">base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">data_ring</span><span class="p">.</span><span class="n">size</span> <span class="o">*</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_TxDataDesc</span><span class="p">),</span>
				    <span class="n">tq</span><span class="o">-&gt;</span><span class="n">data_ring</span><span class="p">.</span><span class="n">base</span><span class="p">,</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">data_ring</span><span class="p">.</span><span class="n">basePA</span><span class="p">);</span>
		<span class="n">tq</span><span class="o">-&gt;</span><span class="n">data_ring</span><span class="p">.</span><span class="n">base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">size</span> <span class="o">*</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_TxCompDesc</span><span class="p">),</span>
				    <span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">base</span><span class="p">,</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">basePA</span><span class="p">);</span>
		<span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">);</span>
	<span class="n">tq</span><span class="o">-&gt;</span><span class="n">buf_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Destroy all tx queues */</span>
<span class="kt">void</span>
<span class="nf">vmxnet3_tq_destroy_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">vmxnet3_tq_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_tq_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_tx_queue</span> <span class="o">*</span><span class="n">tq</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* reset the tx ring contents to 0 and reset the tx ring states */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">base</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">size</span> <span class="o">*</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_TxDesc</span><span class="p">));</span>
	<span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">next2fill</span> <span class="o">=</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">next2comp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">gen</span> <span class="o">=</span> <span class="n">VMXNET3_INIT_GEN</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">data_ring</span><span class="p">.</span><span class="n">base</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">data_ring</span><span class="p">.</span><span class="n">size</span> <span class="o">*</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_TxDataDesc</span><span class="p">));</span>

	<span class="cm">/* reset the tx comp ring contents to 0 and reset comp ring states */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">base</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">size</span> <span class="o">*</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_TxCompDesc</span><span class="p">));</span>
	<span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">next2proc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">gen</span> <span class="o">=</span> <span class="n">VMXNET3_INIT_GEN</span><span class="p">;</span>

	<span class="cm">/* reset the bookkeeping data */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">tq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">map_type</span> <span class="o">=</span> <span class="n">VMXNET3_MAP_NONE</span><span class="p">;</span>

	<span class="cm">/* stats are not reset */</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">vmxnet3_tq_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_tx_queue</span> <span class="o">*</span><span class="n">tq</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">base</span> <span class="o">||</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">data_ring</span><span class="p">.</span><span class="n">base</span> <span class="o">||</span>
	       <span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">base</span> <span class="o">||</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">);</span>

	<span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">size</span>
			   <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_TxDesc</span><span class="p">),</span>
			   <span class="o">&amp;</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">basePA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: failed to allocate tx ring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tq</span><span class="o">-&gt;</span><span class="n">data_ring</span><span class="p">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
			     <span class="n">tq</span><span class="o">-&gt;</span><span class="n">data_ring</span><span class="p">.</span><span class="n">size</span> <span class="o">*</span>
			     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_TxDataDesc</span><span class="p">),</span>
			     <span class="o">&amp;</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">data_ring</span><span class="p">.</span><span class="n">basePA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">data_ring</span><span class="p">.</span><span class="n">base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: failed to allocate data ring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
			     <span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">size</span> <span class="o">*</span>
			     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_TxCompDesc</span><span class="p">),</span>
			     <span class="o">&amp;</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">basePA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: failed to allocate tx comp ring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tq</span><span class="o">-&gt;</span><span class="n">buf_info</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
			       <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="n">vmxnet3_tq_destroy</span><span class="p">(</span><span class="n">tq</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_tq_cleanup_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">vmxnet3_tq_cleanup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *    starting from ring-&gt;next2fill, allocate rx buffers for the given ring</span>
<span class="cm"> *    of the rx queue and update the rx desc. stop after @num_to_alloc buffers</span>
<span class="cm"> *    are allocated or allocation fails</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">vmxnet3_rq_alloc_rx_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_rx_queue</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ring_idx</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">num_to_alloc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">num_allocated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmxnet3_rx_buf_info</span> <span class="o">*</span><span class="n">rbi_base</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="n">ring_idx</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">vmxnet3_cmd_ring</span> <span class="o">*</span><span class="n">ring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">ring_idx</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">num_allocated</span> <span class="o">&lt;=</span> <span class="n">num_to_alloc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vmxnet3_rx_buf_info</span> <span class="o">*</span><span class="n">rbi</span><span class="p">;</span>
		<span class="k">union</span> <span class="n">Vmxnet3_GenericDesc</span> <span class="o">*</span><span class="n">gd</span><span class="p">;</span>

		<span class="n">rbi</span> <span class="o">=</span> <span class="n">rbi_base</span> <span class="o">+</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">next2fill</span><span class="p">;</span>
		<span class="n">gd</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">next2fill</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rbi</span><span class="o">-&gt;</span><span class="n">buf_type</span> <span class="o">==</span> <span class="n">VMXNET3_RX_BUF_SKB</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rbi</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rbi</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">rbi</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span>
							 <span class="n">NET_IP_ALIGN</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rbi</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">rq</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_buf_alloc_failure</span><span class="o">++</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">rbi</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>

				<span class="n">skb_reserve</span><span class="p">(</span><span class="n">rbi</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">NET_IP_ALIGN</span><span class="p">);</span>
				<span class="n">rbi</span><span class="o">-&gt;</span><span class="n">dma_addr</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
						<span class="n">rbi</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">rbi</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
						<span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* rx buffer skipped by the device */</span>
			<span class="p">}</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">VMXNET3_RXD_BTYPE_HEAD</span> <span class="o">&lt;&lt;</span> <span class="n">VMXNET3_RXD_BTYPE_SHIFT</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rbi</span><span class="o">-&gt;</span><span class="n">buf_type</span> <span class="o">!=</span> <span class="n">VMXNET3_RX_BUF_PAGE</span> <span class="o">||</span>
			       <span class="n">rbi</span><span class="o">-&gt;</span><span class="n">len</span>  <span class="o">!=</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">rbi</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rbi</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_ATOMIC</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rbi</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">rq</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_buf_alloc_failure</span><span class="o">++</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">rbi</span><span class="o">-&gt;</span><span class="n">dma_addr</span> <span class="o">=</span> <span class="n">pci_map_page</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
						<span class="n">rbi</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
						<span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* rx buffers skipped by the device */</span>
			<span class="p">}</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">VMXNET3_RXD_BTYPE_BODY</span> <span class="o">&lt;&lt;</span> <span class="n">VMXNET3_RXD_BTYPE_SHIFT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rbi</span><span class="o">-&gt;</span><span class="n">dma_addr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">gd</span><span class="o">-&gt;</span><span class="n">rxd</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">rbi</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">);</span>
		<span class="n">gd</span><span class="o">-&gt;</span><span class="n">dword</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="o">!</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">&lt;&lt;</span> <span class="n">VMXNET3_RXD_GEN_SHIFT</span><span class="p">)</span>
					   <span class="o">|</span> <span class="n">val</span> <span class="o">|</span> <span class="n">rbi</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

		<span class="cm">/* Fill the last buffer but dont mark it ready, or else the</span>
<span class="cm">		 * device will think that the queue is full */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num_allocated</span> <span class="o">==</span> <span class="n">num_to_alloc</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">gd</span><span class="o">-&gt;</span><span class="n">dword</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">&lt;&lt;</span> <span class="n">VMXNET3_RXD_GEN_SHIFT</span><span class="p">);</span>
		<span class="n">num_allocated</span><span class="o">++</span><span class="p">;</span>
		<span class="n">vmxnet3_cmd_ring_adv_next2fill</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">uncommitted</span><span class="p">[</span><span class="n">ring_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">num_allocated</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;alloc_rx_buf: %d allocated, next2fill %u, next2comp &quot;</span>
		<span class="s">&quot;%u, uncommitted %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">num_allocated</span><span class="p">,</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">next2fill</span><span class="p">,</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">next2comp</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">uncommitted</span><span class="p">[</span><span class="n">ring_idx</span><span class="p">]);</span>

	<span class="cm">/* so that the device can distinguish a full ring and an empty ring */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">num_allocated</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">next2fill</span> <span class="o">==</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">next2comp</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">num_allocated</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_append_frag</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Vmxnet3_RxCompDesc</span> <span class="o">*</span><span class="n">rcd</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">vmxnet3_rx_buf_info</span> <span class="o">*</span><span class="n">rbi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">skb_frag_struct</span> <span class="o">*</span><span class="n">frag</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span> <span class="o">+</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">&gt;=</span> <span class="n">MAX_SKB_FRAGS</span><span class="p">);</span>

	<span class="n">__skb_frag_set_page</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">rbi</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
	<span class="n">frag</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">skb_frag_size_set</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+=</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_map_pkt</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmxnet3_tx_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">vmxnet3_tx_queue</span> <span class="o">*</span><span class="n">tq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">dw2</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buf_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">Vmxnet3_GenericDesc</span> <span class="o">*</span><span class="n">gdesc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmxnet3_tx_buf_info</span> <span class="o">*</span><span class="n">tbi</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">copy_size</span> <span class="o">&gt;</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

	<span class="cm">/* use the previous gen bit for the SOP desc */</span>
	<span class="n">dw2</span> <span class="o">=</span> <span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">gen</span> <span class="o">^</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">VMXNET3_TXD_GEN_SHIFT</span><span class="p">;</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sop_txd</span> <span class="o">=</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">base</span> <span class="o">+</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">next2fill</span><span class="p">;</span>
	<span class="n">gdesc</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sop_txd</span><span class="p">;</span> <span class="cm">/* both loops below can be skipped */</span>

	<span class="cm">/* no need to map the buffer if headers are copied */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">copy_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sop_txd</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">data_ring</span><span class="p">.</span><span class="n">basePA</span> <span class="o">+</span>
					<span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">next2fill</span> <span class="o">*</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_TxDataDesc</span><span class="p">));</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sop_txd</span><span class="o">-&gt;</span><span class="n">dword</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">dw2</span> <span class="o">|</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">copy_size</span><span class="p">);</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sop_txd</span><span class="o">-&gt;</span><span class="n">dword</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">tbi</span> <span class="o">=</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">buf_info</span> <span class="o">+</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">next2fill</span><span class="p">;</span>
		<span class="n">tbi</span><span class="o">-&gt;</span><span class="n">map_type</span> <span class="o">=</span> <span class="n">VMXNET3_MAP_NONE</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;txd[%u]: 0x%Lx 0x%x 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">next2fill</span><span class="p">,</span>
			<span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sop_txd</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">.</span><span class="n">addr</span><span class="p">),</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sop_txd</span><span class="o">-&gt;</span><span class="n">dword</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sop_txd</span><span class="o">-&gt;</span><span class="n">dword</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
		<span class="n">vmxnet3_cmd_ring_adv_next2fill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">);</span>

		<span class="cm">/* use the right gen for non-SOP desc */</span>
		<span class="n">dw2</span> <span class="o">=</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">gen</span> <span class="o">&lt;&lt;</span> <span class="n">VMXNET3_TXD_GEN_SHIFT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* linear part can use multiple tx desc if it&#39;s big */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">copy_size</span><span class="p">;</span>
	<span class="n">buf_offset</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">copy_size</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">buf_size</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">VMXNET3_MAX_TX_BUF_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">buf_size</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">dw2</span> <span class="o">|=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">buf_size</span> <span class="o">=</span> <span class="n">VMXNET3_MAX_TX_BUF_SIZE</span><span class="p">;</span>
			<span class="cm">/* spec says that for TxDesc.len, 0 == 2^14 */</span>
		<span class="p">}</span>

		<span class="n">tbi</span> <span class="o">=</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">buf_info</span> <span class="o">+</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">next2fill</span><span class="p">;</span>
		<span class="n">tbi</span><span class="o">-&gt;</span><span class="n">map_type</span> <span class="o">=</span> <span class="n">VMXNET3_MAP_SINGLE</span><span class="p">;</span>
		<span class="n">tbi</span><span class="o">-&gt;</span><span class="n">dma_addr</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
				<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">buf_offset</span><span class="p">,</span> <span class="n">buf_size</span><span class="p">,</span>
				<span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>

		<span class="n">tbi</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">buf_size</span><span class="p">;</span>

		<span class="n">gdesc</span> <span class="o">=</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">base</span> <span class="o">+</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">next2fill</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">.</span><span class="n">gen</span> <span class="o">==</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">gen</span><span class="p">);</span>

		<span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">tbi</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">);</span>
		<span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">dword</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">dw2</span><span class="p">);</span>
		<span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">dword</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;txd[%u]: 0x%Lx 0x%x 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">next2fill</span><span class="p">,</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">.</span><span class="n">addr</span><span class="p">),</span>
			<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">dword</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">dword</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
		<span class="n">vmxnet3_cmd_ring_adv_next2fill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">);</span>
		<span class="n">dw2</span> <span class="o">=</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">gen</span> <span class="o">&lt;&lt;</span> <span class="n">VMXNET3_TXD_GEN_SHIFT</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">-=</span> <span class="n">buf_size</span><span class="p">;</span>
		<span class="n">buf_offset</span> <span class="o">+=</span> <span class="n">buf_size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">skb_frag_struct</span> <span class="o">*</span><span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">tbi</span> <span class="o">=</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">buf_info</span> <span class="o">+</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">next2fill</span><span class="p">;</span>
		<span class="n">tbi</span><span class="o">-&gt;</span><span class="n">map_type</span> <span class="o">=</span> <span class="n">VMXNET3_MAP_PAGE</span><span class="p">;</span>
		<span class="n">tbi</span><span class="o">-&gt;</span><span class="n">dma_addr</span> <span class="o">=</span> <span class="n">skb_frag_dma_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">frag</span><span class="p">,</span>
						 <span class="mi">0</span><span class="p">,</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">),</span>
						 <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>

		<span class="n">tbi</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>

		<span class="n">gdesc</span> <span class="o">=</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">base</span> <span class="o">+</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">next2fill</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">.</span><span class="n">gen</span> <span class="o">==</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">gen</span><span class="p">);</span>

		<span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">tbi</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">);</span>
		<span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">dword</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">dw2</span> <span class="o">|</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">));</span>
		<span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">dword</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;txd[%u]: 0x%llu %u %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">next2fill</span><span class="p">,</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">.</span><span class="n">addr</span><span class="p">),</span>
			<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">dword</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">dword</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
		<span class="n">vmxnet3_cmd_ring_adv_next2fill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">);</span>
		<span class="n">dw2</span> <span class="o">=</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">gen</span> <span class="o">&lt;&lt;</span> <span class="n">VMXNET3_TXD_GEN_SHIFT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">eop_txd</span> <span class="o">=</span> <span class="n">gdesc</span><span class="p">;</span>

	<span class="cm">/* set the last buf_info for the pkt */</span>
	<span class="n">tbi</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="n">tbi</span><span class="o">-&gt;</span><span class="n">sop_idx</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sop_txd</span> <span class="o">-</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">base</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Init all tx queues */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_tq_init_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">vmxnet3_tq_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *    parse and copy relevant protocol headers:</span>
<span class="cm"> *      For a tso pkt, relevant headers are L2/3/4 including options</span>
<span class="cm"> *      For a pkt requesting csum offloading, they are L2/3 and may include L4</span>
<span class="cm"> *      if it&#39;s a TCP/UDP pkt</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *    -1:  error happens during parsing</span>
<span class="cm"> *     0:  protocol headers parsed, but too big to be copied</span>
<span class="cm"> *     1:  protocol headers parsed and copied</span>
<span class="cm"> *</span>
<span class="cm"> * Other effects:</span>
<span class="cm"> *    1. related *ctx fields are updated.</span>
<span class="cm"> *    2. ctx-&gt;copy_size is # of bytes copied</span>
<span class="cm"> *    3. the portion copied is guaranteed to be in the linear part</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">vmxnet3_parse_and_copy_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmxnet3_tx_queue</span> <span class="o">*</span><span class="n">tq</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">vmxnet3_tx_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Vmxnet3_TxDataDesc</span> <span class="o">*</span><span class="n">tdd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mss</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* TSO */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">eth_ip_hdr_size</span> <span class="o">=</span> <span class="n">skb_transport_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">l4_hdr_size</span> <span class="o">=</span> <span class="n">tcp_hdrlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">copy_size</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">eth_ip_hdr_size</span> <span class="o">+</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">l4_hdr_size</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">eth_ip_hdr_size</span> <span class="o">=</span> <span class="n">skb_checksum_start_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ipv4</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_TCP</span><span class="p">)</span>
					<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">l4_hdr_size</span> <span class="o">=</span> <span class="n">tcp_hdrlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
				<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_UDP</span><span class="p">)</span>
					<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">l4_hdr_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">udphdr</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">l4_hdr_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* for simplicity, don&#39;t copy L4 headers */</span>
				<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">l4_hdr_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">copy_size</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">eth_ip_hdr_size</span> <span class="o">+</span>
					 <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">l4_hdr_size</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">eth_ip_hdr_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">l4_hdr_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* copy as much as allowed */</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">copy_size</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">VMXNET3_HDR_COPY_SIZE</span>
					     <span class="p">,</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="cm">/* make sure headers are accessible directly */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pskb_may_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">copy_size</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">copy_size</span> <span class="o">&gt;</span> <span class="n">VMXNET3_HDR_COPY_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tq</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">oversized_hdr</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">copy_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tdd</span> <span class="o">=</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">data_ring</span><span class="p">.</span><span class="n">base</span> <span class="o">+</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">next2fill</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">tdd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">copy_size</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;copy %u bytes to dataRing[%u]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">copy_size</span><span class="p">,</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">next2fill</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_prepare_tso</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">vmxnet3_tx_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">tcph</span> <span class="o">=</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ipv4</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="n">iph</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tcph</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="o">~</span><span class="n">csum_tcpudp_magic</span><span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						 <span class="n">IPPROTO_TCP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ipv6hdr</span> <span class="o">*</span><span class="n">iph</span> <span class="o">=</span> <span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="n">tcph</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="o">~</span><span class="n">csum_ipv6_magic</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					       <span class="n">IPPROTO_TCP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Transmits a pkt thru a given tq</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *    NETDEV_TX_OK:      descriptors are setup successfully</span>
<span class="cm"> *    NETDEV_TX_OK:      error occurred, the pkt is dropped</span>
<span class="cm"> *    NETDEV_TX_BUSY:    tx ring is full, queue is stopped</span>
<span class="cm"> *</span>
<span class="cm"> * Side-effects:</span>
<span class="cm"> *    1. tx ring may be changed</span>
<span class="cm"> *    2. tq stats may be updated accordingly</span>
<span class="cm"> *    3. shared-&gt;txNumDeferred may be updated</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">vmxnet3_tq_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmxnet3_tx_queue</span> <span class="o">*</span><span class="n">tq</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmxnet3_tx_ctx</span> <span class="n">ctx</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">Vmxnet3_GenericDesc</span> <span class="o">*</span><span class="n">gdesc</span><span class="p">;</span>
<span class="cp">#ifdef __BIG_ENDIAN_BITFIELD</span>
	<span class="cm">/* Use temporary descriptor to avoid touching bits multiple times */</span>
	<span class="k">union</span> <span class="n">Vmxnet3_GenericDesc</span> <span class="n">tempTxDesc</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* conservatively estimate # of descriptors to use */</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">VMXNET3_TXD_NEEDED</span><span class="p">(</span><span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="o">+</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">ctx</span><span class="p">.</span><span class="n">ipv4</span> <span class="o">=</span> <span class="p">(</span><span class="n">vlan_get_protocol</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">));</span>

	<span class="n">ctx</span><span class="p">.</span><span class="n">mss</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">mss</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb_header_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pskb_expand_head</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						      <span class="n">GFP_ATOMIC</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">tq</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">drop_tso</span><span class="o">++</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">drop_pkt</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">tq</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">copy_skb_header</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">vmxnet3_prepare_tso</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">VMXNET3_MAX_TXD_PER_PKT</span><span class="p">))</span> <span class="p">{</span>

			<span class="cm">/* non-tso pkts must not use more than</span>
<span class="cm">			 * VMXNET3_MAX_TXD_PER_PKT entries</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb_linearize</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tq</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">drop_too_many_frags</span><span class="o">++</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">drop_pkt</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">tq</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">linearized</span><span class="o">++</span><span class="p">;</span>

			<span class="cm">/* recalculate the # of descriptors to use */</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">VMXNET3_TXD_NEEDED</span><span class="p">(</span><span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">vmxnet3_cmd_ring_desc_avail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tq</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_ring_full</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;tx queue stopped on %s, next2comp %u&quot;</span>
			<span class="s">&quot; next2fill %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			<span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">next2comp</span><span class="p">,</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">next2fill</span><span class="p">);</span>

		<span class="n">vmxnet3_tq_stop</span><span class="p">(</span><span class="n">tq</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="n">ret</span> <span class="o">=</span> <span class="n">vmxnet3_parse_and_copy_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">tq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span><span class="p">.</span><span class="n">copy_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* hdrs parsed, check against other limits */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">mss</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">eth_ip_hdr_size</span> <span class="o">+</span> <span class="n">ctx</span><span class="p">.</span><span class="n">l4_hdr_size</span> <span class="o">&gt;</span>
				     <span class="n">VMXNET3_MAX_TX_BUF_SIZE</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="n">hdr_too_big</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">eth_ip_hdr_size</span> <span class="o">+</span>
					     <span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum_offset</span> <span class="o">&gt;</span>
					     <span class="n">VMXNET3_MAX_CSUM_OFFSET</span><span class="p">))</span> <span class="p">{</span>
					<span class="k">goto</span> <span class="n">hdr_too_big</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tq</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">drop_hdr_inspect_err</span><span class="o">++</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock_drop_pkt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* fill tx descs related to addr &amp; len */</span>
	<span class="n">vmxnet3_map_pkt</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span> <span class="n">tq</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* setup the EOP desc */</span>
	<span class="n">ctx</span><span class="p">.</span><span class="n">eop_txd</span><span class="o">-&gt;</span><span class="n">dword</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">VMXNET3_TXD_CQ</span> <span class="o">|</span> <span class="n">VMXNET3_TXD_EOP</span><span class="p">);</span>

	<span class="cm">/* setup the SOP desc */</span>
<span class="cp">#ifdef __BIG_ENDIAN_BITFIELD</span>
	<span class="n">gdesc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tempTxDesc</span><span class="p">;</span>
	<span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">dword</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">.</span><span class="n">sop_txd</span><span class="o">-&gt;</span><span class="n">dword</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">dword</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">.</span><span class="n">sop_txd</span><span class="o">-&gt;</span><span class="n">dword</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="cp">#else</span>
	<span class="n">gdesc</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">.</span><span class="n">sop_txd</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">mss</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">.</span><span class="n">hlen</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">.</span><span class="n">eth_ip_hdr_size</span> <span class="o">+</span> <span class="n">ctx</span><span class="p">.</span><span class="n">l4_hdr_size</span><span class="p">;</span>
		<span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">.</span><span class="n">om</span> <span class="o">=</span> <span class="n">VMXNET3_OM_TSO</span><span class="p">;</span>
		<span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">.</span><span class="n">msscof</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">.</span><span class="n">mss</span><span class="p">;</span>
		<span class="n">le32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">txNumDeferred</span><span class="p">,</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span>
			     <span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">.</span><span class="n">hlen</span> <span class="o">+</span> <span class="n">ctx</span><span class="p">.</span><span class="n">mss</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">ctx</span><span class="p">.</span><span class="n">mss</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">.</span><span class="n">hlen</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">.</span><span class="n">eth_ip_hdr_size</span><span class="p">;</span>
			<span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">.</span><span class="n">om</span> <span class="o">=</span> <span class="n">VMXNET3_OM_CSUM</span><span class="p">;</span>
			<span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">.</span><span class="n">msscof</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">.</span><span class="n">eth_ip_hdr_size</span> <span class="o">+</span>
					    <span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum_offset</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">.</span><span class="n">om</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">.</span><span class="n">msscof</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">le32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">txNumDeferred</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vlan_tx_tag_present</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">.</span><span class="n">ti</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">.</span><span class="n">tci</span> <span class="o">=</span> <span class="n">vlan_tx_tag_get</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* finally flips the GEN bit of the SOP desc. */</span>
	<span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">dword</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">dword</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">^</span>
						  <span class="n">VMXNET3_TXD_GEN</span><span class="p">);</span>
<span class="cp">#ifdef __BIG_ENDIAN_BITFIELD</span>
	<span class="cm">/* Finished updating in bitfields of Tx Desc, so write them in original</span>
<span class="cm">	 * place.</span>
<span class="cm">	 */</span>
	<span class="n">vmxnet3_TxDescToLe</span><span class="p">((</span><span class="k">struct</span> <span class="n">Vmxnet3_TxDesc</span> <span class="o">*</span><span class="p">)</span><span class="n">gdesc</span><span class="p">,</span>
			   <span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_TxDesc</span> <span class="o">*</span><span class="p">)</span><span class="n">ctx</span><span class="p">.</span><span class="n">sop_txd</span><span class="p">);</span>
	<span class="n">gdesc</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">.</span><span class="n">sop_txd</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;txd[%u]: SOP 0x%Lx 0x%x 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">u32</span><span class="p">)((</span><span class="k">union</span> <span class="n">Vmxnet3_GenericDesc</span> <span class="o">*</span><span class="p">)</span><span class="n">ctx</span><span class="p">.</span><span class="n">sop_txd</span> <span class="o">-</span>
		<span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">base</span><span class="p">),</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">.</span><span class="n">addr</span><span class="p">),</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">dword</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">dword</span><span class="p">[</span><span class="mi">3</span><span class="p">]));</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">txNumDeferred</span><span class="p">)</span> <span class="o">&gt;=</span>
					<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">txThreshold</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tq</span><span class="o">-&gt;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">txNumDeferred</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">VMXNET3_WRITE_BAR0_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
				       <span class="n">VMXNET3_REG_TXPROD</span> <span class="o">+</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">qid</span> <span class="o">*</span> <span class="mi">8</span><span class="p">,</span>
				       <span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">next2fill</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>

<span class="nl">hdr_too_big:</span>
	<span class="n">tq</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">drop_oversized_hdr</span><span class="o">++</span><span class="p">;</span>
<span class="nl">unlock_drop_pkt:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="nl">drop_pkt:</span>
	<span class="n">tq</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">drop_total</span><span class="o">++</span><span class="p">;</span>
	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">netdev_tx_t</span>
<span class="nf">vmxnet3_xmit_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">queue_mapping</span> <span class="o">&gt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">vmxnet3_tq_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">queue_mapping</span><span class="p">],</span>
				       <span class="n">adapter</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_rx_csum</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		<span class="k">union</span> <span class="n">Vmxnet3_GenericDesc</span> <span class="o">*</span><span class="n">gdesc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">rcd</span><span class="p">.</span><span class="n">cnc</span> <span class="o">&amp;&amp;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXCSUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* typical case: TCP/UDP over IP and both csums are correct */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">dword</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">VMXNET3_RCD_CSUM_OK</span><span class="p">)</span> <span class="o">==</span>
							<span class="n">VMXNET3_RCD_CSUM_OK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_UNNECESSARY</span><span class="p">;</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">rcd</span><span class="p">.</span><span class="n">tcp</span> <span class="o">||</span> <span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">rcd</span><span class="p">.</span><span class="n">udp</span><span class="p">));</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">rcd</span><span class="p">.</span><span class="n">v4</span>  <span class="o">||</span> <span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">rcd</span><span class="p">.</span><span class="n">v6</span><span class="p">));</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">rcd</span><span class="p">.</span><span class="n">frg</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">rcd</span><span class="p">.</span><span class="n">csum</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">rcd</span><span class="p">.</span><span class="n">csum</span><span class="p">);</span>
				<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">skb_checksum_none_assert</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">skb_checksum_none_assert</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_rx_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_rx_queue</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Vmxnet3_RxCompDesc</span> <span class="o">*</span><span class="n">rcd</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">vmxnet3_rx_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>  <span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">drop_err</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">fcs</span><span class="p">)</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">drop_fcs</span><span class="o">++</span><span class="p">;</span>

	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">drop_total</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We do not unmap and chain the rx buffer to the skb.</span>
<span class="cm">	 * We basically pretend this buffer is not used and will be recycled</span>
<span class="cm">	 * by vmxnet3_rq_alloc_rx_buf()</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * ctx-&gt;skb may be NULL if this is the first and the only one</span>
<span class="cm">	 * desc for the pkt</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span>
		<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">vmxnet3_rq_rx_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_rx_queue</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">int</span> <span class="n">quota</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">rxprod_reg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">VMXNET3_REG_RXPROD</span><span class="p">,</span> <span class="n">VMXNET3_REG_RXPROD2</span>
	<span class="p">};</span>
	<span class="n">u32</span> <span class="n">num_rxd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">skip_page_frags</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Vmxnet3_RxCompDesc</span> <span class="o">*</span><span class="n">rcd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmxnet3_rx_ctx</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ctx</span><span class="p">;</span>
<span class="cp">#ifdef __BIG_ENDIAN_BITFIELD</span>
	<span class="k">struct</span> <span class="n">Vmxnet3_RxDesc</span> <span class="n">rxCmdDesc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Vmxnet3_RxCompDesc</span> <span class="n">rxComp</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">vmxnet3_getRxComp</span><span class="p">(</span><span class="n">rcd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">base</span><span class="p">[</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">next2proc</span><span class="p">].</span><span class="n">rcd</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">rxComp</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">==</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">gen</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vmxnet3_rx_buf_info</span> <span class="o">*</span><span class="n">rbi</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="o">*</span><span class="n">new_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">new_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">num_to_alloc</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">Vmxnet3_RxDesc</span> <span class="o">*</span><span class="n">rxd</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ring_idx</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">vmxnet3_cmd_ring</span>	<span class="o">*</span><span class="n">ring</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num_rxd</span> <span class="o">&gt;=</span> <span class="n">quota</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* we may stop even before we see the EOP desc of</span>
<span class="cm">			 * the current pkt</span>
<span class="cm">			 */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">num_rxd</span><span class="o">++</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rqID</span> <span class="o">!=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">qid</span> <span class="o">&amp;&amp;</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rqID</span> <span class="o">!=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">qid2</span><span class="p">);</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rxdIdx</span><span class="p">;</span>
		<span class="n">ring_idx</span> <span class="o">=</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rqID</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ring</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span> <span class="o">+</span> <span class="n">ring_idx</span><span class="p">;</span>
		<span class="n">vmxnet3_getRxDesc</span><span class="p">(</span><span class="n">rxd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">ring_idx</span><span class="p">].</span><span class="n">base</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">rxd</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">rxCmdDesc</span><span class="p">);</span>
		<span class="n">rbi</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="n">ring_idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">idx</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rxd</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">!=</span> <span class="n">rbi</span><span class="o">-&gt;</span><span class="n">dma_addr</span> <span class="o">||</span>
		       <span class="n">rxd</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">!=</span> <span class="n">rbi</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">eop</span> <span class="o">&amp;&amp;</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">vmxnet3_rx_error</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rcd</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">rcd_done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">sop</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* first buf of the pkt */</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rxd</span><span class="o">-&gt;</span><span class="n">btype</span> <span class="o">!=</span> <span class="n">VMXNET3_RXD_BTYPE_HEAD</span> <span class="o">||</span>
			       <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rqID</span> <span class="o">!=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">qid</span><span class="p">);</span>

			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rbi</span><span class="o">-&gt;</span><span class="n">buf_type</span> <span class="o">!=</span> <span class="n">VMXNET3_RX_BUF_SKB</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">rbi</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Pretend the rx buffer is skipped. */</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">sop</span> <span class="o">&amp;&amp;</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">eop</span><span class="p">));</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;rxRing[%u][%u] 0 length</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">ring_idx</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">rcd_done</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">skip_page_frags</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">rbi</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
			<span class="n">new_skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">rbi</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="n">NET_IP_ALIGN</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new_skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Skb allocation failed, do not handover this</span>
<span class="cm">				 * skb to stack. Reuse it. Drop the existing pkt</span>
<span class="cm">				 */</span>
				<span class="n">rq</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_buf_alloc_failure</span><span class="o">++</span><span class="p">;</span>
				<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">rq</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">drop_total</span><span class="o">++</span><span class="p">;</span>
				<span class="n">skip_page_frags</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">rcd_done</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">rbi</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">,</span> <span class="n">rbi</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
					 <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>

			<span class="n">skb_put</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

			<span class="cm">/* Immediate refill */</span>
			<span class="n">new_skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
			<span class="n">skb_reserve</span><span class="p">(</span><span class="n">new_skb</span><span class="p">,</span> <span class="n">NET_IP_ALIGN</span><span class="p">);</span>
			<span class="n">rbi</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">new_skb</span><span class="p">;</span>
			<span class="n">rbi</span><span class="o">-&gt;</span><span class="n">dma_addr</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
					<span class="n">rbi</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">rbi</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
					<span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="n">rxd</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">rbi</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">);</span>
			<span class="n">rxd</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">rbi</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">skip_page_frags</span><span class="p">);</span>

			<span class="cm">/* non SOP buffer must be type 1 in most cases */</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rbi</span><span class="o">-&gt;</span><span class="n">buf_type</span> <span class="o">!=</span> <span class="n">VMXNET3_RX_BUF_PAGE</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rxd</span><span class="o">-&gt;</span><span class="n">btype</span> <span class="o">!=</span> <span class="n">VMXNET3_RXD_BTYPE_BODY</span><span class="p">);</span>

			<span class="cm">/* If an sop buffer was dropped, skip all</span>
<span class="cm">			 * following non-sop fragments. They will be reused.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skip_page_frags</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">rcd_done</span><span class="p">;</span>

			<span class="n">new_page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">new_page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Replacement page frag could not be allocated.</span>
<span class="cm">				 * Reuse this page. Drop the pkt and free the</span>
<span class="cm">				 * skb which contained this page as a frag. Skip</span>
<span class="cm">				 * processing all the following non-sop frags.</span>
<span class="cm">				 */</span>
				<span class="n">rq</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_buf_alloc_failure</span><span class="o">++</span><span class="p">;</span>
				<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
				<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">skip_page_frags</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">rcd_done</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pci_unmap_page</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
					       <span class="n">rbi</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">,</span> <span class="n">rbi</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
					       <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>

				<span class="n">vmxnet3_append_frag</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">rcd</span><span class="p">,</span> <span class="n">rbi</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* Immediate refill */</span>
			<span class="n">rbi</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">new_page</span><span class="p">;</span>
			<span class="n">rbi</span><span class="o">-&gt;</span><span class="n">dma_addr</span> <span class="o">=</span> <span class="n">pci_map_page</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">rbi</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span>
						     <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
						     <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="n">rxd</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">rbi</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">);</span>
			<span class="n">rxd</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">rbi</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>


		<span class="n">skb</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">eop</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>

			<span class="n">vmxnet3_rx_csum</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span>
					<span class="p">(</span><span class="k">union</span> <span class="n">Vmxnet3_GenericDesc</span> <span class="o">*</span><span class="p">)</span><span class="n">rcd</span><span class="p">);</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">ts</span><span class="p">))</span>
				<span class="n">__vlan_hwaccel_put_tag</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">tci</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_LRO</span><span class="p">)</span>
				<span class="n">netif_receive_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">napi_gro_receive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

<span class="nl">rcd_done:</span>
		<span class="cm">/* device may have skipped some rx descs */</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">next2comp</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
		<span class="n">num_to_alloc</span> <span class="o">=</span> <span class="n">vmxnet3_cmd_ring_desc_avail</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
		<span class="n">ring</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span> <span class="o">+</span> <span class="n">ring_idx</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">num_to_alloc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vmxnet3_getRxDesc</span><span class="p">(</span><span class="n">rxd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">[</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">next2fill</span><span class="p">].</span><span class="n">rxd</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">rxCmdDesc</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rxd</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>

			<span class="cm">/* Recv desc is ready to be used by the device */</span>
			<span class="n">rxd</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">gen</span><span class="p">;</span>
			<span class="n">vmxnet3_cmd_ring_adv_next2fill</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
			<span class="n">num_to_alloc</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* if needed, update the register */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">updateRxProd</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">VMXNET3_WRITE_BAR0_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
				<span class="n">rxprod_reg</span><span class="p">[</span><span class="n">ring_idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">qid</span> <span class="o">*</span> <span class="mi">8</span><span class="p">,</span>
				<span class="n">ring</span><span class="o">-&gt;</span><span class="n">next2fill</span><span class="p">);</span>
			<span class="n">rq</span><span class="o">-&gt;</span><span class="n">uncommitted</span><span class="p">[</span><span class="n">ring_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">vmxnet3_comp_ring_adv_next2proc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">);</span>
		<span class="n">vmxnet3_getRxComp</span><span class="p">(</span><span class="n">rcd</span><span class="p">,</span>
		     <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">base</span><span class="p">[</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">next2proc</span><span class="p">].</span><span class="n">rcd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxComp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">num_rxd</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_rq_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_rx_queue</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">,</span> <span class="n">ring_idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Vmxnet3_RxDesc</span> <span class="o">*</span><span class="n">rxd</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ring_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ring_idx</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">ring_idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">ring_idx</span><span class="p">].</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef __BIG_ENDIAN_BITFIELD</span>
			<span class="k">struct</span> <span class="n">Vmxnet3_RxDesc</span> <span class="n">rxDesc</span><span class="p">;</span>
<span class="cp">#endif</span>
			<span class="n">vmxnet3_getRxDesc</span><span class="p">(</span><span class="n">rxd</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">ring_idx</span><span class="p">].</span><span class="n">base</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rxd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxDesc</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">rxd</span><span class="o">-&gt;</span><span class="n">btype</span> <span class="o">==</span> <span class="n">VMXNET3_RXD_BTYPE_HEAD</span> <span class="o">&amp;&amp;</span>
					<span class="n">rq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="n">ring_idx</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">rxd</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span>
						 <span class="n">rxd</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
				<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="n">ring_idx</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">skb</span><span class="p">);</span>
				<span class="n">rq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="n">ring_idx</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rxd</span><span class="o">-&gt;</span><span class="n">btype</span> <span class="o">==</span> <span class="n">VMXNET3_RXD_BTYPE_BODY</span> <span class="o">&amp;&amp;</span>
					<span class="n">rq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="n">ring_idx</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pci_unmap_page</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">rxd</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span>
					       <span class="n">rxd</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
				<span class="n">put_page</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="n">ring_idx</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">page</span><span class="p">);</span>
				<span class="n">rq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="n">ring_idx</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">ring_idx</span><span class="p">].</span><span class="n">gen</span> <span class="o">=</span> <span class="n">VMXNET3_INIT_GEN</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">ring_idx</span><span class="p">].</span><span class="n">next2fill</span> <span class="o">=</span>
					<span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">ring_idx</span><span class="p">].</span><span class="n">next2comp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">uncommitted</span><span class="p">[</span><span class="n">ring_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">gen</span> <span class="o">=</span> <span class="n">VMXNET3_INIT_GEN</span><span class="p">;</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">next2proc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_rq_cleanup_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">vmxnet3_rq_cleanup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">vmxnet3_rq_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_rx_queue</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

	<span class="cm">/* all rx buffers must have already been freed */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">page</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>


	<span class="n">kfree</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span>
					    <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_RxDesc</span><span class="p">),</span>
					    <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span><span class="p">,</span>
					    <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">basePA</span><span class="p">);</span>
			<span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">size</span> <span class="o">*</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_RxCompDesc</span><span class="p">),</span>
				    <span class="n">rq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">base</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">basePA</span><span class="p">);</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">vmxnet3_rq_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_rx_queue</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">vmxnet3_adapter</span>  <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* initialize buf_info */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* 1st buf for a pkt is skbuff */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buf_per_pkt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">buf_type</span> <span class="o">=</span> <span class="n">VMXNET3_RX_BUF_SKB</span><span class="p">;</span>
			<span class="n">rq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">skb_buf_size</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="cm">/* subsequent bufs for a pkt is frag */</span>
			<span class="n">rq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">buf_type</span> <span class="o">=</span> <span class="n">VMXNET3_RX_BUF_PAGE</span><span class="p">;</span>
			<span class="n">rq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">buf_type</span> <span class="o">=</span> <span class="n">VMXNET3_RX_BUF_PAGE</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* reset internal state and allocate buffers for both rings */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next2fill</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next2comp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">uncommitted</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">*</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_RxDesc</span><span class="p">));</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">gen</span> <span class="o">=</span> <span class="n">VMXNET3_INIT_GEN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmxnet3_rq_alloc_rx_buf</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
				    <span class="n">adapter</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* at least has 1 rx buffer for the 1st ring */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vmxnet3_rq_alloc_rx_buf</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* reset the comp ring */</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">next2proc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">base</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">size</span> <span class="o">*</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_RxCompDesc</span><span class="p">));</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">gen</span> <span class="o">=</span> <span class="n">VMXNET3_INIT_GEN</span><span class="p">;</span>

	<span class="cm">/* reset rxctx */</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ctx</span><span class="p">.</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* stats are not reset */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">vmxnet3_rq_init_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">vmxnet3_rq_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">adapter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: failed to &quot;</span>
				<span class="s">&quot;initialize rx queue%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">vmxnet3_rq_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_rx_queue</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">sz</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmxnet3_rx_buf_info</span> <span class="o">*</span><span class="n">bi</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">sz</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_RxDesc</span><span class="p">);</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">basePA</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: failed to allocate rx ring %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">sz</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_RxCompDesc</span><span class="p">);</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">basePA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: failed to allocate rx comp ring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_rx_buf_info</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">+</span>
						   <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">);</span>
	<span class="n">bi</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bi</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bi</span><span class="p">;</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bi</span> <span class="o">+</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="n">vmxnet3_rq_destroy</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">vmxnet3_rq_create_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">vmxnet3_rq_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">adapter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;%s: failed to create rx queue%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="nl">err_out:</span>
	<span class="n">vmxnet3_rq_destroy_all</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/* Multiple queue aware polling function for tx and rx */</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">vmxnet3_do_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rcd_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">ecr</span><span class="p">))</span>
		<span class="n">vmxnet3_process_events</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">vmxnet3_tq_tx_complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">adapter</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">rcd_done</span> <span class="o">+=</span> <span class="n">vmxnet3_rq_rx_complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						   <span class="n">adapter</span><span class="p">,</span> <span class="n">budget</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rcd_done</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">vmxnet3_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmxnet3_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">vmxnet3_rx_queue</span><span class="p">,</span> <span class="n">napi</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rxd_done</span><span class="p">;</span>

	<span class="n">rxd_done</span> <span class="o">=</span> <span class="n">vmxnet3_do_poll</span><span class="p">(</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">budget</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rxd_done</span> <span class="o">&lt;</span> <span class="n">budget</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>
		<span class="n">vmxnet3_enable_all_intrs</span><span class="p">(</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rxd_done</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NAPI polling function for MSI-X mode with multiple Rx queues</span>
<span class="cm"> * Returns the # of the NAPI credit consumed (# of rx descriptors processed)</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">vmxnet3_poll_rx_only</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmxnet3_rx_queue</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">vmxnet3_rx_queue</span><span class="p">,</span> <span class="n">napi</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rxd_done</span><span class="p">;</span>

	<span class="cm">/* When sharing interrupt with corresponding tx queue, process</span>
<span class="cm">	 * tx completions in that queue as well</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">share_intr</span> <span class="o">==</span> <span class="n">VMXNET3_INTR_BUDDYSHARE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vmxnet3_tx_queue</span> <span class="o">*</span><span class="n">tq</span> <span class="o">=</span>
				<span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">rq</span> <span class="o">-</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">];</span>
		<span class="n">vmxnet3_tq_tx_complete</span><span class="p">(</span><span class="n">tq</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">rxd_done</span> <span class="o">=</span> <span class="n">vmxnet3_rq_rx_complete</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">adapter</span><span class="p">,</span> <span class="n">budget</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rxd_done</span> <span class="o">&lt;</span> <span class="n">budget</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>
		<span class="n">vmxnet3_enable_intr</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">intr_idx</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rxd_done</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#ifdef CONFIG_PCI_MSI</span>

<span class="cm">/*</span>
<span class="cm"> * Handle completion interrupts on tx queues</span>
<span class="cm"> * Returns whether or not the intr is handled</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">irqreturn_t</span>
<span class="nf">vmxnet3_msix_tx</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmxnet3_tx_queue</span> <span class="o">*</span><span class="n">tq</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">mask_mode</span> <span class="o">==</span> <span class="n">VMXNET3_IMM_ACTIVE</span><span class="p">)</span>
		<span class="n">vmxnet3_disable_intr</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">intr_idx</span><span class="p">);</span>

	<span class="cm">/* Handle the case where only one irq is allocate for all tx queues */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">share_intr</span> <span class="o">==</span> <span class="n">VMXNET3_INTR_TXSHARE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">vmxnet3_tx_queue</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">vmxnet3_tq_tx_complete</span><span class="p">(</span><span class="n">txq</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">vmxnet3_tq_tx_complete</span><span class="p">(</span><span class="n">tq</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">vmxnet3_enable_intr</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">intr_idx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Handle completion interrupts on rx queues. Returns whether or not the</span>
<span class="cm"> * intr is handled</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">irqreturn_t</span>
<span class="nf">vmxnet3_msix_rx</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmxnet3_rx_queue</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>

	<span class="cm">/* disable intr if needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">mask_mode</span> <span class="o">==</span> <span class="n">VMXNET3_IMM_ACTIVE</span><span class="p">)</span>
		<span class="n">vmxnet3_disable_intr</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">intr_idx</span><span class="p">);</span>
	<span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *----------------------------------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> * vmxnet3_msix_event --</span>
<span class="cm"> *</span>
<span class="cm"> *    vmxnet3 msix event intr handler</span>
<span class="cm"> *</span>
<span class="cm"> * Result:</span>
<span class="cm"> *    whether or not the intr is handled</span>
<span class="cm"> *</span>
<span class="cm"> *----------------------------------------------------------------------------</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">irqreturn_t</span>
<span class="nf">vmxnet3_msix_event</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* disable intr if needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">mask_mode</span> <span class="o">==</span> <span class="n">VMXNET3_IMM_ACTIVE</span><span class="p">)</span>
		<span class="n">vmxnet3_disable_intr</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">event_intr_idx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">ecr</span><span class="p">)</span>
		<span class="n">vmxnet3_process_events</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">vmxnet3_enable_intr</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">event_intr_idx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI_MSI  */</span><span class="cp"></span>


<span class="cm">/* Interrupt handler for vmxnet3  */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span>
<span class="nf">vmxnet3_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">VMXNET3_IT_INTX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">icr</span> <span class="o">=</span> <span class="n">VMXNET3_READ_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_ICR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">icr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="cm">/* not ours */</span>
			<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/* disable intr if needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">mask_mode</span> <span class="o">==</span> <span class="n">VMXNET3_IMM_ACTIVE</span><span class="p">)</span>
		<span class="n">vmxnet3_disable_all_intrs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">napi</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>

<span class="cm">/* netpoll callback. */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_netpoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">mask_mode</span> <span class="o">==</span> <span class="n">VMXNET3_IMM_ACTIVE</span><span class="p">)</span>
		<span class="n">vmxnet3_disable_all_intrs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">vmxnet3_do_poll</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">);</span>
	<span class="n">vmxnet3_enable_all_intrs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_NET_POLL_CONTROLLER */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">vmxnet3_request_irqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmxnet3_intr</span> <span class="o">*</span><span class="n">intr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PCI_MSI</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">VMXNET3_IT_MSIX</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">share_intr</span> <span class="o">!=</span> <span class="n">VMXNET3_INTR_BUDDYSHARE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sprintf</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;%s-tx-%d&quot;</span><span class="p">,</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">vector</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span>
					      <span class="n">intr</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">vector</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
					      <span class="n">vmxnet3_msix_tx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					      <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">sprintf</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;%s-rxtx-%d&quot;</span><span class="p">,</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">vector</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;Failed to request irq for MSIX, %s, &quot;</span>
					<span class="s">&quot;error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Handle the case where only 1 MSIx was allocated for</span>
<span class="cm">			 * all tx queues */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">share_intr</span> <span class="o">==</span> <span class="n">VMXNET3_INTR_TXSHARE</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">intr_idx</span>
								<span class="o">=</span> <span class="n">vector</span><span class="p">;</span>
				<span class="n">vector</span><span class="o">++</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">intr_idx</span>
								<span class="o">=</span> <span class="n">vector</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">share_intr</span> <span class="o">==</span> <span class="n">VMXNET3_INTR_BUDDYSHARE</span><span class="p">)</span>
			<span class="n">vector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">share_intr</span> <span class="o">!=</span> <span class="n">VMXNET3_INTR_BUDDYSHARE</span><span class="p">)</span>
				<span class="n">sprintf</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;%s-rx-%d&quot;</span><span class="p">,</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">vector</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">sprintf</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;%s-rxtx-%d&quot;</span><span class="p">,</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">vector</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">intr</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">vector</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
					  <span class="n">vmxnet3_msix_rx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					  <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to request irq for MSIX&quot;</span>
				       <span class="s">&quot;, %s, error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">intr_idx</span> <span class="o">=</span> <span class="n">vector</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sprintf</span><span class="p">(</span><span class="n">intr</span><span class="o">-&gt;</span><span class="n">event_msi_vector_name</span><span class="p">,</span> <span class="s">&quot;%s-event-%d&quot;</span><span class="p">,</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">vector</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">intr</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">vector</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
				  <span class="n">vmxnet3_msix_event</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				  <span class="n">intr</span><span class="o">-&gt;</span><span class="n">event_msi_vector_name</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
		<span class="n">intr</span><span class="o">-&gt;</span><span class="n">event_intr_idx</span> <span class="o">=</span> <span class="n">vector</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">intr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">VMXNET3_IT_MSI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">vmxnet3_intr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				  <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#endif</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">vmxnet3_intr</span><span class="p">,</span>
				  <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				  <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PCI_MSI</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">intr</span><span class="o">-&gt;</span><span class="n">num_intrs</span> <span class="o">=</span> <span class="n">vector</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to request irq %s (intr type:%d), error&quot;</span>
		       <span class="s">&quot;:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">intr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Number of rx queues will not change after this */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">vmxnet3_rx_queue</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">rq</span><span class="o">-&gt;</span><span class="n">qid</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">rq</span><span class="o">-&gt;</span><span class="n">qid2</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span>
		<span class="p">}</span>



		<span class="cm">/* init our intr settings */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intr</span><span class="o">-&gt;</span><span class="n">num_intrs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">intr</span><span class="o">-&gt;</span><span class="n">mod_levels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">UPT1_IML_ADAPTIVE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">VMXNET3_IT_MSIX</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">event_intr_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">intr_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">intr_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: intr type %u, mode %u, %u vectors &quot;</span>
		       <span class="s">&quot;allocated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">intr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span>
		       <span class="n">intr</span><span class="o">-&gt;</span><span class="n">mask_mode</span><span class="p">,</span> <span class="n">intr</span><span class="o">-&gt;</span><span class="n">num_intrs</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_free_irqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmxnet3_intr</span> <span class="o">*</span><span class="n">intr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">intr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">VMXNET3_IT_AUTO</span> <span class="o">||</span> <span class="n">intr</span><span class="o">-&gt;</span><span class="n">num_intrs</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">intr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_PCI_MSI</span>
	<span class="k">case</span> <span class="n">VMXNET3_IT_MSIX</span>:
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">vector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">share_intr</span> <span class="o">!=</span> <span class="n">VMXNET3_INTR_BUDDYSHARE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">free_irq</span><span class="p">(</span><span class="n">intr</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">vector</span><span class="o">++</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">share_intr</span> <span class="o">==</span> <span class="n">VMXNET3_INTR_TXSHARE</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">free_irq</span><span class="p">(</span><span class="n">intr</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">vector</span><span class="o">++</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
		<span class="p">}</span>

		<span class="n">free_irq</span><span class="p">(</span><span class="n">intr</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">vector</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
			 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">vector</span> <span class="o">&gt;=</span> <span class="n">intr</span><span class="o">-&gt;</span><span class="n">num_intrs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">case</span> <span class="n">VMXNET3_IT_MSI</span>:
		<span class="n">free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VMXNET3_IT_INTX</span>:
		<span class="n">free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_restore_vlan</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">vfTable</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">devRead</span><span class="p">.</span><span class="n">rxFilterConf</span><span class="p">.</span><span class="n">vfTable</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">vid</span><span class="p">;</span>

	<span class="cm">/* allow untagged pkts */</span>
	<span class="n">VMXNET3_SET_VFTABLE_ENTRY</span><span class="p">(</span><span class="n">vfTable</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">for_each_set_bit</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">active_vlans</span><span class="p">,</span> <span class="n">VLAN_N_VID</span><span class="p">)</span>
		<span class="n">VMXNET3_SET_VFTABLE_ENTRY</span><span class="p">(</span><span class="n">vfTable</span><span class="p">,</span> <span class="n">vid</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">vmxnet3_vlan_rx_add_vid</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">vid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="o">*</span><span class="n">vfTable</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">devRead</span><span class="p">.</span><span class="n">rxFilterConf</span><span class="p">.</span><span class="n">vfTable</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">VMXNET3_SET_VFTABLE_ENTRY</span><span class="p">(</span><span class="n">vfTable</span><span class="p">,</span> <span class="n">vid</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">VMXNET3_WRITE_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_CMD</span><span class="p">,</span>
				       <span class="n">VMXNET3_CMD_UPDATE_VLAN_FILTERS</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">active_vlans</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">vmxnet3_vlan_rx_kill_vid</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">vid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="o">*</span><span class="n">vfTable</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">devRead</span><span class="p">.</span><span class="n">rxFilterConf</span><span class="p">.</span><span class="n">vfTable</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">VMXNET3_CLEAR_VFTABLE_ENTRY</span><span class="p">(</span><span class="n">vfTable</span><span class="p">,</span> <span class="n">vid</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">VMXNET3_WRITE_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_CMD</span><span class="p">,</span>
				       <span class="n">VMXNET3_CMD_UPDATE_VLAN_FILTERS</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">active_vlans</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">u8</span> <span class="o">*</span>
<span class="nf">vmxnet3_copy_mc</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">netdev_mc_count</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">*</span> <span class="n">ETH_ALEN</span><span class="p">;</span>

	<span class="cm">/* struct Vmxnet3_RxFilterConf.mfTableLen is u16. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sz</span> <span class="o">&lt;=</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We may be called with BH disabled */</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">netdev</span><span class="p">)</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">i</span><span class="o">++</span> <span class="o">*</span> <span class="n">ETH_ALEN</span><span class="p">,</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span>
				       <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_set_mc</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Vmxnet3_RxFilterConf</span> <span class="o">*</span><span class="n">rxConf</span> <span class="o">=</span>
					<span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">devRead</span><span class="p">.</span><span class="n">rxFilterConf</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">new_table</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">new_mode</span> <span class="o">=</span> <span class="n">VMXNET3_RXM_UCAST</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="o">*</span><span class="n">vfTable</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">devRead</span><span class="p">.</span><span class="n">rxFilterConf</span><span class="p">.</span><span class="n">vfTable</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">vfTable</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">VMXNET3_VFT_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">vfTable</span><span class="p">));</span>

		<span class="n">new_mode</span> <span class="o">|=</span> <span class="n">VMXNET3_RXM_PROMISC</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">vmxnet3_restore_vlan</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_BROADCAST</span><span class="p">)</span>
		<span class="n">new_mode</span> <span class="o">|=</span> <span class="n">VMXNET3_RXM_BCAST</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">)</span>
		<span class="n">new_mode</span> <span class="o">|=</span> <span class="n">VMXNET3_RXM_ALL_MULTI</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netdev_mc_empty</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">new_table</span> <span class="o">=</span> <span class="n">vmxnet3_copy_mc</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new_table</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">new_mode</span> <span class="o">|=</span> <span class="n">VMXNET3_RXM_MCAST</span><span class="p">;</span>
				<span class="n">rxConf</span><span class="o">-&gt;</span><span class="n">mfTableLen</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span>
					<span class="n">netdev_mc_count</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">*</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
				<span class="n">rxConf</span><span class="o">-&gt;</span><span class="n">mfTablePA</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">virt_to_phys</span><span class="p">(</span>
						    <span class="n">new_table</span><span class="p">));</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: failed to copy mcast list&quot;</span>
				       <span class="s">&quot;, setting ALL_MULTI</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="n">new_mode</span> <span class="o">|=</span> <span class="n">VMXNET3_RXM_ALL_MULTI</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>


	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">new_mode</span> <span class="o">&amp;</span> <span class="n">VMXNET3_RXM_MCAST</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rxConf</span><span class="o">-&gt;</span><span class="n">mfTableLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rxConf</span><span class="o">-&gt;</span><span class="n">mfTablePA</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_mode</span> <span class="o">!=</span> <span class="n">rxConf</span><span class="o">-&gt;</span><span class="n">rxMode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rxConf</span><span class="o">-&gt;</span><span class="n">rxMode</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">new_mode</span><span class="p">);</span>
		<span class="n">VMXNET3_WRITE_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_CMD</span><span class="p">,</span>
				       <span class="n">VMXNET3_CMD_UPDATE_RX_MODE</span><span class="p">);</span>
		<span class="n">VMXNET3_WRITE_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_CMD</span><span class="p">,</span>
				       <span class="n">VMXNET3_CMD_UPDATE_VLAN_FILTERS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">VMXNET3_WRITE_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_CMD</span><span class="p">,</span>
			       <span class="n">VMXNET3_CMD_UPDATE_MAC_FILTERS</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">new_table</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">vmxnet3_rq_destroy_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">vmxnet3_rq_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *   Set up driver_shared based on settings in adapter.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_setup_driver_shared</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Vmxnet3_DriverShared</span> <span class="o">*</span><span class="n">shared</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Vmxnet3_DSDevRead</span> <span class="o">*</span><span class="n">devRead</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">devRead</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Vmxnet3_TxQueueConf</span> <span class="o">*</span><span class="n">tqc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Vmxnet3_RxQueueConf</span> <span class="o">*</span><span class="n">rqc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">shared</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">shared</span><span class="p">));</span>

	<span class="cm">/* driver settings */</span>
	<span class="n">shared</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">VMXNET3_REV1_MAGIC</span><span class="p">);</span>
	<span class="n">devRead</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">.</span><span class="n">driverInfo</span><span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>
						<span class="n">VMXNET3_DRIVER_VERSION_NUM</span><span class="p">);</span>
	<span class="n">devRead</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">.</span><span class="n">driverInfo</span><span class="p">.</span><span class="n">gos</span><span class="p">.</span><span class="n">gosBits</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">?</span>
				<span class="n">VMXNET3_GOS_BITS_32</span> <span class="o">:</span> <span class="n">VMXNET3_GOS_BITS_64</span><span class="p">);</span>
	<span class="n">devRead</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">.</span><span class="n">driverInfo</span><span class="p">.</span><span class="n">gos</span><span class="p">.</span><span class="n">gosType</span> <span class="o">=</span> <span class="n">VMXNET3_GOS_TYPE_LINUX</span><span class="p">;</span>
	<span class="o">*</span><span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">devRead</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">.</span><span class="n">driverInfo</span><span class="p">.</span><span class="n">gos</span><span class="p">)</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>
				<span class="o">*</span><span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">devRead</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">.</span><span class="n">driverInfo</span><span class="p">.</span><span class="n">gos</span><span class="p">));</span>
	<span class="n">devRead</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">.</span><span class="n">driverInfo</span><span class="p">.</span><span class="n">vmxnet3RevSpt</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">devRead</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">.</span><span class="n">driverInfo</span><span class="p">.</span><span class="n">uptVerSpt</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">devRead</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">.</span><span class="n">ddPA</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">virt_to_phys</span><span class="p">(</span><span class="n">adapter</span><span class="p">));</span>
	<span class="n">devRead</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">.</span><span class="n">ddLen</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span><span class="p">));</span>

	<span class="cm">/* set up feature flags */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXCSUM</span><span class="p">)</span>
		<span class="n">devRead</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">.</span><span class="n">uptFeatures</span> <span class="o">|=</span> <span class="n">UPT1_F_RXCSUM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_LRO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">devRead</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">.</span><span class="n">uptFeatures</span> <span class="o">|=</span> <span class="n">UPT1_F_LRO</span><span class="p">;</span>
		<span class="n">devRead</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">.</span><span class="n">maxNumRxSG</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">MAX_SKB_FRAGS</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_HW_VLAN_RX</span><span class="p">)</span>
		<span class="n">devRead</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">.</span><span class="n">uptFeatures</span> <span class="o">|=</span> <span class="n">UPT1_F_RXVLAN</span><span class="p">;</span>

	<span class="n">devRead</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">.</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">);</span>
	<span class="n">devRead</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">.</span><span class="n">queueDescPA</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">queue_desc_pa</span><span class="p">);</span>
	<span class="n">devRead</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">.</span><span class="n">queueDescLen</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_TxQueueDesc</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_RxQueueDesc</span><span class="p">));</span>

	<span class="cm">/* tx queue settings */</span>
	<span class="n">devRead</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">.</span><span class="n">numTxQueues</span> <span class="o">=</span>  <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vmxnet3_tx_queue</span>	<span class="o">*</span><span class="n">tq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">tqc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tqd_start</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">conf</span><span class="p">;</span>
		<span class="n">tqc</span><span class="o">-&gt;</span><span class="n">txRingBasePA</span>   <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">basePA</span><span class="p">);</span>
		<span class="n">tqc</span><span class="o">-&gt;</span><span class="n">dataRingBasePA</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">data_ring</span><span class="p">.</span><span class="n">basePA</span><span class="p">);</span>
		<span class="n">tqc</span><span class="o">-&gt;</span><span class="n">compRingBasePA</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">basePA</span><span class="p">);</span>
		<span class="n">tqc</span><span class="o">-&gt;</span><span class="n">ddPA</span>           <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">virt_to_phys</span><span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">));</span>
		<span class="n">tqc</span><span class="o">-&gt;</span><span class="n">txRingSize</span>     <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
		<span class="n">tqc</span><span class="o">-&gt;</span><span class="n">dataRingSize</span>   <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">data_ring</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
		<span class="n">tqc</span><span class="o">-&gt;</span><span class="n">compRingSize</span>   <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
		<span class="n">tqc</span><span class="o">-&gt;</span><span class="n">ddLen</span>          <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_tx_buf_info</span><span class="p">)</span> <span class="o">*</span>
					<span class="n">tqc</span><span class="o">-&gt;</span><span class="n">txRingSize</span><span class="p">);</span>
		<span class="n">tqc</span><span class="o">-&gt;</span><span class="n">intrIdx</span>        <span class="o">=</span> <span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">intr_idx</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* rx queue settings */</span>
	<span class="n">devRead</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">.</span><span class="n">numRxQueues</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vmxnet3_rx_queue</span>	<span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">rqc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rqd_start</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">conf</span><span class="p">;</span>
		<span class="n">rqc</span><span class="o">-&gt;</span><span class="n">rxRingBasePA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">basePA</span><span class="p">);</span>
		<span class="n">rqc</span><span class="o">-&gt;</span><span class="n">rxRingBasePA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">basePA</span><span class="p">);</span>
		<span class="n">rqc</span><span class="o">-&gt;</span><span class="n">compRingBasePA</span>  <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">basePA</span><span class="p">);</span>
		<span class="n">rqc</span><span class="o">-&gt;</span><span class="n">ddPA</span>            <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">virt_to_phys</span><span class="p">(</span>
							<span class="n">rq</span><span class="o">-&gt;</span><span class="n">buf_info</span><span class="p">));</span>
		<span class="n">rqc</span><span class="o">-&gt;</span><span class="n">rxRingSize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>   <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">);</span>
		<span class="n">rqc</span><span class="o">-&gt;</span><span class="n">rxRingSize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>   <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">);</span>
		<span class="n">rqc</span><span class="o">-&gt;</span><span class="n">compRingSize</span>    <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
		<span class="n">rqc</span><span class="o">-&gt;</span><span class="n">ddLen</span>           <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_rx_buf_info</span><span class="p">)</span> <span class="o">*</span>
					<span class="p">(</span><span class="n">rqc</span><span class="o">-&gt;</span><span class="n">rxRingSize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
					 <span class="n">rqc</span><span class="o">-&gt;</span><span class="n">rxRingSize</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>
		<span class="n">rqc</span><span class="o">-&gt;</span><span class="n">intrIdx</span>         <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">intr_idx</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef VMXNET3_RSS</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rss_conf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rss_conf</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rss</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">UPT1_RSSConf</span> <span class="o">*</span><span class="n">rssConf</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rss_conf</span><span class="p">;</span>
		<span class="n">devRead</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">.</span><span class="n">uptFeatures</span> <span class="o">|=</span> <span class="n">UPT1_F_RSS</span><span class="p">;</span>
		<span class="n">devRead</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">.</span><span class="n">numRxQueues</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span>
		<span class="n">rssConf</span><span class="o">-&gt;</span><span class="n">hashType</span> <span class="o">=</span> <span class="n">UPT1_RSS_HASH_TYPE_TCP_IPV4</span> <span class="o">|</span>
				    <span class="n">UPT1_RSS_HASH_TYPE_IPV4</span> <span class="o">|</span>
				    <span class="n">UPT1_RSS_HASH_TYPE_TCP_IPV6</span> <span class="o">|</span>
				    <span class="n">UPT1_RSS_HASH_TYPE_IPV6</span><span class="p">;</span>
		<span class="n">rssConf</span><span class="o">-&gt;</span><span class="n">hashFunc</span> <span class="o">=</span> <span class="n">UPT1_RSS_HASH_FUNC_TOEPLITZ</span><span class="p">;</span>
		<span class="n">rssConf</span><span class="o">-&gt;</span><span class="n">hashKeySize</span> <span class="o">=</span> <span class="n">UPT1_RSS_MAX_KEY_SIZE</span><span class="p">;</span>
		<span class="n">rssConf</span><span class="o">-&gt;</span><span class="n">indTableSize</span> <span class="o">=</span> <span class="n">VMXNET3_RSS_IND_TABLE_SIZE</span><span class="p">;</span>
		<span class="n">get_random_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rssConf</span><span class="o">-&gt;</span><span class="n">hashKey</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rssConf</span><span class="o">-&gt;</span><span class="n">hashKeySize</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rssConf</span><span class="o">-&gt;</span><span class="n">indTableSize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">rssConf</span><span class="o">-&gt;</span><span class="n">indTable</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ethtool_rxfh_indir_default</span><span class="p">(</span>
				<span class="n">i</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">);</span>

		<span class="n">devRead</span><span class="o">-&gt;</span><span class="n">rssConfDesc</span><span class="p">.</span><span class="n">confVer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">devRead</span><span class="o">-&gt;</span><span class="n">rssConfDesc</span><span class="p">.</span><span class="n">confLen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rssConf</span><span class="p">);</span>
		<span class="n">devRead</span><span class="o">-&gt;</span><span class="n">rssConfDesc</span><span class="p">.</span><span class="n">confPA</span>  <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">rssConf</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* VMXNET3_RSS */</span><span class="cp"></span>

	<span class="cm">/* intr settings */</span>
	<span class="n">devRead</span><span class="o">-&gt;</span><span class="n">intrConf</span><span class="p">.</span><span class="n">autoMask</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">mask_mode</span> <span class="o">==</span>
				     <span class="n">VMXNET3_IMM_AUTO</span><span class="p">;</span>
	<span class="n">devRead</span><span class="o">-&gt;</span><span class="n">intrConf</span><span class="p">.</span><span class="n">numIntrs</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">num_intrs</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">num_intrs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">devRead</span><span class="o">-&gt;</span><span class="n">intrConf</span><span class="p">.</span><span class="n">modLevels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">mod_levels</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="n">devRead</span><span class="o">-&gt;</span><span class="n">intrConf</span><span class="p">.</span><span class="n">eventIntrIdx</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">event_intr_idx</span><span class="p">;</span>
	<span class="n">devRead</span><span class="o">-&gt;</span><span class="n">intrConf</span><span class="p">.</span><span class="n">intrCtrl</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">VMXNET3_IC_DISABLE_ALL</span><span class="p">);</span>

	<span class="cm">/* rx filter settings */</span>
	<span class="n">devRead</span><span class="o">-&gt;</span><span class="n">rxFilterConf</span><span class="p">.</span><span class="n">rxMode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vmxnet3_restore_vlan</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">vmxnet3_write_mac_addr</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>

	<span class="cm">/* the rest are already zeroed */</span>
<span class="p">}</span>


<span class="kt">int</span>
<span class="nf">vmxnet3_activate_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: skb_buf_size %d, rx_buf_per_pkt %d,&quot;</span>
		<span class="s">&quot; ring sizes %u %u %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">skb_buf_size</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buf_per_pkt</span><span class="p">,</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">size</span><span class="p">,</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">,</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">);</span>

	<span class="n">vmxnet3_tq_init_all</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">vmxnet3_rq_init_all</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to init rx queue for %s: error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">rq_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">vmxnet3_request_irqs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to setup irq for %s: error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">irq_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vmxnet3_setup_driver_shared</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">VMXNET3_WRITE_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_DSAL</span><span class="p">,</span> <span class="n">VMXNET3_GET_ADDR_LO</span><span class="p">(</span>
			       <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shared_pa</span><span class="p">));</span>
	<span class="n">VMXNET3_WRITE_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_DSAH</span><span class="p">,</span> <span class="n">VMXNET3_GET_ADDR_HI</span><span class="p">(</span>
			       <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shared_pa</span><span class="p">));</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">VMXNET3_WRITE_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_CMD</span><span class="p">,</span>
			       <span class="n">VMXNET3_CMD_ACTIVATE_DEV</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">VMXNET3_READ_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_CMD</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to activate dev %s: error %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">activate_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">VMXNET3_WRITE_BAR0_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
				<span class="n">VMXNET3_REG_RXPROD</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">VMXNET3_REG_ALIGN</span><span class="p">,</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">next2fill</span><span class="p">);</span>
		<span class="n">VMXNET3_WRITE_BAR0_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="p">(</span><span class="n">VMXNET3_REG_RXPROD2</span> <span class="o">+</span>
				<span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">VMXNET3_REG_ALIGN</span><span class="p">)),</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">next2fill</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Apply the rx filter settins last. */</span>
	<span class="n">vmxnet3_set_mc</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check link state when first activating device. It will start the</span>
<span class="cm">	 * tx queue if the link is up.</span>
<span class="cm">	 */</span>
	<span class="n">vmxnet3_check_link</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">napi</span><span class="p">);</span>
	<span class="n">vmxnet3_enable_all_intrs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">VMXNET3_STATE_BIT_QUIESCED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">activate_err:</span>
	<span class="n">VMXNET3_WRITE_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_DSAL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">VMXNET3_WRITE_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_DSAH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vmxnet3_free_irqs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="nl">irq_err:</span>
<span class="nl">rq_err:</span>
	<span class="cm">/* free up buffers we allocated */</span>
	<span class="n">vmxnet3_rq_cleanup_all</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span>
<span class="nf">vmxnet3_reset_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">VMXNET3_WRITE_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_CMD</span><span class="p">,</span> <span class="n">VMXNET3_CMD_RESET_DEV</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">int</span>
<span class="nf">vmxnet3_quiesce_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">VMXNET3_STATE_BIT_QUIESCED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>


	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">VMXNET3_WRITE_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_CMD</span><span class="p">,</span>
			       <span class="n">VMXNET3_CMD_QUIESCE_DEV</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">vmxnet3_disable_all_intrs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">napi</span><span class="p">);</span>
	<span class="n">netif_tx_disable</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">vmxnet3_tq_cleanup_all</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">vmxnet3_rq_cleanup_all</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">vmxnet3_free_irqs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_write_mac_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">mac</span><span class="p">;</span>
	<span class="n">VMXNET3_WRITE_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_MACL</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">mac</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">mac</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">VMXNET3_WRITE_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_MACH</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">vmxnet3_set_mac_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="n">vmxnet3_write_mac_addr</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* ==================== initialization and cleanup routines ============ */</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">vmxnet3_alloc_pci_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">dma64</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmio_start</span><span class="p">,</span> <span class="n">mmio_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to enable adapter %s: error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">),</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;pci_set_consistent_dma_mask failed &quot;</span>
			       <span class="s">&quot;for adapter %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">));</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_set_mask</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">dma64</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;pci_set_dma_mask failed for adapter &quot;</span>
			       <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>	<span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">));</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_set_mask</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">dma64</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_request_selected_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
					   <span class="n">vmxnet3_driver_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to request region for adapter %s: &quot;</span>
		       <span class="s">&quot;error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">),</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_set_mask</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">mmio_start</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mmio_len</span> <span class="o">=</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_addr0</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">mmio_start</span><span class="p">,</span> <span class="n">mmio_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_addr0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to map bar0 for adapter %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">));</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_ioremap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mmio_start</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">mmio_len</span> <span class="o">=</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_addr1</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">mmio_start</span><span class="p">,</span> <span class="n">mmio_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_addr1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to map bar1 for adapter %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">));</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_bar1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_bar1:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_addr0</span><span class="p">);</span>
<span class="nl">err_ioremap:</span>
	<span class="n">pci_release_selected_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="nl">err_set_mask:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_free_pci_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">iounmap</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_addr0</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_addr1</span><span class="p">);</span>
	<span class="n">pci_release_selected_regions</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_adjust_rx_ring_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">sz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ring0_size</span><span class="p">,</span> <span class="n">ring1_size</span><span class="p">,</span> <span class="n">comp_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmxnet3_rx_queue</span>	<span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">&lt;=</span> <span class="n">VMXNET3_MAX_SKB_BUF_SIZE</span> <span class="o">-</span>
				    <span class="n">VMXNET3_MAX_ETH_HDR_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">skb_buf_size</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">+</span>
					<span class="n">VMXNET3_MAX_ETH_HDR_SIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">skb_buf_size</span> <span class="o">&lt;</span> <span class="n">VMXNET3_MIN_T0_BUF_SIZE</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">skb_buf_size</span> <span class="o">=</span> <span class="n">VMXNET3_MIN_T0_BUF_SIZE</span><span class="p">;</span>

		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buf_per_pkt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">skb_buf_size</span> <span class="o">=</span> <span class="n">VMXNET3_MAX_SKB_BUF_SIZE</span><span class="p">;</span>
		<span class="n">sz</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">-</span> <span class="n">VMXNET3_MAX_SKB_BUF_SIZE</span> <span class="o">+</span>
					    <span class="n">VMXNET3_MAX_ETH_HDR_SIZE</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buf_per_pkt</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">sz</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * for simplicity, force the ring0 size to be a multiple of</span>
<span class="cm">	 * rx_buf_per_pkt * VMXNET3_RING_SIZE_ALIGN</span>
<span class="cm">	 */</span>
	<span class="n">sz</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buf_per_pkt</span> <span class="o">*</span> <span class="n">VMXNET3_RING_SIZE_ALIGN</span><span class="p">;</span>
	<span class="n">ring0_size</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
	<span class="n">ring0_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">ring0_size</span> <span class="o">+</span> <span class="n">sz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">sz</span> <span class="o">*</span> <span class="n">sz</span><span class="p">;</span>
	<span class="n">ring0_size</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">ring0_size</span><span class="p">,</span> <span class="n">VMXNET3_RX_RING_MAX_SIZE</span> <span class="o">/</span>
			   <span class="n">sz</span> <span class="o">*</span> <span class="n">sz</span><span class="p">);</span>
	<span class="n">ring1_size</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
	<span class="n">comp_size</span> <span class="o">=</span> <span class="n">ring0_size</span> <span class="o">+</span> <span class="n">ring1_size</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">ring0_size</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">ring1_size</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">comp_size</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="kt">int</span>
<span class="nf">vmxnet3_create_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">tx_ring_size</span><span class="p">,</span>
		      <span class="n">u32</span> <span class="n">rx_ring_size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">rx_ring2_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vmxnet3_tx_queue</span>	<span class="o">*</span><span class="n">tq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">tq</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">size</span>   <span class="o">=</span> <span class="n">tx_ring_size</span><span class="p">;</span>
		<span class="n">tq</span><span class="o">-&gt;</span><span class="n">data_ring</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">tx_ring_size</span><span class="p">;</span>
		<span class="n">tq</span><span class="o">-&gt;</span><span class="n">comp_ring</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">tx_ring_size</span><span class="p">;</span>
		<span class="n">tq</span><span class="o">-&gt;</span><span class="n">shared</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tqd_start</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ctrl</span><span class="p">;</span>
		<span class="n">tq</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">tq</span><span class="o">-&gt;</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">adapter</span><span class="p">;</span>
		<span class="n">tq</span><span class="o">-&gt;</span><span class="n">qid</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">vmxnet3_tq_create</span><span class="p">(</span><span class="n">tq</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Too late to change num_tx_queues. We cannot do away with</span>
<span class="cm">		 * lesser number of queues than what we asked for</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">queue_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">rx_ring_size</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">rx_ring2_size</span><span class="p">;</span>
	<span class="n">vmxnet3_adjust_rx_ring_size</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vmxnet3_rx_queue</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="cm">/* qid and qid2 for rx queues will be assigned later when num</span>
<span class="cm">		 * of rx queues is finalized after allocating intrs */</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">shared</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rqd_start</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ctrl</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">adapter</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">vmxnet3_rq_create</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Could not allocate any rx&quot;</span>
				       <span class="s">&quot;queues. Aborting.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">queue_err</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Number of rx queues changed &quot;</span>
				       <span class="s">&quot;to : %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="nl">queue_err:</span>
	<span class="n">vmxnet3_tq_destroy_all</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">vmxnet3_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tx_lock</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">vmxnet3_create_queues</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_DEF_TX_RING_SIZE</span><span class="p">,</span>
				    <span class="n">VMXNET3_DEF_RX_RING_SIZE</span><span class="p">,</span>
				    <span class="n">VMXNET3_DEF_RX_RING_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">queue_err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">vmxnet3_activate_dev</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">activate_err</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">activate_err:</span>
	<span class="n">vmxnet3_rq_destroy_all</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">vmxnet3_tq_destroy_all</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="nl">queue_err:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">vmxnet3_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reset_work may be in the middle of resetting the device, wait for its</span>
<span class="cm">	 * completion.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">VMXNET3_STATE_BIT_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">vmxnet3_quiesce_dev</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">vmxnet3_rq_destroy_all</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">vmxnet3_tq_destroy_all</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">VMXNET3_STATE_BIT_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>


	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span>
<span class="nf">vmxnet3_force_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * we must clear VMXNET3_STATE_BIT_RESETTING, otherwise</span>
<span class="cm">	 * vmxnet3_close() will deadlock.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">VMXNET3_STATE_BIT_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">));</span>

	<span class="cm">/* we need to enable NAPI, otherwise dev_close will deadlock */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">napi</span><span class="p">);</span>
	<span class="n">dev_close</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">vmxnet3_change_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_mtu</span> <span class="o">&lt;</span> <span class="n">VMXNET3_MIN_MTU</span> <span class="o">||</span> <span class="n">new_mtu</span> <span class="o">&gt;</span> <span class="n">VMXNET3_MAX_MTU</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">new_mtu</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reset_work may be in the middle of resetting the device, wait for its</span>
<span class="cm">	 * completion.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">VMXNET3_STATE_BIT_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vmxnet3_quiesce_dev</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">vmxnet3_reset_dev</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

		<span class="cm">/* we need to re-create the rx queue based on the new mtu */</span>
		<span class="n">vmxnet3_rq_destroy_all</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">vmxnet3_adjust_rx_ring_size</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">vmxnet3_rq_create_all</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: failed to re-create rx queues,&quot;</span>
				<span class="s">&quot; error %d. Closing it.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">vmxnet3_activate_dev</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: failed to re-activate, error %d. &quot;</span>
				<span class="s">&quot;Closing it</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">VMXNET3_STATE_BIT_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">vmxnet3_force_close</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_declare_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">bool</span> <span class="n">dma64</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">=</span> <span class="n">NETIF_F_SG</span> <span class="o">|</span> <span class="n">NETIF_F_RXCSUM</span> <span class="o">|</span>
		<span class="n">NETIF_F_HW_CSUM</span> <span class="o">|</span> <span class="n">NETIF_F_HW_VLAN_TX</span> <span class="o">|</span>
		<span class="n">NETIF_F_HW_VLAN_RX</span> <span class="o">|</span> <span class="n">NETIF_F_TSO</span> <span class="o">|</span> <span class="n">NETIF_F_TSO6</span> <span class="o">|</span>
		<span class="n">NETIF_F_LRO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma64</span><span class="p">)</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">|=</span> <span class="n">NETIF_F_HIGHDMA</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">vlan_features</span> <span class="o">=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">&amp;</span>
				<span class="o">~</span><span class="p">(</span><span class="n">NETIF_F_HW_VLAN_TX</span> <span class="o">|</span> <span class="n">NETIF_F_HW_VLAN_RX</span><span class="p">);</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">|</span> <span class="n">NETIF_F_HW_VLAN_FILTER</span><span class="p">;</span>

	<span class="n">netdev_info</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span>
		<span class="s">&quot;features: sg csum vlan jf tso tsoIPv6 lro%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">dma64</span> <span class="o">?</span> <span class="s">&quot; highDMA&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_read_mac_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">VMXNET3_READ_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_MACL</span><span class="p">);</span>
	<span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">mac</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">VMXNET3_READ_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_MACH</span><span class="p">);</span>
	<span class="n">mac</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">mac</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PCI_MSI</span>

<span class="cm">/*</span>
<span class="cm"> * Enable MSIx vectors.</span>
<span class="cm"> * Returns :</span>
<span class="cm"> *	0 on successful enabling of required vectors,</span>
<span class="cm"> *	VMXNET3_LINUX_MIN_MSIX_VECT when only minimum number of vectors required</span>
<span class="cm"> *	 could be enabled.</span>
<span class="cm"> *	number of vectors which can be enabled otherwise (this number is smaller</span>
<span class="cm"> *	 than VMXNET3_LINUX_MIN_MSIX_VECT)</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">vmxnet3_acquire_msix_vectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">vectors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vector_threshold</span><span class="p">;</span>
	<span class="n">vector_threshold</span> <span class="o">=</span> <span class="n">VMXNET3_LINUX_MIN_MSIX_VECT</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">vectors</span> <span class="o">&gt;=</span> <span class="n">vector_threshold</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_msix</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">msix_entries</span><span class="p">,</span>
				      <span class="n">vectors</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">num_intrs</span> <span class="o">=</span> <span class="n">vectors</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span>
				   <span class="s">&quot;Failed to enable MSI-X, error: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="n">vectors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="n">vector_threshold</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* If fails to enable required number of MSI-x vectors</span>
<span class="cm">			 * try enabling minimum number of vectors required.</span>
<span class="cm">			 */</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span>
				   <span class="s">&quot;Failed to enable %d MSI-X, trying %d instead</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">vectors</span><span class="p">,</span> <span class="n">vector_threshold</span><span class="p">);</span>
			<span class="n">vectors</span> <span class="o">=</span> <span class="n">vector_threshold</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">netdev_info</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span>
		    <span class="s">&quot;Number of MSI-X interrupts which can be allocated are lower than min threshold required.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI_MSI */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_alloc_intr_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cfg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* intr settings */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">VMXNET3_WRITE_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_CMD</span><span class="p">,</span>
			       <span class="n">VMXNET3_CMD_GET_CONF_INTR</span><span class="p">);</span>
	<span class="n">cfg</span> <span class="o">=</span> <span class="n">VMXNET3_READ_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_CMD</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">cfg</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">mask_mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">cfg</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">VMXNET3_IT_AUTO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">VMXNET3_IT_MSIX</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PCI_MSI</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">VMXNET3_IT_MSIX</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">vector</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">num_intrs</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">share_intr</span> <span class="o">==</span>
					   <span class="n">VMXNET3_INTR_TXSHARE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span>
					   <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">num_intrs</span> <span class="o">+=</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">share_intr</span> <span class="o">==</span>
					   <span class="n">VMXNET3_INTR_BUDDYSHARE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span>
					   <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">num_intrs</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* for link event */</span>

		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">num_intrs</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">num_intrs</span> <span class="o">&gt;</span>
					   <span class="n">VMXNET3_LINUX_MIN_MSIX_VECT</span>
					   <span class="o">?</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">num_intrs</span> <span class="o">:</span>
					   <span class="n">VMXNET3_LINUX_MIN_MSIX_VECT</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">vector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">vector</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">num_intrs</span><span class="p">;</span> <span class="n">vector</span><span class="o">++</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">vector</span><span class="p">].</span><span class="n">entry</span> <span class="o">=</span> <span class="n">vector</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">vmxnet3_acquire_msix_vectors</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
						   <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">num_intrs</span><span class="p">);</span>
		<span class="cm">/* If we cannot allocate one MSIx vector per queue</span>
<span class="cm">		 * then limit the number of rx queues to 1</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">VMXNET3_LINUX_MIN_MSIX_VECT</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">share_intr</span> <span class="o">!=</span> <span class="n">VMXNET3_INTR_BUDDYSHARE</span>
			    <span class="o">||</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">share_intr</span> <span class="o">=</span> <span class="n">VMXNET3_INTR_TXSHARE</span><span class="p">;</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Number of rx queues : 1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">num_intrs</span> <span class="o">=</span>
						<span class="n">VMXNET3_LINUX_MIN_MSIX_VECT</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="cm">/* If we cannot allocate MSIx vectors use only one rx queue */</span>
		<span class="n">netdev_info</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span>
			    <span class="s">&quot;Failed to enable MSI-X, error %d . Limiting #rx queues to 1, try MSI.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">err</span><span class="p">);</span>

		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">VMXNET3_IT_MSI</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">VMXNET3_IT_MSI</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_msi</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">num_intrs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI_MSI */</span><span class="cp"></span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Using INTx interrupt, #Rx queues: 1.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">VMXNET3_IT_INTX</span><span class="p">;</span>

	<span class="cm">/* INT-X related setting */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">num_intrs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_free_intr_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">VMXNET3_IT_MSIX</span><span class="p">)</span>
		<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">VMXNET3_IT_MSI</span><span class="p">)</span>
		<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">VMXNET3_IT_INTX</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_timeout_count</span><span class="o">++</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: tx hang</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_reset_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>

	<span class="n">adapter</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmxnet3_adapter</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

	<span class="cm">/* if another thread is resetting the device, no need to proceed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">VMXNET3_STATE_BIT_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* if the device is closed, we must leave it alone */</span>
	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: resetting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">vmxnet3_quiesce_dev</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">vmxnet3_reset_dev</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">vmxnet3_activate_dev</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: already closed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">VMXNET3_STATE_BIT_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">vmxnet3_probe_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
		     <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">vmxnet3_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ndo_open</span> <span class="o">=</span> <span class="n">vmxnet3_open</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ndo_stop</span> <span class="o">=</span> <span class="n">vmxnet3_close</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ndo_start_xmit</span> <span class="o">=</span> <span class="n">vmxnet3_xmit_frame</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ndo_set_mac_address</span> <span class="o">=</span> <span class="n">vmxnet3_set_mac_addr</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ndo_change_mtu</span> <span class="o">=</span> <span class="n">vmxnet3_change_mtu</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ndo_set_features</span> <span class="o">=</span> <span class="n">vmxnet3_set_features</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ndo_get_stats64</span> <span class="o">=</span> <span class="n">vmxnet3_get_stats64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ndo_tx_timeout</span> <span class="o">=</span> <span class="n">vmxnet3_tx_timeout</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ndo_set_rx_mode</span> <span class="o">=</span> <span class="n">vmxnet3_set_mc</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ndo_vlan_rx_add_vid</span> <span class="o">=</span> <span class="n">vmxnet3_vlan_rx_add_vid</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ndo_vlan_rx_kill_vid</span> <span class="o">=</span> <span class="n">vmxnet3_vlan_rx_kill_vid</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
		<span class="p">.</span><span class="n">ndo_poll_controller</span> <span class="o">=</span> <span class="n">vmxnet3_netpoll</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">dma64</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="cm">/* stupid gcc */</span>
	<span class="n">u32</span> <span class="n">ver</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">mac</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_tx_queues</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_rx_queues</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_msi_enabled</span><span class="p">())</span>
		<span class="n">enable_mq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef VMXNET3_RSS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable_mq</span><span class="p">)</span>
		<span class="n">num_rx_queues</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">VMXNET3_DEVICE_MAX_RX_QUEUES</span><span class="p">,</span>
				    <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">num_online_cpus</span><span class="p">());</span>
	<span class="k">else</span>
<span class="cp">#endif</span>
		<span class="n">num_rx_queues</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">num_rx_queues</span> <span class="o">=</span> <span class="n">rounddown_pow_of_two</span><span class="p">(</span><span class="n">num_rx_queues</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable_mq</span><span class="p">)</span>
		<span class="n">num_tx_queues</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">VMXNET3_DEVICE_MAX_TX_QUEUES</span><span class="p">,</span>
				    <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">num_online_cpus</span><span class="p">());</span>
	<span class="k">else</span>
		<span class="n">num_tx_queues</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">num_tx_queues</span> <span class="o">=</span> <span class="n">rounddown_pow_of_two</span><span class="p">(</span><span class="n">num_tx_queues</span><span class="p">);</span>
	<span class="n">netdev</span> <span class="o">=</span> <span class="n">alloc_etherdev_mq</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmxnet3_adapter</span><span class="p">),</span>
				   <span class="n">max</span><span class="p">(</span><span class="n">num_tx_queues</span><span class="p">,</span> <span class="n">num_rx_queues</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;# of Tx queues : %d, # of Rx queues : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">num_tx_queues</span><span class="p">,</span> <span class="n">num_rx_queues</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netdev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
	<span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">netdev</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_lock</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shared</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
			  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_DriverShared</span><span class="p">),</span>
			  <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shared_pa</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to allocate memory for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">));</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_alloc_shared</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">=</span> <span class="n">num_rx_queues</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span> <span class="o">=</span> <span class="n">num_tx_queues</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_TxQueueDesc</span><span class="p">)</span> <span class="o">*</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_RxQueueDesc</span><span class="p">)</span> <span class="o">*</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tqd_start</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">queue_desc_pa</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tqd_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to allocate memory for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">));</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_alloc_queue_desc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rqd_start</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_RxQueueDesc</span> <span class="o">*</span><span class="p">)(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tqd_start</span> <span class="o">+</span>
							<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pm_conf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_PMConf</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pm_conf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_alloc_pm</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef VMXNET3_RSS</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rss_conf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">UPT1_RSSConf</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rss_conf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_alloc_rss</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* VMXNET3_RSS */</span><span class="cp"></span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">vmxnet3_alloc_pci_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma64</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_alloc_pci</span><span class="p">;</span>

	<span class="n">ver</span> <span class="o">=</span> <span class="n">VMXNET3_READ_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_VRRS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ver</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">VMXNET3_WRITE_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_VRRS</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Incompatible h/w version (0x%x) for adapter&quot;</span>
		       <span class="s">&quot; %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>	<span class="n">ver</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">));</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_ver</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ver</span> <span class="o">=</span> <span class="n">VMXNET3_READ_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_UVRS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ver</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">VMXNET3_WRITE_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_UVRS</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Incompatible upt version (0x%x) for &quot;</span>
		       <span class="s">&quot;adapter %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ver</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">));</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_ver</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">vmxnet3_declare_features</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">dma64</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev_number</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devices_found</span><span class="p">);</span>

	 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">share_intr</span> <span class="o">=</span> <span class="n">irq_share_mode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">share_intr</span> <span class="o">==</span> <span class="n">VMXNET3_INTR_BUDDYSHARE</span> <span class="o">&amp;&amp;</span>
	    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span> <span class="o">!=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">share_intr</span> <span class="o">=</span> <span class="n">VMXNET3_INTR_DONTSHARE</span><span class="p">;</span>

	<span class="n">vmxnet3_alloc_intr_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

<span class="cp">#ifdef VMXNET3_RSS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
	    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">VMXNET3_IT_MSIX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rss</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;RSS is enabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rss</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">vmxnet3_read_mac_addr</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">mac</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span>  <span class="n">mac</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vmxnet3_netdev_ops</span><span class="p">;</span>
	<span class="n">vmxnet3_set_ethtool_ops</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">vmxnet3_reset_work</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">VMXNET3_IT_MSIX</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_napi_add</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">napi</span><span class="p">,</span>
				       <span class="n">vmxnet3_poll_rx_only</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">netif_napi_add</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">napi</span><span class="p">,</span>
			       <span class="n">vmxnet3_poll</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">netif_set_real_num_tx_queues</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">);</span>
	<span class="n">netif_set_real_num_rx_queues</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to register adapter %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">err_register</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">VMXNET3_STATE_BIT_QUIESCED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="n">vmxnet3_check_link</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devices_found</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_register:</span>
	<span class="n">vmxnet3_free_intr_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="nl">err_ver:</span>
	<span class="n">vmxnet3_free_pci_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="nl">err_alloc_pci:</span>
<span class="cp">#ifdef VMXNET3_RSS</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rss_conf</span><span class="p">);</span>
<span class="nl">err_alloc_rss:</span>
<span class="cp">#endif</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pm_conf</span><span class="p">);</span>
<span class="nl">err_alloc_pm:</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tqd_start</span><span class="p">,</span>
			    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">queue_desc_pa</span><span class="p">);</span>
<span class="nl">err_alloc_queue_desc:</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_DriverShared</span><span class="p">),</span>
			    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shared_pa</span><span class="p">);</span>
<span class="nl">err_alloc_shared:</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span>
<span class="nf">vmxnet3_remove_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_rx_queues</span><span class="p">;</span>

<span class="cp">#ifdef VMXNET3_RSS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable_mq</span><span class="p">)</span>
		<span class="n">num_rx_queues</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">VMXNET3_DEVICE_MAX_RX_QUEUES</span><span class="p">,</span>
				    <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">num_online_cpus</span><span class="p">());</span>
	<span class="k">else</span>
<span class="cp">#endif</span>
		<span class="n">num_rx_queues</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">num_rx_queues</span> <span class="o">=</span> <span class="n">rounddown_pow_of_two</span><span class="p">(</span><span class="n">num_rx_queues</span><span class="p">);</span>

	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>

	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">vmxnet3_free_intr_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">vmxnet3_free_pci_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="cp">#ifdef VMXNET3_RSS</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rss_conf</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pm_conf</span><span class="p">);</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_TxQueueDesc</span><span class="p">)</span> <span class="o">*</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_RxQueueDesc</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_rx_queues</span><span class="p">;</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tqd_start</span><span class="p">,</span>
			    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">queue_desc_pa</span><span class="p">);</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Vmxnet3_DriverShared</span><span class="p">),</span>
			    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shared_pa</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
<span class="p">}</span>


<span class="cp">#ifdef CONFIG_PM</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">vmxnet3_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">Vmxnet3_PMConf</span> <span class="o">*</span><span class="n">pmConf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">ehdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">arphdr</span> <span class="o">*</span><span class="n">ahdr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">arpreq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">in_device</span> <span class="o">*</span><span class="n">in_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">in_ifaddr</span> <span class="o">*</span><span class="n">ifa</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">napi</span><span class="p">);</span>

	<span class="n">vmxnet3_disable_all_intrs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">vmxnet3_free_irqs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">vmxnet3_free_intr_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">netif_device_detach</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">netif_tx_stop_all_queues</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* Create wake-up filters. */</span>
	<span class="n">pmConf</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pm_conf</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pmConf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pmConf</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">wol</span> <span class="o">&amp;</span> <span class="n">WAKE_UCAST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmConf</span><span class="o">-&gt;</span><span class="n">filters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">patternSize</span> <span class="o">=</span> <span class="n">ETH_ALEN</span><span class="p">;</span>
		<span class="n">pmConf</span><span class="o">-&gt;</span><span class="n">filters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">maskSize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">pmConf</span><span class="o">-&gt;</span><span class="n">filters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pattern</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="n">pmConf</span><span class="o">-&gt;</span><span class="n">filters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x3F</span><span class="p">;</span> <span class="cm">/* LSB ETH_ALEN bits */</span>

		<span class="n">pmConf</span><span class="o">-&gt;</span><span class="n">wakeUpEvents</span> <span class="o">|=</span> <span class="n">VMXNET3_PM_WAKEUP_FILTER</span><span class="p">;</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">wol</span> <span class="o">&amp;</span> <span class="n">WAKE_ARP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">in_dev</span> <span class="o">=</span> <span class="n">in_dev_get</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_dev</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">skip_arp</span><span class="p">;</span>

		<span class="n">ifa</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">in_ifaddr</span> <span class="o">*</span><span class="p">)</span><span class="n">in_dev</span><span class="o">-&gt;</span><span class="n">ifa_list</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ifa</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">skip_arp</span><span class="p">;</span>

		<span class="n">pmConf</span><span class="o">-&gt;</span><span class="n">filters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">patternSize</span> <span class="o">=</span> <span class="n">ETH_HLEN</span> <span class="o">+</span> <span class="cm">/* Ethernet header*/</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">arphdr</span><span class="p">)</span> <span class="o">+</span>		<span class="cm">/* ARP header */</span>
			<span class="mi">2</span> <span class="o">*</span> <span class="n">ETH_ALEN</span> <span class="o">+</span>		<span class="cm">/* 2 Ethernet addresses*/</span>
			<span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>	<span class="cm">/*2 IPv4 addresses */</span>
		<span class="n">pmConf</span><span class="o">-&gt;</span><span class="n">filters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">maskSize</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">pmConf</span><span class="o">-&gt;</span><span class="n">filters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">patternSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* ETH_P_ARP in Ethernet header. */</span>
		<span class="n">ehdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">pmConf</span><span class="o">-&gt;</span><span class="n">filters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pattern</span><span class="p">;</span>
		<span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">h_proto</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_ARP</span><span class="p">);</span>

		<span class="cm">/* ARPOP_REQUEST in ARP header. */</span>
		<span class="n">ahdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">arphdr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pmConf</span><span class="o">-&gt;</span><span class="n">filters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pattern</span><span class="p">[</span><span class="n">ETH_HLEN</span><span class="p">];</span>
		<span class="n">ahdr</span><span class="o">-&gt;</span><span class="n">ar_op</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ARPOP_REQUEST</span><span class="p">);</span>
		<span class="n">arpreq</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)(</span><span class="n">ahdr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* The Unicast IPv4 address in &#39;tip&#39; field. */</span>
		<span class="n">arpreq</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ETH_ALEN</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
		<span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">arpreq</span> <span class="o">=</span> <span class="n">ifa</span><span class="o">-&gt;</span><span class="n">ifa_address</span><span class="p">;</span>

		<span class="cm">/* The mask for the relevant bits. */</span>
		<span class="n">pmConf</span><span class="o">-&gt;</span><span class="n">filters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
		<span class="n">pmConf</span><span class="o">-&gt;</span><span class="n">filters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x30</span><span class="p">;</span> <span class="cm">/* ETH_P_ARP */</span>
		<span class="n">pmConf</span><span class="o">-&gt;</span><span class="n">filters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x30</span><span class="p">;</span> <span class="cm">/* ARPOP_REQUEST */</span>
		<span class="n">pmConf</span><span class="o">-&gt;</span><span class="n">filters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
		<span class="n">pmConf</span><span class="o">-&gt;</span><span class="n">filters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xC0</span><span class="p">;</span> <span class="cm">/* IPv4 TIP */</span>
		<span class="n">pmConf</span><span class="o">-&gt;</span><span class="n">filters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">;</span> <span class="cm">/* IPv4 TIP */</span>
		<span class="n">in_dev_put</span><span class="p">(</span><span class="n">in_dev</span><span class="p">);</span>

		<span class="n">pmConf</span><span class="o">-&gt;</span><span class="n">wakeUpEvents</span> <span class="o">|=</span> <span class="n">VMXNET3_PM_WAKEUP_FILTER</span><span class="p">;</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">skip_arp:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">wol</span> <span class="o">&amp;</span> <span class="n">WAKE_MAGIC</span><span class="p">)</span>
		<span class="n">pmConf</span><span class="o">-&gt;</span><span class="n">wakeUpEvents</span> <span class="o">|=</span> <span class="n">VMXNET3_PM_WAKEUP_MAGIC</span><span class="p">;</span>

	<span class="n">pmConf</span><span class="o">-&gt;</span><span class="n">numFilters</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">devRead</span><span class="p">.</span><span class="n">pmConfDesc</span><span class="p">.</span><span class="n">confVer</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">devRead</span><span class="p">.</span><span class="n">pmConfDesc</span><span class="p">.</span><span class="n">confLen</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span>
								  <span class="o">*</span><span class="n">pmConf</span><span class="p">));</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">devRead</span><span class="p">.</span><span class="n">pmConfDesc</span><span class="p">.</span><span class="n">confPA</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">virt_to_phys</span><span class="p">(</span>
								 <span class="n">pmConf</span><span class="p">));</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">VMXNET3_WRITE_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_CMD</span><span class="p">,</span>
			       <span class="n">VMXNET3_CMD_UPDATE_PMCFG</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_enable_wake</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pci_choose_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PMSG_SUSPEND</span><span class="p">),</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">wol</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pci_choose_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PMSG_SUSPEND</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">vmxnet3_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vmxnet3_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">Vmxnet3_PMConf</span> <span class="o">*</span><span class="n">pmConf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Destroy wake-up filters. */</span>
	<span class="n">pmConf</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pm_conf</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pmConf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pmConf</span><span class="p">));</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">devRead</span><span class="p">.</span><span class="n">pmConfDesc</span><span class="p">.</span><span class="n">confVer</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">devRead</span><span class="p">.</span><span class="n">pmConfDesc</span><span class="p">.</span><span class="n">confLen</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span>
								  <span class="o">*</span><span class="n">pmConf</span><span class="p">));</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">devRead</span><span class="p">.</span><span class="n">pmConfDesc</span><span class="p">.</span><span class="n">confPA</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">virt_to_phys</span><span class="p">(</span>
								 <span class="n">pmConf</span><span class="p">));</span>

	<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">);</span>
	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device_mem</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">pci_enable_wake</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">VMXNET3_WRITE_BAR1_REG</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">VMXNET3_REG_CMD</span><span class="p">,</span>
			       <span class="n">VMXNET3_CMD_UPDATE_PMCFG</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">vmxnet3_alloc_intr_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">vmxnet3_request_irqs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">napi</span><span class="p">);</span>
	<span class="n">vmxnet3_enable_all_intrs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">vmxnet3_pm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">vmxnet3_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">vmxnet3_resume</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">vmxnet3_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">vmxnet3_driver_name</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">vmxnet3_pciid_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">vmxnet3_probe_device</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">vmxnet3_remove_device</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="p">.</span><span class="n">driver</span><span class="p">.</span><span class="n">pm</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">vmxnet3_pm_ops</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">vmxnet3_init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s - version %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">VMXNET3_DRIVER_DESC</span><span class="p">,</span>
		<span class="n">VMXNET3_DRIVER_VERSION_REPORT</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmxnet3_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">vmxnet3_init_module</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmxnet3_exit_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmxnet3_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_exit</span><span class="p">(</span><span class="n">vmxnet3_exit_module</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;VMware, Inc.&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">VMXNET3_DRIVER_DESC</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL v2&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">VMXNET3_DRIVER_VERSION_STRING</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
