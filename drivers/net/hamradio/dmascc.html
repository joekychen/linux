<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › hamradio › dmascc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>dmascc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Driver for high-speed SCC boards (those with DMA support)</span>
<span class="cm"> * Copyright (C) 1997-2000 Klaus Kudielka</span>
<span class="cm"> *</span>
<span class="cm"> * S5SCC/DMA support by Janko Koleznik S52HI</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>


<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/if_arp.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/rtnetlink.h&gt;</span>
<span class="cp">#include &lt;linux/sockios.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/dma.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;net/ax25.h&gt;</span>
<span class="cp">#include &quot;z8530.h&quot;</span>


<span class="cm">/* Number of buffers per channel */</span>

<span class="cp">#define NUM_TX_BUF      2	</span><span class="cm">/* NUM_TX_BUF &gt;= 1 (min. 2 recommended) */</span><span class="cp"></span>
<span class="cp">#define NUM_RX_BUF      6	</span><span class="cm">/* NUM_RX_BUF &gt;= 1 (min. 2 recommended) */</span><span class="cp"></span>
<span class="cp">#define BUF_SIZE        1576	</span><span class="cm">/* BUF_SIZE &gt;= mtu + hard_header_len */</span><span class="cp"></span>


<span class="cm">/* Cards supported */</span>

<span class="cp">#define HW_PI           { &quot;Ottawa PI&quot;, 0x300, 0x20, 0x10, 8, \</span>
<span class="cp">                            0, 8, 1843200, 3686400 }</span>
<span class="cp">#define HW_PI2          { &quot;Ottawa PI2&quot;, 0x300, 0x20, 0x10, 8, \</span>
<span class="cp">			    0, 8, 3686400, 7372800 }</span>
<span class="cp">#define HW_TWIN         { &quot;Gracilis PackeTwin&quot;, 0x200, 0x10, 0x10, 32, \</span>
<span class="cp">			    0, 4, 6144000, 6144000 }</span>
<span class="cp">#define HW_S5           { &quot;S5SCC/DMA&quot;, 0x200, 0x10, 0x10, 32, \</span>
<span class="cp">                          0, 8, 4915200, 9830400 }</span>

<span class="cp">#define HARDWARE        { HW_PI, HW_PI2, HW_TWIN, HW_S5 }</span>

<span class="cp">#define TMR_0_HZ        25600	</span><span class="cm">/* Frequency of timer 0 */</span><span class="cp"></span>

<span class="cp">#define TYPE_PI         0</span>
<span class="cp">#define TYPE_PI2        1</span>
<span class="cp">#define TYPE_TWIN       2</span>
<span class="cp">#define TYPE_S5         3</span>
<span class="cp">#define NUM_TYPES       4</span>

<span class="cp">#define MAX_NUM_DEVS    32</span>


<span class="cm">/* SCC chips supported */</span>

<span class="cp">#define Z8530           0</span>
<span class="cp">#define Z85C30          1</span>
<span class="cp">#define Z85230          2</span>

<span class="cp">#define CHIPNAMES       { &quot;Z8530&quot;, &quot;Z85C30&quot;, &quot;Z85230&quot; }</span>


<span class="cm">/* I/O registers */</span>

<span class="cm">/* 8530 registers relative to card base */</span>
<span class="cp">#define SCCB_CMD        0x00</span>
<span class="cp">#define SCCB_DATA       0x01</span>
<span class="cp">#define SCCA_CMD        0x02</span>
<span class="cp">#define SCCA_DATA       0x03</span>

<span class="cm">/* 8253/8254 registers relative to card base */</span>
<span class="cp">#define TMR_CNT0        0x00</span>
<span class="cp">#define TMR_CNT1        0x01</span>
<span class="cp">#define TMR_CNT2        0x02</span>
<span class="cp">#define TMR_CTRL        0x03</span>

<span class="cm">/* Additional PI/PI2 registers relative to card base */</span>
<span class="cp">#define PI_DREQ_MASK    0x04</span>

<span class="cm">/* Additional PackeTwin registers relative to card base */</span>
<span class="cp">#define TWIN_INT_REG    0x08</span>
<span class="cp">#define TWIN_CLR_TMR1   0x09</span>
<span class="cp">#define TWIN_CLR_TMR2   0x0a</span>
<span class="cp">#define TWIN_SPARE_1    0x0b</span>
<span class="cp">#define TWIN_DMA_CFG    0x08</span>
<span class="cp">#define TWIN_SERIAL_CFG 0x09</span>
<span class="cp">#define TWIN_DMA_CLR_FF 0x0a</span>
<span class="cp">#define TWIN_SPARE_2    0x0b</span>


<span class="cm">/* PackeTwin I/O register values */</span>

<span class="cm">/* INT_REG */</span>
<span class="cp">#define TWIN_SCC_MSK       0x01</span>
<span class="cp">#define TWIN_TMR1_MSK      0x02</span>
<span class="cp">#define TWIN_TMR2_MSK      0x04</span>
<span class="cp">#define TWIN_INT_MSK       0x07</span>

<span class="cm">/* SERIAL_CFG */</span>
<span class="cp">#define TWIN_DTRA_ON       0x01</span>
<span class="cp">#define TWIN_DTRB_ON       0x02</span>
<span class="cp">#define TWIN_EXTCLKA       0x04</span>
<span class="cp">#define TWIN_EXTCLKB       0x08</span>
<span class="cp">#define TWIN_LOOPA_ON      0x10</span>
<span class="cp">#define TWIN_LOOPB_ON      0x20</span>
<span class="cp">#define TWIN_EI            0x80</span>

<span class="cm">/* DMA_CFG */</span>
<span class="cp">#define TWIN_DMA_HDX_T1    0x08</span>
<span class="cp">#define TWIN_DMA_HDX_R1    0x0a</span>
<span class="cp">#define TWIN_DMA_HDX_T3    0x14</span>
<span class="cp">#define TWIN_DMA_HDX_R3    0x16</span>
<span class="cp">#define TWIN_DMA_FDX_T3R1  0x1b</span>
<span class="cp">#define TWIN_DMA_FDX_T1R3  0x1d</span>


<span class="cm">/* Status values */</span>

<span class="cp">#define IDLE      0</span>
<span class="cp">#define TX_HEAD   1</span>
<span class="cp">#define TX_DATA   2</span>
<span class="cp">#define TX_PAUSE  3</span>
<span class="cp">#define TX_TAIL   4</span>
<span class="cp">#define RTS_OFF   5</span>
<span class="cp">#define WAIT      6</span>
<span class="cp">#define DCD_ON    7</span>
<span class="cp">#define RX_ON     8</span>
<span class="cp">#define DCD_OFF   9</span>


<span class="cm">/* Ioctls */</span>

<span class="cp">#define SIOCGSCCPARAM SIOCDEVPRIVATE</span>
<span class="cp">#define SIOCSSCCPARAM (SIOCDEVPRIVATE+1)</span>


<span class="cm">/* Data types */</span>

<span class="k">struct</span> <span class="n">scc_param</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">pclk_hz</span><span class="p">;</span>		<span class="cm">/* frequency of BRG input (don&#39;t change) */</span>
	<span class="kt">int</span> <span class="n">brg_tc</span><span class="p">;</span>		<span class="cm">/* BRG terminal count; BRG disabled if &lt; 0 */</span>
	<span class="kt">int</span> <span class="n">nrzi</span><span class="p">;</span>		<span class="cm">/* 0 (nrz), 1 (nrzi) */</span>
	<span class="kt">int</span> <span class="n">clocks</span><span class="p">;</span>		<span class="cm">/* see dmascc_cfg documentation */</span>
	<span class="kt">int</span> <span class="n">txdelay</span><span class="p">;</span>		<span class="cm">/* [1/TMR_0_HZ] */</span>
	<span class="kt">int</span> <span class="n">txtimeout</span><span class="p">;</span>		<span class="cm">/* [1/HZ] */</span>
	<span class="kt">int</span> <span class="n">txtail</span><span class="p">;</span>		<span class="cm">/* [1/TMR_0_HZ] */</span>
	<span class="kt">int</span> <span class="n">waittime</span><span class="p">;</span>		<span class="cm">/* [1/TMR_0_HZ] */</span>
	<span class="kt">int</span> <span class="n">slottime</span><span class="p">;</span>		<span class="cm">/* [1/TMR_0_HZ] */</span>
	<span class="kt">int</span> <span class="n">persist</span><span class="p">;</span>		<span class="cm">/* 1 ... 256 */</span>
	<span class="kt">int</span> <span class="n">dma</span><span class="p">;</span>		<span class="cm">/* -1 (disable), 0, 1, 3 */</span>
	<span class="kt">int</span> <span class="n">txpause</span><span class="p">;</span>		<span class="cm">/* [1/TMR_0_HZ] */</span>
	<span class="kt">int</span> <span class="n">rtsoff</span><span class="p">;</span>		<span class="cm">/* [1/TMR_0_HZ] */</span>
	<span class="kt">int</span> <span class="n">dcdon</span><span class="p">;</span>		<span class="cm">/* [1/TMR_0_HZ] */</span>
	<span class="kt">int</span> <span class="n">dcdoff</span><span class="p">;</span>		<span class="cm">/* [1/TMR_0_HZ] */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">scc_hardware</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">io_region</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">io_delta</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">io_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_devs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">scc_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tmr_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tmr_hz</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pclk_hz</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">scc_priv</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scc_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">channel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">card_base</span><span class="p">,</span> <span class="n">scc_cmd</span><span class="p">,</span> <span class="n">scc_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tmr_cnt</span><span class="p">,</span> <span class="n">tmr_ctrl</span><span class="p">,</span> <span class="n">tmr_mode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scc_param</span> <span class="n">param</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">rx_buf</span><span class="p">[</span><span class="n">NUM_RX_BUF</span><span class="p">][</span><span class="n">BUF_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">rx_len</span><span class="p">[</span><span class="n">NUM_RX_BUF</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">rx_ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">rx_work</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rx_head</span><span class="p">,</span> <span class="n">rx_tail</span><span class="p">,</span> <span class="n">rx_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rx_over</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">tx_buf</span><span class="p">[</span><span class="n">NUM_TX_BUF</span><span class="p">][</span><span class="n">BUF_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">tx_len</span><span class="p">[</span><span class="n">NUM_TX_BUF</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">tx_ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_head</span><span class="p">,</span> <span class="n">tx_tail</span><span class="p">,</span> <span class="n">tx_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tx_start</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rr0</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">register_lock</span><span class="p">;</span>	<span class="cm">/* Per scc_info */</span>
	<span class="n">spinlock_t</span> <span class="n">ring_lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">scc_info</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq_used</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">twin_serial_cfg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">scc_priv</span> <span class="n">priv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">scc_info</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">register_lock</span><span class="p">;</span>	<span class="cm">/* Per device register lock */</span>
<span class="p">};</span>


<span class="cm">/* Function declarations */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">setup_adapter</span><span class="p">(</span><span class="kt">int</span> <span class="n">card_base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="n">__init</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">write_scc</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">write_scc_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fast</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">read_scc</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">read_scc_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">scc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">scc_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">scc_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">scc_send_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">scc_set_mac_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sa</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">tx_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">rx_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">rx_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">start_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r15</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">random</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">z8530_isr</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">scc_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">rx_isr</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">special_condition</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">rx_bh</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">tx_isr</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">es_isr</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">tm_isr</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>


<span class="cm">/* Initialization variables */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">io</span><span class="p">[</span><span class="n">MAX_NUM_DEVS</span><span class="p">]</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">};</span>

<span class="cm">/* Beware! hw[] is also used in dmascc_exit(). */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">scc_hardware</span> <span class="n">hw</span><span class="p">[</span><span class="n">NUM_TYPES</span><span class="p">]</span> <span class="o">=</span> <span class="n">HARDWARE</span><span class="p">;</span>


<span class="cm">/* Global variables */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scc_info</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rand</span><span class="p">;</span>


<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Klaus Kudielka&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Driver for high-speed SCC boards&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">dmascc_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scc_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>

		<span class="cm">/* Unregister devices */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="cm">/* Reset board */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_TWIN</span><span class="p">)</span>
			<span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">TWIN_SERIAL_CFG</span><span class="p">);</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">R9</span><span class="p">,</span> <span class="n">FHWRES</span><span class="p">);</span>
		<span class="n">release_region</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">,</span>
			       <span class="n">hw</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">type</span><span class="p">].</span><span class="n">io_size</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">free_netdev</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="cm">/* Free memory */</span>
		<span class="n">first</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">dmascc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">base</span><span class="p">[</span><span class="n">MAX_NUM_DEVS</span><span class="p">],</span> <span class="n">tcmd</span><span class="p">[</span><span class="n">MAX_NUM_DEVS</span><span class="p">],</span> <span class="n">t0</span><span class="p">[</span><span class="n">MAX_NUM_DEVS</span><span class="p">],</span>
	    <span class="n">t1</span><span class="p">[</span><span class="n">MAX_NUM_DEVS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="n">t_val</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">time</span><span class="p">,</span> <span class="n">start</span><span class="p">[</span><span class="n">MAX_NUM_DEVS</span><span class="p">],</span> <span class="n">delay</span><span class="p">[</span><span class="n">MAX_NUM_DEVS</span><span class="p">],</span>
	    <span class="n">counting</span><span class="p">[</span><span class="n">MAX_NUM_DEVS</span><span class="p">];</span>

	<span class="cm">/* Initialize random number generator */</span>
	<span class="n">rand</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="cm">/* Cards found = 0 */</span>
	<span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Warning message */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;dmascc: autoprobing (dangerous)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Run autodetection for each card type */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">NUM_TYPES</span><span class="p">;</span> <span class="n">h</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">io</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
			<span class="cm">/* User-specified I/O address regions */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">num_devs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">base</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_NUM_DEVS</span> <span class="o">&amp;&amp;</span> <span class="n">io</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">io</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span>
				     <span class="n">hw</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">io_region</span><span class="p">)</span> <span class="o">/</span> <span class="n">hw</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">io_delta</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">num_devs</span> <span class="o">&amp;&amp;</span>
				    <span class="n">hw</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">io_region</span> <span class="o">+</span>
				    <span class="n">j</span> <span class="o">*</span> <span class="n">hw</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">io_delta</span> <span class="o">==</span> <span class="n">io</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
					<span class="n">base</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">io</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Default I/O address regions */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">num_devs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">base</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
				    <span class="n">hw</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">io_region</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">hw</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">io_delta</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Check valid I/O address regions */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">num_devs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_region</span>
				    <span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">hw</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">io_size</span><span class="p">,</span> <span class="s">&quot;dmascc&quot;</span><span class="p">))</span>
					<span class="n">base</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="n">tcmd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
					    <span class="n">base</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">hw</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">tmr_offset</span> <span class="o">+</span>
					    <span class="n">TMR_CTRL</span><span class="p">;</span>
					<span class="n">t0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
					    <span class="n">base</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">hw</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">tmr_offset</span> <span class="o">+</span>
					    <span class="n">TMR_CNT0</span><span class="p">;</span>
					<span class="n">t1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
					    <span class="n">base</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">hw</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">tmr_offset</span> <span class="o">+</span>
					    <span class="n">TMR_CNT1</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

		<span class="cm">/* Start timers */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">num_devs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="cm">/* Timer 0: LSB+MSB, Mode 3, TMR_0_HZ */</span>
				<span class="n">outb</span><span class="p">(</span><span class="mh">0x36</span><span class="p">,</span> <span class="n">tcmd</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="n">outb</span><span class="p">((</span><span class="n">hw</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">tmr_hz</span> <span class="o">/</span> <span class="n">TMR_0_HZ</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">,</span>
				     <span class="n">t0</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="n">outb</span><span class="p">((</span><span class="n">hw</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">tmr_hz</span> <span class="o">/</span> <span class="n">TMR_0_HZ</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span>
				     <span class="n">t0</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="cm">/* Timer 1: LSB+MSB, Mode 0, HZ/10 */</span>
				<span class="n">outb</span><span class="p">(</span><span class="mh">0x70</span><span class="p">,</span> <span class="n">tcmd</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="n">outb</span><span class="p">((</span><span class="n">TMR_0_HZ</span> <span class="o">/</span> <span class="n">HZ</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="n">t1</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="n">outb</span><span class="p">((</span><span class="n">TMR_0_HZ</span> <span class="o">/</span> <span class="n">HZ</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span> <span class="n">t1</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="n">start</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
				<span class="n">delay</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">counting</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="cm">/* Timer 2: LSB+MSB, Mode 0 */</span>
				<span class="n">outb</span><span class="p">(</span><span class="mh">0xb0</span><span class="p">,</span> <span class="n">tcmd</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="p">}</span>
		<span class="n">time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="cm">/* Wait until counter registers are loaded */</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">2000000</span> <span class="o">/</span> <span class="n">TMR_0_HZ</span><span class="p">);</span>

		<span class="cm">/* Timing loop */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">time</span> <span class="o">&lt;</span> <span class="mi">13</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">num_devs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">counting</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
					<span class="cm">/* Read back Timer 1: latch; read LSB; read MSB */</span>
					<span class="n">outb</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="n">tcmd</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
					<span class="n">t_val</span> <span class="o">=</span>
					    <span class="n">inb</span><span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
					<span class="cm">/* Also check whether counter did wrap */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">t_val</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
					    <span class="n">t_val</span> <span class="o">&gt;</span> <span class="n">TMR_0_HZ</span> <span class="o">/</span> <span class="n">HZ</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>
						<span class="n">counting</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">delay</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">-</span> <span class="n">start</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Evaluate measurements */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">num_devs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">delay</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">9</span> <span class="o">&amp;&amp;</span> <span class="n">delay</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">11</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="cm">/* Ok, we have found an adapter */</span>
				    <span class="p">(</span><span class="n">setup_adapter</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">h</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
					<span class="n">n</span><span class="o">++</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">release_region</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						       <span class="n">hw</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">io_size</span><span class="p">);</span>
			<span class="p">}</span>

	<span class="p">}</span>			<span class="cm">/* NUM_TYPES */</span>

	<span class="cm">/* If any adapter was successfully initialized, return ok */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If no adapter found, return error */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;dmascc: no adapters found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">dmascc_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">dmascc_exit</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">dev_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">ARPHRD_AX25</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hard_header_len</span> <span class="o">=</span> <span class="n">AX25_MAX_HEADER_LEN</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="mi">1500</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span> <span class="o">=</span> <span class="n">AX25_ADDR_LEN</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_queue_len</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">broadcast</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ax25_bcast</span><span class="p">,</span> <span class="n">AX25_ADDR_LEN</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ax25_defaddr</span><span class="p">,</span> <span class="n">AX25_ADDR_LEN</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">scc_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span> <span class="o">=</span> <span class="n">scc_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span> <span class="o">=</span> <span class="n">scc_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span> <span class="o">=</span> <span class="n">scc_send_packet</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span> <span class="o">=</span> <span class="n">scc_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span> <span class="o">=</span> <span class="n">scc_set_mac_address</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">setup_adapter</span><span class="p">(</span><span class="kt">int</span> <span class="n">card_base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scc_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">time</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irqs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tmr_base</span> <span class="o">=</span> <span class="n">card_base</span> <span class="o">+</span> <span class="n">hw</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">tmr_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">scc_base</span> <span class="o">=</span> <span class="n">card_base</span> <span class="o">+</span> <span class="n">hw</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">scc_offset</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">chipnames</span><span class="p">[]</span> <span class="o">=</span> <span class="n">CHIPNAMES</span><span class="p">;</span>

	<span class="cm">/* Initialize what is necessary for write_scc and write_scc_data */</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">GFP_DMA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;dmascc: &quot;</span>
		       <span class="s">&quot;could not allocate memory for %s at %#3x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">hw</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">card_base</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">alloc_netdev</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">dev_setup</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;dmascc: &quot;</span>
		       <span class="s">&quot;could not allocate memory for %s at %#3x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">hw</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">card_base</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">alloc_netdev</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">dev_setup</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;dmascc: &quot;</span>
		       <span class="s">&quot;could not allocate memory for %s at %#3x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">hw</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">card_base</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">);</span>

	<span class="n">priv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">card_base</span> <span class="o">=</span> <span class="n">card_base</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">scc_cmd</span> <span class="o">=</span> <span class="n">scc_base</span> <span class="o">+</span> <span class="n">SCCA_CMD</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">scc_data</span> <span class="o">=</span> <span class="n">scc_base</span> <span class="o">+</span> <span class="n">SCCA_DATA</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">register_lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">;</span>

	<span class="cm">/* Reset SCC */</span>
	<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R9</span><span class="p">,</span> <span class="n">FHWRES</span> <span class="o">|</span> <span class="n">MIE</span> <span class="o">|</span> <span class="n">NV</span><span class="p">);</span>

	<span class="cm">/* Determine type of chip by enabling SDLC/HDLC enhancements */</span>
	<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R15</span><span class="p">,</span> <span class="n">SHDLCE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R15</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* WR7&#39; not present. This is an ordinary Z8530 SCC. */</span>
		<span class="n">chip</span> <span class="o">=</span> <span class="n">Z8530</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Put one character in TX FIFO */</span>
		<span class="n">write_scc_data</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">read_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">Tx_BUF_EMP</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* TX FIFO not full. This is a Z85230 ESCC with a 4-byte FIFO. */</span>
			<span class="n">chip</span> <span class="o">=</span> <span class="n">Z85230</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* TX FIFO full. This is a Z85C30 SCC with a 1-byte FIFO. */</span>
			<span class="n">chip</span> <span class="o">=</span> <span class="n">Z85C30</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R15</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Start IRQ auto-detection */</span>
	<span class="n">irqs</span> <span class="o">=</span> <span class="n">probe_irq_on</span><span class="p">();</span>

	<span class="cm">/* Enable interrupts */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_TWIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">card_base</span> <span class="o">+</span> <span class="n">TWIN_DMA_CFG</span><span class="p">);</span>
		<span class="n">inb</span><span class="p">(</span><span class="n">card_base</span> <span class="o">+</span> <span class="n">TWIN_CLR_TMR1</span><span class="p">);</span>
		<span class="n">inb</span><span class="p">(</span><span class="n">card_base</span> <span class="o">+</span> <span class="n">TWIN_CLR_TMR2</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">twin_serial_cfg</span> <span class="o">=</span> <span class="n">TWIN_EI</span><span class="p">;</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">twin_serial_cfg</span><span class="p">,</span> <span class="n">card_base</span> <span class="o">+</span> <span class="n">TWIN_SERIAL_CFG</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R15</span><span class="p">,</span> <span class="n">CTSIE</span><span class="p">);</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">RES_EXT_INT</span><span class="p">);</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">EXT_INT_ENAB</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Start timer */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">tmr_base</span> <span class="o">+</span> <span class="n">TMR_CNT1</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tmr_base</span> <span class="o">+</span> <span class="n">TMR_CNT1</span><span class="p">);</span>

	<span class="cm">/* Wait and detect IRQ */</span>
	<span class="n">time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">time</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">/</span> <span class="n">TMR_0_HZ</span><span class="p">);</span>
	<span class="n">irq</span> <span class="o">=</span> <span class="n">probe_irq_off</span><span class="p">(</span><span class="n">irqs</span><span class="p">);</span>

	<span class="cm">/* Clear pending interrupt, disable interrupts */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_TWIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inb</span><span class="p">(</span><span class="n">card_base</span> <span class="o">+</span> <span class="n">TWIN_CLR_TMR1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R15</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">RES_EXT_INT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;dmascc: could not find irq of %s at %#3x (irq=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">hw</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">card_base</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set up data structures */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">priv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">chip</span> <span class="o">=</span> <span class="n">chip</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ring_lock</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">register_lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">card_base</span> <span class="o">=</span> <span class="n">card_base</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">scc_cmd</span> <span class="o">=</span> <span class="n">scc_base</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">?</span> <span class="n">SCCB_CMD</span> <span class="o">:</span> <span class="n">SCCA_CMD</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">scc_data</span> <span class="o">=</span> <span class="n">scc_base</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">?</span> <span class="n">SCCB_DATA</span> <span class="o">:</span> <span class="n">SCCA_DATA</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tmr_cnt</span> <span class="o">=</span> <span class="n">tmr_base</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">?</span> <span class="n">TMR_CNT2</span> <span class="o">:</span> <span class="n">TMR_CNT1</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tmr_ctrl</span> <span class="o">=</span> <span class="n">tmr_base</span> <span class="o">+</span> <span class="n">TMR_CTRL</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tmr_mode</span> <span class="o">=</span> <span class="n">i</span> <span class="o">?</span> <span class="mh">0xb0</span> <span class="o">:</span> <span class="mh">0x70</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">pclk_hz</span> <span class="o">=</span> <span class="n">hw</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">pclk_hz</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">brg_tc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">clocks</span> <span class="o">=</span> <span class="n">TCTRxCP</span> <span class="o">|</span> <span class="n">RCRTxCP</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">persist</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_work</span><span class="p">,</span> <span class="n">rx_bh</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ml_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;dmascc%i&quot;</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">card_base</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">scc_netdev_ops</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">header_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ax25_header_ops</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">register_netdev</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;dmascc: could not register %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out3</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">register_netdev</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;dmascc: could not register %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out4</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="n">info</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
	<span class="n">first</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;dmascc: found %s (%s) at %#3x, irq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">hw</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">chipnames</span><span class="p">[</span><span class="n">chip</span><span class="p">],</span> <span class="n">card_base</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

      <span class="nl">out4:</span>
	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
      <span class="nl">out3:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_TWIN</span><span class="p">)</span>
		<span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">TWIN_SERIAL_CFG</span><span class="p">);</span>
	<span class="n">write_scc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">R9</span><span class="p">,</span> <span class="n">FHWRES</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
      <span class="nl">out2:</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
      <span class="nl">out1:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
      <span class="nl">out:</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Driver functions */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">write_scc</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TYPE_S5</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="p">)</span>
			<span class="n">outb</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">scc_cmd</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">scc_cmd</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TYPE_TWIN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="p">)</span>
			<span class="n">outb_p</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">scc_cmd</span><span class="p">);</span>
		<span class="n">outb_p</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">scc_cmd</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">outb_p</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">card_base</span> <span class="o">+</span> <span class="n">PI_DREQ_MASK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="p">)</span>
			<span class="n">outb_p</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">scc_cmd</span><span class="p">);</span>
		<span class="n">outb_p</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">scc_cmd</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">card_base</span> <span class="o">+</span> <span class="n">PI_DREQ_MASK</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">write_scc_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fast</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TYPE_S5</span>:
		<span class="n">outb</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">scc_data</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TYPE_TWIN</span>:
		<span class="n">outb_p</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">scc_data</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fast</span><span class="p">)</span>
			<span class="n">outb_p</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">scc_data</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">outb_p</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">card_base</span> <span class="o">+</span> <span class="n">PI_DREQ_MASK</span><span class="p">);</span>
			<span class="n">outb_p</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">scc_data</span><span class="p">);</span>
			<span class="n">outb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">card_base</span> <span class="o">+</span> <span class="n">PI_DREQ_MASK</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_scc</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TYPE_S5</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="p">)</span>
			<span class="n">outb</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">scc_cmd</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">inb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">scc_cmd</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">TYPE_TWIN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="p">)</span>
			<span class="n">outb_p</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">scc_cmd</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">scc_cmd</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">outb_p</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">card_base</span> <span class="o">+</span> <span class="n">PI_DREQ_MASK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="p">)</span>
			<span class="n">outb_p</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">scc_cmd</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">scc_cmd</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">card_base</span> <span class="o">+</span> <span class="n">PI_DREQ_MASK</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_scc_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TYPE_S5</span>:
		<span class="k">return</span> <span class="n">inb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">scc_data</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">TYPE_TWIN</span>:
		<span class="k">return</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">scc_data</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">outb_p</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">card_base</span> <span class="o">+</span> <span class="n">PI_DREQ_MASK</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">scc_data</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">card_base</span> <span class="o">+</span> <span class="n">PI_DREQ_MASK</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">scc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ml_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scc_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">card_base</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">card_base</span><span class="p">;</span>

	<span class="cm">/* Request IRQ if not already used by other channel */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_used</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">scc_isr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;dmascc&quot;</span><span class="p">,</span> <span class="n">info</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_used</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Request DMA if required */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">request_dma</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span> <span class="s">&quot;dmascc&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_used</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">claim_dma_lock</span><span class="p">();</span>
			<span class="n">clear_dma_ff</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span><span class="p">);</span>
			<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize local variables */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_over</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_head</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_tail</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">IDLE</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_head</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_tail</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Reset channel */</span>
	<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R9</span><span class="p">,</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">?</span> <span class="n">CHRB</span> <span class="o">:</span> <span class="n">CHRA</span><span class="p">)</span> <span class="o">|</span> <span class="n">MIE</span> <span class="o">|</span> <span class="n">NV</span><span class="p">);</span>
	<span class="cm">/* X1 clock, SDLC mode */</span>
	<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R4</span><span class="p">,</span> <span class="n">SDLC</span> <span class="o">|</span> <span class="n">X1CLK</span><span class="p">);</span>
	<span class="cm">/* DMA */</span>
	<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">EXT_INT_ENAB</span> <span class="o">|</span> <span class="n">WT_FN_RDYFN</span><span class="p">);</span>
	<span class="cm">/* 8 bit RX char, RX disable */</span>
	<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R3</span><span class="p">,</span> <span class="n">Rx8</span><span class="p">);</span>
	<span class="cm">/* 8 bit TX char, TX disable */</span>
	<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R5</span><span class="p">,</span> <span class="n">Tx8</span><span class="p">);</span>
	<span class="cm">/* SDLC address field */</span>
	<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R6</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* SDLC flag */</span>
	<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R7</span><span class="p">,</span> <span class="n">FLAG</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">Z85C30</span>:
		<span class="cm">/* Select WR7&#39; */</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R15</span><span class="p">,</span> <span class="n">SHDLCE</span><span class="p">);</span>
		<span class="cm">/* Auto EOM reset */</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R7</span><span class="p">,</span> <span class="n">AUTOEOM</span><span class="p">);</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R15</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">Z85230</span>:
		<span class="cm">/* Select WR7&#39; */</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R15</span><span class="p">,</span> <span class="n">SHDLCE</span><span class="p">);</span>
		<span class="cm">/* The following bits are set (see 2.5.2.1):</span>
<span class="cm">		   - Automatic EOM reset</span>
<span class="cm">		   - Interrupt request if RX FIFO is half full</span>
<span class="cm">		   This bit should be ignored in DMA mode (according to the</span>
<span class="cm">		   documentation), but actually isn&#39;t. The receiver doesn&#39;t work if</span>
<span class="cm">		   it is set. Thus, we have to clear it in DMA mode.</span>
<span class="cm">		   - Interrupt/DMA request if TX FIFO is completely empty</span>
<span class="cm">		   a) If set, the ESCC behaves as if it had no TX FIFO (Z85C30</span>
<span class="cm">		   compatibility).</span>
<span class="cm">		   b) If cleared, DMA requests may follow each other very quickly,</span>
<span class="cm">		   filling up the TX FIFO.</span>
<span class="cm">		   Advantage: TX works even in case of high bus latency.</span>
<span class="cm">		   Disadvantage: Edge-triggered DMA request circuitry may miss</span>
<span class="cm">		   a request. No more data is delivered, resulting</span>
<span class="cm">		   in a TX FIFO underrun.</span>
<span class="cm">		   Both PI2 and S5SCC/DMA seem to work fine with TXFIFOE cleared.</span>
<span class="cm">		   The PackeTwin doesn&#39;t. I don&#39;t know about the PI, but let&#39;s</span>
<span class="cm">		   assume it behaves like the PI2.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_TWIN</span><span class="p">)</span>
				<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R7</span><span class="p">,</span> <span class="n">AUTOEOM</span> <span class="o">|</span> <span class="n">TXFIFOE</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R7</span><span class="p">,</span> <span class="n">AUTOEOM</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R7</span><span class="p">,</span> <span class="n">AUTOEOM</span> <span class="o">|</span> <span class="n">RXFIFOH</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R15</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Preset CRC, NRZ(I) encoding */</span>
	<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R10</span><span class="p">,</span> <span class="n">CRCPS</span> <span class="o">|</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">nrzi</span> <span class="o">?</span> <span class="n">NRZI</span> <span class="o">:</span> <span class="n">NRZ</span><span class="p">));</span>

	<span class="cm">/* Configure baud rate generator */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">brg_tc</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Program BR generator */</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R12</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">brg_tc</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R13</span><span class="p">,</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">brg_tc</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
		<span class="cm">/* BRG source = SYS CLK; enable BRG; DTR REQ function (required by</span>
<span class="cm">		   PackeTwin, not connected on the PI2); set DPLL source to BRG */</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R14</span><span class="p">,</span> <span class="n">SSBR</span> <span class="o">|</span> <span class="n">DTRREQ</span> <span class="o">|</span> <span class="n">BRSRC</span> <span class="o">|</span> <span class="n">BRENABL</span><span class="p">);</span>
		<span class="cm">/* Enable DPLL */</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R14</span><span class="p">,</span> <span class="n">SEARCH</span> <span class="o">|</span> <span class="n">DTRREQ</span> <span class="o">|</span> <span class="n">BRSRC</span> <span class="o">|</span> <span class="n">BRENABL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Disable BR generator */</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R14</span><span class="p">,</span> <span class="n">DTRREQ</span> <span class="o">|</span> <span class="n">BRSRC</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Configure clocks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_TWIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Disable external TX clock receiver */</span>
		<span class="n">outb</span><span class="p">((</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">twin_serial_cfg</span> <span class="o">&amp;=</span>
		      <span class="o">~</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">?</span> <span class="n">TWIN_EXTCLKB</span> <span class="o">:</span> <span class="n">TWIN_EXTCLKA</span><span class="p">)),</span>
		     <span class="n">card_base</span> <span class="o">+</span> <span class="n">TWIN_SERIAL_CFG</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R11</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">clocks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_TWIN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">clocks</span> <span class="o">&amp;</span> <span class="n">TRxCOI</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Enable external TX clock receiver */</span>
		<span class="n">outb</span><span class="p">((</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">twin_serial_cfg</span> <span class="o">|=</span>
		      <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">?</span> <span class="n">TWIN_EXTCLKB</span> <span class="o">:</span> <span class="n">TWIN_EXTCLKA</span><span class="p">)),</span>
		     <span class="n">card_base</span> <span class="o">+</span> <span class="n">TWIN_SERIAL_CFG</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Configure PackeTwin */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_TWIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Assert DTR, enable interrupts */</span>
		<span class="n">outb</span><span class="p">((</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">twin_serial_cfg</span> <span class="o">|=</span> <span class="n">TWIN_EI</span> <span class="o">|</span>
		      <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">?</span> <span class="n">TWIN_DTRB_ON</span> <span class="o">:</span> <span class="n">TWIN_DTRA_ON</span><span class="p">)),</span>
		     <span class="n">card_base</span> <span class="o">+</span> <span class="n">TWIN_SERIAL_CFG</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Read current status */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rr0</span> <span class="o">=</span> <span class="n">read_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R0</span><span class="p">);</span>
	<span class="cm">/* Enable DCD interrupt */</span>
	<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R15</span><span class="p">,</span> <span class="n">DCDIE</span><span class="p">);</span>

	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">scc_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ml_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scc_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">card_base</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">card_base</span><span class="p">;</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_TWIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Drop DTR */</span>
		<span class="n">outb</span><span class="p">((</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">twin_serial_cfg</span> <span class="o">&amp;=</span>
		      <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">?</span> <span class="o">~</span><span class="n">TWIN_DTRB_ON</span> <span class="o">:</span> <span class="o">~</span><span class="n">TWIN_DTRA_ON</span><span class="p">)),</span>
		     <span class="n">card_base</span> <span class="o">+</span> <span class="n">TWIN_SERIAL_CFG</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Reset channel, free DMA and IRQ */</span>
	<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R9</span><span class="p">,</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">?</span> <span class="n">CHRB</span> <span class="o">:</span> <span class="n">CHRA</span><span class="p">)</span> <span class="o">|</span> <span class="n">MIE</span> <span class="o">|</span> <span class="n">NV</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_TWIN</span><span class="p">)</span>
			<span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">card_base</span> <span class="o">+</span> <span class="n">TWIN_DMA_CFG</span><span class="p">);</span>
		<span class="n">free_dma</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_used</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">scc_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ml_priv</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCGSCCPARAM</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span>
		    <span class="p">(</span><span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">,</span>
		     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_param</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIOCSSCCPARAM</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span>
		    <span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">,</span> <span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_data</span><span class="p">,</span>
		     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_param</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">scc_send_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ml_priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Temporarily stop the scheduler feeding us packets */</span>
	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Transfer data to DMA buffer */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_head</span><span class="p">;</span>
	<span class="n">skb_copy_from_linear_data_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_len</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Clear interrupts while we touch our circular buffers */</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ring_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* Move the ring buffer&#39;s head */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_head</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">NUM_TX_BUF</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_count</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* If we just filled up the last buffer, leave queue stopped.</span>
<span class="cm">	   The higher layers must wait until we have a DMA buffer</span>
<span class="cm">	   to accept the data. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_count</span> <span class="o">&lt;</span> <span class="n">NUM_TX_BUF</span><span class="p">)</span>
		<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Set new TX state */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">IDLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Assert RTS, start timer */</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TX_HEAD</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R5</span><span class="p">,</span> <span class="n">TxCRC_ENAB</span> <span class="o">|</span> <span class="n">RTS</span> <span class="o">|</span> <span class="n">TxENAB</span> <span class="o">|</span> <span class="n">Tx8</span><span class="p">);</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R15</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">start_timer</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">txdelay</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Turn interrupts back on and free buffer */</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ring_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">scc_set_mac_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="p">((</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="n">sa</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span>
	       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tx_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">chip</span> <span class="o">==</span> <span class="n">Z85230</span><span class="p">)</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Program DMA controller */</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">claim_dma_lock</span><span class="p">();</span>
		<span class="n">set_dma_mode</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span> <span class="n">DMA_MODE_WRITE</span><span class="p">);</span>
		<span class="n">set_dma_addr</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_tail</span><span class="p">]</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>
		<span class="n">set_dma_count</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span>
			      <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_len</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_tail</span><span class="p">]</span> <span class="o">-</span> <span class="n">n</span><span class="p">);</span>
		<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="cm">/* Enable TX underrun interrupt */</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R15</span><span class="p">,</span> <span class="n">TxUIE</span><span class="p">);</span>
		<span class="cm">/* Configure DREQ */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_TWIN</span><span class="p">)</span>
			<span class="n">outb</span><span class="p">((</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span> <span class="o">==</span>
			      <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">TWIN_DMA_HDX_T1</span> <span class="o">:</span> <span class="n">TWIN_DMA_HDX_T3</span><span class="p">,</span>
			     <span class="n">priv</span><span class="o">-&gt;</span><span class="n">card_base</span> <span class="o">+</span> <span class="n">TWIN_DMA_CFG</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span>
				  <span class="n">EXT_INT_ENAB</span> <span class="o">|</span> <span class="n">WT_FN_RDYFN</span> <span class="o">|</span>
				  <span class="n">WT_RDY_ENAB</span><span class="p">);</span>
		<span class="cm">/* Write first byte(s) */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">write_scc_data</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span>
				       <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_tail</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">enable_dma</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R15</span><span class="p">,</span> <span class="n">TxUIE</span><span class="p">);</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span>
			  <span class="n">EXT_INT_ENAB</span> <span class="o">|</span> <span class="n">WT_FN_RDYFN</span> <span class="o">|</span> <span class="n">TxINT_ENAB</span><span class="p">);</span>
		<span class="n">tx_isr</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Reset EOM latch if we do not have the AUTOEOM feature */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">chip</span> <span class="o">==</span> <span class="n">Z8530</span><span class="p">)</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">RES_EOM_L</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rx_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Clear RX FIFO */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">read_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">Rx_CH_AV</span><span class="p">)</span>
		<span class="n">read_scc_data</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_over</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Program DMA controller */</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">claim_dma_lock</span><span class="p">();</span>
		<span class="n">set_dma_mode</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span> <span class="n">DMA_MODE_READ</span><span class="p">);</span>
		<span class="n">set_dma_addr</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_head</span><span class="p">]);</span>
		<span class="n">set_dma_count</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">);</span>
		<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">enable_dma</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span><span class="p">);</span>
		<span class="cm">/* Configure PackeTwin DMA */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_TWIN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">outb</span><span class="p">((</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span> <span class="o">==</span>
			      <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">TWIN_DMA_HDX_R1</span> <span class="o">:</span> <span class="n">TWIN_DMA_HDX_R3</span><span class="p">,</span>
			     <span class="n">priv</span><span class="o">-&gt;</span><span class="n">card_base</span> <span class="o">+</span> <span class="n">TWIN_DMA_CFG</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Sp. cond. intr. only, ext int enable, RX DMA enable */</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">EXT_INT_ENAB</span> <span class="o">|</span> <span class="n">INT_ERR_Rx</span> <span class="o">|</span>
			  <span class="n">WT_RDY_RT</span> <span class="o">|</span> <span class="n">WT_FN_RDYFN</span> <span class="o">|</span> <span class="n">WT_RDY_ENAB</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Reset current frame */</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* Intr. on all Rx characters and Sp. cond., ext int enable */</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">EXT_INT_ENAB</span> <span class="o">|</span> <span class="n">INT_ALL_Rx</span> <span class="o">|</span> <span class="n">WT_RDY_RT</span> <span class="o">|</span>
			  <span class="n">WT_FN_RDYFN</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">ERR_RES</span><span class="p">);</span>
	<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R3</span><span class="p">,</span> <span class="n">RxENABLE</span> <span class="o">|</span> <span class="n">Rx8</span> <span class="o">|</span> <span class="n">RxCRC_ENAB</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rx_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Disable receiver */</span>
	<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R3</span><span class="p">,</span> <span class="n">Rx8</span><span class="p">);</span>
	<span class="cm">/* Disable DREQ / RX interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_TWIN</span><span class="p">)</span>
		<span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">card_base</span> <span class="o">+</span> <span class="n">TWIN_DMA_CFG</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">EXT_INT_ENAB</span> <span class="o">|</span> <span class="n">WT_FN_RDYFN</span><span class="p">);</span>
	<span class="cm">/* Disable DMA */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">disable_dma</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">start_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r15</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tmr_mode</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tmr_ctrl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tm_isr</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">t</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tmr_cnt</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">((</span><span class="n">t</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tmr_cnt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TYPE_TWIN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R15</span><span class="p">,</span> <span class="n">r15</span> <span class="o">|</span> <span class="n">CTSIE</span><span class="p">);</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rr0</span> <span class="o">|=</span> <span class="n">CTS</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">random</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* See &quot;Numerical Recipes in C&quot;, second edition, p. 284 */</span>
	<span class="n">rand</span> <span class="o">=</span> <span class="n">rand</span> <span class="o">*</span> <span class="mi">1664525L</span> <span class="o">+</span> <span class="mi">1013904223L</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">rand</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">z8530_isr</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">is</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">is</span> <span class="o">=</span> <span class="n">read_scc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">R3</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is</span> <span class="o">&amp;</span> <span class="n">CHARxIP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rx_isr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is</span> <span class="o">&amp;</span> <span class="n">CHATxIP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tx_isr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is</span> <span class="o">&amp;</span> <span class="n">CHAEXT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">es_isr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is</span> <span class="o">&amp;</span> <span class="n">CHBRxIP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rx_isr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is</span> <span class="o">&amp;</span> <span class="n">CHBTxIP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tx_isr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">es_isr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">R0</span><span class="p">,</span> <span class="n">RES_H_IUS</span><span class="p">);</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;dmascc: stuck in ISR with RR3=0x%02x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">is</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Ok, no interrupts pending from this 8530. The INT line should</span>
<span class="cm">	   be inactive now. */</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">scc_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scc_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">register_lock</span><span class="p">);</span>
	<span class="cm">/* At this point interrupts are enabled, and the interrupt under service</span>
<span class="cm">	   is already acknowledged, but masked off.</span>

<span class="cm">	   Interrupt processing: We loop until we know that the IRQ line is</span>
<span class="cm">	   low. If another positive edge occurs afterwards during the ISR,</span>
<span class="cm">	   another interrupt will be triggered by the interrupt controller</span>
<span class="cm">	   as soon as the IRQ level is enabled again (see asm/irq.h).</span>

<span class="cm">	   Bottom-half handlers will be processed after scc_isr(). This is</span>
<span class="cm">	   important, since we only have small ringbuffers and want new data</span>
<span class="cm">	   to be fetched/delivered immediately. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_TWIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">is</span><span class="p">,</span> <span class="n">card_base</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">card_base</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">is</span> <span class="o">=</span> <span class="o">~</span><span class="n">inb</span><span class="p">(</span><span class="n">card_base</span> <span class="o">+</span> <span class="n">TWIN_INT_REG</span><span class="p">))</span> <span class="o">&amp;</span>
		       <span class="n">TWIN_INT_MSK</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is</span> <span class="o">&amp;</span> <span class="n">TWIN_SCC_MSK</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">z8530_isr</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is</span> <span class="o">&amp;</span> <span class="n">TWIN_TMR1_MSK</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">inb</span><span class="p">(</span><span class="n">card_base</span> <span class="o">+</span> <span class="n">TWIN_CLR_TMR1</span><span class="p">);</span>
				<span class="n">tm_isr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">inb</span><span class="p">(</span><span class="n">card_base</span> <span class="o">+</span> <span class="n">TWIN_CLR_TMR2</span><span class="p">);</span>
				<span class="n">tm_isr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">z8530_isr</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">register_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">rx_isr</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check special condition and perform error reset. See 2.4.7.5. */</span>
		<span class="n">special_condition</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">read_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R1</span><span class="p">));</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">ERR_RES</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Check special condition for each character. Error reset not necessary.</span>
<span class="cm">		   Same algorithm for SCC and ESCC. See 2.4.7.1 and 2.4.7.4. */</span>
		<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">read_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">Rx_CH_AV</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">read_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_ptr</span> <span class="o">&lt;</span> <span class="n">BUF_SIZE</span><span class="p">)</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_head</span><span class="p">][</span><span class="n">priv</span><span class="o">-&gt;</span>
							    <span class="n">rx_ptr</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span>
				    <span class="n">read_scc_data</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_over</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="n">read_scc_data</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">special_condition</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">special_condition</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* See Figure 2-15. Only overrun and EOF need to be checked. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;</span> <span class="n">Rx_OVR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Receiver overrun */</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_over</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">ERR_RES</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;</span> <span class="n">END_FR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* End of frame. Get byte count */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">flags</span> <span class="o">=</span> <span class="n">claim_dma_lock</span><span class="p">();</span>
			<span class="n">cb</span> <span class="o">=</span> <span class="n">BUF_SIZE</span> <span class="o">-</span> <span class="n">get_dma_residue</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span><span class="p">)</span> <span class="o">-</span>
			    <span class="mi">2</span><span class="p">;</span>
			<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cb</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_ptr</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_over</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* We had an overrun */</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_over</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_length_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_over</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;</span> <span class="n">CRC_ERR</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Count invalid CRC only if packet length &gt;= minimum */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cb</span> <span class="o">&gt;=</span> <span class="mi">15</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_crc_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cb</span> <span class="o">&gt;=</span> <span class="mi">15</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_count</span> <span class="o">&lt;</span> <span class="n">NUM_RX_BUF</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Put good frame in FIFO */</span>
					<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_len</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_head</span><span class="p">]</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span>
					<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_head</span> <span class="o">=</span>
					    <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_head</span> <span class="o">+</span>
					     <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">NUM_RX_BUF</span><span class="p">;</span>
					<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_count</span><span class="o">++</span><span class="p">;</span>
					<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_work</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">priv</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
					<span class="n">priv</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_over_errors</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* Get ready for new frame */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">flags</span> <span class="o">=</span> <span class="n">claim_dma_lock</span><span class="p">();</span>
			<span class="n">set_dma_addr</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span>
				     <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_head</span><span class="p">]);</span>
			<span class="n">set_dma_count</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">);</span>
			<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">rx_bh</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">ugli_api</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ugli_api</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scc_priv</span><span class="p">,</span> <span class="n">rx_work</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_tail</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ring_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ring_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">cb</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_len</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="cm">/* Allocate buffer */</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">cb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Drop packet */</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Fill buffer */</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">cb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cb</span><span class="p">);</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">ax25_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">cb</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ring_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/* Move tail */</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_tail</span> <span class="o">=</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">NUM_RX_BUF</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_count</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ring_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">tx_isr</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_tail</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_ptr</span><span class="p">;</span>

	<span class="cm">/* Suspend TX interrupts if we don&#39;t want to send anything.</span>
<span class="cm">	   See Figure 2-22. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_len</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">RES_Tx_P</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Write characters */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">read_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">Tx_BUF_EMP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_len</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">write_scc_data</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">p</span><span class="o">++</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Reset EOM latch of Z8530 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_ptr</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">chip</span> <span class="o">==</span> <span class="n">Z8530</span><span class="p">)</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">RES_EOM_L</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_ptr</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">es_isr</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rr0</span><span class="p">,</span> <span class="n">drr0</span><span class="p">,</span> <span class="n">res</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Read status, reset interrupt bit (open latches) */</span>
	<span class="n">rr0</span> <span class="o">=</span> <span class="n">read_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R0</span><span class="p">);</span>
	<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">RES_EXT_INT</span><span class="p">);</span>
	<span class="n">drr0</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rr0</span> <span class="o">^</span> <span class="n">rr0</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rr0</span> <span class="o">=</span> <span class="n">rr0</span><span class="p">;</span>

	<span class="cm">/* Transmit underrun (2.4.9.6). We can&#39;t check the TxEOM flag, since</span>
<span class="cm">	   it might have already been cleared again by AUTOEOM. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">TX_DATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get remaining bytes */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_tail</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">disable_dma</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span><span class="p">);</span>
			<span class="n">flags</span> <span class="o">=</span> <span class="n">claim_dma_lock</span><span class="p">();</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">get_dma_residue</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span><span class="p">);</span>
			<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_len</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_ptr</span><span class="p">;</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Disable DREQ / TX interrupt */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dma</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_TWIN</span><span class="p">)</span>
			<span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">card_base</span> <span class="o">+</span> <span class="n">TWIN_DMA_CFG</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">EXT_INT_ENAB</span> <span class="o">|</span> <span class="n">WT_FN_RDYFN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Update packet statistics */</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="cm">/* Other underrun interrupts may already be waiting */</span>
			<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">RES_EXT_INT</span><span class="p">);</span>
			<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">RES_EXT_INT</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Update packet statistics */</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_len</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="cm">/* Remove frame from FIFO */</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_tail</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">NUM_TX_BUF</span><span class="p">;</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_count</span><span class="o">--</span><span class="p">;</span>
			<span class="cm">/* Inform upper layers */</span>
			<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Switch state */</span>
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R15</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_count</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_start</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">txtimeout</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TX_PAUSE</span><span class="p">;</span>
			<span class="n">start_timer</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">txpause</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TX_TAIL</span><span class="p">;</span>
			<span class="n">start_timer</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">txtail</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* DCD transition */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drr0</span> <span class="o">&amp;</span> <span class="n">DCD</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rr0</span> <span class="o">&amp;</span> <span class="n">DCD</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">IDLE</span>:
			<span class="k">case</span> <span class="n">WAIT</span>:
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DCD_ON</span><span class="p">;</span>
				<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R15</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">start_timer</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dcdon</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">RX_ON</span>:
				<span class="n">rx_off</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DCD_OFF</span><span class="p">;</span>
				<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R15</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">start_timer</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">dcdoff</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* CTS transition */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">drr0</span> <span class="o">&amp;</span> <span class="n">CTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">rr0</span> <span class="o">&amp;</span> <span class="n">CTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TYPE_TWIN</span><span class="p">)</span>
		<span class="n">tm_isr</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">tm_isr</span><span class="p">(</span><span class="k">struct</span> <span class="n">scc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TX_HEAD</span>:
	<span class="k">case</span> <span class="n">TX_PAUSE</span>:
		<span class="n">tx_on</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TX_DATA</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TX_TAIL</span>:
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R5</span><span class="p">,</span> <span class="n">TxCRC_ENAB</span> <span class="o">|</span> <span class="n">Tx8</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">RTS_OFF</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TYPE_TWIN</span><span class="p">)</span>
			<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R15</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">start_timer</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">rtsoff</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RTS_OFF</span>:
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R15</span><span class="p">,</span> <span class="n">DCDIE</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rr0</span> <span class="o">=</span> <span class="n">read_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rr0</span> <span class="o">&amp;</span> <span class="n">DCD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">collisions</span><span class="o">++</span><span class="p">;</span>
			<span class="n">rx_on</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">RX_ON</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">WAIT</span><span class="p">;</span>
			<span class="n">start_timer</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">waittime</span><span class="p">,</span> <span class="n">DCDIE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">WAIT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TX_HEAD</span><span class="p">;</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
			<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R5</span><span class="p">,</span>
				  <span class="n">TxCRC_ENAB</span> <span class="o">|</span> <span class="n">RTS</span> <span class="o">|</span> <span class="n">TxENAB</span> <span class="o">|</span> <span class="n">Tx8</span><span class="p">);</span>
			<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R15</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">start_timer</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">txdelay</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">IDLE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TYPE_TWIN</span><span class="p">)</span>
				<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R15</span><span class="p">,</span> <span class="n">DCDIE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DCD_ON</span>:
	<span class="k">case</span> <span class="n">DCD_OFF</span>:
		<span class="n">write_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R15</span><span class="p">,</span> <span class="n">DCDIE</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rr0</span> <span class="o">=</span> <span class="n">read_scc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">R0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rr0</span> <span class="o">&amp;</span> <span class="n">DCD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rx_on</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">RX_ON</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">WAIT</span><span class="p">;</span>
			<span class="n">start_timer</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span>
				    <span class="n">random</span><span class="p">()</span> <span class="o">/</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">persist</span> <span class="o">*</span>
				    <span class="n">priv</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">slottime</span><span class="p">,</span> <span class="n">DCDIE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
