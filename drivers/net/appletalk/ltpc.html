<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › appletalk › ltpc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ltpc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/***    ltpc.c -- a driver for the LocalTalk PC card.</span>
<span class="cm"> *</span>
<span class="cm"> *      Copyright (c) 1995,1996 Bradford W. Johnson &lt;johns393@maroon.tc.umn.edu&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *      This software may be used and distributed according to the terms</span>
<span class="cm"> *      of the GNU General Public License, incorporated herein by reference.</span>
<span class="cm"> *</span>
<span class="cm"> *      This is ALPHA code at best.  It may not work for you.  It may</span>
<span class="cm"> *      damage your equipment.  It may damage your relations with other</span>
<span class="cm"> *      users of your network.  Use it at your own risk!</span>
<span class="cm"> *</span>
<span class="cm"> *      Based in part on:</span>
<span class="cm"> *      skeleton.c      by Donald Becker</span>
<span class="cm"> *      dummy.c         by Nick Holloway and Alan Cox</span>
<span class="cm"> *      loopback.c      by Ross Biro, Fred van Kampen, Donald Becker</span>
<span class="cm"> *      the netatalk source code (UMICH)</span>
<span class="cm"> *      lots of work on the card...</span>
<span class="cm"> *</span>
<span class="cm"> *      I do not have access to the (proprietary) SDK that goes with the card.</span>
<span class="cm"> *      If you do, I don&#39;t want to know about it, and you can probably write</span>
<span class="cm"> *      a better driver yourself anyway.  This does mean that the pieces that</span>
<span class="cm"> *      talk to the card are guesswork on my part, so use at your own risk!</span>
<span class="cm"> *</span>
<span class="cm"> *      This is my first try at writing Linux networking code, and is also</span>
<span class="cm"> *      guesswork.  Again, use at your own risk!  (Although on this part, I&#39;d</span>
<span class="cm"> *      welcome suggestions)</span>
<span class="cm"> *</span>
<span class="cm"> *      This is a loadable kernel module which seems to work at my site</span>
<span class="cm"> *      consisting of a 1.2.13 linux box running netatalk 1.3.3, and with</span>
<span class="cm"> *      the kernel support from 1.3.3b2 including patches routing.patch</span>
<span class="cm"> *      and ddp.disappears.from.chooser.  In order to run it, you will need</span>
<span class="cm"> *      to patch ddp.c and aarp.c in the kernel, but only a little...</span>
<span class="cm"> *</span>
<span class="cm"> *      I&#39;m fairly confident that while this is arguably badly written, the</span>
<span class="cm"> *      problems that people experience will be &quot;higher level&quot;, that is, with</span>
<span class="cm"> *      complications in the netatalk code.  The driver itself doesn&#39;t do</span>
<span class="cm"> *      anything terribly complicated -- it pretends to be an ether device</span>
<span class="cm"> *      as far as netatalk is concerned, strips the DDP data out of the ether</span>
<span class="cm"> *      frame and builds a LLAP packet to send out the card.  In the other</span>
<span class="cm"> *      direction, it receives LLAP frames from the card and builds a fake</span>
<span class="cm"> *      ether packet that it then tosses up to the networking code.  You can</span>
<span class="cm"> *      argue (correctly) that this is an ugly way to do things, but it</span>
<span class="cm"> *      requires a minimal amount of fooling with the code in ddp.c and aarp.c.</span>
<span class="cm"> *</span>
<span class="cm"> *      The card will do a lot more than is used here -- I *think* it has the</span>
<span class="cm"> *      layers up through ATP.  Even if you knew how that part works (which I</span>
<span class="cm"> *      don&#39;t) it would be a big job to carve up the kernel ddp code to insert</span>
<span class="cm"> *      things at a higher level, and probably a bad idea...</span>
<span class="cm"> *</span>
<span class="cm"> *      There are a number of other cards that do LocalTalk on the PC.  If</span>
<span class="cm"> *      nobody finds any insurmountable (at the netatalk level) problems</span>
<span class="cm"> *      here, this driver should encourage people to put some work into the</span>
<span class="cm"> *      other cards (some of which I gather are still commercially available)</span>
<span class="cm"> *      and also to put hooks for LocalTalk into the official ddp code.</span>
<span class="cm"> *</span>
<span class="cm"> *      I welcome comments and suggestions.  This is my first try at Linux</span>
<span class="cm"> *      networking stuff, and there are probably lots of things that I did</span>
<span class="cm"> *      suboptimally.  </span>
<span class="cm"> *</span>
<span class="cm"> ***/</span>

<span class="cm">/***</span>
<span class="cm"> *</span>
<span class="cm"> * $Log: ltpc.c,v $</span>
<span class="cm"> * Revision 1.1.2.1  2000/03/01 05:35:07  jgarzik</span>
<span class="cm"> * at and tr cleanup</span>
<span class="cm"> *</span>
<span class="cm"> * Revision 1.8  1997/01/28 05:44:54  bradford</span>
<span class="cm"> * Clean up for non-module a little.</span>
<span class="cm"> * Hacked about a bit to clean things up - Alan Cox </span>
<span class="cm"> * Probably broken it from the origina 1.8</span>
<span class="cm"> *</span>

<span class="cm"> * 1998/11/09: David Huggins-Daines &lt;dhd@debian.org&gt;</span>
<span class="cm"> * Cleaned up the initialization code to use the standard autoirq methods,</span>
<span class="cm">   and to probe for things in the standard order of i/o, irq, dma.  This</span>
<span class="cm">   removes the &quot;reset the reset&quot; hack, because I couldn&#39;t figure out an</span>
<span class="cm">   easy way to get the card to trigger an interrupt after it.</span>
<span class="cm"> * Added support for passing configuration parameters on the kernel command</span>
<span class="cm">   line and through insmod</span>
<span class="cm"> * Changed the device name from &quot;ltalk0&quot; to &quot;lt0&quot;, both to conform with the</span>
<span class="cm">   other localtalk driver, and to clear up the inconsistency between the</span>
<span class="cm">   module and the non-module versions of the driver :-)</span>
<span class="cm"> * Added a bunch of comments (I was going to make some enums for the state</span>
<span class="cm">   codes and the register offsets, but I&#39;m still not sure exactly what their</span>
<span class="cm">   semantics are)</span>
<span class="cm"> * Don&#39;t poll anymore in interrupt-driven mode</span>
<span class="cm"> * It seems to work as a module now (as of 2.1.127), but I don&#39;t think</span>
<span class="cm">   I&#39;m responsible for that...</span>

<span class="cm"> *</span>
<span class="cm"> * Revision 1.7  1996/12/12 03:42:33  bradford</span>
<span class="cm"> * DMA alloc cribbed from 3c505.c.</span>
<span class="cm"> *</span>
<span class="cm"> * Revision 1.6  1996/12/12 03:18:58  bradford</span>
<span class="cm"> * Added virt_to_bus; works in 2.1.13.</span>
<span class="cm"> *</span>
<span class="cm"> * Revision 1.5  1996/12/12 03:13:22  root</span>
<span class="cm"> * xmitQel initialization -- think through better though.</span>
<span class="cm"> *</span>
<span class="cm"> * Revision 1.4  1996/06/18 14:55:55  root</span>
<span class="cm"> * Change names to ltpc. Tabs. Took a shot at dma alloc,</span>
<span class="cm"> * although more needs to be done eventually.</span>
<span class="cm"> *</span>
<span class="cm"> * Revision 1.3  1996/05/22 14:59:39  root</span>
<span class="cm"> * Change dev-&gt;open, dev-&gt;close to track dummy.c in 1.99.(around 7)</span>
<span class="cm"> *</span>
<span class="cm"> * Revision 1.2  1996/05/22 14:58:24  root</span>
<span class="cm"> * Change tabs mostly.</span>
<span class="cm"> *</span>
<span class="cm"> * Revision 1.1  1996/04/23 04:45:09  root</span>
<span class="cm"> * Initial revision</span>
<span class="cm"> *</span>
<span class="cm"> * Revision 0.16  1996/03/05 15:59:56  root</span>
<span class="cm"> * Change ARPHRD_LOCALTLK definition to the &quot;real&quot; one.</span>
<span class="cm"> *</span>
<span class="cm"> * Revision 0.15  1996/03/05 06:28:30  root</span>
<span class="cm"> * Changes for kernel 1.3.70.  Still need a few patches to kernel, but</span>
<span class="cm"> * it&#39;s getting closer.</span>
<span class="cm"> *</span>
<span class="cm"> * Revision 0.14  1996/02/25 17:38:32  root</span>
<span class="cm"> * More cleanups.  Removed query to card on get_stats.</span>
<span class="cm"> *</span>
<span class="cm"> * Revision 0.13  1996/02/21  16:27:40  root</span>
<span class="cm"> * Refix debug_print_skb.  Fix mac.raw gotcha that appeared in 1.3.65.</span>
<span class="cm"> * Clean up receive code a little.</span>
<span class="cm"> *</span>
<span class="cm"> * Revision 0.12  1996/02/19  16:34:53  root</span>
<span class="cm"> * Fix debug_print_skb.  Kludge outgoing snet to 0 when using startup</span>
<span class="cm"> * range.  Change debug to mask: 1 for verbose, 2 for higher level stuff</span>
<span class="cm"> * including packet printing, 4 for lower level (card i/o) stuff.</span>
<span class="cm"> *</span>
<span class="cm"> * Revision 0.11  1996/02/12  15:53:38  root</span>
<span class="cm"> * Added router sends (requires new aarp.c patch)</span>
<span class="cm"> *</span>
<span class="cm"> * Revision 0.10  1996/02/11  00:19:35  root</span>
<span class="cm"> * Change source LTALK_LOGGING debug switch to insmod ... debug=2.</span>
<span class="cm"> *</span>
<span class="cm"> * Revision 0.9  1996/02/10  23:59:35  root</span>
<span class="cm"> * Fixed those fixes for 1.2 -- DANGER!  The at.h that comes with netatalk</span>
<span class="cm"> * has a *different* definition of struct sockaddr_at than the Linux kernel</span>
<span class="cm"> * does.  This is an &quot;insidious and invidious&quot; bug...</span>
<span class="cm"> * (Actually the preceding comment is false -- it&#39;s the atalk.h in the</span>
<span class="cm"> * ancient atalk-0.06 that&#39;s the problem)</span>
<span class="cm"> *</span>
<span class="cm"> * Revision 0.8  1996/02/10 19:09:00  root</span>
<span class="cm"> * Merge 1.3 changes.  Tested OK under 1.3.60.</span>
<span class="cm"> *</span>
<span class="cm"> * Revision 0.7  1996/02/10 17:56:56  root</span>
<span class="cm"> * Added debug=1 parameter on insmod for debugging prints.  Tried</span>
<span class="cm"> * to fix timer unload on rmmod, but I don&#39;t think that&#39;s the problem.</span>
<span class="cm"> *</span>
<span class="cm"> * Revision 0.6  1995/12/31  19:01:09  root</span>
<span class="cm"> * Clean up rmmod, irq comments per feedback from Corin Anderson (Thanks Corey!)</span>
<span class="cm"> * Clean up initial probing -- sometimes the card wakes up latched in reset.</span>
<span class="cm"> *</span>
<span class="cm"> * Revision 0.5  1995/12/22  06:03:44  root</span>
<span class="cm"> * Added comments in front and cleaned up a bit.</span>
<span class="cm"> * This version sent out to people.</span>
<span class="cm"> *</span>
<span class="cm"> * Revision 0.4  1995/12/18  03:46:44  root</span>
<span class="cm"> * Return shortDDP to longDDP fake to 0/0.  Added command structs.</span>
<span class="cm"> *</span>
<span class="cm"> ***/</span>

<span class="cm">/* ltpc jumpers are:</span>
<span class="cm">*</span>
<span class="cm">*	Interrupts -- set at most one.  If none are set, the driver uses</span>
<span class="cm">*	polled mode.  Because the card was developed in the XT era, the</span>
<span class="cm">*	original documentation refers to IRQ2.  Since you&#39;ll be running</span>
<span class="cm">*	this on an AT (or later) class machine, that really means IRQ9.</span>
<span class="cm">*</span>
<span class="cm">*	SW1	IRQ 4</span>
<span class="cm">*	SW2	IRQ 3</span>
<span class="cm">*	SW3	IRQ 9 (2 in original card documentation only applies to XT)</span>
<span class="cm">*</span>
<span class="cm">*</span>
<span class="cm">*	DMA -- choose DMA 1 or 3, and set both corresponding switches.</span>
<span class="cm">*</span>
<span class="cm">*	SW4	DMA 3</span>
<span class="cm">*	SW5	DMA 1</span>
<span class="cm">*	SW6	DMA 3</span>
<span class="cm">*	SW7	DMA 1</span>
<span class="cm">*</span>
<span class="cm">*</span>
<span class="cm">*	I/O address -- choose one.  </span>
<span class="cm">*</span>
<span class="cm">*	SW8	220 / 240</span>
<span class="cm">*/</span>

<span class="cm">/*	To have some stuff logged, do </span>
<span class="cm">*	insmod ltpc.o debug=1</span>
<span class="cm">*</span>
<span class="cm">*	For a whole bunch of stuff, use higher numbers.</span>
<span class="cm">*</span>
<span class="cm">*	The default is 0, i.e. no messages except for the probe results.</span>
<span class="cm">*/</span>

<span class="cm">/* insmod-tweakable variables */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">debug</span><span class="p">;</span>
<span class="cp">#define DEBUG_VERBOSE 1</span>
<span class="cp">#define DEBUG_UPPER 2</span>
<span class="cp">#define DEBUG_LOWER 4</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">io</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dma</span><span class="p">;</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/if_arp.h&gt;</span>
<span class="cp">#include &lt;linux/if_ltalk.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/atalk.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>

<span class="cp">#include &lt;asm/dma.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="cm">/* our stuff */</span>
<span class="cp">#include &quot;ltpc.h&quot;</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">txqueue_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">mbox_lock</span><span class="p">);</span>

<span class="cm">/* function prototypes */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">do_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cbuf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cbuflen</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dbuf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dbuflen</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sendup_buffer</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/* Dma Memory related stuff, cribbed directly from 3c505.c */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">dma_mem_alloc</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">__get_dma_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* DMA data buffer, DMA command buffer */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ltdmabuf</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ltdmacbuf</span><span class="p">;</span>

<span class="cm">/* private struct, holds our appletalk address */</span>

<span class="k">struct</span> <span class="n">ltpc_private</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atalk_addr</span> <span class="n">my_addr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* transmit queue element struct */</span>

<span class="k">struct</span> <span class="n">xmitQel</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">xmitQel</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="cm">/* command buffer */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cbuf</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">cbuflen</span><span class="p">;</span>
	<span class="cm">/* data buffer */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dbuf</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">dbuflen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">QWrite</span><span class="p">;</span>	<span class="cm">/* read or write data */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mailbox</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* the transmit queue itself */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">xmitQel</span> <span class="o">*</span><span class="n">xmQhd</span><span class="p">,</span> <span class="o">*</span><span class="n">xmQtl</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enQ</span><span class="p">(</span><span class="k">struct</span> <span class="n">xmitQel</span> <span class="o">*</span><span class="n">qel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">qel</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txqueue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xmQtl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xmQtl</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">qel</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">xmQhd</span> <span class="o">=</span> <span class="n">qel</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xmQtl</span> <span class="o">=</span> <span class="n">qel</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txqueue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="n">DEBUG_LOWER</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;enqueued a 0x%02x command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">qel</span><span class="o">-&gt;</span><span class="n">cbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">xmitQel</span> <span class="o">*</span><span class="nf">deQ</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xmitQel</span> <span class="o">*</span><span class="n">qel</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
	
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txqueue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xmQhd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qel</span> <span class="o">=</span> <span class="n">xmQhd</span><span class="p">;</span>
		<span class="n">xmQhd</span> <span class="o">=</span> <span class="n">qel</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">xmQhd</span><span class="p">)</span> <span class="n">xmQtl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txqueue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="n">DEBUG_LOWER</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">qel</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;ltpc: dequeued command &quot;</span><span class="p">);</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">qel</span><span class="o">-&gt;</span><span class="n">cbuflen</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">&gt;</span><span class="mi">100</span><span class="p">)</span> <span class="n">n</span><span class="o">=</span><span class="mi">100</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;%02x &quot;</span><span class="p">,</span><span class="n">qel</span><span class="o">-&gt;</span><span class="n">cbuf</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">qel</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* and... the queue elements we&#39;ll be using */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">xmitQel</span> <span class="n">qels</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

<span class="cm">/* and their corresponding mailboxes */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mailbox</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mboxinuse</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">wait_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* returns true if it stayed c */</span>
	<span class="cm">/* this uses base+6, but it&#39;s ok */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* twenty second or so total */</span>

	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">200000</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="o">+</span><span class="mi">6</span><span class="p">)</span> <span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* timed out */</span>
<span class="p">}</span>

<span class="cm">/* get the first free mailbox */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">getmbox</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mbox_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">mboxinuse</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">mboxinuse</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mbox_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mbox_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* read a command from the card */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">handlefc</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* called *only* from idle, non-reentrant */</span>
	<span class="kt">int</span> <span class="n">dma</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>


	<span class="n">flags</span><span class="o">=</span><span class="n">claim_dma_lock</span><span class="p">();</span>
	<span class="n">disable_dma</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">clear_dma_ff</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">set_dma_mode</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span><span class="n">DMA_MODE_READ</span><span class="p">);</span>
	<span class="n">set_dma_addr</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span><span class="n">virt_to_bus</span><span class="p">(</span><span class="n">ltdmacbuf</span><span class="p">));</span>
	<span class="n">set_dma_count</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span><span class="mi">50</span><span class="p">);</span>
	<span class="n">enable_dma</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">inb_p</span><span class="p">(</span><span class="n">base</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
	<span class="n">inb_p</span><span class="p">(</span><span class="n">base</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">wait_timeout</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="mh">0xfc</span><span class="p">)</span> <span class="p">)</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;timed out in handlefc</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* read data from the card */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">handlefd</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dma</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">flags</span><span class="o">=</span><span class="n">claim_dma_lock</span><span class="p">();</span>
	<span class="n">disable_dma</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">clear_dma_ff</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">set_dma_mode</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span><span class="n">DMA_MODE_READ</span><span class="p">);</span>
	<span class="n">set_dma_addr</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span><span class="n">virt_to_bus</span><span class="p">(</span><span class="n">ltdmabuf</span><span class="p">));</span>
	<span class="n">set_dma_count</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span><span class="mi">800</span><span class="p">);</span>
	<span class="n">enable_dma</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">inb_p</span><span class="p">(</span><span class="n">base</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
	<span class="n">inb_p</span><span class="p">(</span><span class="n">base</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">wait_timeout</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="mh">0xfd</span><span class="p">)</span> <span class="p">)</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;timed out in handlefd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">sendup_buffer</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span> 

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handlewrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* called *only* from idle, non-reentrant */</span>
	<span class="cm">/* on entry, 0xfb and ltdmabuf holds data */</span>
	<span class="kt">int</span> <span class="n">dma</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	
	<span class="n">flags</span><span class="o">=</span><span class="n">claim_dma_lock</span><span class="p">();</span>
	<span class="n">disable_dma</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">clear_dma_ff</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">set_dma_mode</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span><span class="n">DMA_MODE_WRITE</span><span class="p">);</span>
	<span class="n">set_dma_addr</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span><span class="n">virt_to_bus</span><span class="p">(</span><span class="n">ltdmabuf</span><span class="p">));</span>
	<span class="n">set_dma_count</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span><span class="mi">800</span><span class="p">);</span>
	<span class="n">enable_dma</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	
	<span class="n">inb_p</span><span class="p">(</span><span class="n">base</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
	<span class="n">inb_p</span><span class="p">(</span><span class="n">base</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">wait_timeout</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="mh">0xfb</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">flags</span><span class="o">=</span><span class="n">claim_dma_lock</span><span class="p">();</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;timed out in handlewrite, dma res %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">get_dma_residue</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">)</span> <span class="p">);</span>
		<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handleread</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* on entry, 0xfb */</span>
	<span class="cm">/* on exit, ltdmabuf holds data */</span>
	<span class="kt">int</span> <span class="n">dma</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	
	<span class="n">flags</span><span class="o">=</span><span class="n">claim_dma_lock</span><span class="p">();</span>
	<span class="n">disable_dma</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">clear_dma_ff</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">set_dma_mode</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span><span class="n">DMA_MODE_READ</span><span class="p">);</span>
	<span class="n">set_dma_addr</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span><span class="n">virt_to_bus</span><span class="p">(</span><span class="n">ltdmabuf</span><span class="p">));</span>
	<span class="n">set_dma_count</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span><span class="mi">800</span><span class="p">);</span>
	<span class="n">enable_dma</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">inb_p</span><span class="p">(</span><span class="n">base</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
	<span class="n">inb_p</span><span class="p">(</span><span class="n">base</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">wait_timeout</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="mh">0xfb</span><span class="p">)</span> <span class="p">)</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;timed out in handleread</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handlecommand</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* on entry, 0xfa and ltdmacbuf holds command */</span>
	<span class="kt">int</span> <span class="n">dma</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">flags</span><span class="o">=</span><span class="n">claim_dma_lock</span><span class="p">();</span>
	<span class="n">disable_dma</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">clear_dma_ff</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">set_dma_mode</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span><span class="n">DMA_MODE_WRITE</span><span class="p">);</span>
	<span class="n">set_dma_addr</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span><span class="n">virt_to_bus</span><span class="p">(</span><span class="n">ltdmacbuf</span><span class="p">));</span>
	<span class="n">set_dma_count</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span><span class="mi">50</span><span class="p">);</span>
	<span class="n">enable_dma</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">inb_p</span><span class="p">(</span><span class="n">base</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
	<span class="n">inb_p</span><span class="p">(</span><span class="n">base</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">wait_timeout</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="mh">0xfa</span><span class="p">)</span> <span class="p">)</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;timed out in handlecommand</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span> 

<span class="cm">/* ready made command for getting the result from the card */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">rescbuf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">LT_GETRESULT</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">resdbuf</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">QInIdle</span><span class="p">;</span>

<span class="cm">/* idle expects to be called with the IRQ line high -- either because of</span>
<span class="cm"> * an interrupt, or because the line is tri-stated</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">;</span>
	<span class="cm">/* FIXME This is initialized to shut the warning up, but I need to</span>
<span class="cm">	 * think this through again.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">xmitQel</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">oops</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txqueue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">QInIdle</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txqueue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">QInIdle</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txqueue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* this tri-states the IRQ line */</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">base</span><span class="o">+</span><span class="mi">6</span><span class="p">);</span>

	<span class="n">oops</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

<span class="nl">loop:</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="o">&gt;</span><span class="n">oops</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span> 
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;idle: looped too many times</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">base</span><span class="o">+</span><span class="mi">6</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">base</span><span class="o">+</span><span class="mi">6</span><span class="p">))</span> <span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mh">0xfc</span>:
			<span class="cm">/* incoming command */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="n">DEBUG_LOWER</span><span class="p">)</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;idle: fc</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">handlefc</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span> 
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0xfd</span>:
			<span class="cm">/* incoming data */</span>
			<span class="k">if</span><span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="n">DEBUG_LOWER</span><span class="p">)</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;idle: fd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">handlefd</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span> 
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0xf9</span>:
			<span class="cm">/* result ready */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="n">DEBUG_LOWER</span><span class="p">)</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;idle: f9</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">mboxinuse</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">mboxinuse</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">qels</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cbuf</span> <span class="o">=</span> <span class="n">rescbuf</span><span class="p">;</span>
				<span class="n">qels</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cbuflen</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="n">qels</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dbuf</span> <span class="o">=</span> <span class="n">resdbuf</span><span class="p">;</span>
				<span class="n">qels</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dbuflen</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="n">qels</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">QWrite</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">qels</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">mailbox</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">enQ</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qels</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="p">}</span>
			<span class="n">inb_p</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">inb_p</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="o">+</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">wait_timeout</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="mh">0xf9</span><span class="p">)</span> <span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;timed out idle f9</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0xf8</span>:
			<span class="cm">/* ?? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">xmQhd</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">inb_p</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
				<span class="n">inb_p</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="o">+</span><span class="mi">0</span><span class="p">);</span>
				<span class="k">if</span><span class="p">(</span><span class="n">wait_timeout</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="mh">0xf8</span><span class="p">)</span> <span class="p">)</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;timed out idle f8</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0xfa</span>:
			<span class="cm">/* waiting for command */</span>
			<span class="k">if</span><span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="n">DEBUG_LOWER</span><span class="p">)</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;idle: fa</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">xmQhd</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">q</span><span class="o">=</span><span class="n">deQ</span><span class="p">();</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">ltdmacbuf</span><span class="p">,</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cbuf</span><span class="p">,</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cbuflen</span><span class="p">);</span>
				<span class="n">ltdmacbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">mailbox</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span> 
					<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ltpc: sent command     &quot;</span><span class="p">);</span>
					<span class="n">n</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">cbuflen</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">&gt;</span><span class="mi">100</span><span class="p">)</span> <span class="n">n</span><span class="o">=</span><span class="mi">100</span><span class="p">;</span>
					<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
						<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%02x &quot;</span><span class="p">,</span><span class="n">ltdmacbuf</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">handlecommand</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
					<span class="k">if</span><span class="p">(</span><span class="mh">0xfa</span><span class="o">==</span><span class="n">inb_p</span><span class="p">(</span><span class="n">base</span><span class="o">+</span><span class="mi">6</span><span class="p">))</span> <span class="p">{</span>
						<span class="cm">/* we timed out, so return */</span>
						<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
					<span class="p">}</span> 
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* we don&#39;t seem to have a command */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mboxinuse</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
					<span class="n">mboxinuse</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">qels</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cbuf</span> <span class="o">=</span> <span class="n">rescbuf</span><span class="p">;</span>
					<span class="n">qels</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cbuflen</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
					<span class="n">qels</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dbuf</span> <span class="o">=</span> <span class="n">resdbuf</span><span class="p">;</span>
					<span class="n">qels</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dbuflen</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
					<span class="n">qels</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">QWrite</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">qels</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">mailbox</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">enQ</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qels</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;trouble: response command already queued</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> 
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">0</span><span class="n">Xfb</span>:
			<span class="cm">/* data transfer ready */</span>
			<span class="k">if</span><span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="n">DEBUG_LOWER</span><span class="p">)</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;idle: fb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">QWrite</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">ltdmabuf</span><span class="p">,</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">,</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">dbuflen</span><span class="p">);</span>
				<span class="n">handlewrite</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">handleread</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
				<span class="cm">/* non-zero mailbox numbers are for</span>
<span class="cm">				   commmands, 0 is for GETRESULT</span>
<span class="cm">				   requests */</span>
				<span class="k">if</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">mailbox</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">memcpy</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">,</span><span class="n">ltdmabuf</span><span class="p">,</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">dbuflen</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> 
					<span class="cm">/* this was a result */</span>
					<span class="n">mailbox</span><span class="p">[</span> <span class="mh">0x0f</span> <span class="o">&amp;</span> <span class="n">ltdmabuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">]</span> <span class="o">=</span> <span class="n">ltdmabuf</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
					<span class="n">mboxinuse</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>

<span class="nl">done:</span>
	<span class="n">QInIdle</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* now set the interrupts back as appropriate */</span>
	<span class="cm">/* the first read takes it out of tri-state (but still high) */</span>
	<span class="cm">/* the second resets it */</span>
	<span class="cm">/* note that after this point, any read of base+6 will</span>
<span class="cm">	   trigger an interrupt */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inb_p</span><span class="p">(</span><span class="n">base</span><span class="o">+</span><span class="mi">7</span><span class="p">);</span>
		<span class="n">inb_p</span><span class="p">(</span><span class="n">base</span><span class="o">+</span><span class="mi">7</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cbuf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cbuflen</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dbuf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dbuflen</span><span class="p">)</span>
<span class="p">{</span>

	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">getmbox</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qels</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cbuf</span> <span class="o">=</span> <span class="n">cbuf</span><span class="p">;</span>
		<span class="n">qels</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cbuflen</span> <span class="o">=</span> <span class="n">cbuflen</span><span class="p">;</span>
		<span class="n">qels</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dbuf</span> <span class="o">=</span> <span class="n">dbuf</span><span class="p">;</span>
		<span class="n">qels</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dbuflen</span> <span class="o">=</span> <span class="n">dbuflen</span><span class="p">;</span>
		<span class="n">qels</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">QWrite</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">qels</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mailbox</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>  <span class="cm">/* this should be initted rather */</span>
		<span class="n">enQ</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qels</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">idle</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mailbox</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">mboxinuse</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ltpc: could not allocate mbox</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cbuf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cbuflen</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dbuf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dbuflen</span><span class="p">)</span>
<span class="p">{</span>

	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">getmbox</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qels</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cbuf</span> <span class="o">=</span> <span class="n">cbuf</span><span class="p">;</span>
		<span class="n">qels</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cbuflen</span> <span class="o">=</span> <span class="n">cbuflen</span><span class="p">;</span>
		<span class="n">qels</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dbuf</span> <span class="o">=</span> <span class="n">dbuf</span><span class="p">;</span>
		<span class="n">qels</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dbuflen</span> <span class="o">=</span> <span class="n">dbuflen</span><span class="p">;</span>
		<span class="n">qels</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">QWrite</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">qels</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mailbox</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>  <span class="cm">/* this should be initted rather */</span>
		<span class="n">enQ</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qels</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">idle</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mailbox</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">mboxinuse</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ltpc: could not allocate mbox</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* end of idle handlers -- what should be seen is do_read, do_write */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">timer_list</span> <span class="n">ltpc_timer</span><span class="p">;</span>

<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="n">ltpc_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_30</span> <span class="p">(</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lt_command</span> <span class="n">c</span><span class="p">;</span>
	<span class="n">c</span><span class="p">.</span><span class="n">getflags</span><span class="p">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">LT_GETFLAGS</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">do_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">getflags</span><span class="p">),</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_30</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lt_command</span> <span class="n">c</span><span class="p">;</span>
	<span class="n">c</span><span class="p">.</span><span class="n">setflags</span><span class="p">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">LT_SETFLAGS</span><span class="p">;</span>
	<span class="n">c</span><span class="p">.</span><span class="n">setflags</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">do_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">setflags</span><span class="p">),</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* LLAP to DDP translation */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sendup_buffer</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* on entry, command is in ltdmacbuf, data in ltdmabuf */</span>
	<span class="cm">/* called from idle, non-reentrant */</span>

	<span class="kt">int</span> <span class="n">dnode</span><span class="p">,</span> <span class="n">snode</span><span class="p">,</span> <span class="n">llaptype</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span> 
	<span class="kt">int</span> <span class="n">sklen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lt_rcvlap</span> <span class="o">*</span><span class="n">ltc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lt_rcvlap</span> <span class="o">*</span><span class="p">)</span> <span class="n">ltdmacbuf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ltc</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">!=</span> <span class="n">LT_RCVLAP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;unknown command 0x%02x from ltpc card</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">ltc</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dnode</span> <span class="o">=</span> <span class="n">ltc</span><span class="o">-&gt;</span><span class="n">dnode</span><span class="p">;</span>
	<span class="n">snode</span> <span class="o">=</span> <span class="n">ltc</span><span class="o">-&gt;</span><span class="n">snode</span><span class="p">;</span>
	<span class="n">llaptype</span> <span class="o">=</span> <span class="n">ltc</span><span class="o">-&gt;</span><span class="n">laptype</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">ltc</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span> 

	<span class="n">sklen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">llaptype</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> 
		<span class="n">sklen</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>  <span class="cm">/* correct for short ddp */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">sklen</span> <span class="o">&gt;</span> <span class="mi">800</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: nonsense length in ltpc command 0x14: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span><span class="n">sklen</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">llaptype</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">llaptype</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: unknown LLAP type: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span><span class="n">llaptype</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="n">sklen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: dropping packet due to memory squeeze.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sklen</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span><span class="mi">8</span><span class="p">);</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span><span class="n">len</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_LOCALTALK</span><span class="p">);</span>
	<span class="cm">/* add LLAP header */</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dnode</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">snode</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">llaptype</span><span class="p">;</span>
	<span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>	<span class="cm">/* save pointer to llap header */</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>

	<span class="cm">/* copy ddp(s,e)hdr + contents */</span>
	<span class="n">skb_copy_to_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ltdmabuf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">skb_reset_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="cm">/* toss it onwards */</span>
	<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* the handler for the board interrupt */</span>
 
<span class="k">static</span> <span class="n">irqreturn_t</span>
<span class="nf">ltpc_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ltpc_interrupt: unknown device.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">inb_p</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="o">+</span><span class="mi">6</span><span class="p">);</span>  <span class="cm">/* disable further interrupts from board */</span>

	<span class="n">idle</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span> <span class="cm">/* handle whatever is coming in */</span>
 
	<span class="cm">/* idle re-enables interrupts from board */</span> 

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/***</span>
<span class="cm"> *</span>
<span class="cm"> *    The ioctls that the driver responds to are:</span>
<span class="cm"> *</span>
<span class="cm"> *    SIOCSIFADDR -- do probe using the passed node hint.</span>
<span class="cm"> *    SIOCGIFADDR -- return net, node.</span>
<span class="cm"> *</span>
<span class="cm"> *    some of this stuff should be done elsewhere.</span>
<span class="cm"> *</span>
<span class="cm"> ***/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ltpc_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_at</span> <span class="o">*</span><span class="n">sa</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_at</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_addr</span><span class="p">;</span>
	<span class="cm">/* we&#39;ll keep the localtalk node address in dev-&gt;pa_addr */</span>
	<span class="k">struct</span> <span class="n">ltpc_private</span> <span class="o">*</span><span class="n">ltpc_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">atalk_addr</span> <span class="o">*</span><span class="n">aa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ltpc_priv</span><span class="o">-&gt;</span><span class="n">my_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lt_init</span> <span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ltflags</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="n">DEBUG_VERBOSE</span><span class="p">)</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;ltpc_ioctl called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SIOCSIFADDR</span>:

			<span class="n">aa</span><span class="o">-&gt;</span><span class="n">s_net</span>  <span class="o">=</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span><span class="p">;</span>
      
			<span class="cm">/* this does the probe and returns the node addr */</span>
			<span class="n">c</span><span class="p">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">LT_INIT</span><span class="p">;</span>
			<span class="n">c</span><span class="p">.</span><span class="n">hint</span> <span class="o">=</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span><span class="p">;</span>

			<span class="n">aa</span><span class="o">-&gt;</span><span class="n">s_node</span> <span class="o">=</span> <span class="n">do_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">c</span><span class="p">),</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>

			<span class="cm">/* get all llap frames raw */</span>
			<span class="n">ltflags</span> <span class="o">=</span> <span class="n">read_30</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">ltflags</span> <span class="o">|=</span> <span class="n">LT_FLAG_ALLLAP</span><span class="p">;</span>
			<span class="n">set_30</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="n">ltflags</span><span class="p">);</span>  

			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">broadcast</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">aa</span><span class="o">-&gt;</span><span class="n">s_node</span><span class="p">;</span>

			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
   
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SIOCGIFADDR</span>:

			<span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span> <span class="o">=</span> <span class="n">aa</span><span class="o">-&gt;</span><span class="n">s_net</span><span class="p">;</span>
			<span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span> <span class="o">=</span> <span class="n">aa</span><span class="o">-&gt;</span><span class="n">s_node</span><span class="p">;</span>

			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="nl">default:</span> 
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_multicast_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* This needs to be present to keep netatalk happy. */</span>
	<span class="cm">/* Actually netatalk needs fixing! */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ltpc_poll_counter</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ltpc_poll</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">)</span> <span class="n">l</span><span class="p">;</span>

	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ltpc_timer</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="n">DEBUG_VERBOSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ltpc_poll_counter</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ltpc_poll_counter</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ltpc poll is alive</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ltpc_poll_counter</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
  
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>  <span class="cm">/* we&#39;ve been downed */</span>

	<span class="cm">/* poll 20 times per second */</span>
	<span class="n">idle</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">ltpc_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">20</span><span class="p">;</span>
	
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ltpc_timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* DDP to LLAP translation */</span>

<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">ltpc_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* in kernel 1.3.xx, on entry skb-&gt;data points to ddp header,</span>
<span class="cm">	 * and skb-&gt;len is the length of the ddp data + ddp header</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lt_sendlap</span> <span class="n">cbuf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>

	<span class="n">cbuf</span><span class="p">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">LT_SENDLAP</span><span class="p">;</span>
	<span class="n">cbuf</span><span class="p">.</span><span class="n">dnode</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">cbuf</span><span class="p">.</span><span class="n">laptype</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>	<span class="cm">/* skip past LLAP header */</span>
	<span class="n">cbuf</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>	<span class="cm">/* this is host order */</span>
	<span class="n">skb_reset_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="n">DEBUG_UPPER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;command &quot;</span><span class="p">);</span>
		<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%02x &quot;</span><span class="p">,((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cbuf</span><span class="p">)[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">hdr</span> <span class="o">=</span> <span class="n">skb_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">do_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cbuf</span><span class="p">),</span> <span class="n">hdr</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="n">DEBUG_UPPER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;sent %d ddp bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="n">hdr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* initialization stuff */</span>
  
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ltpc_probe_dma</span><span class="p">(</span><span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">want</span> <span class="o">=</span> <span class="p">(</span><span class="n">dma</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="p">(</span><span class="n">dma</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">3</span><span class="p">;</span>
  	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
  	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">f</span><span class="p">;</span>
  
  	<span class="k">if</span> <span class="p">(</span><span class="n">want</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">request_dma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;ltpc&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">want</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">f</span><span class="o">=</span><span class="n">claim_dma_lock</span><span class="p">();</span>
			<span class="n">disable_dma</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">clear_dma_ff</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">set_dma_mode</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">DMA_MODE_WRITE</span><span class="p">);</span>
			<span class="n">set_dma_addr</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">virt_to_bus</span><span class="p">(</span><span class="n">ltdmabuf</span><span class="p">));</span>
			<span class="n">set_dma_count</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lt_mem</span><span class="p">));</span>
			<span class="n">enable_dma</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">want</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">request_dma</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;ltpc&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">want</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">f</span><span class="o">=</span><span class="n">claim_dma_lock</span><span class="p">();</span>
			<span class="n">disable_dma</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
			<span class="n">clear_dma_ff</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
			<span class="n">set_dma_mode</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">DMA_MODE_WRITE</span><span class="p">);</span>
			<span class="n">set_dma_addr</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">virt_to_bus</span><span class="p">(</span><span class="n">ltdmabuf</span><span class="p">));</span>
			<span class="n">set_dma_count</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lt_mem</span><span class="p">));</span>
			<span class="n">enable_dma</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
			<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* set up request */</span>

	<span class="cm">/* FIXME -- do timings better! */</span>

	<span class="n">ltdmabuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">LT_READMEM</span><span class="p">;</span>
	<span class="n">ltdmabuf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* mailbox */</span>
	<span class="n">ltdmabuf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ltdmabuf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* address */</span>
	<span class="n">ltdmabuf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ltdmabuf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* read 0x0100 bytes */</span>
	<span class="n">ltdmabuf</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* dunno if this is necessary */</span>

	<span class="n">inb_p</span><span class="p">(</span><span class="n">io</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">inb_p</span><span class="p">(</span><span class="n">io</span><span class="o">+</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span><span class="o">+</span><span class="mi">100</span><span class="o">*</span><span class="n">HZ</span><span class="o">/</span><span class="mi">100</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span> <span class="mh">0xfa</span> <span class="o">==</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">io</span><span class="o">+</span><span class="mi">6</span><span class="p">)</span> <span class="p">)</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">inb_p</span><span class="p">(</span><span class="n">io</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
	<span class="n">inb_p</span><span class="p">(</span><span class="n">io</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
	<span class="k">while</span><span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span> <span class="mh">0xfb</span> <span class="o">==</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">io</span><span class="o">+</span><span class="mi">6</span><span class="p">)</span> <span class="p">)</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* release the other dma channel (if we opened both of them) */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">want</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">get_dma_residue</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">==</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lt_mem</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">want</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">free_dma</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">want</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">get_dma_residue</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lt_mem</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">want</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">free_dma</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">want</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">want</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">ltpc_netdev</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">ltpc_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span>		<span class="o">=</span> <span class="n">ltpc_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">set_multicast_list</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">ltpc_probe</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">autoirq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">f</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_ltalkdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ltpc_private</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* probe for the I/O port address */</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">io</span> <span class="o">!=</span> <span class="mh">0x240</span> <span class="o">&amp;&amp;</span> <span class="n">request_region</span><span class="p">(</span><span class="mh">0x220</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="s">&quot;ltpc&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">x</span> <span class="o">=</span> <span class="n">inb_p</span><span class="p">(</span><span class="mh">0x220</span><span class="o">+</span><span class="mi">6</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">x</span><span class="o">!=</span><span class="mh">0xff</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">x</span><span class="o">&gt;=</span><span class="mh">0xf0</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">io</span> <span class="o">=</span> <span class="mh">0x220</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">got_port</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">release_region</span><span class="p">(</span><span class="mh">0x220</span><span class="p">,</span><span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">io</span> <span class="o">!=</span> <span class="mh">0x220</span> <span class="o">&amp;&amp;</span> <span class="n">request_region</span><span class="p">(</span><span class="mh">0x240</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="s">&quot;ltpc&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">y</span> <span class="o">=</span> <span class="n">inb_p</span><span class="p">(</span><span class="mh">0x240</span><span class="o">+</span><span class="mi">6</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">y</span><span class="o">!=</span><span class="mh">0xff</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">y</span><span class="o">&gt;=</span><span class="mh">0xf0</span><span class="p">)</span> <span class="p">){</span> 
			<span class="n">io</span> <span class="o">=</span> <span class="mh">0x240</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">got_port</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">release_region</span><span class="p">(</span><span class="mh">0x240</span><span class="p">,</span><span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span> 

	<span class="cm">/* give up in despair */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;LocalTalk card not found; 220 = %02x, 240 = %02x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out1</span><span class="p">;</span>

 <span class="nl">got_port:</span>
	<span class="cm">/* probe for the IRQ line */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_mask</span><span class="p">;</span>

		<span class="n">irq_mask</span> <span class="o">=</span> <span class="n">probe_irq_on</span><span class="p">();</span>
		<span class="cm">/* reset the interrupt line */</span>
		<span class="n">inb_p</span><span class="p">(</span><span class="n">io</span><span class="o">+</span><span class="mi">7</span><span class="p">);</span>
		<span class="n">inb_p</span><span class="p">(</span><span class="n">io</span><span class="o">+</span><span class="mi">7</span><span class="p">);</span>
		<span class="cm">/* trigger an interrupt (I hope) */</span>
		<span class="n">inb_p</span><span class="p">(</span><span class="n">io</span><span class="o">+</span><span class="mi">6</span><span class="p">);</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
		<span class="n">autoirq</span> <span class="o">=</span> <span class="n">probe_irq_off</span><span class="p">(</span><span class="n">irq_mask</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">autoirq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ltpc: probe at %#x failed to detect IRQ line.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">io</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">irq</span> <span class="o">=</span> <span class="n">autoirq</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* allocate a DMA buffer */</span>
	<span class="n">ltdmabuf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">dma_mem_alloc</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ltdmabuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ltpc: mem alloc failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ltdmacbuf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ltdmabuf</span><span class="p">[</span><span class="mi">800</span><span class="p">];</span>

	<span class="k">if</span><span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="n">DEBUG_VERBOSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ltdmabuf pointer %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ltdmabuf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* reset the card */</span>

	<span class="n">inb_p</span><span class="p">(</span><span class="n">io</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">inb_p</span><span class="p">(</span><span class="n">io</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>

	<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>

	<span class="n">inb_p</span><span class="p">(</span><span class="n">io</span><span class="o">+</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">inb_p</span><span class="p">(</span><span class="n">io</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
	<span class="n">inb_p</span><span class="p">(</span><span class="n">io</span><span class="o">+</span><span class="mi">7</span><span class="p">);</span> <span class="cm">/* clear reset */</span>
	<span class="n">inb_p</span><span class="p">(</span><span class="n">io</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span> 
	<span class="n">inb_p</span><span class="p">(</span><span class="n">io</span><span class="o">+</span><span class="mi">5</span><span class="p">);</span>
	<span class="n">inb_p</span><span class="p">(</span><span class="n">io</span><span class="o">+</span><span class="mi">5</span><span class="p">);</span> <span class="cm">/* enable dma */</span>
	<span class="n">inb_p</span><span class="p">(</span><span class="n">io</span><span class="o">+</span><span class="mi">6</span><span class="p">);</span> <span class="cm">/* tri-state interrupt line */</span>

	<span class="n">ssleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	
	<span class="cm">/* now, figure out which dma channel we&#39;re using, unless it&#39;s</span>
<span class="cm">	   already been specified */</span>
	<span class="cm">/* well, 0 is a legal DMA channel, but the LTPC card doesn&#39;t</span>
<span class="cm">	   use it... */</span>
	<span class="n">dma</span> <span class="o">=</span> <span class="n">ltpc_probe_dma</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">dma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dma</span><span class="p">)</span> <span class="p">{</span>  <span class="cm">/* no dma channel */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;No DMA channel found on ltpc card.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* print out friendly message */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">irq</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Apple/Farallon LocalTalk-PC card at %03x, IR%d, DMA%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">io</span><span class="p">,</span><span class="n">irq</span><span class="p">,</span><span class="n">dma</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Apple/Farallon LocalTalk-PC card at %03x, DMA%d.  Using polled mode.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">io</span><span class="p">,</span><span class="n">dma</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ltpc_netdev</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">io</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma</span><span class="p">;</span>

	<span class="cm">/* the card will want to send a result at this point */</span>
	<span class="cm">/* (I think... leaving out this part makes the kernel crash,</span>
<span class="cm">           so I put it back in...) */</span>

	<span class="n">f</span><span class="o">=</span><span class="n">claim_dma_lock</span><span class="p">();</span>
	<span class="n">disable_dma</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">clear_dma_ff</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">set_dma_mode</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span><span class="n">DMA_MODE_READ</span><span class="p">);</span>
	<span class="n">set_dma_addr</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span><span class="n">virt_to_bus</span><span class="p">(</span><span class="n">ltdmabuf</span><span class="p">));</span>
	<span class="n">set_dma_count</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span><span class="mh">0x100</span><span class="p">);</span>
	<span class="n">enable_dma</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>

	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">io</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">io</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span><span class="o">+</span><span class="mi">100</span><span class="o">*</span><span class="n">HZ</span><span class="o">/</span><span class="mi">100</span><span class="p">;</span>

	<span class="k">while</span><span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span> <span class="mh">0xf9</span> <span class="o">==</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">io</span><span class="o">+</span><span class="mi">6</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="n">DEBUG_VERBOSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;setting up timer and irq</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* grab it and don&#39;t let go :-) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&amp;&amp;</span> <span class="n">request_irq</span><span class="p">(</span> <span class="n">irq</span><span class="p">,</span> <span class="n">ltpc_interrupt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;ltpc&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">io</span><span class="o">+</span><span class="mi">7</span><span class="p">);</span>  <span class="cm">/* enable interrupts from board */</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">io</span><span class="o">+</span><span class="mi">7</span><span class="p">);</span>  <span class="cm">/* and reset irq line */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span> <span class="n">irq</span> <span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ltpc: IRQ already in use, using polled mode.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* polled mode -- 20 times per second */</span>
		<span class="cm">/* this is really, really slow... should it poll more often? */</span>
		<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ltpc_timer</span><span class="p">);</span>
		<span class="n">ltpc_timer</span><span class="p">.</span><span class="n">function</span><span class="o">=</span><span class="n">ltpc_poll</span><span class="p">;</span>
		<span class="n">ltpc_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">dev</span><span class="p">;</span>

		<span class="n">ltpc_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">20</span><span class="p">;</span>
		<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ltpc_timer</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out4</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out4:</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ltpc_timer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="nl">out3:</span>
	<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ltdmabuf</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>
<span class="nl">out2:</span>
	<span class="n">release_region</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
<span class="nl">out1:</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifndef MODULE</span>
<span class="cm">/* handles &quot;ltpc=io,irq,dma&quot; kernel command lines */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ltpc_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ints</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

	<span class="n">str</span> <span class="o">=</span> <span class="n">get_options</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ints</span><span class="p">),</span> <span class="n">ints</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">str</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;auto&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* do nothing :-) */</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* usage message */</span>
			<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_ERR</span>
				<span class="s">&quot;ltpc: usage: ltpc=auto|iobase[,irq[,dma]]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">io</span> <span class="o">=</span> <span class="n">ints</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">irq</span> <span class="o">=</span> <span class="n">ints</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dma</span> <span class="o">=</span> <span class="n">ints</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="cm">/* ignore any other parameters */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;ltpc=&quot;</span><span class="p">,</span> <span class="n">ltpc_setup</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* MODULE */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev_ltpc</span><span class="p">;</span>

<span class="cp">#ifdef MODULE</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ltpc_module_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">io</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span>
		       <span class="s">&quot;ltpc: Autoprobing is not recommended for modules</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">dev_ltpc</span> <span class="o">=</span> <span class="n">ltpc_probe</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dev_ltpc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dev_ltpc</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">ltpc_module_init</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">ltpc_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span><span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="n">DEBUG_VERBOSE</span><span class="p">)</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;unregister_netdev</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">dev_ltpc</span><span class="p">);</span>

	<span class="n">ltpc_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* signal the poll routine that we&#39;re done */</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ltpc_timer</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="n">DEBUG_VERBOSE</span><span class="p">)</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;freeing irq</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev_ltpc</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">dev_ltpc</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev_ltpc</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="n">DEBUG_VERBOSE</span><span class="p">)</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;freeing dma</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev_ltpc</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">)</span>
		<span class="n">free_dma</span><span class="p">(</span><span class="n">dev_ltpc</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="n">DEBUG_VERBOSE</span><span class="p">)</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;freeing ioaddr</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev_ltpc</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">)</span>
		<span class="n">release_region</span><span class="p">(</span><span class="n">dev_ltpc</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">,</span><span class="mi">8</span><span class="p">);</span>

	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev_ltpc</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="n">DEBUG_VERBOSE</span><span class="p">)</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;free_pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">free_pages</span><span class="p">(</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ltdmabuf</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>

	<span class="k">if</span><span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="n">DEBUG_VERBOSE</span><span class="p">)</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;returning from cleanup_module</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_exit</span><span class="p">(</span><span class="n">ltpc_cleanup</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
