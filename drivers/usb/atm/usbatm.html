<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › atm › usbatm.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>usbatm.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> *  usbatm.c - Generic USB xDSL driver core</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2001, Alcatel</span>
<span class="cm"> *  Copyright (C) 2003, Duncan Sands, SolNegro, Josep Comas</span>
<span class="cm"> *  Copyright (C) 2004, David Woodhouse, Roman Kagan</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> *  under the terms of the GNU General Public License as published by the Free</span>
<span class="cm"> *  Software Foundation; either version 2 of the License, or (at your option)</span>
<span class="cm"> *  any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> *  more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> *  this program; if not, write to the Free Software Foundation, Inc., 59</span>
<span class="cm"> *  Temple Place - Suite 330, Boston, MA  02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> *  Written by Johan Verrept, Duncan Sands (duncan.sands@free.fr) and David Woodhouse</span>
<span class="cm"> *</span>
<span class="cm"> *  1.7+:	- See the check-in logs</span>
<span class="cm"> *</span>
<span class="cm"> *  1.6:	- No longer opens a connection if the firmware is not loaded</span>
<span class="cm"> *  		- Added support for the speedtouch 330</span>
<span class="cm"> *  		- Removed the limit on the number of devices</span>
<span class="cm"> *  		- Module now autoloads on device plugin</span>
<span class="cm"> *  		- Merged relevant parts of sarlib</span>
<span class="cm"> *  		- Replaced the kernel thread with a tasklet</span>
<span class="cm"> *  		- New packet transmission code</span>
<span class="cm"> *  		- Changed proc file contents</span>
<span class="cm"> *  		- Fixed all known SMP races</span>
<span class="cm"> *  		- Many fixes and cleanups</span>
<span class="cm"> *  		- Various fixes by Oliver Neukum (oliver@neukum.name)</span>
<span class="cm"> *</span>
<span class="cm"> *  1.5A:	- Version for inclusion in 2.5 series kernel</span>
<span class="cm"> *		- Modifications by Richard Purdie (rpurdie@rpsys.net)</span>
<span class="cm"> *		- made compatible with kernel 2.5.6 onwards by changing</span>
<span class="cm"> *		usbatm_usb_send_data_context-&gt;urb to a pointer and adding code</span>
<span class="cm"> *		to alloc and free it</span>
<span class="cm"> *		- remove_wait_queue() added to usbatm_atm_processqueue_thread()</span>
<span class="cm"> *</span>
<span class="cm"> *  1.5:	- fixed memory leak when atmsar_decode_aal5 returned NULL.</span>
<span class="cm"> *		(reported by stephen.robinson@zen.co.uk)</span>
<span class="cm"> *</span>
<span class="cm"> *  1.4:	- changed the spin_lock() under interrupt to spin_lock_irqsave()</span>
<span class="cm"> *		- unlink all active send urbs of a vcc that is being closed.</span>
<span class="cm"> *</span>
<span class="cm"> *  1.3.1:	- added the version number</span>
<span class="cm"> *</span>
<span class="cm"> *  1.3:	- Added multiple send urb support</span>
<span class="cm"> *		- fixed memory leak and vcc-&gt;tx_inuse starvation bug</span>
<span class="cm"> *		  when not enough memory left in vcc.</span>
<span class="cm"> *</span>
<span class="cm"> *  1.2:	- Fixed race condition in usbatm_usb_send_data()</span>
<span class="cm"> *  1.1:	- Turned off packet debugging</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;usbatm.h&quot;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>

<span class="cp">#ifdef VERBOSE_DEBUG</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">usbatm_print_packet</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="cp">#define PACKETDEBUG(arg...)	usbatm_print_packet(arg)</span>
<span class="cp">#define vdbg(arg...)		dev_dbg(arg)</span>
<span class="cp">#else</span>
<span class="cp">#define PACKETDEBUG(arg...)</span>
<span class="cp">#define vdbg(arg...)</span>
<span class="cp">#endif</span>

<span class="cp">#define DRIVER_AUTHOR	&quot;Johan Verrept, Duncan Sands &lt;duncan.sands@free.fr&gt;&quot;</span>
<span class="cp">#define DRIVER_VERSION	&quot;1.10&quot;</span>
<span class="cp">#define DRIVER_DESC	&quot;Generic USB ATM/DSL I/O, version &quot; DRIVER_VERSION</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">usbatm_driver_name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;usbatm&quot;</span><span class="p">;</span>

<span class="cp">#define UDSL_MAX_RCV_URBS		16</span>
<span class="cp">#define UDSL_MAX_SND_URBS		16</span>
<span class="cp">#define UDSL_MAX_BUF_SIZE		65536</span>
<span class="cp">#define UDSL_DEFAULT_RCV_URBS		4</span>
<span class="cp">#define UDSL_DEFAULT_SND_URBS		4</span>
<span class="cp">#define UDSL_DEFAULT_RCV_BUF_SIZE	3392	</span><span class="cm">/* 64 * ATM_CELL_SIZE */</span><span class="cp"></span>
<span class="cp">#define UDSL_DEFAULT_SND_BUF_SIZE	3392	</span><span class="cm">/* 64 * ATM_CELL_SIZE */</span><span class="cp"></span>

<span class="cp">#define ATM_CELL_HEADER			(ATM_CELL_SIZE - ATM_CELL_PAYLOAD)</span>

<span class="cp">#define THROTTLE_MSECS			100	</span><span class="cm">/* delay to recover processing after urb submission fails */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_rcv_urbs</span> <span class="o">=</span> <span class="n">UDSL_DEFAULT_RCV_URBS</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_snd_urbs</span> <span class="o">=</span> <span class="n">UDSL_DEFAULT_SND_URBS</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rcv_buf_bytes</span> <span class="o">=</span> <span class="n">UDSL_DEFAULT_RCV_BUF_SIZE</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">snd_buf_bytes</span> <span class="o">=</span> <span class="n">UDSL_DEFAULT_SND_BUF_SIZE</span><span class="p">;</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">num_rcv_urbs</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">num_rcv_urbs</span><span class="p">,</span>
		 <span class="s">&quot;Number of urbs used for reception (range: 0-&quot;</span>
		 <span class="n">__MODULE_STRING</span><span class="p">(</span><span class="n">UDSL_MAX_RCV_URBS</span><span class="p">)</span> <span class="s">&quot;, default: &quot;</span>
		 <span class="n">__MODULE_STRING</span><span class="p">(</span><span class="n">UDSL_DEFAULT_RCV_URBS</span><span class="p">)</span> <span class="s">&quot;)&quot;</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">num_snd_urbs</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">num_snd_urbs</span><span class="p">,</span>
		 <span class="s">&quot;Number of urbs used for transmission (range: 0-&quot;</span>
		 <span class="n">__MODULE_STRING</span><span class="p">(</span><span class="n">UDSL_MAX_SND_URBS</span><span class="p">)</span> <span class="s">&quot;, default: &quot;</span>
		 <span class="n">__MODULE_STRING</span><span class="p">(</span><span class="n">UDSL_DEFAULT_SND_URBS</span><span class="p">)</span> <span class="s">&quot;)&quot;</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">rcv_buf_bytes</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">rcv_buf_bytes</span><span class="p">,</span>
		 <span class="s">&quot;Size of the buffers used for reception, in bytes (range: 1-&quot;</span>
		 <span class="n">__MODULE_STRING</span><span class="p">(</span><span class="n">UDSL_MAX_BUF_SIZE</span><span class="p">)</span> <span class="s">&quot;, default: &quot;</span>
		 <span class="n">__MODULE_STRING</span><span class="p">(</span><span class="n">UDSL_DEFAULT_RCV_BUF_SIZE</span><span class="p">)</span> <span class="s">&quot;)&quot;</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">snd_buf_bytes</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">snd_buf_bytes</span><span class="p">,</span>
		 <span class="s">&quot;Size of the buffers used for transmission, in bytes (range: 1-&quot;</span>
		 <span class="n">__MODULE_STRING</span><span class="p">(</span><span class="n">UDSL_MAX_BUF_SIZE</span><span class="p">)</span> <span class="s">&quot;, default: &quot;</span>
		 <span class="n">__MODULE_STRING</span><span class="p">(</span><span class="n">UDSL_DEFAULT_SND_BUF_SIZE</span><span class="p">)</span> <span class="s">&quot;)&quot;</span><span class="p">);</span>


<span class="cm">/* receive */</span>

<span class="k">struct</span> <span class="n">usbatm_vcc_data</span> <span class="p">{</span>
	<span class="cm">/* vpi/vci lookup */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">vpi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">;</span>

	<span class="cm">/* raw cell reassembly */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">sarb</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/* send */</span>

<span class="k">struct</span> <span class="n">usbatm_control</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">atm_skb_data</span> <span class="n">atm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">crc</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define UDSL_SKB(x)		((struct usbatm_control *)(x)-&gt;cb)</span>


<span class="cm">/* ATM */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">usbatm_atm_dev_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_dev</span> <span class="o">*</span><span class="n">atm_dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">usbatm_atm_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">usbatm_atm_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">usbatm_atm_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_dev</span> <span class="o">*</span><span class="n">atm_dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">arg</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">usbatm_atm_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">usbatm_atm_proc_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_dev</span> <span class="o">*</span><span class="n">atm_dev</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">atmdev_ops</span> <span class="n">usbatm_atm_devops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">dev_close</span>	<span class="o">=</span> <span class="n">usbatm_atm_dev_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">usbatm_atm_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span>		<span class="o">=</span> <span class="n">usbatm_atm_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span>		<span class="o">=</span> <span class="n">usbatm_atm_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">send</span>		<span class="o">=</span> <span class="n">usbatm_atm_send</span><span class="p">,</span>
	<span class="p">.</span><span class="n">proc_read</span>	<span class="o">=</span> <span class="n">usbatm_atm_proc_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/***********</span>
<span class="cm">**  misc  **</span>
<span class="cm">***********/</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">usbatm_pdu_length</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">length</span> <span class="o">+=</span> <span class="n">ATM_CELL_PAYLOAD</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">ATM_AAL5_TRAILER</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">length</span> <span class="o">-</span> <span class="n">length</span> <span class="o">%</span> <span class="n">ATM_CELL_PAYLOAD</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usbatm_pop</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">pop</span><span class="p">)</span>
		<span class="n">vcc</span><span class="o">-&gt;</span><span class="n">pop</span><span class="p">(</span><span class="n">vcc</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/***********</span>
<span class="cm">**  urbs  **</span>
<span class="cm">************/</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="nf">usbatm_pop_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbatm_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">urb</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span><span class="p">,</span> <span class="n">urb_list</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">urb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbatm_submit_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbatm_channel</span> <span class="o">*</span><span class="n">channel</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">vdbg</span><span class="p">(</span><span class="s">&quot;%s: submitting urb 0x%p, size %u&quot;</span><span class="p">,</span>
	     <span class="n">__func__</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
			<span class="n">atm_warn</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">usbatm</span><span class="p">,</span> <span class="s">&quot;%s: urb 0x%p submission failed (%d)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

		<span class="cm">/* consider all errors transient and return the buffer back to the queue */</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="cm">/* must add to the front when sending; doesn&#39;t matter when receiving */</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="cm">/* make sure the channel doesn&#39;t stall */</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">delay</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">THROTTLE_MSECS</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbatm_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbatm_channel</span> <span class="o">*</span><span class="n">channel</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>

	<span class="n">vdbg</span><span class="p">(</span><span class="s">&quot;%s: urb 0x%p, status %d, actual_length %d&quot;</span><span class="p">,</span>
	     <span class="n">__func__</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>

	<span class="cm">/* usually in_interrupt(), but not always */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* must add to the back when receiving; doesn&#39;t matter when sending */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">usbatm</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UDSL_IGNORE_EILSEQ</span><span class="p">)</span> <span class="o">||</span>
			 <span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EILSEQ</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
			<span class="n">atm_warn</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">usbatm</span><span class="p">,</span> <span class="s">&quot;%s: urb 0x%p failed (%d)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="cm">/* throttle processing in case of an error */</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">delay</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">THROTTLE_MSECS</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*************</span>
<span class="cm">**  decode  **</span>
<span class="cm">*************/</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">usbatm_vcc_data</span> <span class="o">*</span><span class="nf">usbatm_find_vcc</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbatm_data</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
						  <span class="kt">short</span> <span class="n">vpi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbatm_vcc_data</span> <span class="o">*</span><span class="n">vcc_data</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vcc_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">vcc_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">vcc_data</span><span class="o">-&gt;</span><span class="n">vci</span> <span class="o">==</span> <span class="n">vci</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vcc_data</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">==</span> <span class="n">vpi</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">vcc_data</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbatm_extract_one_cell</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbatm_data</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">source</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">sarb</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">vpi</span> <span class="o">=</span> <span class="p">((</span><span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span>  <span class="o">|</span> <span class="p">(</span><span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">vci</span> <span class="o">=</span> <span class="p">((</span><span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">source</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">source</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">pti</span> <span class="o">=</span> <span class="p">((</span><span class="n">source</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xe</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">vdbg</span><span class="p">(</span><span class="s">&quot;%s: vpi %hd, vci %d, pti %d&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">vpi</span><span class="p">,</span> <span class="n">vci</span><span class="p">,</span> <span class="n">pti</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">vci</span> <span class="o">!=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">cached_vci</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">vpi</span> <span class="o">!=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">cached_vpi</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">cached_vpi</span> <span class="o">=</span> <span class="n">vpi</span><span class="p">;</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">cached_vci</span> <span class="o">=</span> <span class="n">vci</span><span class="p">;</span>

		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">cached_vcc</span> <span class="o">=</span> <span class="n">usbatm_find_vcc</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">vpi</span><span class="p">,</span> <span class="n">vci</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cached_vcc</span><span class="p">)</span>
			<span class="n">atm_rldbg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s: unknown vpi/vci (%hd/%d)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">vpi</span><span class="p">,</span> <span class="n">vci</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cached_vcc</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">vcc</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">cached_vcc</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="p">;</span>

	<span class="cm">/* OAM F5 end-to-end */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pti</span> <span class="o">==</span> <span class="n">ATM_PTI_E2EF5</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
			<span class="n">atm_warn</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s: OAM not supported (vpi %d, vci %d)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">vpi</span><span class="p">,</span> <span class="n">vci</span><span class="p">);</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_err</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sarb</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">cached_vcc</span><span class="o">-&gt;</span><span class="n">sarb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sarb</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">+</span> <span class="n">ATM_CELL_PAYLOAD</span> <span class="o">&gt;</span> <span class="n">sarb</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atm_rldbg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s: buffer overrun (sarb-&gt;len %u, vcc: 0x%p)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">sarb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">vcc</span><span class="p">);</span>
		<span class="cm">/* discard cells already received */</span>
		<span class="n">skb_trim</span><span class="p">(</span><span class="n">sarb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">UDSL_ASSERT</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">sarb</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">+</span> <span class="n">ATM_CELL_PAYLOAD</span> <span class="o">&lt;=</span> <span class="n">sarb</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">sarb</span><span class="p">),</span> <span class="n">source</span> <span class="o">+</span> <span class="n">ATM_CELL_HEADER</span><span class="p">,</span> <span class="n">ATM_CELL_PAYLOAD</span><span class="p">);</span>
	<span class="n">__skb_put</span><span class="p">(</span><span class="n">sarb</span><span class="p">,</span> <span class="n">ATM_CELL_PAYLOAD</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pti</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pdu_length</span><span class="p">;</span>

		<span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="n">source</span><span class="p">[</span><span class="n">ATM_CELL_SIZE</span> <span class="o">-</span> <span class="mi">6</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">source</span><span class="p">[</span><span class="n">ATM_CELL_SIZE</span> <span class="o">-</span> <span class="mi">5</span><span class="p">];</span>

		<span class="cm">/* guard against overflow */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">ATM_MAX_AAL5_PDU</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">atm_rldbg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s: bogus length %u (vcc: 0x%p)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">__func__</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">vcc</span><span class="p">);</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_err</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pdu_length</span> <span class="o">=</span> <span class="n">usbatm_pdu_length</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sarb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">pdu_length</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">atm_rldbg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s: bogus pdu_length %u (sarb-&gt;len: %u, vcc: 0x%p)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">__func__</span><span class="p">,</span> <span class="n">pdu_length</span><span class="p">,</span> <span class="n">sarb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">vcc</span><span class="p">);</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_err</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">crc32_be</span><span class="p">(</span><span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">sarb</span><span class="p">)</span> <span class="o">-</span> <span class="n">pdu_length</span><span class="p">,</span> <span class="n">pdu_length</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0xc704dd7b</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">atm_rldbg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s: packet failed crc check (vcc: 0x%p)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">__func__</span><span class="p">,</span> <span class="n">vcc</span><span class="p">);</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_err</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">vdbg</span><span class="p">(</span><span class="s">&quot;%s: got packet (length: %u, pdu_length: %u, vcc: 0x%p)&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">pdu_length</span><span class="p">,</span> <span class="n">vcc</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">length</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
				<span class="n">atm_err</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s: no memory for skb (length: %u)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_drop</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">vdbg</span><span class="p">(</span><span class="s">&quot;%s: allocated new sk_buff (skb: 0x%p, skb-&gt;truesize: %u)&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atm_charge</span><span class="p">(</span><span class="n">vcc</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">atm_rldbg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s: failed atm_charge (skb-&gt;truesize: %u)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">__func__</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">);</span>
			<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>	<span class="cm">/* atm_charge increments rx_drop */</span>
		<span class="p">}</span>

		<span class="n">skb_copy_to_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
					<span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">sarb</span><span class="p">)</span> <span class="o">-</span> <span class="n">pdu_length</span><span class="p">,</span>
					<span class="n">length</span><span class="p">);</span>
		<span class="n">__skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

		<span class="n">vdbg</span><span class="p">(</span><span class="s">&quot;%s: sending skb 0x%p, skb-&gt;len %u, skb-&gt;truesize %u&quot;</span><span class="p">,</span>
		     <span class="n">__func__</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">);</span>

		<span class="n">PACKETDEBUG</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

		<span class="n">vcc</span><span class="o">-&gt;</span><span class="n">push</span><span class="p">(</span><span class="n">vcc</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">);</span>
	<span class="nl">out:</span>
		<span class="n">skb_trim</span><span class="p">(</span><span class="n">sarb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbatm_extract_cells</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbatm_data</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">source</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">avail_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stride</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">.</span><span class="n">stride</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buf_usage</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">buf_usage</span><span class="p">;</span>

	<span class="cm">/* extract cells from incoming data, taking into account that</span>
<span class="cm">	 * the length of avail data may not be a multiple of stride */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf_usage</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* we have a partially received atm cell */</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cell_buf</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">cell_buf</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">space_left</span> <span class="o">=</span> <span class="n">stride</span> <span class="o">-</span> <span class="n">buf_usage</span><span class="p">;</span>

		<span class="n">UDSL_ASSERT</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">buf_usage</span> <span class="o">&lt;=</span> <span class="n">stride</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">avail_data</span> <span class="o">&gt;=</span> <span class="n">space_left</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* add new data and process cell */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">cell_buf</span> <span class="o">+</span> <span class="n">buf_usage</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">space_left</span><span class="p">);</span>
			<span class="n">source</span> <span class="o">+=</span> <span class="n">space_left</span><span class="p">;</span>
			<span class="n">avail_data</span> <span class="o">-=</span> <span class="n">space_left</span><span class="p">;</span>
			<span class="n">usbatm_extract_one_cell</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cell_buf</span><span class="p">);</span>
			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">buf_usage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* not enough data to fill the cell */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">cell_buf</span> <span class="o">+</span> <span class="n">buf_usage</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">avail_data</span><span class="p">);</span>
			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">buf_usage</span> <span class="o">=</span> <span class="n">buf_usage</span> <span class="o">+</span> <span class="n">avail_data</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">avail_data</span> <span class="o">&gt;=</span> <span class="n">stride</span><span class="p">;</span> <span class="n">avail_data</span> <span class="o">-=</span> <span class="n">stride</span><span class="p">,</span> <span class="n">source</span> <span class="o">+=</span> <span class="n">stride</span><span class="p">)</span>
		<span class="n">usbatm_extract_one_cell</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">source</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">avail_data</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* length was not a multiple of stride -</span>
<span class="cm">		 * save remaining data for next call */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cell_buf</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">avail_data</span><span class="p">);</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">buf_usage</span> <span class="o">=</span> <span class="n">avail_data</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*************</span>
<span class="cm">**  encode  **</span>
<span class="cm">*************/</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">usbatm_write_cells</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbatm_data</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				       <span class="n">u8</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">avail_space</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbatm_control</span> <span class="o">*</span><span class="n">ctrl</span> <span class="o">=</span> <span class="n">UDSL_SKB</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span> <span class="o">=</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">atm</span><span class="p">.</span><span class="n">vcc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes_written</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stride</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">.</span><span class="n">stride</span><span class="p">;</span>

	<span class="n">vdbg</span><span class="p">(</span><span class="s">&quot;%s: skb-&gt;len=%d, avail_space=%u&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">avail_space</span><span class="p">);</span>
	<span class="n">UDSL_ASSERT</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">!</span><span class="p">(</span><span class="n">avail_space</span> <span class="o">%</span> <span class="n">stride</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">bytes_written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bytes_written</span> <span class="o">&lt;</span> <span class="n">avail_space</span> <span class="o">&amp;&amp;</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	     <span class="n">bytes_written</span> <span class="o">+=</span> <span class="n">stride</span><span class="p">,</span> <span class="n">target</span> <span class="o">+=</span> <span class="n">stride</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">ATM_CELL_PAYLOAD</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">ATM_CELL_PAYLOAD</span> <span class="o">-</span> <span class="n">data_len</span><span class="p">;</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>

		<span class="n">ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vcc</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">vci</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">);</span>
		<span class="n">ptr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vcc</span><span class="o">-&gt;</span><span class="n">vci</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">ptr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">vcc</span><span class="o">-&gt;</span><span class="n">vci</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">ptr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xec</span><span class="p">;</span>
		<span class="n">ptr</span> <span class="o">+=</span> <span class="n">ATM_CELL_HEADER</span><span class="p">;</span>

		<span class="n">skb_copy_from_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">data_len</span><span class="p">);</span>
		<span class="n">ptr</span> <span class="o">+=</span> <span class="n">data_len</span><span class="p">;</span>
		<span class="n">__skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">data_len</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">left</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="n">ATM_AAL5_TRAILER</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* trailer will go in this cell */</span>
			<span class="n">u8</span> <span class="o">*</span><span class="n">trailer</span> <span class="o">=</span> <span class="n">target</span> <span class="o">+</span> <span class="n">ATM_CELL_SIZE</span> <span class="o">-</span> <span class="n">ATM_AAL5_TRAILER</span><span class="p">;</span>
			<span class="cm">/* trailer[0] = 0;		UU = 0 */</span>
			<span class="cm">/* trailer[1] = 0;		CPI = 0 */</span>
			<span class="n">trailer</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">trailer</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

			<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">crc</span> <span class="o">=</span> <span class="o">~</span><span class="n">crc32_be</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">crc</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">left</span> <span class="o">-</span> <span class="mi">4</span><span class="p">);</span>

			<span class="n">trailer</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">crc</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">;</span>
			<span class="n">trailer</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">crc</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">trailer</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">crc</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">trailer</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">crc</span><span class="p">;</span>

			<span class="n">target</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x2</span><span class="p">;</span>	<span class="cm">/* adjust PTI */</span>

			<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* tag this skb finished */</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">crc</span> <span class="o">=</span> <span class="n">crc32_be</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">crc</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">bytes_written</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**************</span>
<span class="cm">**  receive  **</span>
<span class="cm">**************/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbatm_rx_process</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbatm_data</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usbatm_data</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">urb</span> <span class="o">=</span> <span class="n">usbatm_pop_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">vdbg</span><span class="p">(</span><span class="s">&quot;%s: processing urb 0x%p&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipeisoc</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">merge_start</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">merge_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">packet_size</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">.</span><span class="n">packet_size</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">actual_length</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">actual_length</span><span class="p">;</span>

					<span class="n">UDSL_ASSERT</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">actual_length</span> <span class="o">&lt;=</span> <span class="n">packet_size</span><span class="p">);</span>

					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">merge_length</span><span class="p">)</span>
						<span class="n">merge_start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">+</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span><span class="p">;</span>
					<span class="n">merge_length</span> <span class="o">+=</span> <span class="n">actual_length</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">merge_length</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">actual_length</span> <span class="o">&lt;</span> <span class="n">packet_size</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">usbatm_extract_cells</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">merge_start</span><span class="p">,</span> <span class="n">merge_length</span><span class="p">);</span>
						<span class="n">merge_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">atm_rldbg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s: status %d in frame %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">merge_length</span><span class="p">)</span>
						<span class="n">usbatm_extract_cells</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">merge_start</span><span class="p">,</span> <span class="n">merge_length</span><span class="p">);</span>
					<span class="n">merge_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">instance</span><span class="o">-&gt;</span><span class="n">buf_usage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">merge_length</span><span class="p">)</span>
				<span class="n">usbatm_extract_cells</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">merge_start</span><span class="p">,</span> <span class="n">merge_length</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span>
				<span class="n">usbatm_extract_cells</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">instance</span><span class="o">-&gt;</span><span class="n">buf_usage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">usbatm_submit_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/***********</span>
<span class="cm">**  send  **</span>
<span class="cm">***********/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbatm_tx_process</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbatm_data</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usbatm_data</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">current_skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buf_size</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">.</span><span class="n">buf_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes_written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">sndqueue</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">urb</span> <span class="o">=</span> <span class="n">usbatm_pop_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>		<span class="cm">/* no more senders */</span>
			<span class="n">buffer</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">;</span>
			<span class="n">bytes_written</span> <span class="o">=</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="o">?</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">bytes_written</span> <span class="o">+=</span> <span class="n">usbatm_write_cells</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span>
						  <span class="n">buffer</span> <span class="o">+</span> <span class="n">bytes_written</span><span class="p">,</span>
						  <span class="n">buf_size</span> <span class="o">-</span> <span class="n">bytes_written</span><span class="p">);</span>

		<span class="n">vdbg</span><span class="p">(</span><span class="s">&quot;%s: wrote %u bytes from skb 0x%p to urb 0x%p&quot;</span><span class="p">,</span>
		     <span class="n">__func__</span><span class="p">,</span> <span class="n">bytes_written</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">UDSL_SKB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span> <span class="o">=</span> <span class="n">UDSL_SKB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">atm</span><span class="p">.</span><span class="n">vcc</span><span class="p">;</span>

			<span class="n">usbatm_pop</span><span class="p">(</span><span class="n">vcc</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">);</span>

			<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">sndqueue</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bytes_written</span> <span class="o">==</span> <span class="n">buf_size</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span> <span class="o">&amp;&amp;</span> <span class="n">bytes_written</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">=</span> <span class="n">bytes_written</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">usbatm_submit_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">current_skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbatm_cancel_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbatm_data</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">atm_dbg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s entered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">sndqueue</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">skb_queue_walk_safe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">sndqueue</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">UDSL_SKB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">atm</span><span class="p">.</span><span class="n">vcc</span> <span class="o">==</span> <span class="n">vcc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">atm_dbg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s: popping skb 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">sndqueue</span><span class="p">);</span>
			<span class="n">usbatm_pop</span><span class="p">(</span><span class="n">vcc</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">sndqueue</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">tasklet_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">.</span><span class="n">tasklet</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">current_skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">UDSL_SKB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">atm</span><span class="p">.</span><span class="n">vcc</span> <span class="o">==</span> <span class="n">vcc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">atm_dbg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s: popping current skb (0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">current_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">usbatm_pop</span><span class="p">(</span><span class="n">vcc</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">tasklet_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">.</span><span class="n">tasklet</span><span class="p">);</span>
	<span class="n">atm_dbg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbatm_atm_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbatm_data</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="n">vcc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbatm_control</span> <span class="o">*</span><span class="n">ctrl</span> <span class="o">=</span> <span class="n">UDSL_SKB</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">vdbg</span><span class="p">(</span><span class="s">&quot;%s called (skb 0x%p, len %u)&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="cm">/* racy disconnection check - fine */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span> <span class="o">||</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">disconnected</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef DEBUG</span>
		<span class="n">printk_ratelimited</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: %s!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">instance</span> <span class="o">?</span> <span class="s">&quot;disconnected&quot;</span> <span class="o">:</span> <span class="s">&quot;NULL instance&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">aal</span> <span class="o">!=</span> <span class="n">ATM_AAL5</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atm_rldbg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s: unsupported ATM type %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">vcc</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">aal</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">ATM_MAX_AAL5_PDU</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atm_rldbg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s: packet too long (%d vs %d)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">ATM_MAX_AAL5_PDU</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">PACKETDEBUG</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="cm">/* initialize the control block */</span>
	<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">atm</span><span class="p">.</span><span class="n">vcc</span> <span class="o">=</span> <span class="n">vcc</span><span class="p">;</span>
	<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">crc</span> <span class="o">=</span> <span class="n">crc32_be</span><span class="p">(</span><span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">sndqueue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">.</span><span class="n">tasklet</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">fail:</span>
	<span class="n">usbatm_pop</span><span class="p">(</span><span class="n">vcc</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/********************</span>
<span class="cm">**  bean counting  **</span>
<span class="cm">********************/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbatm_destroy_instance</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbatm_data</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usbatm_data</span><span class="p">,</span> <span class="n">refcount</span><span class="p">);</span>

	<span class="n">usb_dbg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">tasklet_kill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">.</span><span class="n">tasklet</span><span class="p">);</span>
	<span class="n">tasklet_kill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">.</span><span class="n">tasklet</span><span class="p">);</span>
	<span class="n">usb_put_dev</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">usb_dev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbatm_get_instance</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbatm_data</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">usb_dbg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbatm_put_instance</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbatm_data</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">usb_dbg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="n">usbatm_destroy_instance</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**********</span>
<span class="cm">**  ATM  **</span>
<span class="cm">**********/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbatm_atm_dev_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_dev</span> <span class="o">*</span><span class="n">atm_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbatm_data</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="n">atm_dev</span><span class="o">-&gt;</span><span class="n">dev_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">usb_dbg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">atm_dev</span><span class="o">-&gt;</span><span class="n">dev_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* catch bugs */</span>
	<span class="n">usbatm_put_instance</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>	<span class="cm">/* taken in usbatm_atm_init */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbatm_atm_proc_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_dev</span> <span class="o">*</span><span class="n">atm_dev</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbatm_data</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="n">atm_dev</span><span class="o">-&gt;</span><span class="n">dev_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">left</span><span class="o">--</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">left</span><span class="o">--</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="s">&quot;MAC: %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">atm_dev</span><span class="o">-&gt;</span><span class="n">esi</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">left</span><span class="o">--</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="p">,</span>
			       <span class="s">&quot;AAL5: tx %d ( %d err ), rx %d ( %d err, %d drop )</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atm_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">aal5</span><span class="p">.</span><span class="n">tx</span><span class="p">),</span>
			       <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atm_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">aal5</span><span class="p">.</span><span class="n">tx_err</span><span class="p">),</span>
			       <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atm_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">aal5</span><span class="p">.</span><span class="n">rx</span><span class="p">),</span>
			       <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atm_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">aal5</span><span class="p">.</span><span class="n">rx_err</span><span class="p">),</span>
			       <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atm_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">aal5</span><span class="p">.</span><span class="n">rx_drop</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">left</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">disconnected</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="s">&quot;Disconnected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">atm_dev</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">ATM_PHY_SIG_FOUND</span>:
				<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="s">&quot;Line up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">case</span> <span class="n">ATM_PHY_SIG_LOST</span>:
				<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="s">&quot;Line down</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="nl">default:</span>
				<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="s">&quot;Line state unknown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbatm_atm_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbatm_data</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="n">vcc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbatm_vcc_data</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vci</span> <span class="o">=</span> <span class="n">vcc</span><span class="o">-&gt;</span><span class="n">vci</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">vpi</span> <span class="o">=</span> <span class="n">vcc</span><span class="o">-&gt;</span><span class="n">vpi</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">atm_dbg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s: vpi %hd, vci %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">vpi</span><span class="p">,</span> <span class="n">vci</span><span class="p">);</span>

	<span class="cm">/* only support AAL5 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">aal</span> <span class="o">!=</span> <span class="n">ATM_AAL5</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">atm_warn</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s: unsupported ATM type %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">vcc</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">aal</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* sanity checks */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">rxtp</span><span class="p">.</span><span class="n">max_sdu</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">rxtp</span><span class="p">.</span><span class="n">max_sdu</span> <span class="o">&gt;</span> <span class="n">ATM_MAX_AAL5_PDU</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">atm_dbg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s: max_sdu %d out of range!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">vcc</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">rxtp</span><span class="p">.</span><span class="n">max_sdu</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">serialize</span><span class="p">);</span>	<span class="cm">/* vs self, usbatm_atm_close, usbatm_usb_disconnect */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">disconnected</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atm_dbg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s: disconnected!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usbatm_find_vcc</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">vpi</span><span class="p">,</span> <span class="n">vci</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">atm_dbg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s: %hd/%d already in use!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">vpi</span><span class="p">,</span> <span class="n">vci</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EADDRINUSE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">new</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbatm_vcc_data</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">atm_err</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s: no memory for vcc_data!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">new</span><span class="o">-&gt;</span><span class="n">vcc</span> <span class="o">=</span> <span class="n">vcc</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">=</span> <span class="n">vpi</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">vci</span> <span class="o">=</span> <span class="n">vci</span><span class="p">;</span>

	<span class="n">new</span><span class="o">-&gt;</span><span class="n">sarb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">usbatm_pdu_length</span><span class="p">(</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">rxtp</span><span class="p">.</span><span class="n">max_sdu</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">sarb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atm_err</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s: no memory for SAR buffer!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vcc</span><span class="o">-&gt;</span><span class="n">dev_data</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>

	<span class="n">tasklet_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">.</span><span class="n">tasklet</span><span class="p">);</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">cached_vcc</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">cached_vpi</span> <span class="o">=</span> <span class="n">vpi</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">cached_vci</span> <span class="o">=</span> <span class="n">vci</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">vcc_list</span><span class="p">);</span>
	<span class="n">tasklet_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">.</span><span class="n">tasklet</span><span class="p">);</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">ATM_VF_ADDR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">ATM_VF_PARTIAL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">ATM_VF_READY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">serialize</span><span class="p">);</span>

	<span class="n">atm_dbg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s: allocated vcc data 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">serialize</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbatm_atm_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbatm_data</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="n">vcc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbatm_vcc_data</span> <span class="o">*</span><span class="n">vcc_data</span> <span class="o">=</span> <span class="n">vcc</span><span class="o">-&gt;</span><span class="n">dev_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span> <span class="o">||</span> <span class="o">!</span><span class="n">vcc_data</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">atm_dbg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s entered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">atm_dbg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s: deallocating vcc 0x%p with vpi %d vci %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">vcc_data</span><span class="p">,</span> <span class="n">vcc_data</span><span class="o">-&gt;</span><span class="n">vpi</span><span class="p">,</span> <span class="n">vcc_data</span><span class="o">-&gt;</span><span class="n">vci</span><span class="p">);</span>

	<span class="n">usbatm_cancel_send</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">vcc</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">serialize</span><span class="p">);</span>	<span class="cm">/* vs self, usbatm_atm_open, usbatm_usb_disconnect */</span>

	<span class="n">tasklet_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">.</span><span class="n">tasklet</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cached_vcc</span> <span class="o">==</span> <span class="n">vcc_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">cached_vcc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">cached_vpi</span> <span class="o">=</span> <span class="n">ATM_VPI_UNSPEC</span><span class="p">;</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">cached_vci</span> <span class="o">=</span> <span class="n">ATM_VCI_UNSPEC</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcc_data</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">tasklet_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">.</span><span class="n">tasklet</span><span class="p">);</span>

	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">vcc_data</span><span class="o">-&gt;</span><span class="n">sarb</span><span class="p">);</span>
	<span class="n">vcc_data</span><span class="o">-&gt;</span><span class="n">sarb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">vcc_data</span><span class="p">);</span>
	<span class="n">vcc</span><span class="o">-&gt;</span><span class="n">dev_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">vcc</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">=</span> <span class="n">ATM_VPI_UNSPEC</span><span class="p">;</span>
	<span class="n">vcc</span><span class="o">-&gt;</span><span class="n">vci</span> <span class="o">=</span> <span class="n">ATM_VCI_UNSPEC</span><span class="p">;</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">ATM_VF_READY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">ATM_VF_PARTIAL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">ATM_VF_ADDR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">serialize</span><span class="p">);</span>

	<span class="n">atm_dbg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s successful</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbatm_atm_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_dev</span> <span class="o">*</span><span class="n">atm_dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			  <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbatm_data</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="n">atm_dev</span><span class="o">-&gt;</span><span class="n">dev_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span> <span class="o">||</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">disconnected</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ATM_QUERYLOOP</span>:
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">ATM_LM_NONE</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbatm_atm_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbatm_data</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atm_dev</span> <span class="o">*</span><span class="n">atm_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* ATM init.  The ATM initialization scheme suffers from an intrinsic race</span>
<span class="cm">	 * condition: callbacks we register can be executed at once, before we have</span>
<span class="cm">	 * initialized the struct atm_dev.  To protect against this, all callbacks</span>
<span class="cm">	 * abort if atm_dev-&gt;dev_data is NULL. */</span>
	<span class="n">atm_dev</span> <span class="o">=</span> <span class="n">atm_dev_register</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">driver_name</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">usb_intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usbatm_atm_devops</span><span class="p">,</span>
				   <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atm_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_err</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s: failed to register ATM device!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">atm_dev</span> <span class="o">=</span> <span class="n">atm_dev</span><span class="p">;</span>

	<span class="n">atm_dev</span><span class="o">-&gt;</span><span class="n">ci_range</span><span class="p">.</span><span class="n">vpi_bits</span> <span class="o">=</span> <span class="n">ATM_CI_MAX</span><span class="p">;</span>
	<span class="n">atm_dev</span><span class="o">-&gt;</span><span class="n">ci_range</span><span class="p">.</span><span class="n">vci_bits</span> <span class="o">=</span> <span class="n">ATM_CI_MAX</span><span class="p">;</span>
	<span class="n">atm_dev</span><span class="o">-&gt;</span><span class="n">signal</span> <span class="o">=</span> <span class="n">ATM_PHY_SIG_UNKNOWN</span><span class="p">;</span>

	<span class="cm">/* temp init ATM device, set to 128kbit */</span>
	<span class="n">atm_dev</span><span class="o">-&gt;</span><span class="n">link_rate</span> <span class="o">=</span> <span class="mi">128</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">/</span> <span class="mi">424</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">atm_start</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">atm_start</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">atm_dev</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">atm_err</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s: atm_start failed: %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">usbatm_get_instance</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>	<span class="cm">/* dropped in usbatm_atm_dev_close */</span>

	<span class="cm">/* ready for ATM callbacks */</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="n">atm_dev</span><span class="o">-&gt;</span><span class="n">dev_data</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>

	<span class="cm">/* submit all rx URBs */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_rcv_urbs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">usbatm_submit_urb</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">fail:</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">atm_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">atm_dev_deregister</span><span class="p">(</span><span class="n">atm_dev</span><span class="p">);</span> <span class="cm">/* usbatm_atm_dev_close will eventually be called */</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**********</span>
<span class="cm">**  USB  **</span>
<span class="cm">**********/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbatm_do_heavy_init</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbatm_data</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">allow_signal</span><span class="p">(</span><span class="n">SIGTERM</span><span class="p">);</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">thread_started</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">heavy_init</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">usb_intf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">usbatm_atm_init</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">serialize</span><span class="p">);</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">serialize</span><span class="p">);</span>

	<span class="n">complete_and_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">thread_exited</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbatm_heavy_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbatm_data</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">=</span> <span class="n">kthread_create</span><span class="p">(</span><span class="n">usbatm_do_heavy_init</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span>
			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">usb_err</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&quot;%s: failed to create kernel_thread (%ld)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">wake_up_process</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">thread_started</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbatm_tasklet_schedule</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tasklet_schedule</span><span class="p">((</span><span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbatm_init_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbatm_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">channel</span><span class="o">-&gt;</span><span class="n">delay</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">usbatm_tasklet_schedule</span><span class="p">;</span>
	<span class="n">channel</span><span class="o">-&gt;</span><span class="n">delay</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">;</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">delay</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">usbatm_usb_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">usbatm_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbatm_data</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxpacket</span><span class="p">,</span> <span class="n">num_packets</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: trying driver %s with vendor=%04x, product=%04x, ifnum %2d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver_name</span><span class="p">,</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idVendor</span><span class="p">),</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idProduct</span><span class="p">),</span>
			<span class="n">intf</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">);</span>

	<span class="cm">/* instance init */</span>
	<span class="n">instance</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">instance</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_rcv_urbs</span> <span class="o">+</span> <span class="n">num_snd_urbs</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: no memory for instance data!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* public fields */</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="n">driver</span><span class="p">;</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">driver_name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">driver_name</span><span class="p">),</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver_name</span><span class="p">);</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">usb_dev</span> <span class="o">=</span> <span class="n">usb_dev</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">usb_intf</span> <span class="o">=</span> <span class="n">intf</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">=</span> <span class="n">usb_string</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">,</span> <span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">iProduct</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">length</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bind</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">-=</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="s">&quot; (&quot;</span><span class="p">);</span>
	<span class="n">buf</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">-=</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">usb_make_path</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">length</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bind</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">-=</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="s">&quot;)&quot;</span><span class="p">);</span>

 <span class="nl">bind:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">bind</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">bind</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">intf</span><span class="p">,</span> <span class="n">id</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: bind failed: %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* private fields */</span>

	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>		<span class="cm">/* dropped in usbatm_usb_disconnect */</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">serialize</span><span class="p">);</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">thread_started</span><span class="p">);</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">thread_exited</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">vcc_list</span><span class="p">);</span>
	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">sndqueue</span><span class="p">);</span>

	<span class="n">usbatm_init_channel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">);</span>
	<span class="n">usbatm_init_channel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">);</span>
	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">.</span><span class="n">tasklet</span><span class="p">,</span> <span class="n">usbatm_rx_process</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">instance</span><span class="p">);</span>
	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">.</span><span class="n">tasklet</span><span class="p">,</span> <span class="n">usbatm_tx_process</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">instance</span><span class="p">);</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">.</span><span class="n">stride</span> <span class="o">=</span> <span class="n">ATM_CELL_SIZE</span> <span class="o">+</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">rx_padding</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">.</span><span class="n">stride</span> <span class="o">=</span> <span class="n">ATM_CELL_SIZE</span> <span class="o">+</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">tx_padding</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">.</span><span class="n">usbatm</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">.</span><span class="n">usbatm</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UDSL_USE_ISOC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">isoc_in</span><span class="p">)</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">.</span><span class="n">endpoint</span> <span class="o">=</span> <span class="n">usb_rcvisocpipe</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">isoc_in</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">.</span><span class="n">endpoint</span> <span class="o">=</span> <span class="n">usb_rcvbulkpipe</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">);</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">.</span><span class="n">endpoint</span> <span class="o">=</span> <span class="n">usb_sndbulkpipe</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">bulk_out</span><span class="p">);</span>

	<span class="cm">/* tx buffer size must be a positive multiple of the stride */</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">.</span><span class="n">buf_size</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">.</span><span class="n">stride</span><span class="p">,</span>
			<span class="n">snd_buf_bytes</span> <span class="o">-</span> <span class="p">(</span><span class="n">snd_buf_bytes</span> <span class="o">%</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">.</span><span class="n">stride</span><span class="p">));</span>

	<span class="cm">/* rx buffer size must be a positive multiple of the endpoint maxpacket */</span>
	<span class="n">maxpacket</span> <span class="o">=</span> <span class="n">usb_maxpacket</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">.</span><span class="n">endpoint</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">maxpacket</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">maxpacket</span> <span class="o">&gt;</span> <span class="n">UDSL_MAX_BUF_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: invalid endpoint %02x!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">.</span><span class="n">endpoint</span><span class="p">));</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_unbind</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">num_packets</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">1U</span><span class="p">,</span> <span class="p">(</span><span class="n">rcv_buf_bytes</span> <span class="o">+</span> <span class="n">maxpacket</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">maxpacket</span><span class="p">);</span> <span class="cm">/* round */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_packets</span> <span class="o">*</span> <span class="n">maxpacket</span> <span class="o">&gt;</span> <span class="n">UDSL_MAX_BUF_SIZE</span><span class="p">)</span>
		<span class="n">num_packets</span><span class="o">--</span><span class="p">;</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">.</span><span class="n">buf_size</span> <span class="o">=</span> <span class="n">num_packets</span> <span class="o">*</span> <span class="n">maxpacket</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">.</span><span class="n">packet_size</span> <span class="o">=</span> <span class="n">maxpacket</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usbatm_channel</span> <span class="o">*</span><span class="n">channel</span> <span class="o">=</span> <span class="n">i</span> <span class="o">?</span>
			<span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">tx_channel</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: using %d byte buffer for %s channel 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">buf_size</span><span class="p">,</span> <span class="n">i</span> <span class="o">?</span> <span class="s">&quot;tx&quot;</span> <span class="o">:</span> <span class="s">&quot;rx&quot;</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* initialize urbs */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_rcv_urbs</span> <span class="o">+</span> <span class="n">num_snd_urbs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">usbatm_channel</span> <span class="o">*</span><span class="n">channel</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_rcv_urbs</span> <span class="o">?</span>
			<span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">rx_channel</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">iso_packets</span> <span class="o">=</span> <span class="n">usb_pipeisoc</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">)</span> <span class="o">?</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">buf_size</span> <span class="o">/</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">packet_size</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">UDSL_ASSERT</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">!</span><span class="n">usb_pipeisoc</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">)</span> <span class="o">||</span> <span class="n">usb_pipein</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">));</span>

		<span class="n">urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="n">iso_packets</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: no memory for urb %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail_unbind</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>

		<span class="cm">/* zero the tx padding to avoid leaking information */</span>
		<span class="n">buffer</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">buf_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: no memory for buffer %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail_unbind</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">usb_dev</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">,</span>
				  <span class="n">buffer</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">buf_size</span><span class="p">,</span> <span class="n">usbatm_complete</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iso_packets</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">=</span> <span class="n">URB_ISO_ASAP</span><span class="p">;</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span> <span class="o">=</span> <span class="n">iso_packets</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">iso_packets</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">packet_size</span> <span class="o">*</span> <span class="n">j</span><span class="p">;</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">packet_size</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* put all tx URBs on the list of spares */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">num_rcv_urbs</span><span class="p">)</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

		<span class="n">vdbg</span><span class="p">(</span><span class="s">&quot;%s: alloced buffer 0x%p buf size %u urb 0x%p&quot;</span><span class="p">,</span>
		     <span class="n">__func__</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">cached_vpi</span> <span class="o">=</span> <span class="n">ATM_VPI_UNSPEC</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">cached_vci</span> <span class="o">=</span> <span class="n">ATM_VCI_UNSPEC</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">cell_buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">.</span><span class="n">stride</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cell_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: no memory for cell buffer!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_unbind</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UDSL_SKIP_HEAVY_INIT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">heavy_init</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">usbatm_heavy_init</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">thread_exited</span><span class="p">);</span>	<span class="cm">/* pretend that heavy_init was run */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">usbatm_atm_init</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_unbind</span><span class="p">;</span>

	<span class="n">usb_get_dev</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">);</span>
	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">instance</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">fail_unbind:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">unbind</span><span class="p">)</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">unbind</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">intf</span><span class="p">);</span>
 <span class="nl">fail_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cell_buf</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_rcv_urbs</span> <span class="o">+</span> <span class="n">num_snd_urbs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">);</span>
		<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usbatm_usb_probe</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">usbatm_usb_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbatm_data</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbatm_vcc_data</span> <span class="o">*</span><span class="n">vcc_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s entered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: NULL instance!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">serialize</span><span class="p">);</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">disconnected</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">send_sig</span><span class="p">(</span><span class="n">SIGTERM</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">serialize</span><span class="p">);</span>

	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">thread_exited</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">serialize</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vcc_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">vcc_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">vcc_release_async</span><span class="p">(</span><span class="n">vcc_data</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="p">,</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">serialize</span><span class="p">);</span>

	<span class="n">tasklet_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">.</span><span class="n">tasklet</span><span class="p">);</span>
	<span class="n">tasklet_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">.</span><span class="n">tasklet</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_rcv_urbs</span> <span class="o">+</span> <span class="n">num_snd_urbs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">.</span><span class="n">delay</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">.</span><span class="n">delay</span><span class="p">);</span>

	<span class="cm">/* turn usbatm_[rt]x_process into something close to a no-op */</span>
	<span class="cm">/* no need to take the spinlock */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>

	<span class="n">tasklet_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">.</span><span class="n">tasklet</span><span class="p">);</span>
	<span class="n">tasklet_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">.</span><span class="n">tasklet</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">atm_dev</span> <span class="o">&amp;&amp;</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">atm_stop</span><span class="p">)</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">atm_stop</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">atm_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">unbind</span><span class="p">)</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">unbind</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">intf</span><span class="p">);</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_rcv_urbs</span> <span class="o">+</span> <span class="n">num_snd_urbs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">);</span>
		<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cell_buf</span><span class="p">);</span>

	<span class="cm">/* ATM finalize */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">atm_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atm_dev_deregister</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">atm_dev</span><span class="p">);</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">atm_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">usbatm_put_instance</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>	<span class="cm">/* taken in usbatm_usb_probe */</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usbatm_usb_disconnect</span><span class="p">);</span>


<span class="cm">/***********</span>
<span class="cm">**  init  **</span>
<span class="cm">***********/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">usbatm_usb_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbatm_control</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">FIELD_SIZEOF</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">cb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s unusable with this kernel!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usbatm_driver_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">num_rcv_urbs</span> <span class="o">&gt;</span> <span class="n">UDSL_MAX_RCV_URBS</span><span class="p">)</span>
	    <span class="o">||</span> <span class="p">(</span><span class="n">num_snd_urbs</span> <span class="o">&gt;</span> <span class="n">UDSL_MAX_SND_URBS</span><span class="p">)</span>
	    <span class="o">||</span> <span class="p">(</span><span class="n">rcv_buf_bytes</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
	    <span class="o">||</span> <span class="p">(</span><span class="n">rcv_buf_bytes</span> <span class="o">&gt;</span> <span class="n">UDSL_MAX_BUF_SIZE</span><span class="p">)</span>
	    <span class="o">||</span> <span class="p">(</span><span class="n">snd_buf_bytes</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
	    <span class="o">||</span> <span class="p">(</span><span class="n">snd_buf_bytes</span> <span class="o">&gt;</span> <span class="n">UDSL_MAX_BUF_SIZE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">usbatm_usb_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">usbatm_usb_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">usbatm_usb_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="n">DRIVER_AUTHOR</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">DRIVER_DESC</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">DRIVER_VERSION</span><span class="p">);</span>

<span class="cm">/************</span>
<span class="cm">**  debug  **</span>
<span class="cm">************/</span>

<span class="cp">#ifdef VERBOSE_DEBUG</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbatm_print_packet</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;)</span> <span class="p">{</span>
		<span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;%.3d :&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;%s %2.2x&quot;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">dbg</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
