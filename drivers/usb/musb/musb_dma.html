<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › musb › musb_dma.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>musb_dma.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * MUSB OTG driver DMA controller abstraction</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2005 Mentor Graphics Corporation</span>
<span class="cm"> * Copyright (C) 2005-2006 by Texas Instruments</span>
<span class="cm"> * Copyright (C) 2006-2007 Nokia Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * version 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301 USA</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED</span>
<span class="cm"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN</span>
<span class="cm"> * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
<span class="cm"> * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</span>
<span class="cm"> * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF</span>
<span class="cm"> * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON</span>
<span class="cm"> * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</span>
<span class="cm"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __MUSB_DMA_H__</span>
<span class="cp">#define __MUSB_DMA_H__</span>

<span class="k">struct</span> <span class="n">musb_hw_ep</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * DMA Controller Abstraction</span>
<span class="cm"> *</span>
<span class="cm"> * DMA Controllers are abstracted to allow use of a variety of different</span>
<span class="cm"> * implementations of DMA, as allowed by the Inventra USB cores.  On the</span>
<span class="cm"> * host side, usbcore sets up the DMA mappings and flushes caches; on the</span>
<span class="cm"> * peripheral side, the gadget controller driver does.  Responsibilities</span>
<span class="cm"> * of a DMA controller driver include:</span>
<span class="cm"> *</span>
<span class="cm"> *  - Handling the details of moving multiple USB packets</span>
<span class="cm"> *    in cooperation with the Inventra USB core, including especially</span>
<span class="cm"> *    the correct RX side treatment of short packets and buffer-full</span>
<span class="cm"> *    states (both of which terminate transfers).</span>
<span class="cm"> *</span>
<span class="cm"> *  - Knowing the correlation between dma channels and the</span>
<span class="cm"> *    Inventra core&#39;s local endpoint resources and data direction.</span>
<span class="cm"> *</span>
<span class="cm"> *  - Maintaining a list of allocated/available channels.</span>
<span class="cm"> *</span>
<span class="cm"> *  - Updating channel status on interrupts,</span>
<span class="cm"> *    whether shared with the Inventra core or separate.</span>
<span class="cm"> */</span>

<span class="cp">#define	DMA_ADDR_INVALID	(~(dma_addr_t)0)</span>

<span class="cp">#ifndef CONFIG_MUSB_PIO_ONLY</span>
<span class="cp">#define	is_dma_capable()	(1)</span>
<span class="cp">#else</span>
<span class="cp">#define	is_dma_capable()	(0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_USB_TI_CPPI_DMA</span>
<span class="cp">#define	is_cppi_enabled()	1</span>
<span class="cp">#else</span>
<span class="cp">#define	is_cppi_enabled()	0</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_USB_TUSB_OMAP_DMA</span>
<span class="cp">#define tusb_dma_omap()			1</span>
<span class="cp">#else</span>
<span class="cp">#define tusb_dma_omap()			0</span>
<span class="cp">#endif</span>

<span class="cm">/* Anomaly 05000456 - USB Receive Interrupt Is Not Generated in DMA Mode 1</span>
<span class="cm"> *	Only allow DMA mode 1 to be used when the USB will actually generate the</span>
<span class="cm"> *	interrupts we expect.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_BLACKFIN</span>
<span class="cp"># undef USE_MODE1</span>
<span class="cp"># if !ANOMALY_05000456</span>
<span class="cp">#  define USE_MODE1</span>
<span class="cp"># endif</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * DMA channel status ... updated by the dma controller driver whenever that</span>
<span class="cm"> * status changes, and protected by the overall controller spinlock.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">dma_channel_status</span> <span class="p">{</span>
	<span class="cm">/* unallocated */</span>
	<span class="n">MUSB_DMA_STATUS_UNKNOWN</span><span class="p">,</span>
	<span class="cm">/* allocated ... but not busy, no errors */</span>
	<span class="n">MUSB_DMA_STATUS_FREE</span><span class="p">,</span>
	<span class="cm">/* busy ... transactions are active */</span>
	<span class="n">MUSB_DMA_STATUS_BUSY</span><span class="p">,</span>
	<span class="cm">/* transaction(s) aborted due to ... dma or memory bus error */</span>
	<span class="n">MUSB_DMA_STATUS_BUS_ABORT</span><span class="p">,</span>
	<span class="cm">/* transaction(s) aborted due to ... core error or USB fault */</span>
	<span class="n">MUSB_DMA_STATUS_CORE_ABORT</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dma_controller</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct dma_channel - A DMA channel.</span>
<span class="cm"> * @private_data: channel-private data</span>
<span class="cm"> * @max_len: the maximum number of bytes the channel can move in one</span>
<span class="cm"> *	transaction (typically representing many USB maximum-sized packets)</span>
<span class="cm"> * @actual_len: how many bytes have been transferred</span>
<span class="cm"> * @status: current channel status (updated e.g. on interrupt)</span>
<span class="cm"> * @desired_mode: true if mode 1 is desired; false if mode 0 is desired</span>
<span class="cm"> *</span>
<span class="cm"> * channels are associated with an endpoint for the duration of at least</span>
<span class="cm"> * one usb transfer.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dma_channel</span> <span class="p">{</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">private_data</span><span class="p">;</span>
	<span class="cm">/* FIXME not void* private_data, but a dma_controller * */</span>
	<span class="kt">size_t</span>			<span class="n">max_len</span><span class="p">;</span>
	<span class="kt">size_t</span>			<span class="n">actual_len</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">dma_channel_status</span>	<span class="n">status</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">desired_mode</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * dma_channel_status - return status of dma channel</span>
<span class="cm"> * @c: the channel</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the software&#39;s view of the channel status.  If that status is BUSY</span>
<span class="cm"> * then it&#39;s possible that the hardware has completed (or aborted) a transfer,</span>
<span class="cm"> * so the driver needs to update that status.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">dma_channel_status</span>
<span class="nf">dma_channel_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">is_dma_capable</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="o">?</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">:</span> <span class="n">MUSB_DMA_STATUS_UNKNOWN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * struct dma_controller - A DMA Controller.</span>
<span class="cm"> * @start: call this to start a DMA controller;</span>
<span class="cm"> *	return 0 on success, else negative errno</span>
<span class="cm"> * @stop: call this to stop a DMA controller</span>
<span class="cm"> *	return 0 on success, else negative errno</span>
<span class="cm"> * @channel_alloc: call this to allocate a DMA channel</span>
<span class="cm"> * @channel_release: call this to release a DMA channel</span>
<span class="cm"> * @channel_abort: call this to abort a pending DMA transaction,</span>
<span class="cm"> *	returning it to FREE (but allocated) state</span>
<span class="cm"> *</span>
<span class="cm"> * Controllers manage dma channels.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dma_controller</span> <span class="p">{</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">start</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dma_controller</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">stop</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dma_controller</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dma_channel</span>	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">channel_alloc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dma_controller</span> <span class="o">*</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">musb_hw_ep</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="n">is_tx</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">channel_release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dma_channel</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">channel_program</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dma_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
							<span class="n">u16</span> <span class="n">maxpacket</span><span class="p">,</span> <span class="n">u8</span> <span class="n">mode</span><span class="p">,</span>
							<span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">,</span>
							<span class="n">u32</span> <span class="n">length</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">channel_abort</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dma_channel</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">is_compatible</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dma_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
							<span class="n">u16</span> <span class="n">maxpacket</span><span class="p">,</span>
							<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u32</span> <span class="n">length</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* called after channel_program(), may indicate a fault */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">musb_dma_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">musb</span> <span class="o">*</span><span class="n">musb</span><span class="p">,</span> <span class="n">u8</span> <span class="n">epnum</span><span class="p">,</span> <span class="n">u8</span> <span class="n">transmit</span><span class="p">);</span>


<span class="k">extern</span> <span class="k">struct</span> <span class="n">dma_controller</span> <span class="o">*</span><span class="n">__init</span>
<span class="n">dma_controller_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">musb</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">dma_controller_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_controller</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#endif	</span><span class="cm">/* __MUSB_DMA_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
