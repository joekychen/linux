<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › musb › cppi_dma.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>cppi_dma.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2005-2006 by Texas Instruments</span>
<span class="cm"> *</span>
<span class="cm"> * This file implements a DMA  interface using TI&#39;s CPPI DMA.</span>
<span class="cm"> * For now it&#39;s DaVinci-only, but CPPI isn&#39;t specific to DaVinci or USB.</span>
<span class="cm"> * The TUSB6020, using VLYNQ, has CPPI that looks much like DaVinci.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>

<span class="cp">#include &quot;musb_core.h&quot;</span>
<span class="cp">#include &quot;musb_debug.h&quot;</span>
<span class="cp">#include &quot;cppi_dma.h&quot;</span>


<span class="cm">/* CPPI DMA status 7-mar-2006:</span>
<span class="cm"> *</span>
<span class="cm"> * - See musb_{host,gadget}.c for more info</span>
<span class="cm"> *</span>
<span class="cm"> * - Correct RX DMA generally forces the engine into irq-per-packet mode,</span>
<span class="cm"> *   which can easily saturate the CPU under non-mass-storage loads.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTES 24-aug-2006 (2.6.18-rc4):</span>
<span class="cm"> *</span>
<span class="cm"> * - peripheral RXDMA wedged in a test with packets of length 512/512/1.</span>
<span class="cm"> *   evidently after the 1 byte packet was received and acked, the queue</span>
<span class="cm"> *   of BDs got garbaged so it wouldn&#39;t empty the fifo.  (rxcsr 0x2003,</span>
<span class="cm"> *   and RX DMA0: 4 left, 80000000 8feff880, 8feff860 8feff860; 8f321401</span>
<span class="cm"> *   004001ff 00000001 .. 8feff860)  Host was just getting NAKed on tx</span>
<span class="cm"> *   of its next (512 byte) packet.  IRQ issues?</span>
<span class="cm"> *</span>
<span class="cm"> * REVISIT:  the &quot;transfer DMA&quot; glue between CPPI and USB fifos will</span>
<span class="cm"> * evidently also directly update the RX and TX CSRs ... so audit all</span>
<span class="cm"> * host and peripheral side DMA code to avoid CSR access after DMA has</span>
<span class="cm"> * been started.</span>
<span class="cm"> */</span>

<span class="cm">/* REVISIT now we can avoid preallocating these descriptors; or</span>
<span class="cm"> * more simply, switch to a global freelist not per-channel ones.</span>
<span class="cm"> * Note: at full speed, 64 descriptors == 4K bulk data.</span>
<span class="cm"> */</span>
<span class="cp">#define NUM_TXCHAN_BD       64</span>
<span class="cp">#define NUM_RXCHAN_BD       64</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cpu_drain_writebuffer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wmb</span><span class="p">();</span>
<span class="cp">#ifdef	CONFIG_CPU_ARM926T</span>
	<span class="cm">/* REVISIT this &quot;should not be needed&quot;,</span>
<span class="cm">	 * but lack of it sure seemed to hurt ...</span>
<span class="cm">	 */</span>
	<span class="n">asm</span><span class="p">(</span><span class="s">&quot;mcr p15, 0, r0, c7, c10, 4 @ drain write buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cppi_descriptor</span> <span class="o">*</span><span class="nf">cppi_bd_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">cppi_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cppi_descriptor</span>	<span class="o">*</span><span class="n">bd</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bd</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">bd</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">cppi_bd_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">cppi_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cppi_descriptor</span> <span class="o">*</span><span class="n">bd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bd</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">bd</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">bd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Start DMA controller</span>
<span class="cm"> *</span>
<span class="cm"> *  Initialize the DMA controller as necessary.</span>
<span class="cm"> */</span>

<span class="cm">/* zero out entire rx state RAM entry for the channel */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cppi_reset_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">cppi_rx_stateram</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">rx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">rx_skipbytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">rx_head</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">rx_sop</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">rx_current</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">rx_buf_current</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">rx_len_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">rx_cnt_cnt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* zero out entire tx state RAM entry for the channel */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cppi_reset_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">cppi_tx_stateram</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">tx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">tx_head</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">tx_current</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">tx_buf_current</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">tx_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">tx_rem_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* musb_writel(&amp;tx-&gt;tx_dummy, 0, 0); */</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">tx_complete</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">cppi_pool_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">cppi</span> <span class="o">*</span><span class="n">cppi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cppi_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">j</span><span class="p">;</span>

	<span class="cm">/* initialize channel fields */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">last_processed</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">MUSB_DMA_STATUS_UNKNOWN</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">controller</span> <span class="o">=</span> <span class="n">cppi</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">is_rndis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">freelist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* build the BD Free list for the channel */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">NUM_TXCHAN_BD</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cppi_descriptor</span>	<span class="o">*</span><span class="n">bd</span><span class="p">;</span>
		<span class="n">dma_addr_t</span>		<span class="n">dma</span><span class="p">;</span>

		<span class="n">bd</span> <span class="o">=</span> <span class="n">dma_pool_alloc</span><span class="p">(</span><span class="n">cppi</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma</span><span class="p">);</span>
		<span class="n">bd</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma</span><span class="p">;</span>
		<span class="n">cppi_bd_free</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">bd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">cppi_channel_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_channel</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cppi_pool_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">cppi_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cppi</span>		<span class="o">*</span><span class="n">cppi</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cppi_descriptor</span>	<span class="o">*</span><span class="n">bd</span><span class="p">;</span>

	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">cppi_channel_abort</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">MUSB_DMA_STATUS_UNKNOWN</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">controller</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* free all its bds */</span>
	<span class="n">bd</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">last_processed</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bd</span><span class="p">)</span>
			<span class="n">dma_pool_free</span><span class="p">(</span><span class="n">cppi</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">,</span> <span class="n">bd</span><span class="p">,</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
		<span class="n">bd</span> <span class="o">=</span> <span class="n">cppi_bd_alloc</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bd</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">last_processed</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">cppi_controller_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cppi</span>	<span class="o">*</span><span class="n">controller</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">tibase</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>

	<span class="n">controller</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cppi</span><span class="p">,</span> <span class="n">controller</span><span class="p">);</span>

	<span class="cm">/* do whatever is necessary to start controller */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">controller</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">transmit</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">controller</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">controller</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">transmit</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">controller</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* setup BD list on a per channel basis */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cppi_pool_init</span><span class="p">(</span><span class="n">controller</span><span class="p">,</span> <span class="n">controller</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cppi_pool_init</span><span class="p">(</span><span class="n">controller</span><span class="p">,</span> <span class="n">controller</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">tibase</span> <span class="o">=</span>  <span class="n">controller</span><span class="o">-&gt;</span><span class="n">tibase</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">tx_complete</span><span class="p">);</span>

	<span class="cm">/* initialise tx/rx channel head pointers to zero */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cppi_channel</span>	<span class="o">*</span><span class="n">tx_ch</span> <span class="o">=</span> <span class="n">controller</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cppi_tx_stateram</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">tx</span><span class="p">;</span>

		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_ch</span><span class="o">-&gt;</span><span class="n">tx_complete</span><span class="p">);</span>

		<span class="n">tx</span> <span class="o">=</span> <span class="n">tibase</span> <span class="o">+</span> <span class="n">DAVINCI_TXCPPI_STATERAM_OFFSET</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="n">tx_ch</span><span class="o">-&gt;</span><span class="n">state_ram</span> <span class="o">=</span> <span class="n">tx</span><span class="p">;</span>
		<span class="n">cppi_reset_tx</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cppi_channel</span>	<span class="o">*</span><span class="n">rx_ch</span> <span class="o">=</span> <span class="n">controller</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cppi_rx_stateram</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">rx</span><span class="p">;</span>

		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx_ch</span><span class="o">-&gt;</span><span class="n">tx_complete</span><span class="p">);</span>

		<span class="n">rx</span> <span class="o">=</span> <span class="n">tibase</span> <span class="o">+</span> <span class="n">DAVINCI_RXCPPI_STATERAM_OFFSET</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="n">rx_ch</span><span class="o">-&gt;</span><span class="n">state_ram</span> <span class="o">=</span> <span class="n">rx</span><span class="p">;</span>
		<span class="n">cppi_reset_rx</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* enable individual cppi channels */</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">DAVINCI_TXCPPI_INTENAB_REG</span><span class="p">,</span>
			<span class="n">DAVINCI_DMA_ALL_CHANNELS_ENABLE</span><span class="p">);</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">DAVINCI_RXCPPI_INTENAB_REG</span><span class="p">,</span>
			<span class="n">DAVINCI_DMA_ALL_CHANNELS_ENABLE</span><span class="p">);</span>

	<span class="cm">/* enable tx/rx CPPI control */</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">DAVINCI_TXCPPI_CTRL_REG</span><span class="p">,</span> <span class="n">DAVINCI_DMA_CTRL_ENABLE</span><span class="p">);</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">DAVINCI_RXCPPI_CTRL_REG</span><span class="p">,</span> <span class="n">DAVINCI_DMA_CTRL_ENABLE</span><span class="p">);</span>

	<span class="cm">/* disable RNDIS mode, also host rx RNDIS autorequest */</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">DAVINCI_RNDIS_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">DAVINCI_AUTOREQ_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Stop DMA controller</span>
<span class="cm"> *</span>
<span class="cm"> *  De-Init the DMA controller as necessary.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cppi_controller_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cppi</span>		<span class="o">*</span><span class="n">controller</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">tibase</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">musb</span>		<span class="o">*</span><span class="n">musb</span><span class="p">;</span>

	<span class="n">controller</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cppi</span><span class="p">,</span> <span class="n">controller</span><span class="p">);</span>
	<span class="n">musb</span> <span class="o">=</span> <span class="n">controller</span><span class="o">-&gt;</span><span class="n">musb</span><span class="p">;</span>

	<span class="n">tibase</span> <span class="o">=</span> <span class="n">controller</span><span class="o">-&gt;</span><span class="n">tibase</span><span class="p">;</span>
	<span class="cm">/* DISABLE INDIVIDUAL CHANNEL Interrupts */</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">DAVINCI_TXCPPI_INTCLR_REG</span><span class="p">,</span>
			<span class="n">DAVINCI_DMA_ALL_CHANNELS_ENABLE</span><span class="p">);</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">DAVINCI_RXCPPI_INTCLR_REG</span><span class="p">,</span>
			<span class="n">DAVINCI_DMA_ALL_CHANNELS_ENABLE</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;Tearing down RX and TX Channels</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* FIXME restructure of txdma to use bds like rxdma */</span>
		<span class="n">controller</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">last_processed</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">cppi_pool_free</span><span class="p">(</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cppi_pool_free</span><span class="p">(</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="cm">/* in Tx Case proper teardown is supported. We resort to disabling</span>
<span class="cm">	 * Tx/Rx CPPI after cleanup of Tx channels. Before TX teardown is</span>
<span class="cm">	 * complete TX CPPI cannot be disabled.</span>
<span class="cm">	 */</span>
	<span class="cm">/*disable tx/rx cppi */</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">DAVINCI_TXCPPI_CTRL_REG</span><span class="p">,</span> <span class="n">DAVINCI_DMA_CTRL_DISABLE</span><span class="p">);</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">DAVINCI_RXCPPI_CTRL_REG</span><span class="p">,</span> <span class="n">DAVINCI_DMA_CTRL_DISABLE</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* While dma channel is allocated, we only want the core irqs active</span>
<span class="cm"> * for fault reports, otherwise we&#39;d get irqs that we don&#39;t care about.</span>
<span class="cm"> * Except for TX irqs, where dma done != fifo empty and reusable ...</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: docs don&#39;t say either way, but irq masking **enables** irqs.</span>
<span class="cm"> *</span>
<span class="cm"> * REVISIT same issue applies to pure PIO usage too, and non-cppi dma...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">core_rxirq_disable</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">tibase</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">epnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">DAVINCI_USB_INT_MASK_CLR_REG</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">epnum</span> <span class="o">+</span> <span class="mi">8</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">core_rxirq_enable</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">tibase</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">epnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">DAVINCI_USB_INT_MASK_SET_REG</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">epnum</span> <span class="o">+</span> <span class="mi">8</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Allocate a CPPI Channel for DMA.  With CPPI, channels are bound to</span>
<span class="cm"> * each transfer direction of a non-control endpoint, so allocating</span>
<span class="cm"> * (and deallocating) is mostly a way to notice bad housekeeping on</span>
<span class="cm"> * the software side.  We assume the irqs are always active.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dma_channel</span> <span class="o">*</span>
<span class="nf">cppi_channel_allocate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">musb_hw_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="n">u8</span> <span class="n">transmit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cppi</span>		<span class="o">*</span><span class="n">controller</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cppi_channel</span>	<span class="o">*</span><span class="n">cppi_ch</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">tibase</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">musb</span>		<span class="o">*</span><span class="n">musb</span><span class="p">;</span>

	<span class="n">controller</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cppi</span><span class="p">,</span> <span class="n">controller</span><span class="p">);</span>
	<span class="n">tibase</span> <span class="o">=</span> <span class="n">controller</span><span class="o">-&gt;</span><span class="n">tibase</span><span class="p">;</span>
	<span class="n">musb</span> <span class="o">=</span> <span class="n">controller</span><span class="o">-&gt;</span><span class="n">musb</span><span class="p">;</span>

	<span class="cm">/* ep0 doesn&#39;t use DMA; remember cppi indices are 0..N-1 */</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">epnum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* return the corresponding CPPI Channel Handle, and</span>
<span class="cm">	 * probably disable the non-CPPI irq until we need it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transmit</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;no %cX%d CPPI channel</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="sc">&#39;T&#39;</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cppi_ch</span> <span class="o">=</span> <span class="n">controller</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;no %cX%d CPPI channel</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="sc">&#39;R&#39;</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cppi_ch</span> <span class="o">=</span> <span class="n">controller</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>
		<span class="n">core_rxirq_disable</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">epnum</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* REVISIT make this an error later once the same driver code works</span>
<span class="cm">	 * with the other DMA engine too</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">hw_ep</span><span class="p">)</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;re-allocating DMA%d %cX channel %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">index</span><span class="p">,</span> <span class="n">transmit</span> <span class="o">?</span> <span class="sc">&#39;T&#39;</span> <span class="o">:</span> <span class="sc">&#39;R&#39;</span><span class="p">,</span> <span class="n">cppi_ch</span><span class="p">);</span>
	<span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">hw_ep</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
	<span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">MUSB_DMA_STATUS_FREE</span><span class="p">;</span>
	<span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">.</span><span class="n">max_len</span> <span class="o">=</span> <span class="mh">0x7fffffff</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;Allocate CPPI%d %cX</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">transmit</span> <span class="o">?</span> <span class="sc">&#39;T&#39;</span> <span class="o">:</span> <span class="sc">&#39;R&#39;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Release a CPPI Channel.  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cppi_channel_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cppi_channel</span>	<span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">tibase</span><span class="p">;</span>

	<span class="cm">/* REVISIT:  for paranoia, check state and abort if needed... */</span>

	<span class="n">c</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cppi_channel</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
	<span class="n">tibase</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">tibase</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">hw_ep</span><span class="p">)</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">,</span>
			<span class="s">&quot;releasing idle DMA channel %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">transmit</span><span class="p">)</span>
		<span class="n">core_rxirq_enable</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* for now, leave its cppi IRQ enabled (we won&#39;t trigger it) */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">hw_ep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">channel</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">MUSB_DMA_STATUS_UNKNOWN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Context: controller irqlocked */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cppi_dump_rx</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cppi_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span>			<span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cppi_rx_stateram</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">rx</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">state_ram</span><span class="p">;</span>

	<span class="n">musb_ep_select</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">,</span>
		<span class="s">&quot;RX DMA%d%s: %d left, csr %04x, &quot;</span>
		<span class="s">&quot;%08x H%08x S%08x C%08x, &quot;</span>
		<span class="s">&quot;B%08x L%08x %08x .. %08x&quot;</span>
		<span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span>
		<span class="n">musb_readl</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">tibase</span><span class="p">,</span>
			<span class="n">DAVINCI_RXCPPI_BUFCNT0_REG</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">),</span>
		<span class="n">musb_readw</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">hw_ep</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">MUSB_RXCSR</span><span class="p">),</span>

		<span class="n">musb_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">rx_skipbytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">musb_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">rx_head</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">musb_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">rx_sop</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">musb_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">rx_current</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>

		<span class="n">musb_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">rx_buf_current</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">musb_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">rx_len_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">musb_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">rx_cnt_cnt</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">musb_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">rx_complete</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Context: controller irqlocked */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cppi_dump_tx</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cppi_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span>			<span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cppi_tx_stateram</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">tx</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">state_ram</span><span class="p">;</span>

	<span class="n">musb_ep_select</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">,</span>
		<span class="s">&quot;TX DMA%d%s: csr %04x, &quot;</span>
		<span class="s">&quot;H%08x S%08x C%08x %08x, &quot;</span>
		<span class="s">&quot;F%08x L%08x .. %08x&quot;</span>
		<span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span>
		<span class="n">musb_readw</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">hw_ep</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">MUSB_TXCSR</span><span class="p">),</span>

		<span class="n">musb_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">tx_head</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">musb_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">musb_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">tx_current</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">musb_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">tx_buf_current</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>

		<span class="n">musb_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">tx_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">musb_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">tx_rem_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="cm">/* dummy/unused word 6 */</span>
		<span class="n">musb_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">tx_complete</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Context: controller irqlocked */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">cppi_rndis_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">cppi_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_rx</span><span class="p">,</span>
		<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">tibase</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_rndis</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* we may need to change the rndis flag for this cppi channel */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">is_rndis</span> <span class="o">!=</span> <span class="n">is_rndis</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span>	<span class="n">value</span> <span class="o">=</span> <span class="n">musb_readl</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">DAVINCI_RNDIS_REG</span><span class="p">);</span>
		<span class="n">u32</span>	<span class="n">temp</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_rx</span><span class="p">)</span>
			<span class="n">temp</span> <span class="o">&lt;&lt;=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_rndis</span><span class="p">)</span>
			<span class="n">value</span> <span class="o">|=</span> <span class="n">temp</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">value</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">temp</span><span class="p">;</span>
		<span class="n">musb_writel</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">DAVINCI_RNDIS_REG</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">is_rndis</span> <span class="o">=</span> <span class="n">is_rndis</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_USB_MUSB_DEBUG</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cppi_dump_rxbd</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tag</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cppi_descriptor</span> <span class="o">*</span><span class="n">bd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;RXBD/%s %08x: &quot;</span>
			<span class="s">&quot;nxt %08x buf %08x off.blen %08x opt.plen %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">tag</span><span class="p">,</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
			<span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">,</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_bufp</span><span class="p">,</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_off_len</span><span class="p">,</span>
			<span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_options</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cppi_dump_rxq</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tag</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cppi_channel</span> <span class="o">*</span><span class="n">rx</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_USB_MUSB_DEBUG</span>
	<span class="k">struct</span> <span class="n">cppi_descriptor</span>	<span class="o">*</span><span class="n">bd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_dbg_level</span><span class="p">(</span><span class="n">level</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">cppi_dump_rx</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">rx</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">last_processed</span><span class="p">)</span>
		<span class="n">cppi_dump_rxbd</span><span class="p">(</span><span class="s">&quot;last&quot;</span><span class="p">,</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">last_processed</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">bd</span> <span class="o">=</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span> <span class="n">bd</span><span class="p">;</span> <span class="n">bd</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
		<span class="n">cppi_dump_rxbd</span><span class="p">(</span><span class="s">&quot;active&quot;</span><span class="p">,</span> <span class="n">bd</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>


<span class="cm">/* NOTE:  DaVinci autoreq is ignored except for host side &quot;RNDIS&quot; mode RX;</span>
<span class="cm"> * so we won&#39;t ever use it (see &quot;CPPI RX Woes&quot; below).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cppi_autoreq_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">cppi_channel</span> <span class="o">*</span><span class="n">rx</span><span class="p">,</span>
		<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">tibase</span><span class="p">,</span> <span class="kt">int</span> <span class="n">onepacket</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">n_bds</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>	<span class="n">val</span><span class="p">;</span>

<span class="cp">#ifdef	RNDIS_RX_IS_USABLE</span>
	<span class="n">u32</span>	<span class="n">tmp</span><span class="p">;</span>
	<span class="cm">/* assert(is_host_active(musb)) */</span>

	<span class="cm">/* start from &quot;AutoReq never&quot; */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">musb_readl</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">DAVINCI_AUTOREQ_REG</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">((</span><span class="mh">0x3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">*</span> <span class="mi">2</span><span class="p">));</span>

	<span class="cm">/* HCD arranged reqpkt for packet #1.  we arrange int</span>
<span class="cm">	 * for all but the last one, maybe in two segments.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">onepacket</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		/* use two segments, autoreq &quot;all&quot; then the last &quot;never&quot; */</span>
<span class="c">		val |= ((0x3) &lt;&lt; (rx-&gt;index * 2));</span>
<span class="c">		n_bds--;</span>
<span class="cp">#else</span>
		<span class="cm">/* one segment, autoreq &quot;all-but-last&quot; */</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="p">((</span><span class="mh">0x1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">*</span> <span class="mi">2</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

		<span class="cm">/* make sure that autoreq is updated before continuing */</span>
		<span class="n">musb_writel</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">DAVINCI_AUTOREQ_REG</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">musb_readl</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">DAVINCI_AUTOREQ_REG</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* REQPKT is turned off after each segment */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n_bds</span> <span class="o">&amp;&amp;</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">.</span><span class="n">actual_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">hw_ep</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">;</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">musb_readw</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">MUSB_RXCSR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">MUSB_RXCSR_H_REQPKT</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="n">MUSB_RXCSR_H_REQPKT</span> <span class="o">|</span> <span class="n">MUSB_RXCSR_H_WZC_BITS</span><span class="p">;</span>
			<span class="n">musb_writew</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">MUSB_RXCSR</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
			<span class="cm">/* flush writebuffer */</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">musb_readw</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">MUSB_RXCSR</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">n_bds</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Buffer enqueuing Logic:</span>
<span class="cm"> *</span>
<span class="cm"> *  - RX builds new queues each time, to help handle routine &quot;early</span>
<span class="cm"> *    termination&quot; cases (faults, including errors and short reads)</span>
<span class="cm"> *    more correctly.</span>
<span class="cm"> *</span>
<span class="cm"> *  - for now, TX reuses the same queue of BDs every time</span>
<span class="cm"> *</span>
<span class="cm"> * REVISIT long term, we want a normal dynamic model.</span>
<span class="cm"> * ... the goal will be to append to the</span>
<span class="cm"> * existing queue, processing completed &quot;dma buffers&quot; (segments) on the fly.</span>
<span class="cm"> *</span>
<span class="cm"> * Otherwise we force an IRQ latency between requests, which slows us a lot</span>
<span class="cm"> * (especially in &quot;transparent&quot; dma).  Unfortunately that model seems to be</span>
<span class="cm"> * inherent in the DMA model from the Mentor code, except in the rare case</span>
<span class="cm"> * of transfers big enough (~128+ KB) that we could append &quot;middle&quot; segments</span>
<span class="cm"> * in the TX paths.  (RX can&#39;t do this, see below.)</span>
<span class="cm"> *</span>
<span class="cm"> * That&#39;s true even in the CPPI- friendly iso case, where most urbs have</span>
<span class="cm"> * several small segments provided in a group and where the &quot;packet at a time&quot;</span>
<span class="cm"> * &quot;transparent&quot; DMA model is always correct, even on the RX side.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * CPPI TX:</span>
<span class="cm"> * ========</span>
<span class="cm"> * TX is a lot more reasonable than RX; it doesn&#39;t need to run in</span>
<span class="cm"> * irq-per-packet mode very often.  RNDIS mode seems to behave too</span>
<span class="cm"> * (except how it handles the exactly-N-packets case).  Building a</span>
<span class="cm"> * txdma queue with multiple requests (urb or usb_request) looks</span>
<span class="cm"> * like it would work ... but fault handling would need much testing.</span>
<span class="cm"> *</span>
<span class="cm"> * The main issue with TX mode RNDIS relates to transfer lengths that</span>
<span class="cm"> * are an exact multiple of the packet length.  It appears that there&#39;s</span>
<span class="cm"> * a hiccup in that case (maybe the DMA completes before the ZLP gets</span>
<span class="cm"> * written?) boiling down to not being able to rely on CPPI writing any</span>
<span class="cm"> * terminating zero length packet before the next transfer is written.</span>
<span class="cm"> * So that&#39;s punted to PIO; better yet, gadget drivers can avoid it.</span>
<span class="cm"> *</span>
<span class="cm"> * Plus, there&#39;s allegedly an undocumented constraint that rndis transfer</span>
<span class="cm"> * length be a multiple of 64 bytes ... but the chip doesn&#39;t act that</span>
<span class="cm"> * way, and we really don&#39;t _want_ that behavior anyway.</span>
<span class="cm"> *</span>
<span class="cm"> * On TX, &quot;transparent&quot; mode works ... although experiments have shown</span>
<span class="cm"> * problems trying to use the SOP/EOP bits in different USB packets.</span>
<span class="cm"> *</span>
<span class="cm"> * REVISIT try to handle terminating zero length packets using CPPI</span>
<span class="cm"> * instead of doing it by PIO after an IRQ.  (Meanwhile, make Ethernet</span>
<span class="cm"> * links avoid that issue by forcing them to avoid zlps.)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cppi_next_tx_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">musb</span> <span class="o">*</span><span class="n">musb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cppi_channel</span> <span class="o">*</span><span class="n">tx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span>		<span class="n">maxpacket</span> <span class="o">=</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">maxpacket</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">addr</span> <span class="o">=</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">buf_dma</span> <span class="o">+</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
	<span class="kt">size_t</span>			<span class="n">length</span> <span class="o">=</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">buf_len</span> <span class="o">-</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cppi_descriptor</span>	<span class="o">*</span><span class="n">bd</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">n_bds</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cppi_tx_stateram</span>	<span class="n">__iomem</span> <span class="o">*</span><span class="n">tx_ram</span> <span class="o">=</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">state_ram</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rndis</span><span class="p">;</span>

	<span class="cm">/* TX can use the CPPI &quot;rndis&quot; mode, where we can probably fit this</span>
<span class="cm">	 * transfer in one BD and one IRQ.  The only time we would NOT want</span>
<span class="cm">	 * to use it is when hardware constraints prevent it, or if we&#39;d</span>
<span class="cm">	 * trigger the &quot;send a ZLP?&quot; confusion.</span>
<span class="cm">	 */</span>
	<span class="n">rndis</span> <span class="o">=</span> <span class="p">(</span><span class="n">maxpacket</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
		<span class="o">&amp;&amp;</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="n">maxpacket</span>
		<span class="o">&amp;&amp;</span> <span class="n">length</span> <span class="o">&lt;</span> <span class="mh">0xffff</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">length</span> <span class="o">%</span> <span class="n">maxpacket</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rndis</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">maxpacket</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
		<span class="n">n_bds</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">n_bds</span> <span class="o">=</span> <span class="n">length</span> <span class="o">/</span> <span class="n">maxpacket</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">length</span> <span class="o">||</span> <span class="p">(</span><span class="n">length</span> <span class="o">%</span> <span class="n">maxpacket</span><span class="p">))</span>
			<span class="n">n_bds</span><span class="o">++</span><span class="p">;</span>
		<span class="n">n_bds</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">n_bds</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">NUM_TXCHAN_BD</span><span class="p">);</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">n_bds</span> <span class="o">*</span> <span class="n">maxpacket</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;TX DMA%d, pktSz %d %s bds %d dma 0x%llx len %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">tx</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span>
			<span class="n">maxpacket</span><span class="p">,</span>
			<span class="n">rndis</span> <span class="o">?</span> <span class="s">&quot;rndis&quot;</span> <span class="o">:</span> <span class="s">&quot;transparent&quot;</span><span class="p">,</span>
			<span class="n">n_bds</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

	<span class="n">cppi_rndis_update</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">musb</span><span class="o">-&gt;</span><span class="n">ctrl_base</span><span class="p">,</span> <span class="n">rndis</span><span class="p">);</span>

	<span class="cm">/* assuming here that channel_program is called during</span>
<span class="cm">	 * transfer initiation ... current code maintains state</span>
<span class="cm">	 * for one outstanding request only (no queues, not even</span>
<span class="cm">	 * the implicit ones of an iso urb).</span>
<span class="cm">	 */</span>

	<span class="n">bd</span> <span class="o">=</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">;</span>
	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">bd</span><span class="p">;</span>
	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">last_processed</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* FIXME use BD pool like RX side does, and just queue</span>
<span class="cm">	 * the minimum number for this request.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Prepare queue of BDs first, then hand it to hardware.</span>
<span class="cm">	 * All BDs except maybe the last should be of full packet</span>
<span class="cm">	 * size; for RNDIS there _is_ only that last packet.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_bds</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_bds</span> <span class="o">&amp;&amp;</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
			<span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_bufp</span> <span class="o">=</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">buf_dma</span> <span class="o">+</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>

		<span class="cm">/* FIXME set EOP only on the last packet,</span>
<span class="cm">		 * SOP only on the first ... avoid IRQs</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">maxpacket</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">buf_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tx</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">maxpacket</span><span class="p">;</span>
			<span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_off_len</span> <span class="o">=</span> <span class="n">maxpacket</span><span class="p">;</span>
			<span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_options</span> <span class="o">=</span> <span class="n">CPPI_SOP_SET</span> <span class="o">|</span> <span class="n">CPPI_EOP_SET</span>
				<span class="o">|</span> <span class="n">CPPI_OWN_SET</span> <span class="o">|</span> <span class="n">maxpacket</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* only this one may be a partial USB Packet */</span>
			<span class="n">u32</span>		<span class="n">partial_len</span><span class="p">;</span>

			<span class="n">partial_len</span> <span class="o">=</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">buf_len</span> <span class="o">-</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
			<span class="n">tx</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">buf_len</span><span class="p">;</span>
			<span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_off_len</span> <span class="o">=</span> <span class="n">partial_len</span><span class="p">;</span>

			<span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_options</span> <span class="o">=</span> <span class="n">CPPI_SOP_SET</span> <span class="o">|</span> <span class="n">CPPI_EOP_SET</span>
				<span class="o">|</span> <span class="n">CPPI_OWN_SET</span> <span class="o">|</span> <span class="n">partial_len</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">partial_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_options</span> <span class="o">|=</span> <span class="n">CPPI_ZERO_SET</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;TXBD %p: nxt %08x buf %08x len %04x opt %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bd</span><span class="p">,</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">,</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_bufp</span><span class="p">,</span>
				<span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_off_len</span><span class="p">,</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_options</span><span class="p">);</span>

		<span class="cm">/* update the last BD enqueued to the list */</span>
		<span class="n">tx</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">bd</span><span class="p">;</span>
		<span class="n">bd</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* BDs live in DMA-coherent memory, but writes might be pending */</span>
	<span class="n">cpu_drain_writebuffer</span><span class="p">();</span>

	<span class="cm">/* Write to the HeadPtr in state RAM to trigger */</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_ram</span><span class="o">-&gt;</span><span class="n">tx_head</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>

	<span class="n">cppi_dump_tx</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="s">&quot;/S&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * CPPI RX Woes:</span>
<span class="cm"> * =============</span>
<span class="cm"> * Consider a 1KB bulk RX buffer in two scenarios:  (a) it&#39;s fed two 300 byte</span>
<span class="cm"> * packets back-to-back, and (b) it&#39;s fed two 512 byte packets back-to-back.</span>
<span class="cm"> * (Full speed transfers have similar scenarios.)</span>
<span class="cm"> *</span>
<span class="cm"> * The correct behavior for Linux is that (a) fills the buffer with 300 bytes,</span>
<span class="cm"> * and the next packet goes into a buffer that&#39;s queued later; while (b) fills</span>
<span class="cm"> * the buffer with 1024 bytes.  How to do that with CPPI?</span>
<span class="cm"> *</span>
<span class="cm"> * - RX queues in &quot;rndis&quot; mode -- one single BD -- handle (a) correctly, but</span>
<span class="cm"> *   (b) loses **BADLY** because nothing (!) happens when that second packet</span>
<span class="cm"> *   fills the buffer, much less when a third one arrives.  (Which makes this</span>
<span class="cm"> *   not a &quot;true&quot; RNDIS mode.  In the RNDIS protocol short-packet termination</span>
<span class="cm"> *   is optional, and it&#39;s fine if peripherals -- not hosts! -- pad messages</span>
<span class="cm"> *   out to end-of-buffer.  Standard PCI host controller DMA descriptors</span>
<span class="cm"> *   implement that mode by default ... which is no accident.)</span>
<span class="cm"> *</span>
<span class="cm"> * - RX queues in &quot;transparent&quot; mode -- two BDs with 512 bytes each -- have</span>
<span class="cm"> *   converse problems:  (b) is handled right, but (a) loses badly.  CPPI RX</span>
<span class="cm"> *   ignores SOP/EOP markings and processes both of those BDs; so both packets</span>
<span class="cm"> *   are loaded into the buffer (with a 212 byte gap between them), and the next</span>
<span class="cm"> *   buffer queued will NOT get its 300 bytes of data. (It seems like SOP/EOP</span>
<span class="cm"> *   are intended as outputs for RX queues, not inputs...)</span>
<span class="cm"> *</span>
<span class="cm"> * - A variant of &quot;transparent&quot; mode -- one BD at a time -- is the only way to</span>
<span class="cm"> *   reliably make both cases work, with software handling both cases correctly</span>
<span class="cm"> *   and at the significant penalty of needing an IRQ per packet.  (The lack of</span>
<span class="cm"> *   I/O overlap can be slightly ameliorated by enabling double buffering.)</span>
<span class="cm"> *</span>
<span class="cm"> * So how to get rid of IRQ-per-packet?  The transparent multi-BD case could</span>
<span class="cm"> * be used in special cases like mass storage, which sets URB_SHORT_NOT_OK</span>
<span class="cm"> * (or maybe its peripheral side counterpart) to flag (a) scenarios as errors</span>
<span class="cm"> * with guaranteed driver level fault recovery and scrubbing out what&#39;s left</span>
<span class="cm"> * of that garbaged datastream.</span>
<span class="cm"> *</span>
<span class="cm"> * But there seems to be no way to identify the cases where CPPI RNDIS mode</span>
<span class="cm"> * is appropriate -- which do NOT include RNDIS host drivers, but do include</span>
<span class="cm"> * the CDC Ethernet driver! -- and the documentation is incomplete/wrong.</span>
<span class="cm"> * So we can&#39;t _ever_ use RX RNDIS mode ... except by using a heuristic</span>
<span class="cm"> * that applies best on the peripheral side (and which could fail rudely).</span>
<span class="cm"> *</span>
<span class="cm"> * Leaving only &quot;transparent&quot; mode; we avoid multi-bd modes in almost all</span>
<span class="cm"> * cases other than mass storage class.  Otherwise we&#39;re correct but slow,</span>
<span class="cm"> * since CPPI penalizes our need for a &quot;true RNDIS&quot; default mode.</span>
<span class="cm"> */</span>


<span class="cm">/* Heuristic, intended to kick in for ethernet/rndis peripheral ONLY</span>
<span class="cm"> *</span>
<span class="cm"> * IFF</span>
<span class="cm"> *  (a)	peripheral mode ... since rndis peripherals could pad their</span>
<span class="cm"> *	writes to hosts, causing i/o failure; or we&#39;d have to cope with</span>
<span class="cm"> *	a largely unknowable variety of host side protocol variants</span>
<span class="cm"> *  (b)	and short reads are NOT errors ... since full reads would</span>
<span class="cm"> *	cause those same i/o failures</span>
<span class="cm"> *  (c)	and read length is</span>
<span class="cm"> *	- less than 64KB (max per cppi descriptor)</span>
<span class="cm"> *	- not a multiple of 4096 (g_zero default, full reads typical)</span>
<span class="cm"> *	- N (&gt;1) packets long, ditto (full reads not EXPECTED)</span>
<span class="cm"> * THEN</span>
<span class="cm"> *   try rx rndis mode</span>
<span class="cm"> *</span>
<span class="cm"> * Cost of heuristic failing:  RXDMA wedges at the end of transfers that</span>
<span class="cm"> * fill out the whole buffer.  Buggy host side usb network drivers could</span>
<span class="cm"> * trigger that, but &quot;in the field&quot; such bugs seem to be all but unknown.</span>
<span class="cm"> *</span>
<span class="cm"> * So this module parameter lets the heuristic be disabled.  When using</span>
<span class="cm"> * gadgetfs, the heuristic will probably need to be disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">cppi_rx_rndis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">cppi_rx_rndis</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">cppi_rx_rndis</span><span class="p">,</span> <span class="s">&quot;enable/disable RX RNDIS heuristic&quot;</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * cppi_next_rx_segment - dma read for the next chunk of a buffer</span>
<span class="cm"> * @musb: the controller</span>
<span class="cm"> * @rx: dma channel</span>
<span class="cm"> * @onepacket: true unless caller treats short reads as errors, and</span>
<span class="cm"> *	performs fault recovery above usbcore.</span>
<span class="cm"> * Context: controller irqlocked</span>
<span class="cm"> *</span>
<span class="cm"> * See above notes about why we can&#39;t use multi-BD RX queues except in</span>
<span class="cm"> * rare cases (mass storage class), and can never use the hardware &quot;rndis&quot;</span>
<span class="cm"> * mode (since it&#39;s not a &quot;true&quot; RNDIS mode) with complete safety..</span>
<span class="cm"> *</span>
<span class="cm"> * It&#39;s ESSENTIAL that callers specify &quot;onepacket&quot; mode unless they kick in</span>
<span class="cm"> * code to recover from corrupted datastreams after each short transfer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cppi_next_rx_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">musb</span> <span class="o">*</span><span class="n">musb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cppi_channel</span> <span class="o">*</span><span class="n">rx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">onepacket</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span>		<span class="n">maxpacket</span> <span class="o">=</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">maxpacket</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">addr</span> <span class="o">=</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">buf_dma</span> <span class="o">+</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
	<span class="kt">size_t</span>			<span class="n">length</span> <span class="o">=</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">buf_len</span> <span class="o">-</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cppi_descriptor</span>	<span class="o">*</span><span class="n">bd</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">n_bds</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">i</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">tibase</span> <span class="o">=</span> <span class="n">musb</span><span class="o">-&gt;</span><span class="n">ctrl_base</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">is_rndis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cppi_rx_stateram</span>	<span class="n">__iomem</span> <span class="o">*</span><span class="n">rx_ram</span> <span class="o">=</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">state_ram</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">onepacket</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* almost every USB driver, host or peripheral side */</span>
		<span class="n">n_bds</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* maybe apply the heuristic above */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cppi_rx_rndis</span>
				<span class="o">&amp;&amp;</span> <span class="n">is_peripheral_active</span><span class="p">(</span><span class="n">musb</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="n">maxpacket</span>
				<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">length</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xffff</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
				<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">length</span> <span class="o">&amp;</span> <span class="mh">0x0fff</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
				<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">length</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">maxpacket</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">maxpacket</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
			<span class="n">is_rndis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* virtually nothing except mass storage class */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">n_bds</span> <span class="o">=</span> <span class="mh">0xffff</span> <span class="o">/</span> <span class="n">maxpacket</span><span class="p">;</span>
			<span class="n">length</span> <span class="o">=</span> <span class="n">n_bds</span> <span class="o">*</span> <span class="n">maxpacket</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">n_bds</span> <span class="o">=</span> <span class="n">length</span> <span class="o">/</span> <span class="n">maxpacket</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">%</span> <span class="n">maxpacket</span><span class="p">)</span>
				<span class="n">n_bds</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n_bds</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">onepacket</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">n_bds</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">n_bds</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">NUM_RXCHAN_BD</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* In host mode, autorequest logic can generate some IN tokens; it&#39;s</span>
<span class="cm">	 * tricky since we can&#39;t leave REQPKT set in RXCSR after the transfer</span>
<span class="cm">	 * finishes. So:  multipacket transfers involve two or more segments.</span>
<span class="cm">	 * And always at least two IRQs ... RNDIS mode is not an option.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_host_active</span><span class="p">(</span><span class="n">musb</span><span class="p">))</span>
		<span class="n">n_bds</span> <span class="o">=</span> <span class="n">cppi_autoreq_update</span><span class="p">(</span><span class="n">rx</span><span class="p">,</span> <span class="n">tibase</span><span class="p">,</span> <span class="n">onepacket</span><span class="p">,</span> <span class="n">n_bds</span><span class="p">);</span>

	<span class="n">cppi_rndis_update</span><span class="p">(</span><span class="n">rx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">musb</span><span class="o">-&gt;</span><span class="n">ctrl_base</span><span class="p">,</span> <span class="n">is_rndis</span><span class="p">);</span>

	<span class="n">length</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">n_bds</span> <span class="o">*</span> <span class="n">maxpacket</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;RX DMA%d seg, maxp %d %s bds %d (cnt %d) &quot;</span>
			<span class="s">&quot;dma 0x%llx len %u %u/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">rx</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">maxpacket</span><span class="p">,</span>
			<span class="n">onepacket</span>
				<span class="o">?</span> <span class="p">(</span><span class="n">is_rndis</span> <span class="o">?</span> <span class="s">&quot;rndis&quot;</span> <span class="o">:</span> <span class="s">&quot;onepacket&quot;</span><span class="p">)</span>
				<span class="o">:</span> <span class="s">&quot;multipacket&quot;</span><span class="p">,</span>
			<span class="n">n_bds</span><span class="p">,</span>
			<span class="n">musb_readl</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span>
				<span class="n">DAVINCI_RXCPPI_BUFCNT0_REG</span> <span class="o">+</span> <span class="p">(</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span>
					<span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span>
			<span class="n">rx</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">.</span><span class="n">actual_len</span><span class="p">,</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">buf_len</span><span class="p">);</span>

	<span class="cm">/* only queue one segment at a time, since the hardware prevents</span>
<span class="cm">	 * correct queue shutdown after unexpected short packets</span>
<span class="cm">	 */</span>
	<span class="n">bd</span> <span class="o">=</span> <span class="n">cppi_bd_alloc</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>
	<span class="n">rx</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">bd</span><span class="p">;</span>

	<span class="cm">/* Build BDs for all packets in this segment */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">bd</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_bds</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">bd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span>	<span class="n">bd_len</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bd</span> <span class="o">=</span> <span class="n">cppi_bd_alloc</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bd</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">bd</span><span class="p">;</span>
			<span class="n">tail</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* all but the last packet will be maxpacket size */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">maxpacket</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span>
			<span class="n">bd_len</span> <span class="o">=</span> <span class="n">maxpacket</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">bd_len</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>

		<span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_bufp</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">bd_len</span><span class="p">;</span>
		<span class="n">rx</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">bd_len</span><span class="p">;</span>

		<span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_off_len</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="cm">/*offset*/</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="n">bd_len</span><span class="p">;</span>
		<span class="n">bd</span><span class="o">-&gt;</span><span class="n">buflen</span> <span class="o">=</span> <span class="n">bd_len</span><span class="p">;</span>

		<span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_options</span> <span class="o">=</span> <span class="n">CPPI_OWN_SET</span> <span class="o">|</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">length</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">length</span> <span class="o">-=</span> <span class="n">bd_len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we always expect at least one reusable BD! */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tail</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARNING</span><span class="p">(</span><span class="s">&quot;rx dma%d -- no BDs? need %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">n_bds</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_bds</span><span class="p">)</span>
		<span class="n">WARNING</span><span class="p">(</span><span class="s">&quot;rx dma%d -- only %d of %d BDs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n_bds</span><span class="p">);</span>

	<span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">tail</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bd</span> <span class="o">=</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
	<span class="n">rx</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="p">;</span>

	<span class="cm">/* short reads and other faults should terminate this entire</span>
<span class="cm">	 * dma segment.  we want one &quot;dma packet&quot; per dma segment, not</span>
<span class="cm">	 * one per USB packet, terminating the whole queue at once...</span>
<span class="cm">	 * NOTE that current hardware seems to ignore SOP and EOP.</span>
<span class="cm">	 */</span>
	<span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_options</span> <span class="o">|=</span> <span class="n">CPPI_SOP_SET</span><span class="p">;</span>
	<span class="n">tail</span><span class="o">-&gt;</span><span class="n">hw_options</span> <span class="o">|=</span> <span class="n">CPPI_EOP_SET</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_USB_MUSB_DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">_dbg_level</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cppi_descriptor</span>	<span class="o">*</span><span class="n">d</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">d</span> <span class="o">=</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span> <span class="n">d</span><span class="p">;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
			<span class="n">cppi_dump_rxbd</span><span class="p">(</span><span class="s">&quot;S&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* in case the preceding transfer left some state... */</span>
	<span class="n">tail</span> <span class="o">=</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">last_processed</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tail</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">bd</span><span class="p">;</span>
		<span class="n">tail</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">core_rxirq_enable</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* BDs live in DMA-coherent memory, but writes might be pending */</span>
	<span class="n">cpu_drain_writebuffer</span><span class="p">();</span>

	<span class="cm">/* REVISIT specs say to write this AFTER the BUFCNT register</span>
<span class="cm">	 * below ... but that loses badly.</span>
<span class="cm">	 */</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx_ram</span><span class="o">-&gt;</span><span class="n">rx_head</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>

	<span class="cm">/* bufferCount must be at least 3, and zeroes on completion</span>
<span class="cm">	 * unless it underflows below zero, or stops at two, or keeps</span>
<span class="cm">	 * growing ... grr.</span>
<span class="cm">	 */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">musb_readl</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span>
			<span class="n">DAVINCI_RXCPPI_BUFCNT0_REG</span> <span class="o">+</span> <span class="p">(</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span>
			<span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span>
		<span class="n">musb_writel</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span>
			<span class="n">DAVINCI_RXCPPI_BUFCNT0_REG</span> <span class="o">+</span> <span class="p">(</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">*</span> <span class="mi">4</span><span class="p">),</span>
			<span class="n">n_bds</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n_bds</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">3</span><span class="p">))</span>
		<span class="n">musb_writel</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span>
			<span class="n">DAVINCI_RXCPPI_BUFCNT0_REG</span> <span class="o">+</span> <span class="p">(</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">*</span> <span class="mi">4</span><span class="p">),</span>
			<span class="n">n_bds</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">3</span><span class="p">));</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">musb_readl</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span>
			<span class="n">DAVINCI_RXCPPI_BUFCNT0_REG</span> <span class="o">+</span> <span class="p">(</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span>
			<span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">n_bds</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;bufcnt%d underrun - %d (for %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">rx</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n_bds</span><span class="p">);</span>
		<span class="n">musb_writel</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span>
			<span class="n">DAVINCI_RXCPPI_BUFCNT0_REG</span> <span class="o">+</span> <span class="p">(</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">*</span> <span class="mi">4</span><span class="p">),</span>
			<span class="n">n_bds</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cppi_dump_rx</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">rx</span><span class="p">,</span> <span class="s">&quot;/S&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cppi_channel_program - program channel for data transfer</span>
<span class="cm"> * @ch: the channel</span>
<span class="cm"> * @maxpacket: max packet size</span>
<span class="cm"> * @mode: For RX, 1 unless the usb protocol driver promised to treat</span>
<span class="cm"> *	all short reads as errors and kick in high level fault recovery.</span>
<span class="cm"> *	For TX, ignored because of RNDIS mode races/glitches.</span>
<span class="cm"> * @dma_addr: dma address of buffer</span>
<span class="cm"> * @len: length of buffer</span>
<span class="cm"> * Context: controller irqlocked</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cppi_channel_program</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">,</span>
		<span class="n">u16</span> <span class="n">maxpacket</span><span class="p">,</span> <span class="n">u8</span> <span class="n">mode</span><span class="p">,</span>
		<span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cppi_channel</span>	<span class="o">*</span><span class="n">cppi_ch</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cppi</span>		<span class="o">*</span><span class="n">controller</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">musb</span>		<span class="o">*</span><span class="n">musb</span><span class="p">;</span>

	<span class="n">cppi_ch</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cppi_channel</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
	<span class="n">controller</span> <span class="o">=</span> <span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">;</span>
	<span class="n">musb</span> <span class="o">=</span> <span class="n">controller</span><span class="o">-&gt;</span><span class="n">musb</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MUSB_DMA_STATUS_BUS_ABORT</span>:
	<span class="k">case</span> <span class="n">MUSB_DMA_STATUS_CORE_ABORT</span>:
		<span class="cm">/* fault irq handler should have handled cleanup */</span>
		<span class="n">WARNING</span><span class="p">(</span><span class="s">&quot;%cX DMA%d not cleaned up after abort!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">transmit</span> <span class="o">?</span> <span class="sc">&#39;T&#39;</span> <span class="o">:</span> <span class="sc">&#39;R&#39;</span><span class="p">,</span>
				<span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="cm">/* WARN_ON(1); */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MUSB_DMA_STATUS_BUSY</span>:
		<span class="n">WARNING</span><span class="p">(</span><span class="s">&quot;program active channel?  %cX DMA%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">transmit</span> <span class="o">?</span> <span class="sc">&#39;T&#39;</span> <span class="o">:</span> <span class="sc">&#39;R&#39;</span><span class="p">,</span>
				<span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="cm">/* WARN_ON(1); */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MUSB_DMA_STATUS_UNKNOWN</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;%cX DMA%d not allocated!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">transmit</span> <span class="o">?</span> <span class="sc">&#39;T&#39;</span> <span class="o">:</span> <span class="sc">&#39;R&#39;</span><span class="p">,</span>
				<span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="cm">/* FALLTHROUGH */</span>
	<span class="k">case</span> <span class="n">MUSB_DMA_STATUS_FREE</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">MUSB_DMA_STATUS_BUSY</span><span class="p">;</span>

	<span class="cm">/* set transfer parameters, then queue up its first segment */</span>
	<span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">buf_dma</span> <span class="o">=</span> <span class="n">dma_addr</span><span class="p">;</span>
	<span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">maxpacket</span> <span class="o">=</span> <span class="n">maxpacket</span><span class="p">;</span>
	<span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">buf_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">.</span><span class="n">actual_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* TX channel? or RX? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">transmit</span><span class="p">)</span>
		<span class="n">cppi_next_tx_segment</span><span class="p">(</span><span class="n">musb</span><span class="p">,</span> <span class="n">cppi_ch</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">cppi_next_rx_segment</span><span class="p">(</span><span class="n">musb</span><span class="p">,</span> <span class="n">cppi_ch</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">cppi_rx_scan</span><span class="p">(</span><span class="k">struct</span> <span class="n">cppi</span> <span class="o">*</span><span class="n">cppi</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cppi_channel</span>		<span class="o">*</span><span class="n">rx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cppi</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">[</span><span class="n">ch</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">cppi_rx_stateram</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">state_ram</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cppi_descriptor</span>		<span class="o">*</span><span class="n">bd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cppi_descriptor</span>		<span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">last_processed</span><span class="p">;</span>
	<span class="n">bool</span>				<span class="n">completed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">bool</span>				<span class="n">acked</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">i</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>			<span class="n">safe2ack</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>			<span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">hw_ep</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">musb</span>			<span class="o">*</span><span class="n">musb</span> <span class="o">=</span> <span class="n">cppi</span><span class="o">-&gt;</span><span class="n">musb</span><span class="p">;</span>

	<span class="n">cppi_dump_rx</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">rx</span><span class="p">,</span> <span class="s">&quot;/K&quot;</span><span class="p">);</span>

	<span class="n">bd</span> <span class="o">=</span> <span class="n">last</span> <span class="o">?</span> <span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">:</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bd</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* run through all completed BDs */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">safe2ack</span> <span class="o">=</span> <span class="n">musb_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">rx_complete</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">(</span><span class="n">safe2ack</span> <span class="o">||</span> <span class="n">completed</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">bd</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_RXCHAN_BD</span><span class="p">;</span>
			<span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">bd</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span>	<span class="n">len</span><span class="p">;</span>

		<span class="cm">/* catch latest BD writes from CPPI */</span>
		<span class="n">rmb</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">completed</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_options</span> <span class="o">&amp;</span> <span class="n">CPPI_OWN_SET</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;C/RXBD %llx: nxt %08x buf %08x &quot;</span>
			<span class="s">&quot;off.len %08x opt.len %08x (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">,</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_bufp</span><span class="p">,</span>
			<span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_off_len</span><span class="p">,</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_options</span><span class="p">,</span>
			<span class="n">rx</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">.</span><span class="n">actual_len</span><span class="p">);</span>

		<span class="cm">/* actual packet received length */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_options</span> <span class="o">&amp;</span> <span class="n">CPPI_SOP_SET</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">completed</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_off_len</span> <span class="o">&amp;</span> <span class="n">CPPI_RECV_PKTLEN_MASK</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_options</span> <span class="o">&amp;</span> <span class="n">CPPI_EOQ_MASK</span><span class="p">)</span>
			<span class="n">completed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">completed</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">buflen</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* NOTE:  when we get a short packet, RXCSR_H_REQPKT</span>
<span class="cm">			 * must have been cleared, and no more DMA packets may</span>
<span class="cm">			 * active be in the queue... TI docs didn&#39;t say, but</span>
<span class="cm">			 * CPPI ignores those BDs even though OWN is still set.</span>
<span class="cm">			 */</span>
			<span class="n">completed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;rx short %d/%d (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">len</span><span class="p">,</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">buflen</span><span class="p">,</span>
					<span class="n">rx</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">.</span><span class="n">actual_len</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* If we got here, we expect to ack at least one BD; meanwhile</span>
<span class="cm">		 * CPPI may completing other BDs while we scan this list...</span>
<span class="cm">		 *</span>
<span class="cm">		 * RACE: we can notice OWN cleared before CPPI raises the</span>
<span class="cm">		 * matching irq by writing that BD as the completion pointer.</span>
<span class="cm">		 * In such cases, stop scanning and wait for the irq, avoiding</span>
<span class="cm">		 * lost acks and states where BD ownership is unclear.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">==</span> <span class="n">safe2ack</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">musb_writel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">rx_complete</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">safe2ack</span><span class="p">);</span>
			<span class="n">safe2ack</span> <span class="o">=</span> <span class="n">musb_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">rx_complete</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">acked</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">==</span> <span class="n">safe2ack</span><span class="p">)</span>
				<span class="n">safe2ack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rx</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">.</span><span class="n">actual_len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">cppi_bd_free</span><span class="p">(</span><span class="n">rx</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">bd</span><span class="p">;</span>

		<span class="cm">/* stop scanning on end-of-segment */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">completed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rx</span><span class="o">-&gt;</span><span class="n">last_processed</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>

	<span class="cm">/* dma abort, lost ack, or ... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">acked</span> <span class="o">&amp;&amp;</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">csr</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">safe2ack</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">safe2ack</span> <span class="o">==</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">last_processed</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">)</span>
			<span class="n">musb_writel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">rx_complete</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">safe2ack</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">safe2ack</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cppi_bd_free</span><span class="p">(</span><span class="n">rx</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
			<span class="n">rx</span><span class="o">-&gt;</span><span class="n">last_processed</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="cm">/* if we land here on the host side, H_REQPKT will</span>
<span class="cm">			 * be clear and we need to restart the queue...</span>
<span class="cm">			 */</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">musb_ep_select</span><span class="p">(</span><span class="n">cppi</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">,</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">csr</span> <span class="o">=</span> <span class="n">musb_readw</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">MUSB_RXCSR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">csr</span> <span class="o">&amp;</span> <span class="n">MUSB_RXCSR_DMAENAB</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;list%d %p/%p, last %llx%s, csr %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">rx</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span>
				<span class="n">rx</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">,</span>
				<span class="n">rx</span><span class="o">-&gt;</span><span class="n">last_processed</span>
					<span class="o">?</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
						<span class="n">rx</span><span class="o">-&gt;</span><span class="n">last_processed</span><span class="o">-&gt;</span><span class="n">dma</span>
					<span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">completed</span> <span class="o">?</span> <span class="s">&quot;, completed&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
				<span class="n">csr</span><span class="p">);</span>
			<span class="n">cppi_dump_rxq</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;/what?&quot;</span><span class="p">,</span> <span class="n">rx</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">completed</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">csr</span><span class="p">;</span>

		<span class="n">rx</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">bd</span><span class="p">;</span>

		<span class="cm">/* REVISIT seems like &quot;autoreq all but EOP&quot; doesn&#39;t...</span>
<span class="cm">		 * setting it here &quot;should&quot; be racey, but seems to work</span>
<span class="cm">		 */</span>
		<span class="n">csr</span> <span class="o">=</span> <span class="n">musb_readw</span><span class="p">(</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">hw_ep</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">MUSB_RXCSR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_host_active</span><span class="p">(</span><span class="n">cppi</span><span class="o">-&gt;</span><span class="n">musb</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span> <span class="n">bd</span>
				<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">csr</span> <span class="o">&amp;</span> <span class="n">MUSB_RXCSR_H_REQPKT</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">csr</span> <span class="o">|=</span> <span class="n">MUSB_RXCSR_H_REQPKT</span><span class="p">;</span>
			<span class="n">musb_writew</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">MUSB_RXCSR</span><span class="p">,</span>
					<span class="n">MUSB_RXCSR_H_WZC_BITS</span> <span class="o">|</span> <span class="n">csr</span><span class="p">);</span>
			<span class="n">csr</span> <span class="o">=</span> <span class="n">musb_readw</span><span class="p">(</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">hw_ep</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">MUSB_RXCSR</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rx</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">rx</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cppi_dump_rx</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">rx</span><span class="p">,</span> <span class="n">completed</span> <span class="o">?</span> <span class="s">&quot;/completed&quot;</span> <span class="o">:</span> <span class="s">&quot;/cleaned&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">completed</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">irqreturn_t</span> <span class="nf">cppi_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">musb</span>		<span class="o">*</span><span class="n">musb</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cppi</span>		<span class="o">*</span><span class="n">cppi</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">tibase</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">musb_hw_ep</span>	<span class="o">*</span><span class="n">hw_ep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">rx</span><span class="p">,</span> <span class="n">tx</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">,</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">uninitialized_var</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">cppi</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">dma_controller</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cppi</span><span class="p">,</span> <span class="n">controller</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cppi</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">tibase</span> <span class="o">=</span> <span class="n">musb</span><span class="o">-&gt;</span><span class="n">ctrl_base</span><span class="p">;</span>

	<span class="n">tx</span> <span class="o">=</span> <span class="n">musb_readl</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">DAVINCI_TXCPPI_MASKED_REG</span><span class="p">);</span>
	<span class="n">rx</span> <span class="o">=</span> <span class="n">musb_readl</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">DAVINCI_RXCPPI_MASKED_REG</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rx</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cppi</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;CPPI IRQ Tx%x Rx%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">rx</span><span class="p">);</span>

	<span class="cm">/* process TX channels */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tx</span><span class="p">;</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">tx</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cppi_channel</span>		<span class="o">*</span><span class="n">tx_ch</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cppi_tx_stateram</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">tx_ram</span><span class="p">;</span>
		<span class="n">bool</span>				<span class="n">completed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cppi_descriptor</span>		<span class="o">*</span><span class="n">bd</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tx</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">tx_ch</span> <span class="o">=</span> <span class="n">cppi</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>
		<span class="n">tx_ram</span> <span class="o">=</span> <span class="n">tx_ch</span><span class="o">-&gt;</span><span class="n">state_ram</span><span class="p">;</span>

		<span class="cm">/* FIXME  need a cppi_tx_scan() routine, which</span>
<span class="cm">		 * can also be called from abort code</span>
<span class="cm">		 */</span>

		<span class="n">cppi_dump_tx</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">tx_ch</span><span class="p">,</span> <span class="s">&quot;/E&quot;</span><span class="p">);</span>

		<span class="n">bd</span> <span class="o">=</span> <span class="n">tx_ch</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If Head is null then this could mean that a abort interrupt</span>
<span class="cm">		 * that needs to be acknowledged.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">bd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;null BD</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">musb_writel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_ram</span><span class="o">-&gt;</span><span class="n">tx_complete</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* run through all completed BDs */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">!</span><span class="n">completed</span> <span class="o">&amp;&amp;</span> <span class="n">bd</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_TXCHAN_BD</span><span class="p">;</span>
				<span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">bd</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u16</span>	<span class="n">len</span><span class="p">;</span>

			<span class="cm">/* catch latest BD writes from CPPI */</span>
			<span class="n">rmb</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_options</span> <span class="o">&amp;</span> <span class="n">CPPI_OWN_SET</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;C/TXBD %p n %x b %x off %x opt %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">bd</span><span class="p">,</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">,</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_bufp</span><span class="p">,</span>
					<span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_off_len</span><span class="p">,</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_options</span><span class="p">);</span>

			<span class="n">len</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_off_len</span> <span class="o">&amp;</span> <span class="n">CPPI_BUFFER_LEN_MASK</span><span class="p">;</span>
			<span class="n">tx_ch</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">.</span><span class="n">actual_len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

			<span class="n">tx_ch</span><span class="o">-&gt;</span><span class="n">last_processed</span> <span class="o">=</span> <span class="n">bd</span><span class="p">;</span>

			<span class="cm">/* write completion register to acknowledge</span>
<span class="cm">			 * processing of completed BDs, and possibly</span>
<span class="cm">			 * release the IRQ; EOQ might not be set ...</span>
<span class="cm">			 *</span>
<span class="cm">			 * REVISIT use the same ack strategy as rx</span>
<span class="cm">			 *</span>
<span class="cm">			 * REVISIT have observed bit 18 set; huh??</span>
<span class="cm">			 */</span>
			<span class="cm">/* if ((bd-&gt;hw_options &amp; CPPI_EOQ_MASK)) */</span>
				<span class="n">musb_writel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_ram</span><span class="o">-&gt;</span><span class="n">tx_complete</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>

			<span class="cm">/* stop scanning on end-of-segment */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">completed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* on end of segment, maybe go to next one */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">completed</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* cppi_dump_tx(4, tx_ch, &quot;/complete&quot;); */</span>

			<span class="cm">/* transfer more, or report completion */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tx_ch</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">tx_ch</span><span class="o">-&gt;</span><span class="n">buf_len</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tx_ch</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">tx_ch</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">tx_ch</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">MUSB_DMA_STATUS_FREE</span><span class="p">;</span>

				<span class="n">hw_ep</span> <span class="o">=</span> <span class="n">tx_ch</span><span class="o">-&gt;</span><span class="n">hw_ep</span><span class="p">;</span>

				<span class="n">musb_dma_completion</span><span class="p">(</span><span class="n">musb</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Bigger transfer than we could fit in</span>
<span class="cm">				 * that first batch of descriptors...</span>
<span class="cm">				 */</span>
				<span class="n">cppi_next_tx_segment</span><span class="p">(</span><span class="n">musb</span><span class="p">,</span> <span class="n">tx_ch</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">tx_ch</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">bd</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Start processing the RX block */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rx</span><span class="p">;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">rx</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rx</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">cppi_channel</span>		<span class="o">*</span><span class="n">rx_ch</span><span class="p">;</span>

			<span class="n">rx_ch</span> <span class="o">=</span> <span class="n">cppi</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>

			<span class="cm">/* let incomplete dma segments finish */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cppi_rx_scan</span><span class="p">(</span><span class="n">cppi</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* start another dma segment if needed */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rx_ch</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">.</span><span class="n">actual_len</span> <span class="o">!=</span> <span class="n">rx_ch</span><span class="o">-&gt;</span><span class="n">buf_len</span>
					<span class="o">&amp;&amp;</span> <span class="n">rx_ch</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">.</span><span class="n">actual_len</span>
						<span class="o">==</span> <span class="n">rx_ch</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cppi_next_rx_segment</span><span class="p">(</span><span class="n">musb</span><span class="p">,</span> <span class="n">rx_ch</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* all segments completed! */</span>
			<span class="n">rx_ch</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">MUSB_DMA_STATUS_FREE</span><span class="p">;</span>

			<span class="n">hw_ep</span> <span class="o">=</span> <span class="n">rx_ch</span><span class="o">-&gt;</span><span class="n">hw_ep</span><span class="p">;</span>

			<span class="n">core_rxirq_disable</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">musb_dma_completion</span><span class="p">(</span><span class="n">musb</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* write to CPPI EOI register to re-enable interrupts */</span>
	<span class="n">musb_writel</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">DAVINCI_CPPI_EOI_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cppi</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Instantiate a software object representing a DMA controller. */</span>
<span class="k">struct</span> <span class="n">dma_controller</span> <span class="o">*</span><span class="n">__init</span>
<span class="nf">dma_controller_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">musb</span> <span class="o">*</span><span class="n">musb</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mregs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cppi</span>		<span class="o">*</span><span class="n">controller</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">platform_device</span>	<span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_platform_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">irq</span> <span class="o">=</span> <span class="n">platform_get_irq_byname</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="s">&quot;dma&quot;</span><span class="p">);</span>

	<span class="n">controller</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">controller</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">controller</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">controller</span><span class="o">-&gt;</span><span class="n">mregs</span> <span class="o">=</span> <span class="n">mregs</span><span class="p">;</span>
	<span class="n">controller</span><span class="o">-&gt;</span><span class="n">tibase</span> <span class="o">=</span> <span class="n">mregs</span> <span class="o">-</span> <span class="n">DAVINCI_BASE_OFFSET</span><span class="p">;</span>

	<span class="n">controller</span><span class="o">-&gt;</span><span class="n">musb</span> <span class="o">=</span> <span class="n">musb</span><span class="p">;</span>
	<span class="n">controller</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">cppi_controller_start</span><span class="p">;</span>
	<span class="n">controller</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">cppi_controller_stop</span><span class="p">;</span>
	<span class="n">controller</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">.</span><span class="n">channel_alloc</span> <span class="o">=</span> <span class="n">cppi_channel_allocate</span><span class="p">;</span>
	<span class="n">controller</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">.</span><span class="n">channel_release</span> <span class="o">=</span> <span class="n">cppi_channel_release</span><span class="p">;</span>
	<span class="n">controller</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">.</span><span class="n">channel_program</span> <span class="o">=</span> <span class="n">cppi_channel_program</span><span class="p">;</span>
	<span class="n">controller</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">.</span><span class="n">channel_abort</span> <span class="o">=</span> <span class="n">cppi_channel_abort</span><span class="p">;</span>

	<span class="cm">/* NOTE: allocating from on-chip SRAM would give the least</span>
<span class="cm">	 * contention for memory access, if that ever matters here.</span>
<span class="cm">	 */</span>

	<span class="cm">/* setup BufferPool */</span>
	<span class="n">controller</span><span class="o">-&gt;</span><span class="n">pool</span> <span class="o">=</span> <span class="n">dma_pool_create</span><span class="p">(</span><span class="s">&quot;cppi&quot;</span><span class="p">,</span>
			<span class="n">controller</span><span class="o">-&gt;</span><span class="n">musb</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cppi_descriptor</span><span class="p">),</span>
			<span class="n">CPPI_DESCRIPTOR_ALIGN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">controller</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">cppi_interrupt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;cppi-dma&quot;</span><span class="p">,</span> <span class="n">musb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;request_irq %d failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
			<span class="n">dma_controller_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">controller</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Destroy a previously-instantiated DMA controller.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dma_controller_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cppi</span>	<span class="o">*</span><span class="n">cppi</span><span class="p">;</span>

	<span class="n">cppi</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cppi</span><span class="p">,</span> <span class="n">controller</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cppi</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">cppi</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">cppi</span><span class="o">-&gt;</span><span class="n">musb</span><span class="p">);</span>

	<span class="cm">/* assert:  caller stopped the controller first */</span>
	<span class="n">dma_pool_destroy</span><span class="p">(</span><span class="n">cppi</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">cppi</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Context: controller irqlocked, endpoint selected</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cppi_channel_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cppi_channel</span>	<span class="o">*</span><span class="n">cppi_ch</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cppi</span>		<span class="o">*</span><span class="n">controller</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">mbase</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">tibase</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">value</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cppi_descriptor</span>	<span class="o">*</span><span class="n">queue</span><span class="p">;</span>

	<span class="n">cppi_ch</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cppi_channel</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>

	<span class="n">controller</span> <span class="o">=</span> <span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MUSB_DMA_STATUS_BUS_ABORT</span>:
	<span class="k">case</span> <span class="n">MUSB_DMA_STATUS_CORE_ABORT</span>:
		<span class="cm">/* from RX or TX fault irq handler */</span>
	<span class="k">case</span> <span class="n">MUSB_DMA_STATUS_BUSY</span>:
		<span class="cm">/* the hardware needs shutting down */</span>
		<span class="n">regs</span> <span class="o">=</span> <span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">hw_ep</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MUSB_DMA_STATUS_UNKNOWN</span>:
	<span class="k">case</span> <span class="n">MUSB_DMA_STATUS_FREE</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">transmit</span> <span class="o">&amp;&amp;</span> <span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">)</span>
		<span class="n">cppi_dump_rxq</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;/abort&quot;</span><span class="p">,</span> <span class="n">cppi_ch</span><span class="p">);</span>

	<span class="n">mbase</span> <span class="o">=</span> <span class="n">controller</span><span class="o">-&gt;</span><span class="n">mregs</span><span class="p">;</span>
	<span class="n">tibase</span> <span class="o">=</span> <span class="n">controller</span><span class="o">-&gt;</span><span class="n">tibase</span><span class="p">;</span>

	<span class="n">queue</span> <span class="o">=</span> <span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
	<span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* REVISIT should rely on caller having done this,</span>
<span class="cm">	 * and caller should rely on us not changing it.</span>
<span class="cm">	 * peripheral code is safe ... check host too.</span>
<span class="cm">	 */</span>
	<span class="n">musb_ep_select</span><span class="p">(</span><span class="n">mbase</span><span class="p">,</span> <span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">transmit</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cppi_tx_stateram</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">tx_ram</span><span class="p">;</span>
		<span class="cm">/* REVISIT put timeouts on these controller handshakes */</span>

		<span class="n">cppi_dump_tx</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">cppi_ch</span><span class="p">,</span> <span class="s">&quot; (teardown)&quot;</span><span class="p">);</span>

		<span class="cm">/* teardown DMA engine then usb core */</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">value</span> <span class="o">=</span> <span class="n">musb_readl</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">DAVINCI_TXCPPI_TEAR_REG</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="n">CPPI_TEAR_READY</span><span class="p">));</span>
		<span class="n">musb_writel</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">DAVINCI_TXCPPI_TEAR_REG</span><span class="p">,</span> <span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>

		<span class="n">tx_ram</span> <span class="o">=</span> <span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">state_ram</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">value</span> <span class="o">=</span> <span class="n">musb_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_ram</span><span class="o">-&gt;</span><span class="n">tx_complete</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mh">0xFFFFFFFC</span> <span class="o">!=</span> <span class="n">value</span><span class="p">);</span>

		<span class="cm">/* FIXME clean up the transfer state ... here?</span>
<span class="cm">		 * the completion routine should get called with</span>
<span class="cm">		 * an appropriate status code.</span>
<span class="cm">		 */</span>

		<span class="n">value</span> <span class="o">=</span> <span class="n">musb_readw</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">MUSB_TXCSR</span><span class="p">);</span>
		<span class="n">value</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MUSB_TXCSR_DMAENAB</span><span class="p">;</span>
		<span class="n">value</span> <span class="o">|=</span> <span class="n">MUSB_TXCSR_FLUSHFIFO</span><span class="p">;</span>
		<span class="n">musb_writew</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">MUSB_TXCSR</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
		<span class="n">musb_writew</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">MUSB_TXCSR</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * 1. Write to completion Ptr value 0x1(bit 0 set)</span>
<span class="cm">		 *    (write back mode)</span>
<span class="cm">		 * 2. Wait for abort interrupt and then put the channel in</span>
<span class="cm">		 *    compare mode by writing 1 to the tx_complete register.</span>
<span class="cm">		 */</span>
		<span class="n">cppi_reset_tx</span><span class="p">(</span><span class="n">tx_ram</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">musb_writel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_ram</span><span class="o">-&gt;</span><span class="n">tx_complete</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">cppi_dump_tx</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">cppi_ch</span><span class="p">,</span> <span class="s">&quot; (done teardown)&quot;</span><span class="p">);</span>

		<span class="cm">/* REVISIT tx side _should_ clean up the same way</span>
<span class="cm">		 * as the RX side ... this does no cleanup at all!</span>
<span class="cm">		 */</span>

	<span class="p">}</span> <span class="k">else</span> <span class="cm">/* RX */</span> <span class="p">{</span>
		<span class="n">u16</span>			<span class="n">csr</span><span class="p">;</span>

		<span class="cm">/* NOTE: docs don&#39;t guarantee any of this works ...  we</span>
<span class="cm">		 * expect that if the usb core stops telling the cppi core</span>
<span class="cm">		 * to pull more data from it, then it&#39;ll be safe to flush</span>
<span class="cm">		 * current RX DMA state iff any pending fifo transfer is done.</span>
<span class="cm">		 */</span>

		<span class="n">core_rxirq_disable</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* for host, ensure ReqPkt is never set again */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_host_active</span><span class="p">(</span><span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">musb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">value</span> <span class="o">=</span> <span class="n">musb_readl</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">DAVINCI_AUTOREQ_REG</span><span class="p">);</span>
			<span class="n">value</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">((</span><span class="mh">0x3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">*</span> <span class="mi">2</span><span class="p">));</span>
			<span class="n">musb_writel</span><span class="p">(</span><span class="n">tibase</span><span class="p">,</span> <span class="n">DAVINCI_AUTOREQ_REG</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">csr</span> <span class="o">=</span> <span class="n">musb_readw</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">MUSB_RXCSR</span><span class="p">);</span>

		<span class="cm">/* for host, clear (just) ReqPkt at end of current packet(s) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_host_active</span><span class="p">(</span><span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">musb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">csr</span> <span class="o">|=</span> <span class="n">MUSB_RXCSR_H_WZC_BITS</span><span class="p">;</span>
			<span class="n">csr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MUSB_RXCSR_H_REQPKT</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">csr</span> <span class="o">|=</span> <span class="n">MUSB_RXCSR_P_WZC_BITS</span><span class="p">;</span>

		<span class="cm">/* clear dma enable */</span>
		<span class="n">csr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">MUSB_RXCSR_DMAENAB</span><span class="p">);</span>
		<span class="n">musb_writew</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">MUSB_RXCSR</span><span class="p">,</span> <span class="n">csr</span><span class="p">);</span>
		<span class="n">csr</span> <span class="o">=</span> <span class="n">musb_readw</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">MUSB_RXCSR</span><span class="p">);</span>

		<span class="cm">/* Quiesce: wait for current dma to finish (if not cleanup).</span>
<span class="cm">		 * We can&#39;t use bit zero of stateram-&gt;rx_sop, since that</span>
<span class="cm">		 * refers to an entire &quot;DMA packet&quot; not just emptying the</span>
<span class="cm">		 * current fifo.  Most segments need multiple usb packets.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">MUSB_DMA_STATUS_BUSY</span><span class="p">)</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>

		<span class="cm">/* scan the current list, reporting any data that was</span>
<span class="cm">		 * transferred and acking any IRQ</span>
<span class="cm">		 */</span>
		<span class="n">cppi_rx_scan</span><span class="p">(</span><span class="n">controller</span><span class="p">,</span> <span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>

		<span class="cm">/* clobber the existing state once it&#39;s idle</span>
<span class="cm">		 *</span>
<span class="cm">		 * NOTE:  arguably, we should also wait for all the other</span>
<span class="cm">		 * RX channels to quiesce (how??) and then temporarily</span>
<span class="cm">		 * disable RXCPPI_CTRL_REG ... but it seems that we can</span>
<span class="cm">		 * rely on the controller restarting from state ram, with</span>
<span class="cm">		 * only RXCPPI_BUFCNT state being bogus.  BUFCNT will</span>
<span class="cm">		 * correct itself after the next DMA transfer though.</span>
<span class="cm">		 *</span>
<span class="cm">		 * REVISIT does using rndis mode change that?</span>
<span class="cm">		 */</span>
		<span class="n">cppi_reset_rx</span><span class="p">(</span><span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">state_ram</span><span class="p">);</span>

		<span class="cm">/* next DMA request _should_ load cppi head ptr */</span>

		<span class="cm">/* ... we don&#39;t &quot;free&quot; that list, only mutate it in place.  */</span>
		<span class="n">cppi_dump_rx</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">cppi_ch</span><span class="p">,</span> <span class="s">&quot; (done abort)&quot;</span><span class="p">);</span>

		<span class="cm">/* clean up previously pending bds */</span>
		<span class="n">cppi_bd_free</span><span class="p">(</span><span class="n">cppi_ch</span><span class="p">,</span> <span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">last_processed</span><span class="p">);</span>
		<span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">last_processed</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">cppi_descriptor</span>	<span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

			<span class="n">cppi_bd_free</span><span class="p">(</span><span class="n">cppi_ch</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
			<span class="n">queue</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">channel</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">MUSB_DMA_STATUS_FREE</span><span class="p">;</span>
	<span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">buf_dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">buf_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cppi_ch</span><span class="o">-&gt;</span><span class="n">maxpacket</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* TBD Queries:</span>
<span class="cm"> *</span>
<span class="cm"> * Power Management ... probably turn off cppi during suspend, restart;</span>
<span class="cm"> * check state ram?  Clocking is presumably shared with usb core.</span>
<span class="cm"> */</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
