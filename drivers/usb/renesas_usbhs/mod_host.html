<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › renesas_usbhs › mod_host.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>mod_host.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Renesas USB driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2011 Renesas Solutions Corp.</span>
<span class="cm"> * Kuninori Morimoto &lt;kuninori.morimoto.gx@renesas.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/usb/hcd.h&gt;</span>
<span class="cp">#include &quot;common.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> *** HARDWARE LIMITATION ***</span>
<span class="cm"> *</span>
<span class="cm"> * 1) renesas_usbhs has a limited number of controllable devices.</span>
<span class="cm"> *    it can control only 9 devices in generally.</span>
<span class="cm"> *	see DEVADDn / DCPMAXP / PIPEMAXP.</span>
<span class="cm"> *</span>
<span class="cm"> * 2) renesas_usbhs pipe number is limited.</span>
<span class="cm"> *    the pipe will be re-used for each devices.</span>
<span class="cm"> *    so, software should control DATA0/1 sequence of each devices.</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> *		image of mod_host</span>
<span class="cm"> *</span>
<span class="cm"> * +--------+</span>
<span class="cm"> * | udev 0 | --&gt; it is used when set address</span>
<span class="cm"> * +--------+</span>
<span class="cm"> *</span>
<span class="cm"> * +--------+					pipes are reused for each uep.</span>
<span class="cm"> * | udev 1 |-+- [uep 0 (dcp) ] --+		pipe will be switched when</span>
<span class="cm"> * +--------+ |			  |		other device requested</span>
<span class="cm"> *	      +- [uep 1 (bulk)]	--|---+		   +--------------+</span>
<span class="cm"> *	      |			  +--------------&gt; | pipe0 (dcp)  |</span>
<span class="cm"> *	      +- [uep 2 (bulk)]	-@    |		   +--------------+</span>
<span class="cm"> *				      |		   | pipe1 (isoc) |</span>
<span class="cm"> * +--------+			      |		   +--------------+</span>
<span class="cm"> * | udev 2 |-+- [uep 0 (dcp) ]	-@    +----------&gt; | pipe2 (bulk) |</span>
<span class="cm"> * +--------+ |					   +--------------+</span>
<span class="cm"> *	      +- [uep 1 (int) ]	----+	  +------&gt; | pipe3 (bulk) |</span>
<span class="cm"> *				    |	  |	   +--------------+</span>
<span class="cm"> * +--------+			    +-----|------&gt; | pipe4 (int)  |</span>
<span class="cm"> * | udev 3 |-+- [uep 0 (dcp) ]	-@	  |	   +--------------+</span>
<span class="cm"> * +--------+ |				  |	   | ....	  |</span>
<span class="cm"> *	      +- [uep 1 (bulk)]	-@	  |	   | ....	  |</span>
<span class="cm"> *	      |				  |</span>
<span class="cm"> *	      +- [uep 2 (bulk)]-----------+</span>
<span class="cm"> *</span>
<span class="cm"> * @ :	uep requested free pipe, but all have been used.</span>
<span class="cm"> *	now it is waiting for free pipe</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> *		struct</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usbhsh_request</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbhs_pkt</span>	<span class="n">pkt</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">usbhsh_device</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">usbv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">ep_list_head</span><span class="p">;</span> <span class="cm">/* list of usbhsh_ep */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">usbhsh_ep</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhs_pipe</span>	<span class="o">*</span><span class="n">pipe</span><span class="p">;</span>   <span class="cm">/* attached pipe */</span>
	<span class="k">struct</span> <span class="n">usbhsh_device</span>	<span class="o">*</span><span class="n">udev</span><span class="p">;</span>   <span class="cm">/* attached udev */</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">ep_list</span><span class="p">;</span> <span class="cm">/* list to usbhsh_device */</span>
<span class="p">};</span>

<span class="cp">#define USBHSH_DEVICE_MAX	10 </span><span class="cm">/* see DEVADDn / DCPMAXP / PIPEMAXP */</span><span class="cp"></span>
<span class="cp">#define USBHSH_PORT_MAX		 7 </span><span class="cm">/* see DEVADDn :: HUBPORT */</span><span class="cp"></span>
<span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhs_mod</span>	<span class="n">mod</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbhs_pipe</span>	<span class="o">*</span><span class="n">dcp</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">usbhsh_device</span>	<span class="n">udev</span><span class="p">[</span><span class="n">USBHSH_DEVICE_MAX</span><span class="p">];</span>

	<span class="n">u32</span>	<span class="n">port_stat</span><span class="p">;</span>	<span class="cm">/* USB_PORT_STAT_xxx */</span>

	<span class="k">struct</span> <span class="n">completion</span>	<span class="n">setup_ack_done</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">usbhsh_hcd_name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;renesas_usbhs host&quot;</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *		macro</span>
<span class="cm"> */</span>
<span class="cp">#define usbhsh_priv_to_hpriv(priv) \</span>
<span class="cp">	container_of(usbhs_mod_get(priv, USBHS_HOST), struct usbhsh_hpriv, mod)</span>

<span class="cp">#define __usbhsh_for_each_udev(start, pos, h, i)	\</span>
<span class="cp">	for (i = start, pos = (h)-&gt;udev + i;		\</span>
<span class="cp">	     i &lt; USBHSH_DEVICE_MAX;			\</span>
<span class="cp">	     i++, pos = (h)-&gt;udev + i)</span>

<span class="cp">#define usbhsh_for_each_udev(pos, hpriv, i)	\</span>
<span class="cp">	__usbhsh_for_each_udev(1, pos, hpriv, i)</span>

<span class="cp">#define usbhsh_for_each_udev_with_dev0(pos, hpriv, i)	\</span>
<span class="cp">	__usbhsh_for_each_udev(0, pos, hpriv, i)</span>

<span class="cp">#define usbhsh_hcd_to_hpriv(h)	(struct usbhsh_hpriv *)((h)-&gt;hcd_priv)</span>
<span class="cp">#define usbhsh_hcd_to_dev(h)	((h)-&gt;self.controller)</span>

<span class="cp">#define usbhsh_hpriv_to_priv(h)	((h)-&gt;mod.priv)</span>
<span class="cp">#define usbhsh_hpriv_to_dcp(h)	((h)-&gt;dcp)</span>
<span class="cp">#define usbhsh_hpriv_to_hcd(h)	\</span>
<span class="cp">	container_of((void *)h, struct usb_hcd, hcd_priv)</span>

<span class="cp">#define usbhsh_ep_to_uep(u)	((u)-&gt;hcpriv)</span>
<span class="cp">#define usbhsh_uep_to_pipe(u)	((u)-&gt;pipe)</span>
<span class="cp">#define usbhsh_uep_to_udev(u)	((u)-&gt;udev)</span>
<span class="cp">#define usbhsh_uep_to_ep(u)	((u)-&gt;ep)</span>

<span class="cp">#define usbhsh_urb_to_ureq(u)	((u)-&gt;hcpriv)</span>
<span class="cp">#define usbhsh_urb_to_usbv(u)	((u)-&gt;dev)</span>

<span class="cp">#define usbhsh_usbv_to_udev(d)	dev_get_drvdata(&amp;(d)-&gt;dev)</span>

<span class="cp">#define usbhsh_udev_to_usbv(h)	((h)-&gt;usbv)</span>
<span class="cp">#define usbhsh_udev_is_used(h)	usbhsh_udev_to_usbv(h)</span>

<span class="cp">#define usbhsh_pipe_to_uep(p)	((p)-&gt;mod_private)</span>

<span class="cp">#define usbhsh_device_parent(d)		(usbhsh_usbv_to_udev((d)-&gt;usbv-&gt;parent))</span>
<span class="cp">#define usbhsh_device_hubport(d)	((d)-&gt;usbv-&gt;portnum)</span>
<span class="cp">#define usbhsh_device_number(h, d)	((int)((d) - (h)-&gt;udev))</span>
<span class="cp">#define usbhsh_device_nth(h, d)		((h)-&gt;udev + d)</span>
<span class="cp">#define usbhsh_device0(h)		usbhsh_device_nth(h, 0)</span>

<span class="cp">#define usbhsh_port_stat_init(h)	((h)-&gt;port_stat = 0)</span>
<span class="cp">#define usbhsh_port_stat_set(h, s)	((h)-&gt;port_stat |= (s))</span>
<span class="cp">#define usbhsh_port_stat_clear(h, s)	((h)-&gt;port_stat &amp;= ~(s))</span>
<span class="cp">#define usbhsh_port_stat_get(h)		((h)-&gt;port_stat)</span>

<span class="cp">#define usbhsh_pkt_to_ureq(p)	\</span>
<span class="cp">	container_of((void *)p, struct usbhsh_request, pkt)</span>

<span class="cm">/*</span>
<span class="cm"> *		req alloc/free</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usbhsh_request</span> <span class="o">*</span><span class="nf">usbhsh_ureq_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
					       <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsh_request</span> <span class="o">*</span><span class="n">ureq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">usbhsh_hpriv_to_priv</span><span class="p">(</span><span class="n">hpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhs_priv_to_dev</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="n">ureq</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsh_request</span><span class="p">),</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ureq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ureq alloc fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">usbhs_pkt_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ureq</span><span class="o">-&gt;</span><span class="n">pkt</span><span class="p">);</span>
	<span class="n">ureq</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>
	<span class="n">usbhsh_urb_to_ureq</span><span class="p">(</span><span class="n">urb</span><span class="p">)</span> <span class="o">=</span> <span class="n">ureq</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ureq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbhsh_ureq_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">usbhsh_request</span> <span class="o">*</span><span class="n">ureq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">usbhsh_urb_to_ureq</span><span class="p">(</span><span class="n">ureq</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ureq</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ureq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *		status</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsh_is_running</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * we can decide some device is attached or not</span>
<span class="cm">	 * by checking mod.irq_attch</span>
<span class="cm">	 * see</span>
<span class="cm">	 *	usbhsh_irq_attch()</span>
<span class="cm">	 *	usbhsh_irq_dtch()</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">.</span><span class="n">irq_attch</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *		pipe control</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbhsh_endpoint_sequence_save</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">usbhs_pkt</span> <span class="o">*</span><span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maxp</span> <span class="o">=</span> <span class="n">usb_endpoint_maxp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* DCP is out of sequence control */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipecontrol</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * renesas_usbhs pipe has a limitation in a number.</span>
<span class="cm">	 * So, driver should re-use the limited pipe for each device/endpoint.</span>
<span class="cm">	 * DATA0/1 sequence should be saved for it.</span>
<span class="cm">	 * see [image of mod_host]</span>
<span class="cm">	 *     [HARDWARE LIMITATION]</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * next sequence depends on actual_length</span>
<span class="cm">	 *</span>
<span class="cm">	 * ex) actual_length = 1147, maxp = 512</span>
<span class="cm">	 * data0 : 512</span>
<span class="cm">	 * data1 : 512</span>
<span class="cm">	 * data0 : 123</span>
<span class="cm">	 * data1 is the next sequence</span>
<span class="cm">	 */</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="n">maxp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">%</span> <span class="n">maxp</span><span class="p">)</span>
		<span class="n">t</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">zero</span><span class="p">)</span>
		<span class="n">t</span><span class="o">++</span><span class="p">;</span>
	<span class="n">t</span> <span class="o">%=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span>
		<span class="n">usb_dotoggle</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			     <span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">),</span>
			     <span class="n">usb_pipeout</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usbhsh_device</span> <span class="o">*</span><span class="n">usbhsh_device_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsh_pipe_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">usbhsh_hpriv_to_priv</span><span class="p">(</span><span class="n">hpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhsh_ep</span> <span class="o">*</span><span class="n">uep</span> <span class="o">=</span> <span class="n">usbhsh_ep_to_uep</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhsh_device</span> <span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">usbhsh_device_get</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhs_priv_to_dev</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dir_in_req</span> <span class="o">=</span> <span class="o">!!</span><span class="n">usb_pipein</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">is_dcp</span> <span class="o">=</span> <span class="n">usb_endpoint_xfer_control</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">dir_in</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="cm">/********************  spin lock ********************/</span>
	<span class="n">usbhs_lock</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">usbhsh_uep_to_pipe</span><span class="p">(</span><span class="n">uep</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;uep already has pipe</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">usbhsh_pipe_attach_done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">usbhs_for_each_pipe_with_dcp</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="n">priv</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* check pipe type */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usbhs_pipe_type_is</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="n">usb_endpoint_type</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* check pipe direction if normal pipe */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_dcp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dir_in</span> <span class="o">=</span> <span class="o">!!</span><span class="n">usbhs_pipe_is_dir_in</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="p">(</span><span class="n">dir_in</span> <span class="o">-</span> <span class="n">dir_in_req</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* check pipe is free */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">usbhsh_pipe_to_uep</span><span class="p">(</span><span class="n">pipe</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * attach pipe to uep</span>
<span class="cm">		 *</span>
<span class="cm">		 * usbhs_pipe_config_update() should be called after</span>
<span class="cm">		 * usbhs_set_device_config()</span>
<span class="cm">		 * see</span>
<span class="cm">		 *  DCPMAXP/PIPEMAXP</span>
<span class="cm">		 */</span>
		<span class="n">usbhsh_uep_to_pipe</span><span class="p">(</span><span class="n">uep</span><span class="p">)</span>		<span class="o">=</span> <span class="n">pipe</span><span class="p">;</span>
		<span class="n">usbhsh_pipe_to_uep</span><span class="p">(</span><span class="n">pipe</span><span class="p">)</span>	<span class="o">=</span> <span class="n">uep</span><span class="p">;</span>

		<span class="n">usbhs_pipe_config_update</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span>
					 <span class="n">usbhsh_device_number</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">udev</span><span class="p">),</span>
					 <span class="n">usb_endpoint_num</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span>
					 <span class="n">usb_endpoint_maxp</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s [%d-%d(%s:%s)]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">usbhsh_device_number</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">udev</span><span class="p">),</span>
			<span class="n">usb_endpoint_num</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span>
			<span class="n">usbhs_pipe_name</span><span class="p">(</span><span class="n">pipe</span><span class="p">),</span>
			<span class="n">dir_in_req</span> <span class="o">?</span> <span class="s">&quot;in&quot;</span> <span class="o">:</span> <span class="s">&quot;out&quot;</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">usbhsh_pipe_attach_done:</span>
	<span class="n">usbhs_unlock</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/********************  spin unlock ******************/</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbhsh_pipe_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">usbhsh_ep</span> <span class="o">*</span><span class="n">uep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">usbhsh_hpriv_to_priv</span><span class="p">(</span><span class="n">hpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhs_priv_to_dev</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/********************  spin lock ********************/</span>
	<span class="n">usbhs_lock</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">pipe</span> <span class="o">=</span> <span class="n">usbhsh_uep_to_pipe</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pipe</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;uep doens&#39;t have pipe</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">usbhsh_uep_to_ep</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">usbhsh_device</span> <span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">usbhsh_uep_to_udev</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>

		<span class="cm">/* detach pipe from uep */</span>
		<span class="n">usbhsh_uep_to_pipe</span><span class="p">(</span><span class="n">uep</span><span class="p">)</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">usbhsh_pipe_to_uep</span><span class="p">(</span><span class="n">pipe</span><span class="p">)</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s [%d-%d(%s)]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">usbhsh_device_number</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">udev</span><span class="p">),</span>
			<span class="n">usb_endpoint_num</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">),</span>
			<span class="n">usbhs_pipe_name</span><span class="p">(</span><span class="n">pipe</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">usbhs_unlock</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/********************  spin unlock ******************/</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *		endpoint control</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsh_endpoint_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
				  <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">usbhsh_hpriv_to_priv</span><span class="p">(</span><span class="n">hpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhsh_device</span> <span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">usbhsh_device_get</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbhsh_ep</span> <span class="o">*</span><span class="n">uep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhs_priv_to_dev</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">uep</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsh_ep</span><span class="p">),</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uep</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;usbhsh_ep alloc fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/********************  spin lock ********************/</span>
	<span class="n">usbhs_lock</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * init endpoint</span>
<span class="cm">	 */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uep</span><span class="o">-&gt;</span><span class="n">ep_list</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uep</span><span class="o">-&gt;</span><span class="n">ep_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">ep_list_head</span><span class="p">);</span>

	<span class="n">usbhsh_uep_to_udev</span><span class="p">(</span><span class="n">uep</span><span class="p">)</span>	<span class="o">=</span> <span class="n">udev</span><span class="p">;</span>
	<span class="n">usbhsh_uep_to_ep</span><span class="p">(</span><span class="n">uep</span><span class="p">)</span>	<span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
	<span class="n">usbhsh_ep_to_uep</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span>	<span class="o">=</span> <span class="n">uep</span><span class="p">;</span>

	<span class="n">usbhs_unlock</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/********************  spin unlock ******************/</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s [%d-%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="n">usbhsh_device_number</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">udev</span><span class="p">),</span>
		<span class="n">usb_endpoint_num</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbhsh_endpoint_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">usbhsh_hpriv_to_priv</span><span class="p">(</span><span class="n">hpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhs_priv_to_dev</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhsh_ep</span> <span class="o">*</span><span class="n">uep</span> <span class="o">=</span> <span class="n">usbhsh_ep_to_uep</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uep</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s [%d-%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="n">usbhsh_device_number</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">usbhsh_uep_to_udev</span><span class="p">(</span><span class="n">uep</span><span class="p">)),</span>
		<span class="n">usb_endpoint_num</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usbhsh_uep_to_pipe</span><span class="p">(</span><span class="n">uep</span><span class="p">))</span>
		<span class="n">usbhsh_pipe_detach</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">uep</span><span class="p">);</span>

	<span class="cm">/********************  spin lock ********************/</span>
	<span class="n">usbhs_lock</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* remove this endpoint from udev */</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uep</span><span class="o">-&gt;</span><span class="n">ep_list</span><span class="p">);</span>

	<span class="n">usbhsh_uep_to_udev</span><span class="p">(</span><span class="n">uep</span><span class="p">)</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">usbhsh_uep_to_ep</span><span class="p">(</span><span class="n">uep</span><span class="p">)</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">usbhsh_ep_to_uep</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">usbhs_unlock</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/********************  spin unlock ******************/</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbhsh_endpoint_detach_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">usbhsh_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsh_ep</span> <span class="o">*</span><span class="n">uep</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">uep</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">ep_list_head</span><span class="p">,</span> <span class="n">ep_list</span><span class="p">)</span>
		<span class="n">usbhsh_endpoint_detach</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">usbhsh_uep_to_ep</span><span class="p">(</span><span class="n">uep</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *		device control</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsh_connected_to_rhdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">usbhsh_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usbv</span> <span class="o">=</span> <span class="n">usbhsh_udev_to_usbv</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span> <span class="o">==</span> <span class="n">usbv</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsh_device_has_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsh_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">ep_list_head</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usbhsh_device</span> <span class="o">*</span><span class="nf">usbhsh_device_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usbv</span> <span class="o">=</span> <span class="n">usbhsh_urb_to_usbv</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhsh_device</span> <span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">usbhsh_usbv_to_udev</span><span class="p">(</span><span class="n">usbv</span><span class="p">);</span>

	<span class="cm">/* usbhsh_device_attach() is still not called */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udev</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* if it is device0, return it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">usb_pipedevice</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">usbhsh_device0</span><span class="p">(</span><span class="n">hpriv</span><span class="p">);</span>

	<span class="cm">/* return attached device */</span>
	<span class="k">return</span> <span class="n">udev</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usbhsh_device</span> <span class="o">*</span><span class="nf">usbhsh_device_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsh_device</span> <span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbhsh_device</span> <span class="o">*</span><span class="n">udev0</span> <span class="o">=</span> <span class="n">usbhsh_device0</span><span class="p">(</span><span class="n">hpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhsh_device</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">usbhsh_hpriv_to_hcd</span><span class="p">(</span><span class="n">hpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhsh_hcd_to_dev</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usbv</span> <span class="o">=</span> <span class="n">usbhsh_urb_to_usbv</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">usbhsh_hpriv_to_priv</span><span class="p">(</span><span class="n">hpriv</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">upphub</span><span class="p">,</span> <span class="n">hubport</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This function should be called only while urb is pointing to device0.</span>
<span class="cm">	 * It will attach unused usbhsh_device to urb (usbv),</span>
<span class="cm">	 * and initialize device0.</span>
<span class="cm">	 * You can use usbhsh_device_get() to get &quot;current&quot; udev,</span>
<span class="cm">	 * and usbhsh_usbv_to_udev() is for &quot;attached&quot; udev.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">usb_pipedevice</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s fail: urb isn&#39;t pointing device0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/********************  spin lock ********************/</span>
	<span class="n">usbhs_lock</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * find unused device</span>
<span class="cm">	 */</span>
	<span class="n">usbhsh_for_each_udev</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">hpriv</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">usbhsh_udev_is_used</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">udev</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * usbhsh_usbv_to_udev()</span>
<span class="cm">		 * usbhsh_udev_to_usbv()</span>
<span class="cm">		 * will be enable</span>
<span class="cm">		 */</span>
		<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usbv</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">udev</span><span class="p">);</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">usbv</span> <span class="o">=</span> <span class="n">usbv</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">usbhs_unlock</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/********************  spin unlock ******************/</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no free usbhsh_device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usbhsh_device_has_endpoint</span><span class="p">(</span><span class="n">udev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;udev have old endpoint</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">usbhsh_endpoint_detach_all</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">udev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usbhsh_device_has_endpoint</span><span class="p">(</span><span class="n">udev0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;udev0 have old endpoint</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">usbhsh_endpoint_detach_all</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">udev0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* uep will be attached */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev0</span><span class="o">-&gt;</span><span class="n">ep_list_head</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">ep_list_head</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * set device0 config</span>
<span class="cm">	 */</span>
	<span class="n">usbhs_set_device_config</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">usbv</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * set new device config</span>
<span class="cm">	 */</span>
	<span class="n">upphub</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hubport</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usbhsh_connected_to_rhdev</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* if udev is not connected to rhdev, it means parent is Hub */</span>
		<span class="k">struct</span> <span class="n">usbhsh_device</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">usbhsh_device_parent</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

		<span class="n">upphub</span>	<span class="o">=</span> <span class="n">usbhsh_device_number</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
		<span class="n">hubport</span>	<span class="o">=</span> <span class="n">usbhsh_device_hubport</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s connecte to Hub [%d:%d](%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">upphub</span><span class="p">,</span> <span class="n">hubport</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">usbhs_set_device_config</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span>
			       <span class="n">usbhsh_device_number</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">udev</span><span class="p">),</span>
			       <span class="n">upphub</span><span class="p">,</span> <span class="n">hubport</span><span class="p">,</span> <span class="n">usbv</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s [%d](%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="n">usbhsh_device_number</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">udev</span><span class="p">),</span> <span class="n">udev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">udev</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbhsh_device_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">usbhsh_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">usbhsh_hpriv_to_hcd</span><span class="p">(</span><span class="n">hpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">usbhsh_hpriv_to_priv</span><span class="p">(</span><span class="n">hpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhsh_hcd_to_dev</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usbv</span> <span class="o">=</span> <span class="n">usbhsh_udev_to_usbv</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s [%d](%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="n">usbhsh_device_number</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">udev</span><span class="p">),</span> <span class="n">udev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usbhsh_device_has_endpoint</span><span class="p">(</span><span class="n">udev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;udev still have endpoint</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">usbhsh_endpoint_detach_all</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">udev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * There is nothing to do if it is device0.</span>
<span class="cm">	 * see</span>
<span class="cm">	 *  usbhsh_device_attach()</span>
<span class="cm">	 *  usbhsh_device_get()</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">usbhsh_device_number</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">udev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/********************  spin lock ********************/</span>
	<span class="n">usbhs_lock</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * usbhsh_usbv_to_udev()</span>
<span class="cm">	 * usbhsh_udev_to_usbv()</span>
<span class="cm">	 * will be disable</span>
<span class="cm">	 */</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usbv</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">udev</span><span class="o">-&gt;</span><span class="n">usbv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">usbhs_unlock</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/********************  spin unlock ******************/</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *		queue push/pop</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbhsh_queue_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usbhs_pkt</span> <span class="o">*</span><span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsh_request</span> <span class="o">*</span><span class="n">ureq</span> <span class="o">=</span> <span class="n">usbhsh_pkt_to_ureq</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">usbhsh_priv_to_hpriv</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">usbhsh_hpriv_to_hcd</span><span class="p">(</span><span class="n">hpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span> <span class="o">=</span> <span class="n">ureq</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhs_priv_to_dev</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pkt doesn&#39;t have urb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usbhsh_is_running</span><span class="p">(</span><span class="n">hpriv</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>

	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">actual</span><span class="p">;</span>
	<span class="n">usbhsh_ureq_free</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">ureq</span><span class="p">);</span>

	<span class="n">usbhsh_endpoint_sequence_save</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
	<span class="n">usbhsh_pipe_detach</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">usbhsh_ep_to_uep</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">));</span>

	<span class="n">usb_hcd_unlink_urb_from_ep</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="n">usb_hcd_giveback_urb</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsh_queue_push</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
			     <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">usbhsh_hcd_to_hpriv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhsh_ep</span> <span class="o">*</span><span class="n">uep</span> <span class="o">=</span> <span class="n">usbhsh_ep_to_uep</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_pipe</span> <span class="o">*</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">usbhsh_uep_to_pipe</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhsh_hcd_to_dev</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhsh_request</span> <span class="o">*</span><span class="n">ureq</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">sequence</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipeisoc</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pipe iso is not supported now</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* this ureq will be freed on usbhsh_queue_done() */</span>
	<span class="n">ureq</span> <span class="o">=</span> <span class="n">usbhsh_ureq_alloc</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ureq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ureq alloc fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipein</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span>
		<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usbhs_fifo_pio_pop_handler</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usbhs_fifo_pio_push_handler</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">+</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">-</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">;</span>

	<span class="n">sequence</span> <span class="o">=</span> <span class="n">usb_gettoggle</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">),</span>
				 <span class="n">usb_pipeout</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">));</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">usbhs_pkt_push</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ureq</span><span class="o">-&gt;</span><span class="n">pkt</span><span class="p">,</span> <span class="n">usbhsh_queue_done</span><span class="p">,</span>
		       <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_ZERO_PACKET</span><span class="p">),</span>
		       <span class="n">sequence</span><span class="p">);</span>

	<span class="n">usbhs_pkt_start</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbhsh_queue_force_pop</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">usbhs_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhs_pkt</span> <span class="o">*</span><span class="n">pkt</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pkt</span> <span class="o">=</span> <span class="n">usbhs_pkt_pop</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pkt</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * if all packet are gone, usbhsh_endpoint_disable()</span>
<span class="cm">		 * will be called.</span>
<span class="cm">		 * then, attached device/endpoint/pipe will be detached</span>
<span class="cm">		 */</span>
		<span class="n">usbhsh_queue_done</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbhsh_queue_force_pop_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhs_pipe</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">usbhs_for_each_pipe_with_dcp</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">priv</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
		<span class="n">usbhsh_queue_force_pop</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *		DCP setup stage</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsh_is_request_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="p">)</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">setup_packet</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">DeviceOutRequest</span>    <span class="o">==</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">USB_REQ_SET_ADDRESS</span> <span class="o">==</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">bRequest</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbhsh_setup_stage_packet_push</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">usbhs_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">usbhsh_hpriv_to_priv</span><span class="p">(</span><span class="n">hpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhs_priv_to_dev</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * wait setup packet ACK</span>
<span class="cm">	 * see</span>
<span class="cm">	 *	usbhsh_irq_setup_ack()</span>
<span class="cm">	 *	usbhsh_irq_setup_err()</span>
<span class="cm">	 */</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">setup_ack_done</span><span class="p">);</span>

	<span class="cm">/* copy original request */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">setup_packet</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ctrlrequest</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * renesas_usbhs can not use original usb address.</span>
<span class="cm">	 * see HARDWARE LIMITATION.</span>
<span class="cm">	 * modify usb address here to use attached device.</span>
<span class="cm">	 * see usbhsh_device_attach()</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usbhsh_is_request_address</span><span class="p">(</span><span class="n">urb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usbv</span> <span class="o">=</span> <span class="n">usbhsh_urb_to_usbv</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">usbhsh_device</span> <span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">usbhsh_usbv_to_udev</span><span class="p">(</span><span class="n">usbv</span><span class="p">);</span>

		<span class="cm">/* udev is a attached device */</span>
		<span class="n">req</span><span class="p">.</span><span class="n">wValue</span> <span class="o">=</span> <span class="n">usbhsh_device_number</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">udev</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;create new address - %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">req</span><span class="p">.</span><span class="n">wValue</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* set request */</span>
	<span class="n">usbhs_usbreq_set_val</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * wait setup packet ACK</span>
<span class="cm">	 */</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">setup_ack_done</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *		DCP data stage</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbhsh_data_stage_packet_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">usbhs_pkt</span> <span class="o">*</span><span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsh_request</span> <span class="o">*</span><span class="n">ureq</span> <span class="o">=</span> <span class="n">usbhsh_pkt_to_ureq</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">usbhsh_priv_to_hpriv</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="cm">/* this ureq was connected to urb when usbhsh_urb_enqueue()  */</span>

	<span class="n">usbhsh_ureq_free</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">ureq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsh_data_stage_packet_push</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">usbhs_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span>
					 <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>

<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsh_request</span> <span class="o">*</span><span class="n">ureq</span><span class="p">;</span>

	<span class="cm">/* this ureq will be freed on usbhsh_data_stage_packet_done() */</span>
	<span class="n">ureq</span> <span class="o">=</span> <span class="n">usbhsh_ureq_alloc</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ureq</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipein</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span>
		<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usbhs_dcp_data_stage_in_handler</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usbhs_dcp_data_stage_out_handler</span><span class="p">;</span>

	<span class="n">usbhs_pkt_push</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ureq</span><span class="o">-&gt;</span><span class="n">pkt</span><span class="p">,</span>
		       <span class="n">usbhsh_data_stage_packet_done</span><span class="p">,</span>
		       <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span>
		       <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">,</span>
		       <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_ZERO_PACKET</span><span class="p">),</span>
		       <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *		DCP status stage</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsh_status_stage_packet_push</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">usbhs_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span>
					    <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsh_request</span> <span class="o">*</span><span class="n">ureq</span><span class="p">;</span>

	<span class="cm">/* This ureq will be freed on usbhsh_queue_done() */</span>
	<span class="n">ureq</span> <span class="o">=</span> <span class="n">usbhsh_ureq_alloc</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ureq</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipein</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span>
		<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usbhs_dcp_status_stage_in_handler</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usbhs_dcp_status_stage_out_handler</span><span class="p">;</span>

	<span class="n">usbhs_pkt_push</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ureq</span><span class="o">-&gt;</span><span class="n">pkt</span><span class="p">,</span>
		       <span class="n">usbhsh_queue_done</span><span class="p">,</span>
		       <span class="nb">NULL</span><span class="p">,</span>
		       <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">,</span>
		       <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsh_dcp_queue_push</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
				 <span class="n">gfp_t</span> <span class="n">mflags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">usbhsh_hcd_to_hpriv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhsh_ep</span> <span class="o">*</span><span class="n">uep</span> <span class="o">=</span> <span class="n">usbhsh_ep_to_uep</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_pipe</span> <span class="o">*</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">usbhsh_uep_to_pipe</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhsh_hcd_to_dev</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * setup stage</span>
<span class="cm">	 *</span>
<span class="cm">	 * usbhsh_send_setup_stage_packet() wait SACK/SIGN</span>
<span class="cm">	 */</span>
	<span class="n">usbhsh_setup_stage_packet_push</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * data stage</span>
<span class="cm">	 *</span>
<span class="cm">	 * It is pushed only when urb has buffer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">usbhsh_data_stage_packet_push</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">mflags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;data stage failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * status stage</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">usbhsh_status_stage_packet_push</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">mflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;status stage failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * start pushed packets</span>
<span class="cm">	 */</span>
	<span class="n">usbhs_pkt_start</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *		dma map functions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsh_dma_map_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_pkt</span> <span class="o">*</span><span class="n">pkt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *		for hc_driver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsh_host_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbhsh_host_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsh_urb_enqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
			      <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">usbhsh_hcd_to_hpriv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">usbhsh_hpriv_to_priv</span><span class="p">(</span><span class="n">hpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhs_priv_to_dev</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbhsh_device</span> <span class="o">*</span><span class="n">new_udev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_dir_in</span> <span class="o">=</span> <span class="n">usb_pipein</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">is_dir_in</span> <span class="o">?</span> <span class="s">&quot;in&quot;</span> <span class="o">:</span> <span class="s">&quot;out&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usbhsh_is_running</span><span class="p">(</span><span class="n">hpriv</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;host is not running</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">usbhsh_urb_enqueue_error_not_linked</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_hcd_link_urb_to_ep</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;urb link failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">usbhsh_urb_enqueue_error_not_linked</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * attach udev if needed</span>
<span class="cm">	 * see [image of mod_host]</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usbhsh_device_get</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">urb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">new_udev</span> <span class="o">=</span> <span class="n">usbhsh_device_attach</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_udev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device attach failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">usbhsh_urb_enqueue_error_not_linked</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * attach endpoint if needed</span>
<span class="cm">	 * see [image of mod_host]</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usbhsh_ep_to_uep</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">usbhsh_endpoint_attach</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;endpoint attach failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">usbhsh_urb_enqueue_error_free_device</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * attach pipe to endpoint</span>
<span class="cm">	 * see [image of mod_host]</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1024</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">usbhsh_pipe_attach</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pipe attach failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">usbhsh_urb_enqueue_error_free_endpoint</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * push packet</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipecontrol</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">usbhsh_dcp_queue_push</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">usbhsh_queue_push</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">usbhsh_urb_enqueue_error_free_endpoint:</span>
	<span class="n">usbhsh_endpoint_detach</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
<span class="nl">usbhsh_urb_enqueue_error_free_device:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_udev</span><span class="p">)</span>
		<span class="n">usbhsh_device_detach</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">new_udev</span><span class="p">);</span>
<span class="nl">usbhsh_urb_enqueue_error_not_linked:</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsh_urb_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">usbhsh_hcd_to_hpriv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhsh_request</span> <span class="o">*</span><span class="n">ureq</span> <span class="o">=</span> <span class="n">usbhsh_urb_to_ureq</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ureq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">usbhsh_hpriv_to_priv</span><span class="p">(</span><span class="n">hpriv</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">usbhs_pkt</span> <span class="o">*</span><span class="n">pkt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ureq</span><span class="o">-&gt;</span><span class="n">pkt</span><span class="p">;</span>

		<span class="n">usbhs_pkt_pop</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
		<span class="n">usbhsh_queue_done</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbhsh_endpoint_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsh_ep</span> <span class="o">*</span><span class="n">uep</span> <span class="o">=</span> <span class="n">usbhsh_ep_to_uep</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhsh_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * this function might be called manytimes by same hcd/ep</span>
<span class="cm">	 * in-endpoint == out-endpoint if ep == dcp.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uep</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">udev</span>	<span class="o">=</span> <span class="n">usbhsh_uep_to_udev</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>
	<span class="n">hpriv</span>	<span class="o">=</span> <span class="n">usbhsh_hcd_to_hpriv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="n">usbhsh_endpoint_detach</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * if there is no endpoint,</span>
<span class="cm">	 * free device</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usbhsh_device_has_endpoint</span><span class="p">(</span><span class="n">udev</span><span class="p">))</span>
		<span class="n">usbhsh_device_detach</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">udev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsh_hub_status_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">usbhsh_hcd_to_hpriv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">usbhsh_hpriv_to_priv</span><span class="p">(</span><span class="n">hpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhs_priv_to_dev</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">roothub_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* only 1 root hub */</span>

	<span class="cm">/*</span>
<span class="cm">	 * does port stat was changed ?</span>
<span class="cm">	 * check USB_PORT_STAT_C_xxx &lt;&lt; 16</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usbhsh_port_stat_get</span><span class="p">(</span><span class="n">hpriv</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFF0000</span><span class="p">)</span>
		<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">roothub_id</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s (%02x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">!!</span><span class="p">(</span><span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__usbhsh_hub_hub_feature</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
				    <span class="n">u16</span> <span class="n">typeReq</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wValue</span><span class="p">,</span>
				    <span class="n">u16</span> <span class="n">wIndex</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wLength</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">usbhsh_hpriv_to_priv</span><span class="p">(</span><span class="n">hpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhs_priv_to_dev</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">wValue</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">C_HUB_OVER_CURRENT</span>:
	<span class="k">case</span> <span class="n">C_HUB_LOCAL_POWER</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s :: C_HUB_xx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__usbhsh_hub_port_feature</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
				     <span class="n">u16</span> <span class="n">typeReq</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wValue</span><span class="p">,</span>
				     <span class="n">u16</span> <span class="n">wIndex</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wLength</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">usbhsh_hpriv_to_priv</span><span class="p">(</span><span class="n">hpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhs_priv_to_dev</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">enable</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeReq</span> <span class="o">==</span> <span class="n">SetPortFeature</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">speed</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">roothub_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* only 1 root hub */</span>

	<span class="cm">/* common error */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wIndex</span> <span class="o">&gt;</span> <span class="n">roothub_id</span> <span class="o">||</span> <span class="n">wLength</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>

	<span class="cm">/* check wValue */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">wValue</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_POWER</span>:
		<span class="n">usbhs_vbus_ctrl</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">enable</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s :: USB_PORT_FEAT_POWER</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">USB_PORT_FEAT_ENABLE</span>:
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_SUSPEND</span>:
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_ENABLE</span>:
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_SUSPEND</span>:
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_CONNECTION</span>:
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_OVER_CURRENT</span>:
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_RESET</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s :: USB_PORT_FEAT_xxx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">USB_PORT_FEAT_RESET</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enable</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">usbhsh_port_stat_clear</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span>
				       <span class="n">USB_PORT_STAT_HIGH_SPEED</span> <span class="o">|</span>
				       <span class="n">USB_PORT_STAT_LOW_SPEED</span><span class="p">);</span>

		<span class="n">usbhsh_queue_force_pop_all</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

		<span class="n">usbhs_bus_send_reset</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
		<span class="n">usbhs_bus_send_sof_enable</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">timeout</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">usbhs_bus_get_speed</span><span class="p">(</span><span class="n">priv</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">USB_SPEED_LOW</span>:
				<span class="n">speed</span> <span class="o">=</span> <span class="n">USB_PORT_STAT_LOW_SPEED</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">got_usb_bus_speed</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">USB_SPEED_HIGH</span>:
				<span class="n">speed</span> <span class="o">=</span> <span class="n">USB_PORT_STAT_HIGH_SPEED</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">got_usb_bus_speed</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">USB_SPEED_FULL</span>:
				<span class="n">speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">got_usb_bus_speed</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>

<span class="nl">got_usb_bus_speed:</span>
		<span class="n">usbhsh_port_stat_set</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">speed</span><span class="p">);</span>
		<span class="n">usbhsh_port_stat_set</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">USB_PORT_STAT_ENABLE</span><span class="p">);</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s :: USB_PORT_FEAT_RESET (speed = %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">speed</span><span class="p">);</span>

		<span class="cm">/* status change is not needed */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* set/clear status */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span>
		<span class="n">usbhsh_port_stat_set</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">wValue</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">usbhsh_port_stat_clear</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">wValue</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__usbhsh_hub_get_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
				   <span class="n">u16</span> <span class="n">typeReq</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wValue</span><span class="p">,</span>
				   <span class="n">u16</span> <span class="n">wIndex</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wLength</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">usbhsh_hpriv_to_priv</span><span class="p">(</span><span class="n">hpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_hub_descriptor</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub_descriptor</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhs_priv_to_dev</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">roothub_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* only 1 root hub */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">typeReq</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">GetHubStatus</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s :: GetHubStatus</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

		<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">GetPortStatus</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">wIndex</span> <span class="o">!=</span> <span class="n">roothub_id</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s :: GetPortStatus</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="o">*</span><span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">usbhsh_port_stat_get</span><span class="p">(</span><span class="n">hpriv</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">GetHubDescriptor</span>:
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span>		<span class="o">=</span> <span class="mh">0x29</span><span class="p">;</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bHubContrCurrent</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bNbrPorts</span>			<span class="o">=</span> <span class="n">roothub_id</span><span class="p">;</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bDescLength</span>		<span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bPwrOn2PwrGood</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">wHubCharacteristics</span>	<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0011</span><span class="p">);</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hs</span><span class="p">.</span><span class="n">DeviceRemovable</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>	<span class="o">=</span> <span class="p">(</span><span class="n">roothub_id</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hs</span><span class="p">.</span><span class="n">DeviceRemovable</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>	<span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s :: GetHubDescriptor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsh_hub_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="n">u16</span> <span class="n">typeReq</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wValue</span><span class="p">,</span>
			      <span class="n">u16</span> <span class="n">wIndex</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wLength</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">usbhsh_hcd_to_hpriv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">usbhsh_hpriv_to_priv</span><span class="p">(</span><span class="n">hpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhs_priv_to_dev</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">typeReq</span><span class="p">)</span> <span class="p">{</span>

	<span class="cm">/* Hub Feature */</span>
	<span class="k">case</span> <span class="n">ClearHubFeature</span>:
	<span class="k">case</span> <span class="n">SetHubFeature</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__usbhsh_hub_hub_feature</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">typeReq</span><span class="p">,</span>
					       <span class="n">wValue</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">wLength</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* Port Feature */</span>
	<span class="k">case</span> <span class="n">SetPortFeature</span>:
	<span class="k">case</span> <span class="n">ClearPortFeature</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__usbhsh_hub_port_feature</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">typeReq</span><span class="p">,</span>
						<span class="n">wValue</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">wLength</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* Get status */</span>
	<span class="k">case</span> <span class="n">GetHubStatus</span>:
	<span class="k">case</span> <span class="n">GetPortStatus</span>:
	<span class="k">case</span> <span class="n">GetHubDescriptor</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__usbhsh_hub_get_status</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">typeReq</span><span class="p">,</span>
					      <span class="n">wValue</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">wLength</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;typeReq = %x, ret = %d, port_stat = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">typeReq</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">usbhsh_port_stat_get</span><span class="p">(</span><span class="n">hpriv</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">hc_driver</span> <span class="n">usbhsh_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">description</span> <span class="o">=</span>		<span class="n">usbhsh_hcd_name</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hcd_priv_size</span> <span class="o">=</span>	<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsh_hpriv</span><span class="p">),</span>

	<span class="cm">/*</span>
<span class="cm">	 * generic hardware linkage</span>
<span class="cm">	 */</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span>		<span class="n">HCD_USB2</span><span class="p">,</span>

	<span class="p">.</span><span class="n">start</span> <span class="o">=</span>		<span class="n">usbhsh_host_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span> <span class="o">=</span>			<span class="n">usbhsh_host_stop</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * managing i/o requests and associated device resources</span>
<span class="cm">	 */</span>
	<span class="p">.</span><span class="n">urb_enqueue</span> <span class="o">=</span>		<span class="n">usbhsh_urb_enqueue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">urb_dequeue</span> <span class="o">=</span>		<span class="n">usbhsh_urb_dequeue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">endpoint_disable</span> <span class="o">=</span>	<span class="n">usbhsh_endpoint_disable</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * root hub</span>
<span class="cm">	 */</span>
	<span class="p">.</span><span class="n">hub_status_data</span> <span class="o">=</span>	<span class="n">usbhsh_hub_status_data</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hub_control</span> <span class="o">=</span>		<span class="n">usbhsh_hub_control</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *		interrupt functions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsh_irq_attch</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">usbhs_irq_state</span> <span class="o">*</span><span class="n">irq_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">usbhsh_priv_to_hpriv</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhs_priv_to_dev</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device attached</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">usbhsh_port_stat_set</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">USB_PORT_STAT_CONNECTION</span><span class="p">);</span>
	<span class="n">usbhsh_port_stat_set</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">USB_PORT_STAT_C_CONNECTION</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * attch interrupt might happen infinitely on some device</span>
<span class="cm">	 * (on self power USB hub ?)</span>
<span class="cm">	 * disable it here.</span>
<span class="cm">	 *</span>
<span class="cm">	 * usbhsh_is_running() becomes effective</span>
<span class="cm">	 * according to this process.</span>
<span class="cm">	 * see</span>
<span class="cm">	 *	usbhsh_is_running()</span>
<span class="cm">	 *	usbhsh_urb_enqueue()</span>
<span class="cm">	 */</span>
	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">.</span><span class="n">irq_attch</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">usbhs_irq_callback_update</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsh_irq_dtch</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">usbhs_irq_state</span> <span class="o">*</span><span class="n">irq_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">usbhsh_priv_to_hpriv</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhs_priv_to_dev</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device detached</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">usbhsh_port_stat_clear</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">USB_PORT_STAT_CONNECTION</span><span class="p">);</span>
	<span class="n">usbhsh_port_stat_set</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">USB_PORT_STAT_C_CONNECTION</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * enable attch interrupt again</span>
<span class="cm">	 *</span>
<span class="cm">	 * usbhsh_is_running() becomes invalid</span>
<span class="cm">	 * according to this process.</span>
<span class="cm">	 * see</span>
<span class="cm">	 *	usbhsh_is_running()</span>
<span class="cm">	 *	usbhsh_urb_enqueue()</span>
<span class="cm">	 */</span>
	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">.</span><span class="n">irq_attch</span> <span class="o">=</span> <span class="n">usbhsh_irq_attch</span><span class="p">;</span>
	<span class="n">usbhs_irq_callback_update</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * usbhsh_queue_force_pop_all() should be called</span>
<span class="cm">	 * after usbhsh_is_running() becomes invalid.</span>
<span class="cm">	 */</span>
	<span class="n">usbhsh_queue_force_pop_all</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsh_irq_setup_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">usbhs_irq_state</span> <span class="o">*</span><span class="n">irq_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">usbhsh_priv_to_hpriv</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhs_priv_to_dev</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;setup packet OK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">setup_ack_done</span><span class="p">);</span> <span class="cm">/* see usbhsh_urb_enqueue() */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsh_irq_setup_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">usbhs_irq_state</span> <span class="o">*</span><span class="n">irq_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">usbhsh_priv_to_hpriv</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhs_priv_to_dev</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;setup packet Err</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">setup_ack_done</span><span class="p">);</span> <span class="cm">/* see usbhsh_urb_enqueue() */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *		module start/stop</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbhsh_pipe_init_for_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">usbhsh_priv_to_hpriv</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">pipe_type</span> <span class="o">=</span> <span class="n">usbhs_get_dparam</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">pipe_type</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">pipe_size</span> <span class="o">=</span> <span class="n">usbhs_get_dparam</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">pipe_size</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">old_type</span><span class="p">,</span> <span class="n">dir_in</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* init all pipe */</span>
	<span class="n">old_type</span> <span class="o">=</span> <span class="n">USB_ENDPOINT_XFER_CONTROL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pipe_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * data &quot;output&quot; will be finished as soon as possible,</span>
<span class="cm">		 * but there is no guaranty at data &quot;input&quot; case.</span>
<span class="cm">		 *</span>
<span class="cm">		 * &quot;input&quot; needs &quot;standby&quot; pipe.</span>
<span class="cm">		 * So, &quot;input&quot; direction pipe &gt; &quot;output&quot; direction pipe</span>
<span class="cm">		 * is good idea.</span>
<span class="cm">		 *</span>
<span class="cm">		 * 1st USB_ENDPOINT_XFER_xxx will be output direction,</span>
<span class="cm">		 * and the other will be input direction here.</span>
<span class="cm">		 *</span>
<span class="cm">		 * ex)</span>
<span class="cm">		 * ...</span>
<span class="cm">		 * USB_ENDPOINT_XFER_ISOC -&gt; dir out</span>
<span class="cm">		 * USB_ENDPOINT_XFER_ISOC -&gt; dir in</span>
<span class="cm">		 * USB_ENDPOINT_XFER_BULK -&gt; dir out</span>
<span class="cm">		 * USB_ENDPOINT_XFER_BULK -&gt; dir in</span>
<span class="cm">		 * USB_ENDPOINT_XFER_BULK -&gt; dir in</span>
<span class="cm">		 * ...</span>
<span class="cm">		 */</span>
		<span class="n">dir_in</span> <span class="o">=</span> <span class="p">(</span><span class="n">pipe_type</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">old_type</span><span class="p">);</span>
		<span class="n">old_type</span> <span class="o">=</span> <span class="n">pipe_type</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">USB_ENDPOINT_XFER_CONTROL</span> <span class="o">==</span> <span class="n">pipe_type</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">pipe</span> <span class="o">=</span> <span class="n">usbhs_dcp_malloc</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
			<span class="n">usbhsh_hpriv_to_dcp</span><span class="p">(</span><span class="n">hpriv</span><span class="p">)</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pipe</span> <span class="o">=</span> <span class="n">usbhs_pipe_malloc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span>
						 <span class="n">pipe_type</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						 <span class="n">dir_in</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">mod_private</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsh_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">usbhsh_priv_to_hpriv</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">usbhsh_hpriv_to_hcd</span><span class="p">(</span><span class="n">hpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_mod</span> <span class="o">*</span><span class="n">mod</span> <span class="o">=</span> <span class="n">usbhs_mod_get_current</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhs_priv_to_dev</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* add hcd */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_add_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * pipe initialize and enable DCP</span>
<span class="cm">	 */</span>
	<span class="n">usbhs_pipe_init</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span>
			<span class="n">usbhsh_dma_map_ctrl</span><span class="p">);</span>
	<span class="n">usbhs_fifo_init</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="n">usbhsh_pipe_init_for_host</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * system config enble</span>
<span class="cm">	 * - HI speed</span>
<span class="cm">	 * - host</span>
<span class="cm">	 * - usb module</span>
<span class="cm">	 */</span>
	<span class="n">usbhs_sys_host_ctrl</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * enable irq callback</span>
<span class="cm">	 */</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">irq_attch</span>		<span class="o">=</span> <span class="n">usbhsh_irq_attch</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">irq_dtch</span>		<span class="o">=</span> <span class="n">usbhsh_irq_dtch</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">irq_sack</span>		<span class="o">=</span> <span class="n">usbhsh_irq_setup_ack</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">irq_sign</span>		<span class="o">=</span> <span class="n">usbhsh_irq_setup_err</span><span class="p">;</span>
	<span class="n">usbhs_irq_callback_update</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">mod</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;start host</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsh_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">usbhsh_priv_to_hpriv</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">usbhsh_hpriv_to_hcd</span><span class="p">(</span><span class="n">hpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_mod</span> <span class="o">*</span><span class="n">mod</span> <span class="o">=</span> <span class="n">usbhs_mod_get_current</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhs_priv_to_dev</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * disable irq callback</span>
<span class="cm">	 */</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">irq_attch</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">irq_dtch</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">irq_sack</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">irq_sign</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">usbhs_irq_callback_update</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">mod</span><span class="p">);</span>

	<span class="n">usb_remove_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="cm">/* disable sys */</span>
	<span class="n">usbhs_sys_host_ctrl</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;quit host</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">usbhs_mod_host_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbhsh_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhs_priv_to_dev</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* initialize hcd */</span>
	<span class="n">hcd</span> <span class="o">=</span> <span class="n">usb_create_hcd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usbhsh_driver</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">usbhsh_hcd_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hcd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to create hcd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">has_tt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* for low/full speed */</span>

	<span class="cm">/*</span>
<span class="cm">	 * CAUTION</span>
<span class="cm">	 *</span>
<span class="cm">	 * There is no guarantee that it is possible to access usb module here.</span>
<span class="cm">	 * Don&#39;t accesses to it.</span>
<span class="cm">	 * The accesse will be enable after &quot;usbhsh_start&quot;</span>
<span class="cm">	 */</span>

	<span class="n">hpriv</span> <span class="o">=</span> <span class="n">usbhsh_hcd_to_hpriv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * register itself</span>
<span class="cm">	 */</span>
	<span class="n">usbhs_mod_register</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">,</span> <span class="n">USBHS_HOST</span><span class="p">);</span>

	<span class="cm">/* init hpriv */</span>
	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;host&quot;</span><span class="p">;</span>
	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">.</span><span class="n">start</span>	<span class="o">=</span> <span class="n">usbhsh_start</span><span class="p">;</span>
	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">.</span><span class="n">stop</span>		<span class="o">=</span> <span class="n">usbhsh_stop</span><span class="p">;</span>
	<span class="n">usbhsh_port_stat_init</span><span class="p">(</span><span class="n">hpriv</span><span class="p">);</span>

	<span class="cm">/* init all device */</span>
	<span class="n">usbhsh_for_each_udev_with_dev0</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">hpriv</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">usbv</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">ep_list_head</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;host probed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">usbhs_mod_host_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsh_hpriv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">usbhsh_priv_to_hpriv</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">usbhsh_hpriv_to_hcd</span><span class="p">(</span><span class="n">hpriv</span><span class="p">);</span>

	<span class="n">usb_put_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
