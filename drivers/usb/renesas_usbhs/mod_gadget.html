<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › renesas_usbhs › mod_gadget.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>mod_gadget.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Renesas USB driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2011 Renesas Solutions Corp.</span>
<span class="cm"> * Kuninori Morimoto &lt;kuninori.morimoto.gx@renesas.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/usb/ch9.h&gt;</span>
<span class="cp">#include &lt;linux/usb/gadget.h&gt;</span>
<span class="cp">#include &quot;common.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> *		struct</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usbhsg_request</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_request</span>	<span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbhs_pkt</span>	<span class="n">pkt</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define EP_NAME_SIZE 8</span>
<span class="k">struct</span> <span class="n">usbhsg_gpriv</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_ep</span>		 <span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbhs_pipe</span>	<span class="o">*</span><span class="n">pipe</span><span class="p">;</span>

	<span class="kt">char</span> <span class="n">ep_name</span><span class="p">[</span><span class="n">EP_NAME_SIZE</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">usbhsg_gpriv</span> <span class="o">*</span><span class="n">gpriv</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">usbhsg_gpriv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_gadget</span>	 <span class="n">gadget</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbhs_mod</span>	 <span class="n">mod</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">usbhsg_uep</span>	<span class="o">*</span><span class="n">uep</span><span class="p">;</span>
	<span class="kt">int</span>			 <span class="n">uep_size</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">usb_gadget_driver</span>	<span class="o">*</span><span class="n">driver</span><span class="p">;</span>

	<span class="n">u32</span>	<span class="n">status</span><span class="p">;</span>
<span class="cp">#define USBHSG_STATUS_STARTED		(1 &lt;&lt; 0)</span>
<span class="cp">#define USBHSG_STATUS_REGISTERD		(1 &lt;&lt; 1)</span>
<span class="cp">#define USBHSG_STATUS_WEDGE		(1 &lt;&lt; 2)</span>
<span class="cp">#define USBHSG_STATUS_SELF_POWERED	(1 &lt;&lt; 3)</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">usbhsg_recip_handle</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">device</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">uep</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">interface</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">uep</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">endpoint</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">uep</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *		macro</span>
<span class="cm"> */</span>
<span class="cp">#define usbhsg_priv_to_gpriv(priv)			\</span>
<span class="cp">	container_of(					\</span>
<span class="cp">		usbhs_mod_get(priv, USBHS_GADGET),	\</span>
<span class="cp">		struct usbhsg_gpriv, mod)</span>

<span class="cp">#define __usbhsg_for_each_uep(start, pos, g, i)	\</span>
<span class="cp">	for (i = start, pos = (g)-&gt;uep + i;	\</span>
<span class="cp">	     i &lt; (g)-&gt;uep_size;			\</span>
<span class="cp">	     i++, pos = (g)-&gt;uep + i)</span>

<span class="cp">#define usbhsg_for_each_uep(pos, gpriv, i)	\</span>
<span class="cp">	__usbhsg_for_each_uep(1, pos, gpriv, i)</span>

<span class="cp">#define usbhsg_for_each_uep_with_dcp(pos, gpriv, i)	\</span>
<span class="cp">	__usbhsg_for_each_uep(0, pos, gpriv, i)</span>

<span class="cp">#define usbhsg_gadget_to_gpriv(g)\</span>
<span class="cp">	container_of(g, struct usbhsg_gpriv, gadget)</span>

<span class="cp">#define usbhsg_req_to_ureq(r)\</span>
<span class="cp">	container_of(r, struct usbhsg_request, req)</span>

<span class="cp">#define usbhsg_ep_to_uep(e)		container_of(e, struct usbhsg_uep, ep)</span>
<span class="cp">#define usbhsg_gpriv_to_dev(gp)		usbhs_priv_to_dev((gp)-&gt;mod.priv)</span>
<span class="cp">#define usbhsg_gpriv_to_priv(gp)	((gp)-&gt;mod.priv)</span>
<span class="cp">#define usbhsg_gpriv_to_dcp(gp)		((gp)-&gt;uep)</span>
<span class="cp">#define usbhsg_gpriv_to_nth_uep(gp, i)	((gp)-&gt;uep + i)</span>
<span class="cp">#define usbhsg_uep_to_gpriv(u)		((u)-&gt;gpriv)</span>
<span class="cp">#define usbhsg_uep_to_pipe(u)		((u)-&gt;pipe)</span>
<span class="cp">#define usbhsg_pipe_to_uep(p)		((p)-&gt;mod_private)</span>
<span class="cp">#define usbhsg_is_dcp(u)		((u) == usbhsg_gpriv_to_dcp((u)-&gt;gpriv))</span>

<span class="cp">#define usbhsg_ureq_to_pkt(u)		(&amp;(u)-&gt;pkt)</span>
<span class="cp">#define usbhsg_pkt_to_ureq(i)	\</span>
<span class="cp">	container_of(i, struct usbhsg_request, pkt)</span>

<span class="cp">#define usbhsg_is_not_connected(gp) ((gp)-&gt;gadget.speed == USB_SPEED_UNKNOWN)</span>

<span class="cm">/* status */</span>
<span class="cp">#define usbhsg_status_init(gp)   do {(gp)-&gt;status = 0; } while (0)</span>
<span class="cp">#define usbhsg_status_set(gp, b) (gp-&gt;status |=  b)</span>
<span class="cp">#define usbhsg_status_clr(gp, b) (gp-&gt;status &amp;= ~b)</span>
<span class="cp">#define usbhsg_status_has(gp, b) (gp-&gt;status &amp;   b)</span>

<span class="cm">/*</span>
<span class="cm"> *		queue push/pop</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbhsg_queue_pop</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">uep</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">usbhsg_request</span> <span class="o">*</span><span class="n">ureq</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_gpriv</span> <span class="o">*</span><span class="n">gpriv</span> <span class="o">=</span> <span class="n">usbhsg_uep_to_gpriv</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_pipe</span> <span class="o">*</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">usbhsg_uep_to_pipe</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhsg_gpriv_to_dev</span><span class="p">(</span><span class="n">gpriv</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pipe %d : queue pop</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usbhs_pipe_number</span><span class="p">(</span><span class="n">pipe</span><span class="p">));</span>

	<span class="n">ureq</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">ureq</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ureq</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbhsg_queue_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usbhs_pkt</span> <span class="o">*</span><span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhs_pipe</span> <span class="o">*</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">uep</span> <span class="o">=</span> <span class="n">usbhsg_pipe_to_uep</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhsg_request</span> <span class="o">*</span><span class="n">ureq</span> <span class="o">=</span> <span class="n">usbhsg_pkt_to_ureq</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

	<span class="n">ureq</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span> <span class="o">=</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">actual</span><span class="p">;</span>

	<span class="n">usbhsg_queue_pop</span><span class="p">(</span><span class="n">uep</span><span class="p">,</span> <span class="n">ureq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbhsg_queue_push</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">uep</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">usbhsg_request</span> <span class="o">*</span><span class="n">ureq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_gpriv</span> <span class="o">*</span><span class="n">gpriv</span> <span class="o">=</span> <span class="n">usbhsg_uep_to_gpriv</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhsg_gpriv_to_dev</span><span class="p">(</span><span class="n">gpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_pipe</span> <span class="o">*</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">usbhsg_uep_to_pipe</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_pkt</span> <span class="o">*</span><span class="n">pkt</span> <span class="o">=</span> <span class="n">usbhsg_ureq_to_pkt</span><span class="p">(</span><span class="n">ureq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ureq</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">;</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">actual</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
	<span class="n">usbhs_pkt_push</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="n">pkt</span><span class="p">,</span> <span class="n">usbhsg_queue_done</span><span class="p">,</span>
		       <span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">zero</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">usbhs_pkt_start</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pipe %d : queue push (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">usbhs_pipe_number</span><span class="p">(</span><span class="n">pipe</span><span class="p">),</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *		dma map/unmap</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsg_dma_map_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_pkt</span> <span class="o">*</span><span class="n">pkt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_request</span> <span class="o">*</span><span class="n">ureq</span> <span class="o">=</span> <span class="n">usbhsg_pkt_to_ureq</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ureq</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbhs_pipe</span> <span class="o">*</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">uep</span> <span class="o">=</span> <span class="n">usbhsg_pipe_to_uep</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhsg_gpriv</span> <span class="o">*</span><span class="n">gpriv</span> <span class="o">=</span> <span class="n">usbhsg_uep_to_gpriv</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>
	<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dir</span> <span class="o">=</span> <span class="n">usbhs_pipe_is_dir_host</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* it can not use scatter/gather */</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">num_sgs</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_gadget_map_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">pkt</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">usb_gadget_unmap_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *		USB_TYPE_STANDARD / clear feature functions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsg_recip_handler_std_control_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">uep</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_gpriv</span> <span class="o">*</span><span class="n">gpriv</span> <span class="o">=</span> <span class="n">usbhsg_priv_to_gpriv</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">dcp</span> <span class="o">=</span> <span class="n">usbhsg_gpriv_to_dcp</span><span class="p">(</span><span class="n">gpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_pipe</span> <span class="o">*</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">usbhsg_uep_to_pipe</span><span class="p">(</span><span class="n">dcp</span><span class="p">);</span>

	<span class="n">usbhs_dcp_control_transfer_done</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsg_recip_handler_std_clear_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">uep</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_gpriv</span> <span class="o">*</span><span class="n">gpriv</span> <span class="o">=</span> <span class="n">usbhsg_uep_to_gpriv</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_pipe</span> <span class="o">*</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">usbhsg_uep_to_pipe</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usbhsg_status_has</span><span class="p">(</span><span class="n">gpriv</span><span class="p">,</span> <span class="n">USBHSG_STATUS_WEDGE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">usbhs_pipe_disable</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>
		<span class="n">usbhs_pipe_sequence_data0</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>
		<span class="n">usbhs_pipe_enable</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">usbhsg_recip_handler_std_control_done</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">uep</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>

	<span class="n">usbhs_pkt_start</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">usbhsg_recip_handle</span> <span class="n">req_clear_feature</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;clear feature&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">device</span>		<span class="o">=</span> <span class="n">usbhsg_recip_handler_std_control_done</span><span class="p">,</span>
	<span class="p">.</span><span class="n">interface</span>	<span class="o">=</span> <span class="n">usbhsg_recip_handler_std_control_done</span><span class="p">,</span>
	<span class="p">.</span><span class="n">endpoint</span>	<span class="o">=</span> <span class="n">usbhsg_recip_handler_std_clear_endpoint</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *		USB_TYPE_STANDARD / set feature functions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsg_recip_handler_std_set_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">uep</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">wValue</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_DEVICE_TEST_MODE</span>:
		<span class="n">usbhsg_recip_handler_std_control_done</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">uep</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
		<span class="n">usbhs_sys_set_test_mode</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">wIndex</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">usbhsg_recip_handler_std_control_done</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">uep</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsg_recip_handler_std_set_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">uep</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhs_pipe</span> <span class="o">*</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">usbhsg_uep_to_pipe</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>

	<span class="n">usbhs_pipe_stall</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>

	<span class="n">usbhsg_recip_handler_std_control_done</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">uep</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">usbhsg_recip_handle</span> <span class="n">req_set_feature</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;set feature&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">device</span>		<span class="o">=</span> <span class="n">usbhsg_recip_handler_std_set_device</span><span class="p">,</span>
	<span class="p">.</span><span class="n">interface</span>	<span class="o">=</span> <span class="n">usbhsg_recip_handler_std_control_done</span><span class="p">,</span>
	<span class="p">.</span><span class="n">endpoint</span>	<span class="o">=</span> <span class="n">usbhsg_recip_handler_std_set_endpoint</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *		USB_TYPE_STANDARD / get status functions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__usbhsg_recip_send_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_request</span> <span class="o">*</span><span class="n">ureq</span> <span class="o">=</span> <span class="n">usbhsg_req_to_ureq</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="cm">/* free allocated recip-buffer/usb_request */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ureq</span><span class="o">-&gt;</span><span class="n">pkt</span><span class="p">.</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">usb_ep_free_request</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__usbhsg_recip_send_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsg_gpriv</span> <span class="o">*</span><span class="n">gpriv</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">dcp</span> <span class="o">=</span> <span class="n">usbhsg_gpriv_to_dcp</span><span class="p">(</span><span class="n">gpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_pipe</span> <span class="o">*</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">usbhsg_uep_to_pipe</span><span class="p">(</span><span class="n">dcp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhsg_gpriv_to_dev</span><span class="p">(</span><span class="n">gpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="cm">/* alloc new usb_request for recip */</span>
	<span class="n">req</span> <span class="o">=</span> <span class="n">usb_ep_alloc_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcp</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;recip request allocation fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* alloc recip data buffer */</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">buf</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_ep_free_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcp</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;recip data allocation fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* recip data is status */</span>
	<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>

	<span class="cm">/* allocated usb_request/buffer will be freed */</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">complete</span>	<span class="o">=</span> <span class="n">__usbhsg_recip_send_complete</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span>	<span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">length</span>	<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">zero</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* push packet */</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usbhs_fifo_pio_push_handler</span><span class="p">;</span>
	<span class="n">usbhsg_queue_push</span><span class="p">(</span><span class="n">dcp</span><span class="p">,</span> <span class="n">usbhsg_req_to_ureq</span><span class="p">(</span><span class="n">req</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsg_recip_handler_std_get_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">uep</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_gpriv</span> <span class="o">*</span><span class="n">gpriv</span> <span class="o">=</span> <span class="n">usbhsg_uep_to_gpriv</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usbhsg_status_has</span><span class="p">(</span><span class="n">gpriv</span><span class="p">,</span> <span class="n">USBHSG_STATUS_SELF_POWERED</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USB_DEVICE_SELF_POWERED</span><span class="p">;</span>

	<span class="n">__usbhsg_recip_send_status</span><span class="p">(</span><span class="n">gpriv</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsg_recip_handler_std_get_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">uep</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_gpriv</span> <span class="o">*</span><span class="n">gpriv</span> <span class="o">=</span> <span class="n">usbhsg_uep_to_gpriv</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">__usbhsg_recip_send_status</span><span class="p">(</span><span class="n">gpriv</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsg_recip_handler_std_get_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">uep</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_gpriv</span> <span class="o">*</span><span class="n">gpriv</span> <span class="o">=</span> <span class="n">usbhsg_uep_to_gpriv</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_pipe</span> <span class="o">*</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">usbhsg_uep_to_pipe</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usbhs_pipe_is_stall</span><span class="p">(</span><span class="n">pipe</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USB_ENDPOINT_HALT</span><span class="p">;</span>

	<span class="n">__usbhsg_recip_send_status</span><span class="p">(</span><span class="n">gpriv</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">usbhsg_recip_handle</span> <span class="n">req_get_status</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;get status&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">device</span>		<span class="o">=</span> <span class="n">usbhsg_recip_handler_std_get_device</span><span class="p">,</span>
	<span class="p">.</span><span class="n">interface</span>	<span class="o">=</span> <span class="n">usbhsg_recip_handler_std_get_interface</span><span class="p">,</span>
	<span class="p">.</span><span class="n">endpoint</span>	<span class="o">=</span> <span class="n">usbhsg_recip_handler_std_get_endpoint</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *		USB_TYPE handler</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsg_recip_run_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">usbhsg_recip_handle</span> <span class="o">*</span><span class="n">handler</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_gpriv</span> <span class="o">*</span><span class="n">gpriv</span> <span class="o">=</span> <span class="n">usbhsg_priv_to_gpriv</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhsg_gpriv_to_dev</span><span class="p">(</span><span class="n">gpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">uep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbhs_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">recip</span> <span class="o">=</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="n">USB_RECIP_MASK</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nth</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">wIndex</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_NUMBER_MASK</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">uep</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>

	<span class="n">uep</span> <span class="o">=</span> <span class="n">usbhsg_gpriv_to_nth_uep</span><span class="p">(</span><span class="n">gpriv</span><span class="p">,</span> <span class="n">nth</span><span class="p">);</span>
	<span class="n">pipe</span> <span class="o">=</span> <span class="n">usbhsg_uep_to_pipe</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pipe</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;wrong recip request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">recip</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_RECIP_DEVICE</span>:
		<span class="n">msg</span>	<span class="o">=</span> <span class="s">&quot;DEVICE&quot;</span><span class="p">;</span>
		<span class="n">func</span>	<span class="o">=</span> <span class="n">handler</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_RECIP_INTERFACE</span>:
		<span class="n">msg</span>	<span class="o">=</span> <span class="s">&quot;INTERFACE&quot;</span><span class="p">;</span>
		<span class="n">func</span>	<span class="o">=</span> <span class="n">handler</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_RECIP_ENDPOINT</span>:
		<span class="n">msg</span>	<span class="o">=</span> <span class="s">&quot;ENDPOINT&quot;</span><span class="p">;</span>
		<span class="n">func</span>	<span class="o">=</span> <span class="n">handler</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unsupported RECIP(%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">recip</span><span class="p">);</span>
		<span class="n">func</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s (pipe %d :%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">handler</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">nth</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">uep</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *		irq functions</span>
<span class="cm"> *</span>
<span class="cm"> * it will be called from usbhs_interrupt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsg_irq_dev_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">usbhs_irq_state</span> <span class="o">*</span><span class="n">irq_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_gpriv</span> <span class="o">*</span><span class="n">gpriv</span> <span class="o">=</span> <span class="n">usbhsg_priv_to_gpriv</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhsg_gpriv_to_dev</span><span class="p">(</span><span class="n">gpriv</span><span class="p">);</span>

	<span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">usbhs_bus_get_speed</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;state = %x : speed : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">usbhs_status_get_device_state</span><span class="p">(</span><span class="n">irq_state</span><span class="p">),</span>
		<span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsg_irq_ctrl_stage</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">usbhs_irq_state</span> <span class="o">*</span><span class="n">irq_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_gpriv</span> <span class="o">*</span><span class="n">gpriv</span> <span class="o">=</span> <span class="n">usbhsg_priv_to_gpriv</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">dcp</span> <span class="o">=</span> <span class="n">usbhsg_gpriv_to_dcp</span><span class="p">(</span><span class="n">gpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_pipe</span> <span class="o">*</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">usbhsg_uep_to_pipe</span><span class="p">(</span><span class="n">dcp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhsg_gpriv_to_dev</span><span class="p">(</span><span class="n">gpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbhsg_recip_handle</span> <span class="o">*</span><span class="n">recip_handler</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">stage</span> <span class="o">=</span> <span class="n">usbhs_status_get_ctrl_stage</span><span class="p">(</span><span class="n">irq_state</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;stage = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stage</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * see Manual</span>
<span class="cm">	 *</span>
<span class="cm">	 *  &quot;Operation&quot;</span>
<span class="cm">	 *  - &quot;Interrupt Function&quot;</span>
<span class="cm">	 *    - &quot;Control Transfer Stage Transition Interrupt&quot;</span>
<span class="cm">	 *      - Fig. &quot;Control Transfer Stage Transitions&quot;</span>
<span class="cm">	 */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">stage</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">READ_DATA_STAGE</span>:
		<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usbhs_fifo_pio_push_handler</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">WRITE_DATA_STAGE</span>:
		<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usbhs_fifo_pio_pop_handler</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NODATA_STATUS_STAGE</span>:
		<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usbhs_ctrl_stage_end_handler</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * get usb request</span>
<span class="cm">	 */</span>
	<span class="n">usbhs_usbreq_get_val</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctrl</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ctrl</span><span class="p">.</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="n">USB_TYPE_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_TYPE_STANDARD</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">ctrl</span><span class="p">.</span><span class="n">bRequest</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">USB_REQ_CLEAR_FEATURE</span>:
			<span class="n">recip_handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">req_clear_feature</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_REQ_SET_FEATURE</span>:
			<span class="n">recip_handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">req_set_feature</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_REQ_GET_STATUS</span>:
			<span class="n">recip_handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">req_get_status</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * setup stage / run recip</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">recip_handler</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">usbhsg_recip_run_handle</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">recip_handler</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctrl</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctrl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">usbhs_pipe_stall</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> *		usb_dcp_ops</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsg_pipe_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">uep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhs_pipe</span> <span class="o">*</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">usbhsg_uep_to_pipe</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_pkt</span> <span class="o">*</span><span class="n">pkt</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pkt</span> <span class="o">=</span> <span class="n">usbhs_pkt_pop</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pkt</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">usbhsg_queue_pop</span><span class="p">(</span><span class="n">uep</span><span class="p">,</span> <span class="n">usbhsg_pkt_to_ureq</span><span class="p">(</span><span class="n">pkt</span><span class="p">),</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">usbhs_pipe_disable</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbhsg_uep_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsg_gpriv</span> <span class="o">*</span><span class="n">gpriv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">uep</span><span class="p">;</span>

	<span class="n">usbhsg_for_each_uep_with_dcp</span><span class="p">(</span><span class="n">uep</span><span class="p">,</span> <span class="n">gpriv</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
		<span class="n">uep</span><span class="o">-&gt;</span><span class="n">pipe</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> *		usb_ep_ops</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsg_ep_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">uep</span>   <span class="o">=</span> <span class="n">usbhsg_ep_to_uep</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhsg_gpriv</span> <span class="o">*</span><span class="n">gpriv</span> <span class="o">=</span> <span class="n">usbhsg_uep_to_gpriv</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">usbhsg_gpriv_to_priv</span><span class="p">(</span><span class="n">gpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * if it already have pipe,</span>
<span class="cm">	 * nothing to do</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uep</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usbhs_pipe_clear</span><span class="p">(</span><span class="n">uep</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">);</span>
		<span class="n">usbhs_pipe_sequence_data0</span><span class="p">(</span><span class="n">uep</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pipe</span> <span class="o">=</span> <span class="n">usbhs_pipe_malloc</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span>
				 <span class="n">usb_endpoint_type</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span>
				 <span class="n">usb_endpoint_dir_in</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uep</span><span class="o">-&gt;</span><span class="n">pipe</span>		<span class="o">=</span> <span class="n">pipe</span><span class="p">;</span>
		<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">mod_private</span>	<span class="o">=</span> <span class="n">uep</span><span class="p">;</span>

		<span class="cm">/* set epnum / maxp */</span>
		<span class="n">usbhs_pipe_config_update</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					 <span class="n">usb_endpoint_num</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span>
					 <span class="n">usb_endpoint_maxp</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * usbhs_fifo_dma_push/pop_handler try to</span>
<span class="cm">		 * use dmaengine if possible.</span>
<span class="cm">		 * It will use pio handler if impossible.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_dir_in</span><span class="p">(</span><span class="n">desc</span><span class="p">))</span>
			<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usbhs_fifo_dma_push_handler</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usbhs_fifo_dma_pop_handler</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsg_ep_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">uep</span> <span class="o">=</span> <span class="n">usbhsg_ep_to_uep</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">usbhsg_pipe_disable</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="nf">usbhsg_ep_alloc_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
						   <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_request</span> <span class="o">*</span><span class="n">ureq</span><span class="p">;</span>

	<span class="n">ureq</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">ureq</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ureq</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">usbhs_pkt_init</span><span class="p">(</span><span class="n">usbhsg_ureq_to_pkt</span><span class="p">(</span><span class="n">ureq</span><span class="p">));</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">ureq</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbhsg_ep_free_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_request</span> <span class="o">*</span><span class="n">ureq</span> <span class="o">=</span> <span class="n">usbhsg_req_to_ureq</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ureq</span><span class="o">-&gt;</span><span class="n">pkt</span><span class="p">.</span><span class="n">node</span><span class="p">));</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ureq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsg_ep_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
			  <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">uep</span> <span class="o">=</span> <span class="n">usbhsg_ep_to_uep</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhsg_gpriv</span> <span class="o">*</span><span class="n">gpriv</span> <span class="o">=</span> <span class="n">usbhsg_uep_to_gpriv</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhsg_request</span> <span class="o">*</span><span class="n">ureq</span> <span class="o">=</span> <span class="n">usbhsg_req_to_ureq</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_pipe</span> <span class="o">*</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">usbhsg_uep_to_pipe</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>

	<span class="cm">/* param check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usbhsg_is_not_connected</span><span class="p">(</span><span class="n">gpriv</span><span class="p">)</span>	<span class="o">||</span>
	    <span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span>		<span class="o">||</span>
	    <span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pipe</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>

	<span class="n">usbhsg_queue_push</span><span class="p">(</span><span class="n">uep</span><span class="p">,</span> <span class="n">ureq</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsg_ep_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">uep</span> <span class="o">=</span> <span class="n">usbhsg_ep_to_uep</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhsg_request</span> <span class="o">*</span><span class="n">ureq</span> <span class="o">=</span> <span class="n">usbhsg_req_to_ureq</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_pipe</span> <span class="o">*</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">usbhsg_uep_to_pipe</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>

	<span class="n">usbhs_pkt_pop</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="n">usbhsg_ureq_to_pkt</span><span class="p">(</span><span class="n">ureq</span><span class="p">));</span>
	<span class="n">usbhsg_queue_pop</span><span class="p">(</span><span class="n">uep</span><span class="p">,</span> <span class="n">ureq</span><span class="p">,</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__usbhsg_ep_set_halt_wedge</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">halt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wedge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">uep</span> <span class="o">=</span> <span class="n">usbhsg_ep_to_uep</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_pipe</span> <span class="o">*</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">usbhsg_uep_to_pipe</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhsg_gpriv</span> <span class="o">*</span><span class="n">gpriv</span> <span class="o">=</span> <span class="n">usbhsg_uep_to_gpriv</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">usbhsg_gpriv_to_priv</span><span class="p">(</span><span class="n">gpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhsg_gpriv_to_dev</span><span class="p">(</span><span class="n">gpriv</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">usbhsg_pipe_disable</span><span class="p">(</span><span class="n">uep</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;set halt %d (pipe %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">halt</span><span class="p">,</span> <span class="n">usbhs_pipe_number</span><span class="p">(</span><span class="n">pipe</span><span class="p">));</span>

	<span class="cm">/********************  spin lock ********************/</span>
	<span class="n">usbhs_lock</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">halt</span><span class="p">)</span>
		<span class="n">usbhs_pipe_stall</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">usbhs_pipe_disable</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">halt</span> <span class="o">&amp;&amp;</span> <span class="n">wedge</span><span class="p">)</span>
		<span class="n">usbhsg_status_set</span><span class="p">(</span><span class="n">gpriv</span><span class="p">,</span> <span class="n">USBHSG_STATUS_WEDGE</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">usbhsg_status_clr</span><span class="p">(</span><span class="n">gpriv</span><span class="p">,</span> <span class="n">USBHSG_STATUS_WEDGE</span><span class="p">);</span>

	<span class="n">usbhs_unlock</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/********************  spin unlock ******************/</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsg_ep_set_halt</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__usbhsg_ep_set_halt_wedge</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsg_ep_set_wedge</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__usbhsg_ep_set_halt_wedge</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_ep_ops</span> <span class="n">usbhsg_ep_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">enable</span>		<span class="o">=</span> <span class="n">usbhsg_ep_enable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disable</span>	<span class="o">=</span> <span class="n">usbhsg_ep_disable</span><span class="p">,</span>

	<span class="p">.</span><span class="n">alloc_request</span>	<span class="o">=</span> <span class="n">usbhsg_ep_alloc_request</span><span class="p">,</span>
	<span class="p">.</span><span class="n">free_request</span>	<span class="o">=</span> <span class="n">usbhsg_ep_free_request</span><span class="p">,</span>

	<span class="p">.</span><span class="n">queue</span>		<span class="o">=</span> <span class="n">usbhsg_ep_queue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dequeue</span>	<span class="o">=</span> <span class="n">usbhsg_ep_dequeue</span><span class="p">,</span>

	<span class="p">.</span><span class="n">set_halt</span>	<span class="o">=</span> <span class="n">usbhsg_ep_set_halt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_wedge</span>	<span class="o">=</span> <span class="n">usbhsg_ep_set_wedge</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *		usb module start/end</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsg_try_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="n">u32</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_gpriv</span> <span class="o">*</span><span class="n">gpriv</span> <span class="o">=</span> <span class="n">usbhsg_priv_to_gpriv</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">dcp</span> <span class="o">=</span> <span class="n">usbhsg_gpriv_to_dcp</span><span class="p">(</span><span class="n">gpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_mod</span> <span class="o">*</span><span class="n">mod</span> <span class="o">=</span> <span class="n">usbhs_mod_get_current</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhs_priv_to_dev</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/********************  spin lock ********************/</span>
	<span class="n">usbhs_lock</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">usbhsg_status_set</span><span class="p">(</span><span class="n">gpriv</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">usbhsg_status_has</span><span class="p">(</span><span class="n">gpriv</span><span class="p">,</span> <span class="n">USBHSG_STATUS_STARTED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	      <span class="n">usbhsg_status_has</span><span class="p">(</span><span class="n">gpriv</span><span class="p">,</span> <span class="n">USBHSG_STATUS_REGISTERD</span><span class="p">)))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* not ready */</span>

	<span class="n">usbhs_unlock</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/********************  spin unlock ********************/</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* not ready is not error */</span>

	<span class="cm">/*</span>
<span class="cm">	 * enable interrupt and systems if ready</span>
<span class="cm">	 */</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;start gadget</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * pipe initialize and enable DCP</span>
<span class="cm">	 */</span>
	<span class="n">usbhs_pipe_init</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span>
			<span class="n">usbhsg_dma_map_ctrl</span><span class="p">);</span>
	<span class="n">usbhs_fifo_init</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="n">usbhsg_uep_init</span><span class="p">(</span><span class="n">gpriv</span><span class="p">);</span>

	<span class="cm">/* dcp init */</span>
	<span class="n">dcp</span><span class="o">-&gt;</span><span class="n">pipe</span>		<span class="o">=</span> <span class="n">usbhs_dcp_malloc</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="n">dcp</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">mod_private</span>	<span class="o">=</span> <span class="n">dcp</span><span class="p">;</span>
	<span class="n">usbhs_pipe_config_update</span><span class="p">(</span><span class="n">dcp</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * system config enble</span>
<span class="cm">	 * - HI speed</span>
<span class="cm">	 * - function</span>
<span class="cm">	 * - usb module</span>
<span class="cm">	 */</span>
	<span class="n">usbhs_sys_function_ctrl</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * enable irq callback</span>
<span class="cm">	 */</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">irq_dev_state</span>	<span class="o">=</span> <span class="n">usbhsg_irq_dev_state</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">irq_ctrl_stage</span>	<span class="o">=</span> <span class="n">usbhsg_irq_ctrl_stage</span><span class="p">;</span>
	<span class="n">usbhs_irq_callback_update</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">mod</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsg_try_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="n">u32</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_gpriv</span> <span class="o">*</span><span class="n">gpriv</span> <span class="o">=</span> <span class="n">usbhsg_priv_to_gpriv</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_mod</span> <span class="o">*</span><span class="n">mod</span> <span class="o">=</span> <span class="n">usbhs_mod_get_current</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">dcp</span> <span class="o">=</span> <span class="n">usbhsg_gpriv_to_dcp</span><span class="p">(</span><span class="n">gpriv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhs_priv_to_dev</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/********************  spin lock ********************/</span>
	<span class="n">usbhs_lock</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">usbhsg_status_clr</span><span class="p">(</span><span class="n">gpriv</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usbhsg_status_has</span><span class="p">(</span><span class="n">gpriv</span><span class="p">,</span> <span class="n">USBHSG_STATUS_STARTED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">usbhsg_status_has</span><span class="p">(</span><span class="n">gpriv</span><span class="p">,</span> <span class="n">USBHSG_STATUS_REGISTERD</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* already done */</span>

	<span class="n">usbhs_unlock</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/********************  spin unlock ********************/</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* already done is not error */</span>

	<span class="cm">/*</span>
<span class="cm">	 * disable interrupt and systems if 1st try</span>
<span class="cm">	 */</span>
	<span class="n">usbhs_fifo_quit</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="cm">/* disable all irq */</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">irq_dev_state</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">irq_ctrl_stage</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">usbhs_irq_callback_update</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">mod</span><span class="p">);</span>

	<span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">;</span>

	<span class="cm">/* disable sys */</span>
	<span class="n">usbhs_sys_set_test_mode</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">usbhs_sys_function_ctrl</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">usbhsg_pipe_disable</span><span class="p">(</span><span class="n">dcp</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;stop gadget</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> *		linux usb function</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsg_gadget_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_gpriv</span> <span class="o">*</span><span class="n">gpriv</span> <span class="o">=</span> <span class="n">usbhsg_gadget_to_gpriv</span><span class="p">(</span><span class="n">gadget</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">usbhsg_gpriv_to_priv</span><span class="p">(</span><span class="n">gpriv</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span>		<span class="o">||</span>
	    <span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">setup</span>	<span class="o">||</span>
	    <span class="n">driver</span><span class="o">-&gt;</span><span class="n">max_speed</span> <span class="o">&lt;</span> <span class="n">USB_SPEED_FULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* first hook up the driver ... */</span>
	<span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="n">driver</span><span class="p">;</span>
	<span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">usbhsg_try_start</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">USBHSG_STATUS_REGISTERD</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsg_gadget_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_gpriv</span> <span class="o">*</span><span class="n">gpriv</span> <span class="o">=</span> <span class="n">usbhsg_gadget_to_gpriv</span><span class="p">(</span><span class="n">gadget</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">usbhsg_gpriv_to_priv</span><span class="p">(</span><span class="n">gpriv</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span>		<span class="o">||</span>
	    <span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">unbind</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">usbhsg_try_stop</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">USBHSG_STATUS_REGISTERD</span><span class="p">);</span>
	<span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *		usb gadget ops</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsg_get_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_gpriv</span> <span class="o">*</span><span class="n">gpriv</span> <span class="o">=</span> <span class="n">usbhsg_gadget_to_gpriv</span><span class="p">(</span><span class="n">gadget</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">usbhsg_gpriv_to_priv</span><span class="p">(</span><span class="n">gpriv</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">usbhs_frame_get_num</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsg_set_selfpowered</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_gpriv</span> <span class="o">*</span><span class="n">gpriv</span> <span class="o">=</span> <span class="n">usbhsg_gadget_to_gpriv</span><span class="p">(</span><span class="n">gadget</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_self</span><span class="p">)</span>
		<span class="n">usbhsg_status_set</span><span class="p">(</span><span class="n">gpriv</span><span class="p">,</span> <span class="n">USBHSG_STATUS_SELF_POWERED</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">usbhsg_status_clr</span><span class="p">(</span><span class="n">gpriv</span><span class="p">,</span> <span class="n">USBHSG_STATUS_SELF_POWERED</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_gadget_ops</span> <span class="n">usbhsg_gadget_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_frame</span>		<span class="o">=</span> <span class="n">usbhsg_get_frame</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_selfpowered</span>	<span class="o">=</span> <span class="n">usbhsg_set_selfpowered</span><span class="p">,</span>
	<span class="p">.</span><span class="n">udc_start</span>		<span class="o">=</span> <span class="n">usbhsg_gadget_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">udc_stop</span>		<span class="o">=</span> <span class="n">usbhsg_gadget_stop</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsg_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">usbhsg_try_start</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">USBHSG_STATUS_STARTED</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbhsg_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_gpriv</span> <span class="o">*</span><span class="n">gpriv</span> <span class="o">=</span> <span class="n">usbhsg_priv_to_gpriv</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="cm">/* cable disconnect */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">&amp;&amp;</span>
	    <span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">)</span>
		<span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">usbhsg_try_stop</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">USBHSG_STATUS_STARTED</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbhs_mod_gadget_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* do nothing */</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">usbhs_mod_gadget_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_gpriv</span> <span class="o">*</span><span class="n">gpriv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbhsg_uep</span> <span class="o">*</span><span class="n">uep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usbhs_priv_to_dev</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">pipe_size</span> <span class="o">=</span> <span class="n">usbhs_get_dparam</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">pipe_size</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">gpriv</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsg_gpriv</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gpriv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not allocate gadget priv</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">uep</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhsg_uep</span><span class="p">)</span> <span class="o">*</span> <span class="n">pipe_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uep</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not allocate ep</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">usbhs_mod_gadget_probe_err_gpriv</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * CAUTION</span>
<span class="cm">	 *</span>
<span class="cm">	 * There is no guarantee that it is possible to access usb module here.</span>
<span class="cm">	 * Don&#39;t accesses to it.</span>
<span class="cm">	 * The accesse will be enable after &quot;usbhsg_start&quot;</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * register itself</span>
<span class="cm">	 */</span>
	<span class="n">usbhs_mod_register</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">,</span> <span class="n">USBHS_GADGET</span><span class="p">);</span>

	<span class="cm">/* init gpriv */</span>
	<span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;gadget&quot;</span><span class="p">;</span>
	<span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">.</span><span class="n">start</span>	<span class="o">=</span> <span class="n">usbhsg_start</span><span class="p">;</span>
	<span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">.</span><span class="n">stop</span>		<span class="o">=</span> <span class="n">usbhsg_stop</span><span class="p">;</span>
	<span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">uep</span>		<span class="o">=</span> <span class="n">uep</span><span class="p">;</span>
	<span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">uep_size</span>		<span class="o">=</span> <span class="n">pipe_size</span><span class="p">;</span>
	<span class="n">usbhsg_status_init</span><span class="p">(</span><span class="n">gpriv</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * init gadget</span>
<span class="cm">	 */</span>
	<span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;gadget&quot;</span><span class="p">);</span>
	<span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span>	<span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">usbhs_mod_gadget_release</span><span class="p">;</span>
	<span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;renesas_usbhs_udc&quot;</span><span class="p">;</span>
	<span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">usbhsg_gadget_ops</span><span class="p">;</span>
	<span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">max_speed</span>		<span class="o">=</span> <span class="n">USB_SPEED_HIGH</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_add_udc</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ep_list</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * init usb_ep</span>
<span class="cm">	 */</span>
	<span class="n">usbhsg_for_each_uep_with_dcp</span><span class="p">(</span><span class="n">uep</span><span class="p">,</span> <span class="n">gpriv</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uep</span><span class="o">-&gt;</span><span class="n">gpriv</span>	<span class="o">=</span> <span class="n">gpriv</span><span class="p">;</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">uep</span><span class="o">-&gt;</span><span class="n">ep_name</span><span class="p">,</span> <span class="n">EP_NAME_SIZE</span><span class="p">,</span> <span class="s">&quot;ep%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="n">uep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">uep</span><span class="o">-&gt;</span><span class="n">ep_name</span><span class="p">;</span>
		<span class="n">uep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">usbhsg_ep_ops</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">ep_list</span><span class="p">);</span>

		<span class="cm">/* init DCP */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">usbhsg_is_dcp</span><span class="p">(</span><span class="n">uep</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ep0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">uep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>
			<span class="n">uep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* init normal pipe */</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">uep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">ep_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ep_list</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_add_gadget_udc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_register</span><span class="p">;</span>


	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;gadget probed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_register:</span>
	<span class="n">device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
<span class="nl">err_add_udc:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">uep</span><span class="p">);</span>

<span class="nl">usbhs_mod_gadget_probe_err_gpriv:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">gpriv</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">usbhs_mod_gadget_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbhs_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbhsg_gpriv</span> <span class="o">*</span><span class="n">gpriv</span> <span class="o">=</span> <span class="n">usbhsg_priv_to_gpriv</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="n">usb_del_gadget_udc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>

	<span class="n">device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">gpriv</span><span class="o">-&gt;</span><span class="n">uep</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">gpriv</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
