<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › usb-skeleton.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>usb-skeleton.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * USB Skeleton driver - 2.2</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2001-2004 Greg Kroah-Hartman (greg@kroah.com)</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or</span>
<span class="cm"> *	modify it under the terms of the GNU General Public License as</span>
<span class="cm"> *	published by the Free Software Foundation, version 2.</span>
<span class="cm"> *</span>
<span class="cm"> * This driver is based on the 2.6.3 version of drivers/usb/usb-skeleton.c</span>
<span class="cm"> * but has been rewritten to be easier to read and use.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kref.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>


<span class="cm">/* Define these values to match your devices */</span>
<span class="cp">#define USB_SKEL_VENDOR_ID	0xfff0</span>
<span class="cp">#define USB_SKEL_PRODUCT_ID	0xfff0</span>

<span class="cm">/* table of devices that work with this driver */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="n">skel_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">USB_DEVICE</span><span class="p">(</span><span class="n">USB_SKEL_VENDOR_ID</span><span class="p">,</span> <span class="n">USB_SKEL_PRODUCT_ID</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span>					<span class="cm">/* Terminating entry */</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">usb</span><span class="p">,</span> <span class="n">skel_table</span><span class="p">);</span>


<span class="cm">/* Get a minor range for your devices from the usb maintainer */</span>
<span class="cp">#define USB_SKEL_MINOR_BASE	192</span>

<span class="cm">/* our private defines. if this grows any larger, use your own .h file */</span>
<span class="cp">#define MAX_TRANSFER		(PAGE_SIZE - 512)</span>
<span class="cm">/* MAX_TRANSFER is chosen so that the VM is not stressed by</span>
<span class="cm">   allocations &gt; PAGE_SIZE and the number of packets in a page</span>
<span class="cm">   is an integer 512 is the largest possible packet on EHCI */</span>
<span class="cp">#define WRITES_IN_FLIGHT	8</span>
<span class="cm">/* arbitrarily chosen */</span>

<span class="cm">/* Structure to hold all of our device specific stuff */</span>
<span class="k">struct</span> <span class="n">usb_skel</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span><span class="p">;</span>			<span class="cm">/* the usb device for this device */</span>
	<span class="k">struct</span> <span class="n">usb_interface</span>	<span class="o">*</span><span class="n">interface</span><span class="p">;</span>		<span class="cm">/* the interface for this device */</span>
	<span class="k">struct</span> <span class="n">semaphore</span>	<span class="n">limit_sem</span><span class="p">;</span>		<span class="cm">/* limiting the number of writes in progress */</span>
	<span class="k">struct</span> <span class="n">usb_anchor</span>	<span class="n">submitted</span><span class="p">;</span>		<span class="cm">/* in case we need to retract our submissions */</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">bulk_in_urb</span><span class="p">;</span>		<span class="cm">/* the urb to read data with */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>           <span class="o">*</span><span class="n">bulk_in_buffer</span><span class="p">;</span>	<span class="cm">/* the buffer to receive data */</span>
	<span class="kt">size_t</span>			<span class="n">bulk_in_size</span><span class="p">;</span>		<span class="cm">/* the size of the receive buffer */</span>
	<span class="kt">size_t</span>			<span class="n">bulk_in_filled</span><span class="p">;</span>		<span class="cm">/* number of bytes in the buffer */</span>
	<span class="kt">size_t</span>			<span class="n">bulk_in_copied</span><span class="p">;</span>		<span class="cm">/* already copied to user space */</span>
	<span class="n">__u8</span>			<span class="n">bulk_in_endpointAddr</span><span class="p">;</span>	<span class="cm">/* the address of the bulk in endpoint */</span>
	<span class="n">__u8</span>			<span class="n">bulk_out_endpointAddr</span><span class="p">;</span>	<span class="cm">/* the address of the bulk out endpoint */</span>
	<span class="kt">int</span>			<span class="n">errors</span><span class="p">;</span>			<span class="cm">/* the last request tanked */</span>
	<span class="n">bool</span>			<span class="n">ongoing_read</span><span class="p">;</span>		<span class="cm">/* a read is going on */</span>
	<span class="n">bool</span>			<span class="n">processed_urb</span><span class="p">;</span>		<span class="cm">/* indicates we haven&#39;t processed the urb */</span>
	<span class="n">spinlock_t</span>		<span class="n">err_lock</span><span class="p">;</span>		<span class="cm">/* lock for errors */</span>
	<span class="k">struct</span> <span class="n">kref</span>		<span class="n">kref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">io_mutex</span><span class="p">;</span>		<span class="cm">/* synchronize I/O with disconnect */</span>
	<span class="k">struct</span> <span class="n">completion</span>	<span class="n">bulk_in_completion</span><span class="p">;</span>	<span class="cm">/* to wait for an ongoing read */</span>
<span class="p">};</span>
<span class="cp">#define to_skel_dev(d) container_of(d, struct usb_skel, kref)</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_driver</span> <span class="n">skel_driver</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">skel_draw_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_skel</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">skel_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_skel</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">to_skel_dev</span><span class="p">(</span><span class="n">kref</span><span class="p">);</span>

	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_urb</span><span class="p">);</span>
	<span class="n">usb_put_dev</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_buffer</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">skel_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_skel</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">subminor</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">subminor</span> <span class="o">=</span> <span class="n">iminor</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">interface</span> <span class="o">=</span> <span class="n">usb_find_interface</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skel_driver</span><span class="p">,</span> <span class="n">subminor</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">interface</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s - error, can&#39;t find device for minor %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">subminor</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* increment our usage count for the device */</span>
	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>

	<span class="cm">/* lock the device to allow correctly handling errors</span>
<span class="cm">	 * in resumption */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_autopm_get_interface</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="cm">/* save our object in the file&#39;s private structure */</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>

<span class="nl">exit:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">skel_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_skel</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* allow the device to be autosuspended */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">)</span>
		<span class="n">usb_autopm_put_interface</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>

	<span class="cm">/* decrement the count on our device */</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="n">skel_delete</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">skel_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">fl_owner_t</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_skel</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* wait for io to stop */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
	<span class="n">skel_draw_down</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* read out errors, leave subsequent opens a clean slate */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">err_lock</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">?</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPIPE</span> <span class="o">?</span> <span class="o">-</span><span class="n">EPIPE</span> <span class="o">:</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">err_lock</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">skel_read_bulk_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_skel</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">err_lock</span><span class="p">);</span>
	<span class="cm">/* sync/async unlink faults aren&#39;t errors */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span> <span class="o">||</span>
		    <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ECONNRESET</span> <span class="o">||</span>
		    <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">))</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;%s - nonzero write bulk status received: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_filled</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ongoing_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">err_lock</span><span class="p">);</span>

	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_completion</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">skel_do_read_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_skel</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>

	<span class="cm">/* prepare a read */</span>
	<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_urb</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span>
			<span class="n">usb_rcvbulkpipe</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_endpointAddr</span><span class="p">),</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_buffer</span><span class="p">,</span>
			<span class="n">min</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_size</span><span class="p">,</span> <span class="n">count</span><span class="p">),</span>
			<span class="n">skel_read_bulk_callback</span><span class="p">,</span>
			<span class="n">dev</span><span class="p">);</span>
	<span class="cm">/* tell everybody to leave the URB alone */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">err_lock</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ongoing_read</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">err_lock</span><span class="p">);</span>

	<span class="cm">/* do it */</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_urb</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s - failed submitting read urb, error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">rv</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_filled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="p">(</span><span class="n">rv</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span> <span class="o">?</span> <span class="n">rv</span> <span class="o">:</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">err_lock</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ongoing_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">err_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">skel_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
			 <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_skel</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ongoing_io</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="cm">/* if we cannot read at all, return EOF */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_urb</span> <span class="o">||</span> <span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* no concurrent readers */</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* disconnect() was called */</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if IO is under way, we must not touch things */</span>
<span class="nl">retry:</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">err_lock</span><span class="p">);</span>
	<span class="n">ongoing_io</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ongoing_read</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">err_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ongoing_io</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* nonblocking IO shall not wait */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * IO may take forever</span>
<span class="cm">		 * hence wait in an interruptible state</span>
<span class="cm">		 */</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="n">wait_for_completion_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_completion</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * by waiting we also semiprocessed the urb</span>
<span class="cm">		 * we must finish now</span>
<span class="cm">		 */</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">processed_urb</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">processed_urb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * the URB hasn&#39;t been processed</span>
<span class="cm">		 * do it now</span>
<span class="cm">		 */</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_completion</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">processed_urb</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* errors must be reported */</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">errors</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* any error is reported once */</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* to preserve notifications about reset */</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="p">(</span><span class="n">rv</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">)</span> <span class="o">?</span> <span class="n">rv</span> <span class="o">:</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="cm">/* no data to deliver */</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_filled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* report it */</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * if the buffer is filled we may satisfy the read</span>
<span class="cm">	 * else we need to start IO</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_filled</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* we had read data */</span>
		<span class="kt">size_t</span> <span class="n">available</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_filled</span> <span class="o">-</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_copied</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">chunk</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">available</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">available</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * all data has been used</span>
<span class="cm">			 * actual IO needs to be done</span>
<span class="cm">			 */</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="n">skel_do_read_io</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * data is available</span>
<span class="cm">		 * chunk tells us how much shall be copied</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span>
				 <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_buffer</span> <span class="o">+</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_copied</span><span class="p">,</span>
				 <span class="n">chunk</span><span class="p">))</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="n">chunk</span><span class="p">;</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_copied</span> <span class="o">+=</span> <span class="n">chunk</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * if we are asked for more than we have,</span>
<span class="cm">		 * we start IO but don&#39;t wait</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">available</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">)</span>
			<span class="n">skel_do_read_io</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">count</span> <span class="o">-</span> <span class="n">chunk</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* no data in the buffer */</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="n">skel_do_read_io</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">exit:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">skel_write_bulk_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_skel</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>

	<span class="cm">/* sync/async unlink faults aren&#39;t errors */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span> <span class="o">||</span>
		    <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ECONNRESET</span> <span class="o">||</span>
		    <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">))</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;%s - nonzero write bulk status received: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">err_lock</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">err_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* free up our allocated buffer */</span>
	<span class="n">usb_free_coherent</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">,</span>
			  <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span><span class="p">);</span>
	<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">limit_sem</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">skel_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">user_buffer</span><span class="p">,</span>
			  <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_skel</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">writesize</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">MAX_TRANSFER</span><span class="p">);</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="cm">/* verify that we actually have some data to write */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * limit the number of URBs in flight to stop a user from using up all</span>
<span class="cm">	 * RAM</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">down_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">limit_sem</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">down_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">limit_sem</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">err_lock</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">errors</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* any error is reported once */</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* to preserve notifications about reset */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">)</span> <span class="o">?</span> <span class="n">retval</span> <span class="o">:</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">err_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* create a urb, and a buffer for it, and copy the data to the urb */</span>
	<span class="n">urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">usb_alloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">writesize</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">user_buffer</span><span class="p">,</span> <span class="n">writesize</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* this lock makes sure we don&#39;t submit URBs to gone devices */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* disconnect() was called */</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* initialize the urb properly */</span>
	<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span>
			  <span class="n">usb_sndbulkpipe</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_out_endpointAddr</span><span class="p">),</span>
			  <span class="n">buf</span><span class="p">,</span> <span class="n">writesize</span><span class="p">,</span> <span class="n">skel_write_bulk_callback</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">|=</span> <span class="n">URB_NO_TRANSFER_DMA_MAP</span><span class="p">;</span>
	<span class="n">usb_anchor_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">submitted</span><span class="p">);</span>

	<span class="cm">/* send the data out the bulk port */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s - failed submitting write urb, error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_unanchor</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * release our reference to this urb, the USB core will eventually free</span>
<span class="cm">	 * it entirely</span>
<span class="cm">	 */</span>
	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>


	<span class="k">return</span> <span class="n">writesize</span><span class="p">;</span>

<span class="nl">error_unanchor:</span>
	<span class="n">usb_unanchor_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_free_coherent</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">writesize</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span><span class="p">);</span>
		<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">limit_sem</span><span class="p">);</span>

<span class="nl">exit:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">skel_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span>		<span class="n">skel_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span>	<span class="n">skel_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span>		<span class="n">skel_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span>	<span class="n">skel_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush</span> <span class="o">=</span>	<span class="n">skel_flush</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span>	<span class="n">noop_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * usb class driver info in order to get a minor number from the usb core,</span>
<span class="cm"> * and to have the device registered with the driver core</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_class_driver</span> <span class="n">skel_class</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;skel%d&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fops</span> <span class="o">=</span>		<span class="o">&amp;</span><span class="n">skel_fops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">minor_base</span> <span class="o">=</span>	<span class="n">USB_SKEL_MINOR_BASE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">skel_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_skel</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">iface_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">endpoint</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">buffer_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* allocate memory for our device state and initialize it */</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dev</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
	<span class="n">sema_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">limit_sem</span><span class="p">,</span> <span class="n">WRITES_IN_FLIGHT</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">err_lock</span><span class="p">);</span>
	<span class="n">init_usb_anchor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">submitted</span><span class="p">);</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_completion</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span> <span class="o">=</span> <span class="n">usb_get_dev</span><span class="p">(</span><span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">interface</span><span class="p">));</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">interface</span> <span class="o">=</span> <span class="n">interface</span><span class="p">;</span>

	<span class="cm">/* set up the endpoint information */</span>
	<span class="cm">/* use only the first bulk-in and bulk-out endpoints */</span>
	<span class="n">iface_desc</span> <span class="o">=</span> <span class="n">interface</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iface_desc</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumEndpoints</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">endpoint</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iface_desc</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_endpointAddr</span> <span class="o">&amp;&amp;</span>
		    <span class="n">usb_endpoint_is_bulk_in</span><span class="p">(</span><span class="n">endpoint</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* we found a bulk in endpoint */</span>
			<span class="n">buffer_size</span> <span class="o">=</span> <span class="n">usb_endpoint_maxp</span><span class="p">(</span><span class="n">endpoint</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_size</span> <span class="o">=</span> <span class="n">buffer_size</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_endpointAddr</span> <span class="o">=</span> <span class="n">endpoint</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_buffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">buffer_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_buffer</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;Could not allocate bulk_in_buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_urb</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;Could not allocate bulk_in_urb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_out_endpointAddr</span> <span class="o">&amp;&amp;</span>
		    <span class="n">usb_endpoint_is_bulk_out</span><span class="p">(</span><span class="n">endpoint</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* we found a bulk out endpoint */</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_out_endpointAddr</span> <span class="o">=</span> <span class="n">endpoint</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_endpointAddr</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_out_endpointAddr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Could not find both bulk-in and bulk-out endpoints</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* save our data pointer in this interface device */</span>
	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* we can register the device now, as it is ready */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_register_dev</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">skel_class</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* something prevented us from registering this driver */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Not able to get a minor for this device.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* let the user know what node this device is now attached to */</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		 <span class="s">&quot;USB Skeleton device now attached to USBSkel-%d&quot;</span><span class="p">,</span>
		 <span class="n">interface</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span>
		<span class="cm">/* this frees allocated memory */</span>
		<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="n">skel_delete</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">skel_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_skel</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">minor</span> <span class="o">=</span> <span class="n">interface</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>
	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* give back our minor */</span>
	<span class="n">usb_deregister_dev</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">skel_class</span><span class="p">);</span>

	<span class="cm">/* prevent more I/O from starting */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">interface</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>

	<span class="n">usb_kill_anchored_urbs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">submitted</span><span class="p">);</span>

	<span class="cm">/* decrement our usage count */</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="n">skel_delete</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;USB Skeleton #%d now disconnected&quot;</span><span class="p">,</span> <span class="n">minor</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">skel_draw_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_skel</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">time</span><span class="p">;</span>

	<span class="n">time</span> <span class="o">=</span> <span class="n">usb_wait_anchor_empty_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">submitted</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">time</span><span class="p">)</span>
		<span class="n">usb_kill_anchored_urbs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">submitted</span><span class="p">);</span>
	<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bulk_in_urb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">skel_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_skel</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">skel_draw_down</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">skel_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">skel_pre_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_skel</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
	<span class="n">skel_draw_down</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">skel_post_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_skel</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="cm">/* we are sure no URBs are active - no locking needed */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_driver</span> <span class="n">skel_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;skeleton&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span>	<span class="n">skel_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disconnect</span> <span class="o">=</span>	<span class="n">skel_disconnect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span>	<span class="n">skel_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span>	<span class="n">skel_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pre_reset</span> <span class="o">=</span>	<span class="n">skel_pre_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">post_reset</span> <span class="o">=</span>	<span class="n">skel_post_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span>	<span class="n">skel_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">supports_autosuspend</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">module_usb_driver</span><span class="p">(</span><span class="n">skel_driver</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
