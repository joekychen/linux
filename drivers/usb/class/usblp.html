<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › class › usblp.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>usblp.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * usblp.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 1999 Michael Gee	&lt;michael@linuxspecific.com&gt;</span>
<span class="cm"> * Copyright (c) 1999 Pavel Machek	&lt;pavel@ucw.cz&gt;</span>
<span class="cm"> * Copyright (c) 2000 Randy Dunlap	&lt;rdunlap@xenotime.net&gt;</span>
<span class="cm"> * Copyright (c) 2000 Vojtech Pavlik	&lt;vojtech@suse.cz&gt;</span>
<span class="cm"> # Copyright (c) 2001 Pete Zaitcev	&lt;zaitcev@redhat.com&gt;</span>
<span class="cm"> # Copyright (c) 2001 David Paschal	&lt;paschal@rcsis.com&gt;</span>
<span class="cm"> * Copyright (c) 2006 Oliver Neukum	&lt;oliver@neukum.name&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * USB Printer Device Class driver for USB printers and printer cables</span>
<span class="cm"> *</span>
<span class="cm"> * Sponsored by SuSE</span>
<span class="cm"> *</span>
<span class="cm"> * ChangeLog:</span>
<span class="cm"> *	v0.1 - thorough cleaning, URBification, almost a rewrite</span>
<span class="cm"> *	v0.2 - some more cleanups</span>
<span class="cm"> *	v0.3 - cleaner again, waitqueue fixes</span>
<span class="cm"> *	v0.4 - fixes in unidirectional mode</span>
<span class="cm"> *	v0.5 - add DEVICE_ID string support</span>
<span class="cm"> *	v0.6 - never time out</span>
<span class="cm"> *	v0.7 - fixed bulk-IN read and poll (David Paschal)</span>
<span class="cm"> *	v0.8 - add devfs support</span>
<span class="cm"> *	v0.9 - fix unplug-while-open paths</span>
<span class="cm"> *	v0.10- remove sleep_on, fix error on oom (oliver@neukum.org)</span>
<span class="cm"> *	v0.11 - add proto_bias option (Pete Zaitcev)</span>
<span class="cm"> *	v0.12 - add hpoj.sourceforge.net ioctls (David Paschal)</span>
<span class="cm"> *	v0.13 - alloc space for statusbuf (&lt;status&gt; not on stack);</span>
<span class="cm"> *		use usb_alloc_coherent() for read buf &amp; write buf;</span>
<span class="cm"> *      none  - Maintained in Linux kernel after v0.13</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/lp.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#undef DEBUG</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Version Information</span>
<span class="cm"> */</span>
<span class="cp">#define DRIVER_AUTHOR &quot;Michael Gee, Pavel Machek, Vojtech Pavlik, Randy Dunlap, Pete Zaitcev, David Paschal&quot;</span>
<span class="cp">#define DRIVER_DESC &quot;USB Printer Device Class driver&quot;</span>

<span class="cp">#define USBLP_BUF_SIZE		8192</span>
<span class="cp">#define USBLP_BUF_SIZE_IN	1024</span>
<span class="cp">#define USBLP_DEVICE_ID_SIZE	1024</span>

<span class="cm">/* ioctls: */</span>
<span class="cp">#define IOCNR_GET_DEVICE_ID		1</span>
<span class="cp">#define IOCNR_GET_PROTOCOLS		2</span>
<span class="cp">#define IOCNR_SET_PROTOCOL		3</span>
<span class="cp">#define IOCNR_HP_SET_CHANNEL		4</span>
<span class="cp">#define IOCNR_GET_BUS_ADDRESS		5</span>
<span class="cp">#define IOCNR_GET_VID_PID		6</span>
<span class="cp">#define IOCNR_SOFT_RESET		7</span>
<span class="cm">/* Get device_id string: */</span>
<span class="cp">#define LPIOC_GET_DEVICE_ID(len) _IOC(_IOC_READ, &#39;P&#39;, IOCNR_GET_DEVICE_ID, len)</span>
<span class="cm">/* The following ioctls were added for http://hpoj.sourceforge.net: */</span>
<span class="cm">/* Get two-int array:</span>
<span class="cm"> * [0]=current protocol (1=7/1/1, 2=7/1/2, 3=7/1/3),</span>
<span class="cm"> * [1]=supported protocol mask (mask&amp;(1&lt;&lt;n)!=0 means 7/1/n supported): */</span>
<span class="cp">#define LPIOC_GET_PROTOCOLS(len) _IOC(_IOC_READ, &#39;P&#39;, IOCNR_GET_PROTOCOLS, len)</span>
<span class="cm">/* Set protocol (arg: 1=7/1/1, 2=7/1/2, 3=7/1/3): */</span>
<span class="cp">#define LPIOC_SET_PROTOCOL _IOC(_IOC_WRITE, &#39;P&#39;, IOCNR_SET_PROTOCOL, 0)</span>
<span class="cm">/* Set channel number (HP Vendor-specific command): */</span>
<span class="cp">#define LPIOC_HP_SET_CHANNEL _IOC(_IOC_WRITE, &#39;P&#39;, IOCNR_HP_SET_CHANNEL, 0)</span>
<span class="cm">/* Get two-int array: [0]=bus number, [1]=device address: */</span>
<span class="cp">#define LPIOC_GET_BUS_ADDRESS(len) _IOC(_IOC_READ, &#39;P&#39;, IOCNR_GET_BUS_ADDRESS, len)</span>
<span class="cm">/* Get two-int array: [0]=vendor ID, [1]=product ID: */</span>
<span class="cp">#define LPIOC_GET_VID_PID(len) _IOC(_IOC_READ, &#39;P&#39;, IOCNR_GET_VID_PID, len)</span>
<span class="cm">/* Perform class specific soft reset */</span>
<span class="cp">#define LPIOC_SOFT_RESET _IOC(_IOC_NONE, &#39;P&#39;, IOCNR_SOFT_RESET, 0);</span>

<span class="cm">/*</span>
<span class="cm"> * A DEVICE_ID string may include the printer&#39;s serial number.</span>
<span class="cm"> * It should end with a semi-colon (&#39;;&#39;).</span>
<span class="cm"> * An example from an HP 970C DeskJet printer is (this is one long string,</span>
<span class="cm"> * with the serial number changed):</span>
<span class="cm">MFG:HEWLETT-PACKARD;MDL:DESKJET 970C;CMD:MLC,PCL,PML;CLASS:PRINTER;DESCRIPTION:Hewlett-Packard DeskJet 970C;SERN:US970CSEPROF;VSTATUS:$HB0$NC0,ff,DN,IDLE,CUT,K1,C0,DP,NR,KP000,CP027;VP:0800,FL,B0;VJ:                    ;</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * USB Printer Requests</span>
<span class="cm"> */</span>

<span class="cp">#define USBLP_REQ_GET_ID			0x00</span>
<span class="cp">#define USBLP_REQ_GET_STATUS			0x01</span>
<span class="cp">#define USBLP_REQ_RESET				0x02</span>
<span class="cp">#define USBLP_REQ_HP_CHANNEL_CHANGE_REQUEST	0x00	</span><span class="cm">/* HP Vendor-specific */</span><span class="cp"></span>

<span class="cp">#define USBLP_MINORS		16</span>
<span class="cp">#define USBLP_MINOR_BASE	0</span>

<span class="cp">#define USBLP_CTL_TIMEOUT	5000			</span><span class="cm">/* 5 seconds */</span><span class="cp"></span>

<span class="cp">#define USBLP_FIRST_PROTOCOL	1</span>
<span class="cp">#define USBLP_LAST_PROTOCOL	3</span>
<span class="cp">#define USBLP_MAX_PROTOCOLS	(USBLP_LAST_PROTOCOL+1)</span>

<span class="cm">/*</span>
<span class="cm"> * some arbitrary status buffer size;</span>
<span class="cm"> * need a status buffer that is allocated via kmalloc(), not on stack</span>
<span class="cm"> */</span>
<span class="cp">#define STATUS_BUF_SIZE		8</span>

<span class="cm">/*</span>
<span class="cm"> * Locks down the locking order:</span>
<span class="cm"> * -&gt;wmut locks wstatus.</span>
<span class="cm"> * -&gt;mut locks the whole usblp, except [rw]complete, and thus, by indirection,</span>
<span class="cm"> * [rw]status. We only touch status when we know the side idle.</span>
<span class="cm"> * -&gt;lock locks what interrupt accesses.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usblp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>			<span class="cm">/* USB device */</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">wmut</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">mut</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>		<span class="cm">/* locks rcomplete, wcomplete */</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">readbuf</span><span class="p">;</span>		<span class="cm">/* read transfer_buffer */</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">statusbuf</span><span class="p">;</span>		<span class="cm">/* status transfer_buffer */</span>
	<span class="k">struct</span> <span class="n">usb_anchor</span>	<span class="n">urbs</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">rwait</span><span class="p">,</span> <span class="n">wwait</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">readcount</span><span class="p">;</span>		<span class="cm">/* Counter for reads */</span>
	<span class="kt">int</span>			<span class="n">ifnum</span><span class="p">;</span>			<span class="cm">/* Interface number */</span>
	<span class="k">struct</span> <span class="n">usb_interface</span>	<span class="o">*</span><span class="n">intf</span><span class="p">;</span>			<span class="cm">/* The interface */</span>
	<span class="cm">/* Alternate-setting numbers and endpoints for each protocol</span>
<span class="cm">	 * (7/1/{index=1,2,3}) that the device supports: */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">int</span>				<span class="n">alt_setting</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span>	<span class="o">*</span><span class="n">epwrite</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span>	<span class="o">*</span><span class="n">epread</span><span class="p">;</span>
	<span class="p">}</span>			<span class="n">protocol</span><span class="p">[</span><span class="n">USBLP_MAX_PROTOCOLS</span><span class="p">];</span>
	<span class="kt">int</span>			<span class="n">current_protocol</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">minor</span><span class="p">;</span>			<span class="cm">/* minor number of device */</span>
	<span class="kt">int</span>			<span class="n">wcomplete</span><span class="p">,</span> <span class="n">rcomplete</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">wstatus</span><span class="p">;</span>	<span class="cm">/* bytes written or error */</span>
	<span class="kt">int</span>			<span class="n">rstatus</span><span class="p">;</span>	<span class="cm">/* bytes ready or error */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">quirks</span><span class="p">;</span>			<span class="cm">/* quirks flags */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flags</span><span class="p">;</span>			<span class="cm">/* mode flags */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">used</span><span class="p">;</span>			<span class="cm">/* True if open */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">present</span><span class="p">;</span>		<span class="cm">/* True if not disconnected */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">bidir</span><span class="p">;</span>			<span class="cm">/* interface is bidirectional */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">no_paper</span><span class="p">;</span>		<span class="cm">/* Paper Out happened */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">device_id_string</span><span class="p">;</span>	<span class="cm">/* IEEE 1284 DEVICE ID string (ptr) */</span>
							<span class="cm">/* first 2 bytes are (big-endian) length */</span>
<span class="p">};</span>

<span class="cp">#ifdef DEBUG</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usblp_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">p</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;usblp=0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usblp</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;dev=0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;present=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">present</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;readbuf=0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">readbuf</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;readcount=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">readcount</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ifnum=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">ifnum</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">USBLP_FIRST_PROTOCOL</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">USBLP_LAST_PROTOCOL</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;protocol[%d].alt_setting=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
			<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">alt_setting</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;protocol[%d].epwrite=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
			<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">epwrite</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;protocol[%d].epread=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
			<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">epread</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;current_protocol=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">current_protocol</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;minor=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;wstatus=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">wstatus</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;rstatus=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">rstatus</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;quirks=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">quirks</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;used=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;bidir=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">bidir</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device_id_string=</span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">device_id_string</span> <span class="o">?</span>
			<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">device_id_string</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">:</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="s">&quot;(null)&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* Quirks: various printer quirks are handled by this table &amp; its flags. */</span>

<span class="k">struct</span> <span class="n">quirk_printer_struct</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">vendorId</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">productId</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">quirks</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define USBLP_QUIRK_BIDIR	0x1	</span><span class="cm">/* reports bidir but requires unidirectional mode (no INs/reads) */</span><span class="cp"></span>
<span class="cp">#define USBLP_QUIRK_USB_INIT	0x2	</span><span class="cm">/* needs vendor USB init string */</span><span class="cp"></span>
<span class="cp">#define USBLP_QUIRK_BAD_CLASS	0x4	</span><span class="cm">/* descriptor uses vendor-specific Class or SubClass */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">quirk_printer_struct</span> <span class="n">quirk_printers</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="mh">0x03f0</span><span class="p">,</span> <span class="mh">0x0004</span><span class="p">,</span> <span class="n">USBLP_QUIRK_BIDIR</span> <span class="p">},</span> <span class="cm">/* HP DeskJet 895C */</span>
	<span class="p">{</span> <span class="mh">0x03f0</span><span class="p">,</span> <span class="mh">0x0104</span><span class="p">,</span> <span class="n">USBLP_QUIRK_BIDIR</span> <span class="p">},</span> <span class="cm">/* HP DeskJet 880C */</span>
	<span class="p">{</span> <span class="mh">0x03f0</span><span class="p">,</span> <span class="mh">0x0204</span><span class="p">,</span> <span class="n">USBLP_QUIRK_BIDIR</span> <span class="p">},</span> <span class="cm">/* HP DeskJet 815C */</span>
	<span class="p">{</span> <span class="mh">0x03f0</span><span class="p">,</span> <span class="mh">0x0304</span><span class="p">,</span> <span class="n">USBLP_QUIRK_BIDIR</span> <span class="p">},</span> <span class="cm">/* HP DeskJet 810C/812C */</span>
	<span class="p">{</span> <span class="mh">0x03f0</span><span class="p">,</span> <span class="mh">0x0404</span><span class="p">,</span> <span class="n">USBLP_QUIRK_BIDIR</span> <span class="p">},</span> <span class="cm">/* HP DeskJet 830C */</span>
	<span class="p">{</span> <span class="mh">0x03f0</span><span class="p">,</span> <span class="mh">0x0504</span><span class="p">,</span> <span class="n">USBLP_QUIRK_BIDIR</span> <span class="p">},</span> <span class="cm">/* HP DeskJet 885C */</span>
	<span class="p">{</span> <span class="mh">0x03f0</span><span class="p">,</span> <span class="mh">0x0604</span><span class="p">,</span> <span class="n">USBLP_QUIRK_BIDIR</span> <span class="p">},</span> <span class="cm">/* HP DeskJet 840C */</span>
	<span class="p">{</span> <span class="mh">0x03f0</span><span class="p">,</span> <span class="mh">0x0804</span><span class="p">,</span> <span class="n">USBLP_QUIRK_BIDIR</span> <span class="p">},</span> <span class="cm">/* HP DeskJet 816C */</span>
	<span class="p">{</span> <span class="mh">0x03f0</span><span class="p">,</span> <span class="mh">0x1104</span><span class="p">,</span> <span class="n">USBLP_QUIRK_BIDIR</span> <span class="p">},</span> <span class="cm">/* HP Deskjet 959C */</span>
	<span class="p">{</span> <span class="mh">0x0409</span><span class="p">,</span> <span class="mh">0xefbe</span><span class="p">,</span> <span class="n">USBLP_QUIRK_BIDIR</span> <span class="p">},</span> <span class="cm">/* NEC Picty900 (HP OEM) */</span>
	<span class="p">{</span> <span class="mh">0x0409</span><span class="p">,</span> <span class="mh">0xbef4</span><span class="p">,</span> <span class="n">USBLP_QUIRK_BIDIR</span> <span class="p">},</span> <span class="cm">/* NEC Picty760 (HP OEM) */</span>
	<span class="p">{</span> <span class="mh">0x0409</span><span class="p">,</span> <span class="mh">0xf0be</span><span class="p">,</span> <span class="n">USBLP_QUIRK_BIDIR</span> <span class="p">},</span> <span class="cm">/* NEC Picty920 (HP OEM) */</span>
	<span class="p">{</span> <span class="mh">0x0409</span><span class="p">,</span> <span class="mh">0xf1be</span><span class="p">,</span> <span class="n">USBLP_QUIRK_BIDIR</span> <span class="p">},</span> <span class="cm">/* NEC Picty800 (HP OEM) */</span>
	<span class="p">{</span> <span class="mh">0x0482</span><span class="p">,</span> <span class="mh">0x0010</span><span class="p">,</span> <span class="n">USBLP_QUIRK_BIDIR</span> <span class="p">},</span> <span class="cm">/* Kyocera Mita FS 820, by zut &lt;kernel@zut.de&gt; */</span>
	<span class="p">{</span> <span class="mh">0x04f9</span><span class="p">,</span> <span class="mh">0x000d</span><span class="p">,</span> <span class="n">USBLP_QUIRK_BIDIR</span> <span class="p">},</span> <span class="cm">/* Brother Industries, Ltd HL-1440 Laser Printer */</span>
	<span class="p">{</span> <span class="mh">0x04b8</span><span class="p">,</span> <span class="mh">0x0202</span><span class="p">,</span> <span class="n">USBLP_QUIRK_BAD_CLASS</span> <span class="p">},</span> <span class="cm">/* Seiko Epson Receipt Printer M129C */</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">usblp_wwait</span><span class="p">(</span><span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nonblock</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">usblp_wtest</span><span class="p">(</span><span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nonblock</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">usblp_rwait_and_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nonblock</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">usblp_rtest</span><span class="p">(</span><span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nonblock</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">usblp_submit_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">usblp_select_alts</span><span class="p">(</span><span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">usblp_set_protocol</span><span class="p">(</span><span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">usblp_cache_device_id_string</span><span class="p">(</span><span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span><span class="p">);</span>

<span class="cm">/* forward reference to make our lives easier */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_driver</span> <span class="n">usblp_driver</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">usblp_mutex</span><span class="p">);</span>	<span class="cm">/* locks the existence of usblp&#39;s */</span>

<span class="cm">/*</span>
<span class="cm"> * Functions for usblp control messages.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usblp_ctrl_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">request</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span> <span class="kt">int</span> <span class="n">recip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">ifnum</span><span class="p">;</span>

	<span class="cm">/* High byte has the interface index.</span>
<span class="cm">	   Low byte has the alternate setting.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">request</span> <span class="o">==</span> <span class="n">USBLP_REQ_GET_ID</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">USB_TYPE_CLASS</span><span class="p">))</span>
		<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">ifnum</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">)</span><span class="o">|</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">[</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">current_protocol</span><span class="p">].</span><span class="n">alt_setting</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="n">dir</span> <span class="o">?</span> <span class="n">usb_rcvctrlpipe</span><span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">request</span><span class="p">,</span> <span class="n">type</span> <span class="o">|</span> <span class="n">dir</span> <span class="o">|</span> <span class="n">recip</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">USBLP_CTL_TIMEOUT</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;usblp_control_msg: rq: 0x%02x dir: %d recip: %d value: %d idx: %d len: %#x result: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">request</span><span class="p">,</span> <span class="o">!!</span><span class="n">dir</span><span class="p">,</span> <span class="n">recip</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">retval</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define usblp_read_status(usblp, status)\</span>
<span class="cp">	usblp_ctrl_msg(usblp, USBLP_REQ_GET_STATUS, USB_TYPE_CLASS, USB_DIR_IN, USB_RECIP_INTERFACE, 0, status, 1)</span>
<span class="cp">#define usblp_get_id(usblp, config, id, maxlen)\</span>
<span class="cp">	usblp_ctrl_msg(usblp, USBLP_REQ_GET_ID, USB_TYPE_CLASS, USB_DIR_IN, USB_RECIP_INTERFACE, config, id, maxlen)</span>
<span class="cp">#define usblp_reset(usblp)\</span>
<span class="cp">	usblp_ctrl_msg(usblp, USBLP_REQ_RESET, USB_TYPE_CLASS, USB_DIR_OUT, USB_RECIP_OTHER, 0, NULL, 0)</span>

<span class="cp">#define usblp_hp_channel_change_request(usblp, channel, buffer) \</span>
<span class="cp">	usblp_ctrl_msg(usblp, USBLP_REQ_HP_CHANNEL_CHANGE_REQUEST, USB_TYPE_VENDOR, USB_DIR_IN, USB_RECIP_INTERFACE, channel, buffer, 1)</span>

<span class="cm">/*</span>
<span class="cm"> * See the description for usblp_select_alts() below for the usage</span>
<span class="cm"> * explanation.  Look into your /proc/bus/usb/devices and dmesg in</span>
<span class="cm"> * case of any trouble.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">proto_bias</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * URB callback.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usblp_bulk_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">present</span> <span class="o">&amp;&amp;</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;usblp%d: &quot;</span>
			    <span class="s">&quot;nonzero read bulk status received: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">rstatus</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">rstatus</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">;</span>
	<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">rcomplete</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">rwait</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usblp_bulk_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">present</span> <span class="o">&amp;&amp;</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;usblp%d: &quot;</span>
			    <span class="s">&quot;nonzero write bulk status received: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">wstatus</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">wstatus</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">;</span>
	<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">no_paper</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">wcomplete</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">wwait</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get and print printer errors.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">usblp_messages</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;ok&quot;</span><span class="p">,</span> <span class="s">&quot;out of paper&quot;</span><span class="p">,</span> <span class="s">&quot;off-line&quot;</span><span class="p">,</span> <span class="s">&quot;on fire&quot;</span> <span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usblp_check_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">status</span><span class="p">,</span> <span class="n">newerr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">mut</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">usblp_read_status</span><span class="p">(</span><span class="n">usblp</span><span class="p">,</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">statusbuf</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">mut</span><span class="p">);</span>
		<span class="n">printk_ratelimited</span><span class="p">(</span><span class="n">KERN_ERR</span>
				<span class="s">&quot;usblp%d: error %d reading printer status</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">status</span> <span class="o">=</span> <span class="o">*</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">statusbuf</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">mut</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">LP_PERRORP</span><span class="p">)</span>
		<span class="n">newerr</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">LP_POUTPA</span><span class="p">)</span>
		<span class="n">newerr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">LP_PSELECD</span><span class="p">)</span>
		<span class="n">newerr</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">newerr</span> <span class="o">!=</span> <span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;usblp%d: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span> <span class="n">usblp_messages</span><span class="p">[</span><span class="n">newerr</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">newerr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_bidir</span><span class="p">(</span><span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">bidir</span> <span class="o">&amp;&amp;</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">usblp_submit_read</span><span class="p">(</span><span class="n">usblp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * File op functions.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usblp_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">minor</span> <span class="o">=</span> <span class="n">iminor</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">minor</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp_mutex</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">intf</span> <span class="o">=</span> <span class="n">usb_find_interface</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp_driver</span><span class="p">,</span> <span class="n">minor</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intf</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">usblp</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usblp</span> <span class="o">||</span> <span class="o">!</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">||</span> <span class="o">!</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">present</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We do not implement LP_ABORTOPEN/LPABORTOPEN for two reasons:</span>
<span class="cm">	 *  - We do not want persistent state which close(2) does not clear</span>
<span class="cm">	 *  - It is not used anyway, according to CUPS people</span>
<span class="cm">	 */</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_autopm_get_interface</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">usblp</span><span class="p">;</span>

	<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">wcomplete</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* we begin writeable */</span>
	<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">wstatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">rcomplete</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">handle_bidir</span><span class="p">(</span><span class="n">usblp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_autopm_put_interface</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
		<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usblp_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;usblp%d: removed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">readbuf</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">device_id_string</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">statusbuf</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">usblp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usblp_unlink_urbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">usb_kill_anchored_urbs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usblp_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LP_ABORT</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp_mutex</span><span class="p">);</span>
	<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">present</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usblp_unlink_urbs</span><span class="p">(</span><span class="n">usblp</span><span class="p">);</span>
		<span class="n">usb_autopm_put_interface</span><span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>		<span class="cm">/* finish cleanup from disconnect */</span>
		<span class="n">usblp_cleanup</span><span class="p">(</span><span class="n">usblp</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* No kernel lock - fine */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">usblp_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">poll_table_struct</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="cm">/* Should we check file-&gt;f_mode &amp; FMODE_WRITE before poll_wait()? */</span>
	<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">rwait</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
	<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">wwait</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="p">((</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">bidir</span> <span class="o">&amp;&amp;</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">rcomplete</span><span class="p">)</span> <span class="o">?</span> <span class="n">POLLIN</span>  <span class="o">|</span> <span class="n">POLLRDNORM</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
	   <span class="p">((</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">no_paper</span> <span class="o">||</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">wcomplete</span><span class="p">)</span> <span class="o">?</span> <span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">usblp_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">newChannel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">twoints</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">mut</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">present</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;usblp_ioctl: cmd=0x%x (%c nr=%d len=%d dir=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span>
		<span class="n">_IOC_TYPE</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">_IOC_NR</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">_IOC_SIZE</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">_IOC_DIR</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">_IOC_TYPE</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">==</span> <span class="sc">&#39;P&#39;</span><span class="p">)</span>	<span class="cm">/* new-style ioctl number */</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">_IOC_NR</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">case</span> <span class="n">IOCNR_GET_DEVICE_ID</span>: <span class="cm">/* get the DEVICE_ID string */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">_IOC_DIR</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">_IOC_READ</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">length</span> <span class="o">=</span> <span class="n">usblp_cache_device_id_string</span><span class="p">(</span><span class="n">usblp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">_IOC_SIZE</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span>
				<span class="n">length</span> <span class="o">=</span> <span class="n">_IOC_SIZE</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span> <span class="cm">/* truncate */</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">,</span>
					<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">device_id_string</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">length</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">IOCNR_GET_PROTOCOLS</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">_IOC_DIR</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">_IOC_READ</span> <span class="o">||</span>
			    <span class="n">_IOC_SIZE</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">twoints</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">twoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">current_protocol</span><span class="p">;</span>
			<span class="n">twoints</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">USBLP_FIRST_PROTOCOL</span><span class="p">;</span>
			     <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">USBLP_LAST_PROTOCOL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">alt_setting</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">twoints</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">twoints</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">twoints</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">IOCNR_SET_PROTOCOL</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">_IOC_DIR</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">_IOC_WRITE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>

<span class="cp">#ifdef DEBUG</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">==</span> <span class="o">-</span><span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">usblp_dump</span><span class="p">(</span><span class="n">usblp</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#endif</span>

			<span class="n">usblp_unlink_urbs</span><span class="p">(</span><span class="n">usblp</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">usblp_set_protocol</span><span class="p">(</span><span class="n">usblp</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">usblp_set_protocol</span><span class="p">(</span><span class="n">usblp</span><span class="p">,</span>
					<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">current_protocol</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">IOCNR_HP_SET_CHANNEL</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">_IOC_DIR</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">_IOC_WRITE</span> <span class="o">||</span>
			    <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idVendor</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x03F0</span> <span class="o">||</span>
			    <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">USBLP_QUIRK_BIDIR</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">usblp_hp_channel_change_request</span><span class="p">(</span><span class="n">usblp</span><span class="p">,</span>
				<span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newChannel</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;usblp%d: error = %d setting &quot;</span>
					<span class="s">&quot;HP channel</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;usblp%d requested/got HP channel %ld/%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">newChannel</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">IOCNR_GET_BUS_ADDRESS</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">_IOC_DIR</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">_IOC_READ</span> <span class="o">||</span>
			    <span class="n">_IOC_SIZE</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">twoints</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">twoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">busnum</span><span class="p">;</span>
			<span class="n">twoints</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">twoints</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">twoints</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;usblp%d is bus=%d, device=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span> <span class="n">twoints</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">twoints</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">IOCNR_GET_VID_PID</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">_IOC_DIR</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">_IOC_READ</span> <span class="o">||</span>
			    <span class="n">_IOC_SIZE</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">twoints</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">twoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idVendor</span><span class="p">);</span>
			<span class="n">twoints</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idProduct</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">twoints</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">twoints</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;usblp%d is VID=0x%4.4X, PID=0x%4.4X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span> <span class="n">twoints</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">twoints</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">IOCNR_SOFT_RESET</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">_IOC_DIR</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">_IOC_NONE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">usblp_reset</span><span class="p">(</span><span class="n">usblp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">else</span>	<span class="cm">/* old-style ioctl value */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">case</span> <span class="n">LPGETSTATUS</span>:
			<span class="k">if</span> <span class="p">((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">usblp_read_status</span><span class="p">(</span><span class="n">usblp</span><span class="p">,</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">statusbuf</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">printk_ratelimited</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;usblp%d:&quot;</span>
					    <span class="s">&quot;failed reading printer status (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					    <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">*</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">statusbuf</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)))</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">LPABORT</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">arg</span><span class="p">)</span>
				<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">LP_ABORT</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LP_ABORT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
		<span class="p">}</span>

<span class="nl">done:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">mut</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="nf">usblp_new_writeurb</span><span class="p">(</span><span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">transfer_length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">writebuf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">writebuf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">transfer_length</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">writebuf</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="n">usb_sndbulkpipe</span><span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		 <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">[</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">current_protocol</span><span class="p">].</span><span class="n">epwrite</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span><span class="p">),</span>
		<span class="n">writebuf</span><span class="p">,</span> <span class="n">transfer_length</span><span class="p">,</span> <span class="n">usblp_bulk_write</span><span class="p">,</span> <span class="n">usblp</span><span class="p">);</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">|=</span> <span class="n">URB_FREE_BUFFER</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">urb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">usblp_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">writeurb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">transfer_length</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">writecount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">wmut</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">raise_biglock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rv</span> <span class="o">=</span> <span class="n">usblp_wwait</span><span class="p">(</span><span class="n">usblp</span><span class="p">,</span> <span class="o">!!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">raise_wait</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">writecount</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Step 1: Submit next block.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">transfer_length</span> <span class="o">=</span> <span class="n">count</span> <span class="o">-</span> <span class="n">writecount</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">USBLP_BUF_SIZE</span><span class="p">)</span>
			<span class="n">transfer_length</span> <span class="o">=</span> <span class="n">USBLP_BUF_SIZE</span><span class="p">;</span>

		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">writeurb</span> <span class="o">=</span> <span class="n">usblp_new_writeurb</span><span class="p">(</span><span class="n">usblp</span><span class="p">,</span> <span class="n">transfer_length</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">raise_urb</span><span class="p">;</span>
		<span class="n">usb_anchor_urb</span><span class="p">(</span><span class="n">writeurb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">writeurb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span>
				   <span class="n">buffer</span> <span class="o">+</span> <span class="n">writecount</span><span class="p">,</span> <span class="n">transfer_length</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">raise_badaddr</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">wcomplete</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rv</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">writeurb</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">wstatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">no_paper</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">wcomplete</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">wwait</span><span class="p">);</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
				<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">raise_submit</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Step 2: Wait for transfer to end, collect results.</span>
<span class="cm">		 */</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="n">usblp_wwait</span><span class="p">(</span><span class="n">usblp</span><span class="p">,</span> <span class="o">!!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span><span class="o">&amp;</span><span class="n">O_NONBLOCK</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Presume that it&#39;s going to complete well. */</span>
				<span class="n">writecount</span> <span class="o">+=</span> <span class="n">transfer_length</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
				<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">no_paper</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Mark for poll(2) */</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
				<span class="n">writecount</span> <span class="o">+=</span> <span class="n">transfer_length</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Leave URB dangling, to be cleaned on close. */</span>
			<span class="k">goto</span> <span class="n">collect_error</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">wstatus</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">collect_error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * This is critical: it must be our URB, not other writer&#39;s.</span>
<span class="cm">		 * The wmut exists mainly to cover us here.</span>
<span class="cm">		 */</span>
		<span class="n">writecount</span> <span class="o">+=</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">wstatus</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">wmut</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">writecount</span><span class="p">;</span>

<span class="nl">raise_submit:</span>
<span class="nl">raise_badaddr:</span>
	<span class="n">usb_unanchor_urb</span><span class="p">(</span><span class="n">writeurb</span><span class="p">);</span>
	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">writeurb</span><span class="p">);</span>
<span class="nl">raise_urb:</span>
<span class="nl">raise_wait:</span>
<span class="nl">collect_error:</span>		<span class="cm">/* Out of raise sequence */</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">wmut</span><span class="p">);</span>
<span class="nl">raise_biglock:</span>
	<span class="k">return</span> <span class="n">writecount</span> <span class="o">?</span> <span class="n">writecount</span> <span class="o">:</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Notice that we fail to restart in a few cases: on EFAULT, on restart</span>
<span class="cm"> * error, etc. This is the historical behaviour. In all such cases we return</span>
<span class="cm"> * EIO, and applications loop in order to get the new read going.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">usblp_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">avail</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">bidir</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">rv</span> <span class="o">=</span> <span class="n">usblp_rwait_and_lock</span><span class="p">(</span><span class="n">usblp</span><span class="p">,</span> <span class="o">!!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">avail</span> <span class="o">=</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">rstatus</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;usblp%d: error %d reading from printer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">avail</span><span class="p">);</span>
		<span class="n">usblp_submit_read</span><span class="p">(</span><span class="n">usblp</span><span class="p">);</span>
		<span class="n">count</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">count</span> <span class="o">=</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">avail</span> <span class="o">-</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">readcount</span> <span class="o">?</span> <span class="n">len</span> <span class="o">:</span> <span class="n">avail</span> <span class="o">-</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">readcount</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">copy_to_user</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">readbuf</span> <span class="o">+</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">readcount</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">readcount</span> <span class="o">+=</span> <span class="n">count</span><span class="p">)</span> <span class="o">==</span> <span class="n">avail</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">usblp_submit_read</span><span class="p">(</span><span class="n">usblp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* We don&#39;t want to leak USB return codes into errno. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">count</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">mut</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wait for the write path to come idle.</span>
<span class="cm"> * This is called under the -&gt;wmut, so the idle path stays idle.</span>
<span class="cm"> *</span>
<span class="cm"> * Our write path has a peculiar property: it does not buffer like a tty,</span>
<span class="cm"> * but waits for the write to succeed. This allows our -&gt;release to bug out</span>
<span class="cm"> * without waiting for writes to drain. But it obviously does not work</span>
<span class="cm"> * when O_NONBLOCK is set. So, applications setting O_NONBLOCK must use</span>
<span class="cm"> * select(2) or poll(2) to wait for the buffer to drain before closing.</span>
<span class="cm"> * Alternatively, set blocking mode with fcntl and issue a zero-size write.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usblp_wwait</span><span class="p">(</span><span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nonblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">waita</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">wwait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">waita</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">mut</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">usblp_wtest</span><span class="p">(</span><span class="n">usblp</span><span class="p">,</span> <span class="n">nonblock</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">mut</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">schedule_timeout</span><span class="p">(</span><span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">1500</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LP_ABORT</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">usblp_check_status</span><span class="p">(</span><span class="n">usblp</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Paper out */</span>
					<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Prod the printer, Gentoo#251237. */</span>
				<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">mut</span><span class="p">);</span>
				<span class="n">usblp_read_status</span><span class="p">(</span><span class="n">usblp</span><span class="p">,</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">statusbuf</span><span class="p">);</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">mut</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">wwait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">waita</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usblp_wtest</span><span class="p">(</span><span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nonblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">present</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">wcomplete</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nonblock</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wait for read bytes to become available. This probably should have been</span>
<span class="cm"> * called usblp_r_lock_and_wait(), because we lock first. But it&#39;s a traditional</span>
<span class="cm"> * name for functions which lock and return.</span>
<span class="cm"> *</span>
<span class="cm"> * We do not use wait_event_interruptible because it makes locking iffy.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usblp_rwait_and_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nonblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">waita</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">rwait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">waita</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">mut</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">usblp_rtest</span><span class="p">(</span><span class="n">usblp</span><span class="p">,</span> <span class="n">nonblock</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">mut</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>	<span class="cm">/* Keep it locked */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">mut</span><span class="p">);</span>
		<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">rwait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">waita</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usblp_rtest</span><span class="p">(</span><span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nonblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">present</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">rcomplete</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nonblock</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Please check -&gt;bidir and other such things outside for now.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usblp_submit_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">raise_urb</span><span class="p">;</span>

	<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="n">usb_rcvbulkpipe</span><span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		  <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">[</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">current_protocol</span><span class="p">].</span><span class="n">epread</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span><span class="p">),</span>
		<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">readbuf</span><span class="p">,</span> <span class="n">USBLP_BUF_SIZE_IN</span><span class="p">,</span>
		<span class="n">usblp_bulk_read</span><span class="p">,</span> <span class="n">usblp</span><span class="p">);</span>
	<span class="n">usb_anchor_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">readcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* XXX Why here? */</span>
	<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">rcomplete</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;error submitting urb (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">rstatus</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
		<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">rcomplete</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">raise_submit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">raise_submit:</span>
	<span class="n">usb_unanchor_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
<span class="nl">raise_urb:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Checks for printers that have quirks, such as requiring unidirectional</span>
<span class="cm"> * communication but reporting bidirectional; currently some HP printers</span>
<span class="cm"> * have this flaw (HP 810, 880, 895, etc.), or needing an init string</span>
<span class="cm"> * sent at each open (like some Epsons).</span>
<span class="cm"> * Returns 1 if found, 0 if not found.</span>
<span class="cm"> *</span>
<span class="cm"> * HP recommended that we use the bidirectional interface but</span>
<span class="cm"> * don&#39;t attempt any bulk IN transfers from the IN endpoint.</span>
<span class="cm"> * Here&#39;s some more detail on the problem:</span>
<span class="cm"> * The problem is not that it isn&#39;t bidirectional though. The problem</span>
<span class="cm"> * is that if you request a device ID, or status information, while</span>
<span class="cm"> * the buffers are full, the return data will end up in the print data</span>
<span class="cm"> * buffer. For example if you make sure you never request the device ID</span>
<span class="cm"> * while you are sending print data, and you don&#39;t try to query the</span>
<span class="cm"> * printer status every couple of milliseconds, you will probably be OK.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">usblp_quirks</span><span class="p">(</span><span class="n">__u16</span> <span class="n">vendor</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">product</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">quirk_printers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vendorId</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vendor</span> <span class="o">==</span> <span class="n">quirk_printers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vendorId</span> <span class="o">&amp;&amp;</span>
		    <span class="n">product</span> <span class="o">==</span> <span class="n">quirk_printers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">productId</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">quirk_printers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">quirks</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">usblp_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span>		<span class="n">usblp_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span>	<span class="n">usblp_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span> <span class="o">=</span>		<span class="n">usblp_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span>	<span class="n">usblp_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">compat_ioctl</span> <span class="o">=</span>		<span class="n">usblp_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span>		<span class="n">usblp_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span>	<span class="n">usblp_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span>	<span class="n">noop_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">usblp_devnode</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">umode_t</span> <span class="o">*</span><span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kasprintf</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="s">&quot;usb/%s&quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_class_driver</span> <span class="n">usblp_class</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;lp%d&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">devnode</span> <span class="o">=</span>	<span class="n">usblp_devnode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fops</span> <span class="o">=</span>		<span class="o">&amp;</span><span class="n">usblp_fops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">minor_base</span> <span class="o">=</span>	<span class="n">USBLP_MINOR_BASE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">usblp_show_ieee1284_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span> <span class="o">=</span> <span class="n">to_usb_interface</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">device_id_string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">device_id_string</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">device_id_string</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">ieee1284_id</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">usblp_show_ieee1284_id</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usblp_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">protocol</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* Malloc and start initializing usblp structure so we can use it</span>
<span class="cm">	 * directly. */</span>
	<span class="n">usblp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usblp</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usblp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">abort_ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">wmut</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">mut</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">rwait</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">wwait</span><span class="p">);</span>
	<span class="n">init_usb_anchor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">);</span>
	<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">ifnum</span> <span class="o">=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">;</span>
	<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">intf</span> <span class="o">=</span> <span class="n">intf</span><span class="p">;</span>

	<span class="cm">/* Malloc device ID string buffer to the largest expected length,</span>
<span class="cm">	 * since we can re-query it on an ioctl and a dynamic string</span>
<span class="cm">	 * could change in length. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">device_id_string</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">USBLP_DEVICE_ID_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate read buffer. We somewhat wastefully</span>
<span class="cm">	 * malloc both regardless of bidirectionality, because the</span>
<span class="cm">	 * alternate setting can be changed later via an ioctl.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">readbuf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">USBLP_BUF_SIZE_IN</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate buffer for printer status */</span>
	<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">statusbuf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">STATUS_BUF_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">statusbuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Lookup quirks for this printer. */</span>
	<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">=</span> <span class="n">usblp_quirks</span><span class="p">(</span>
		<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idVendor</span><span class="p">),</span>
		<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idProduct</span><span class="p">));</span>

	<span class="cm">/* Analyze and pick initial alternate settings and endpoints. */</span>
	<span class="n">protocol</span> <span class="o">=</span> <span class="n">usblp_select_alts</span><span class="p">(</span><span class="n">usblp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">protocol</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;incompatible printer-class device 0x%4.4X/0x%4.4X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idVendor</span><span class="p">),</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idProduct</span><span class="p">));</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Setup the selected alternate setting and endpoints. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usblp_set_protocol</span><span class="p">(</span><span class="n">usblp</span><span class="p">,</span> <span class="n">protocol</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>	<span class="cm">/* -&gt;probe isn&#39;t -&gt;ioctl */</span>
		<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Retrieve and store the device ID string. */</span>
	<span class="n">usblp_cache_device_id_string</span><span class="p">(</span><span class="n">usblp</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_ieee1284_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">abort_intfdata</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="n">usblp_check_status</span><span class="p">(</span><span class="n">usblp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">usblp</span><span class="p">);</span>

	<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">present</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_register_dev</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usblp_class</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;usblp: Not able to get a minor (base %u, slice default): %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">USBLP_MINOR_BASE</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">abort_intfdata</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">minor</span> <span class="o">=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">;</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;usblp%d: USB %sdirectional printer dev %d if %d alt %d proto %d vid 0x%4.4X pid 0x%4.4X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">bidir</span> <span class="o">?</span> <span class="s">&quot;Bi&quot;</span> <span class="o">:</span> <span class="s">&quot;Uni&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">,</span>
		<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">ifnum</span><span class="p">,</span>
		<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">[</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">current_protocol</span><span class="p">].</span><span class="n">alt_setting</span><span class="p">,</span>
		<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">current_protocol</span><span class="p">,</span>
		<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idVendor</span><span class="p">),</span>
		<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idProduct</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">abort_intfdata:</span>
	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">device_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_ieee1284_id</span><span class="p">);</span>
<span class="nl">abort:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">readbuf</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">statusbuf</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">device_id_string</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">usblp</span><span class="p">);</span>
<span class="nl">abort_ret:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We are a &quot;new&quot; style driver with usb_device_id table,</span>
<span class="cm"> * but our requirements are too intricate for simple match to handle.</span>
<span class="cm"> *</span>
<span class="cm"> * The &quot;proto_bias&quot; option may be used to specify the preferred protocol</span>
<span class="cm"> * for all USB printers (1=7/1/1, 2=7/1/2, 3=7/1/3).  If the device</span>
<span class="cm"> * supports the preferred protocol, then we bind to it.</span>
<span class="cm"> *</span>
<span class="cm"> * The best interface for us is 7/1/2, because it is compatible</span>
<span class="cm"> * with a stream of characters. If we find it, we bind to it.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the people from hpoj.sourceforge.net need to be able to</span>
<span class="cm"> * bind to 7/1/3 (MLC/1284.4), so we provide them ioctls for this purpose.</span>
<span class="cm"> *</span>
<span class="cm"> * Failing 7/1/2, we look for 7/1/3, even though it&#39;s probably not</span>
<span class="cm"> * stream-compatible, because this matches the behaviour of the old code.</span>
<span class="cm"> *</span>
<span class="cm"> * If nothing else, we bind to 7/1/1 - the unidirectional interface.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usblp_select_alts</span><span class="p">(</span><span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">if_alt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">ifd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">epd</span><span class="p">,</span> <span class="o">*</span><span class="n">epwrite</span><span class="p">,</span> <span class="o">*</span><span class="n">epread</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span><span class="p">;</span>

	<span class="n">if_alt</span> <span class="o">=</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">USBLP_MAX_PROTOCOLS</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span>
		<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">alt_setting</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Find out what we have. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">if_alt</span><span class="o">-&gt;</span><span class="n">num_altsetting</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ifd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">if_alt</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ifd</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceClass</span> <span class="o">!=</span> <span class="mi">7</span> <span class="o">||</span> <span class="n">ifd</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceSubClass</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">USBLP_QUIRK_BAD_CLASS</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ifd</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceProtocol</span> <span class="o">&lt;</span> <span class="n">USBLP_FIRST_PROTOCOL</span> <span class="o">||</span>
		    <span class="n">ifd</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceProtocol</span> <span class="o">&gt;</span> <span class="n">USBLP_LAST_PROTOCOL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Look for bulk OUT and IN endpoints. */</span>
		<span class="n">epwrite</span> <span class="o">=</span> <span class="n">epread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">e</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="n">ifd</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumEndpoints</span><span class="p">;</span> <span class="n">e</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">epd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ifd</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">[</span><span class="n">e</span><span class="p">].</span><span class="n">desc</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_is_bulk_out</span><span class="p">(</span><span class="n">epd</span><span class="p">))</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">epwrite</span><span class="p">)</span>
					<span class="n">epwrite</span> <span class="o">=</span> <span class="n">epd</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_is_bulk_in</span><span class="p">(</span><span class="n">epd</span><span class="p">))</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">epread</span><span class="p">)</span>
					<span class="n">epread</span> <span class="o">=</span> <span class="n">epd</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Ignore buggy hardware without the right endpoints. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">epwrite</span> <span class="o">||</span> <span class="p">(</span><span class="n">ifd</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceProtocol</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">epread</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Turn off reads for 7/1/1 (unidirectional) interfaces</span>
<span class="cm">		 * and buggy bidirectional printers. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ifd</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceProtocol</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">epread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">USBLP_QUIRK_BIDIR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;usblp%d: Disabling reads from &quot;</span>
			    <span class="s">&quot;problematic bidirectional printer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>
			<span class="n">epread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">[</span><span class="n">ifd</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceProtocol</span><span class="p">].</span><span class="n">alt_setting</span> <span class="o">=</span>
				<span class="n">ifd</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bAlternateSetting</span><span class="p">;</span>
		<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">[</span><span class="n">ifd</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceProtocol</span><span class="p">].</span><span class="n">epwrite</span> <span class="o">=</span> <span class="n">epwrite</span><span class="p">;</span>
		<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">[</span><span class="n">ifd</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceProtocol</span><span class="p">].</span><span class="n">epread</span> <span class="o">=</span> <span class="n">epread</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If our requested protocol is supported, then use it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">proto_bias</span> <span class="o">&gt;=</span> <span class="n">USBLP_FIRST_PROTOCOL</span> <span class="o">&amp;&amp;</span>
	    <span class="n">proto_bias</span> <span class="o">&lt;=</span> <span class="n">USBLP_LAST_PROTOCOL</span> <span class="o">&amp;&amp;</span>
	    <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">[</span><span class="n">proto_bias</span><span class="p">].</span><span class="n">alt_setting</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">proto_bias</span><span class="p">;</span>

	<span class="cm">/* Ordering is important here. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">alt_setting</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">alt_setting</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">alt_setting</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>

	<span class="cm">/* If nothing is available, then don&#39;t bind to this device. */</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usblp_set_protocol</span><span class="p">(</span><span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">alts</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">protocol</span> <span class="o">&lt;</span> <span class="n">USBLP_FIRST_PROTOCOL</span> <span class="o">||</span> <span class="n">protocol</span> <span class="o">&gt;</span> <span class="n">USBLP_LAST_PROTOCOL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">alts</span> <span class="o">=</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">[</span><span class="n">protocol</span><span class="p">].</span><span class="n">alt_setting</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alts</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">usb_set_interface</span><span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">ifnum</span><span class="p">,</span> <span class="n">alts</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;usblp: can&#39;t set desired altsetting %d on interface %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">alts</span><span class="p">,</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">ifnum</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">bidir</span> <span class="o">=</span> <span class="p">(</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">[</span><span class="n">protocol</span><span class="p">].</span><span class="n">epread</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">current_protocol</span> <span class="o">=</span> <span class="n">protocol</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;usblp%d set protocol %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span> <span class="n">protocol</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Retrieves and caches device ID string.</span>
<span class="cm"> * Returns length, including length bytes but not null terminator.</span>
<span class="cm"> * On error, returns a negative errno value. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usblp_cache_device_id_string</span><span class="p">(</span><span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">length</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">usblp_get_id</span><span class="p">(</span><span class="n">usblp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">device_id_string</span><span class="p">,</span> <span class="n">USBLP_DEVICE_ID_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;usblp%d: error = %d reading IEEE-1284 Device ID string</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">device_id_string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">usblp</span><span class="o">-&gt;</span><span class="n">device_id_string</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* First two bytes are length in big-endian.</span>
<span class="cm">	 * They count themselves, and we copy them into</span>
<span class="cm">	 * the user&#39;s buffer. */</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">__be16</span> <span class="o">*</span><span class="p">)</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">device_id_string</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">length</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;=</span> <span class="n">USBLP_DEVICE_ID_SIZE</span><span class="p">)</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">USBLP_DEVICE_ID_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">device_id_string</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;usblp%d Device ID string [len=%d]=</span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">device_id_string</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usblp_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="n">usb_deregister_dev</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usblp_class</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usblp</span> <span class="o">||</span> <span class="o">!</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;bogus disconnect</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">device_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_ieee1284_id</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp_mutex</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">mut</span><span class="p">);</span>
	<span class="n">usblp</span><span class="o">-&gt;</span><span class="n">present</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">wwait</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">rwait</span><span class="p">);</span>
	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">usblp_unlink_urbs</span><span class="p">(</span><span class="n">usblp</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">mut</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usblp</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">)</span>
		<span class="n">usblp_cleanup</span><span class="p">(</span><span class="n">usblp</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usblp_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usblp_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="n">usblp_unlink_urbs</span><span class="p">(</span><span class="n">usblp</span><span class="p">);</span>
<span class="cp">#if 0</span><span class="c"> /* XXX Do we want this? What if someone is reading, should we fail? */</span>
<span class="c">	/* not strictly necessary, but just in case */</span>
<span class="c">	wake_up(&amp;usblp-&gt;wwait);</span>
<span class="c">	wake_up(&amp;usblp-&gt;rwait);</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usblp_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usblp</span> <span class="o">*</span><span class="n">usblp</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">handle_bidir</span><span class="p">(</span><span class="n">usblp</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="n">usblp_ids</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">USB_DEVICE_INFO</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">USB_DEVICE_INFO</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">USB_DEVICE_INFO</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">USB_INTERFACE_INFO</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">USB_INTERFACE_INFO</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">USB_INTERFACE_INFO</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x04b8</span><span class="p">,</span> <span class="mh">0x0202</span><span class="p">)</span> <span class="p">},</span>	<span class="cm">/* Seiko Epson Receipt Printer M129C */</span>
	<span class="p">{</span> <span class="p">}</span>						<span class="cm">/* Terminating entry */</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">usb</span><span class="p">,</span> <span class="n">usblp_ids</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_driver</span> <span class="n">usblp_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;usblp&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span>	<span class="n">usblp_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disconnect</span> <span class="o">=</span>	<span class="n">usblp_disconnect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span>	<span class="n">usblp_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span>	<span class="n">usblp_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span>	<span class="n">usblp_ids</span><span class="p">,</span>
	<span class="p">.</span><span class="n">supports_autosuspend</span> <span class="o">=</span>	<span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">module_usb_driver</span><span class="p">(</span><span class="n">usblp_driver</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="n">DRIVER_AUTHOR</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">DRIVER_DESC</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">proto_bias</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">proto_bias</span><span class="p">,</span> <span class="s">&quot;Favourite protocol number&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
