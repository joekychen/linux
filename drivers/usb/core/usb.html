<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › core › usb.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>usb.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * drivers/usb/core/usb.c</span>
<span class="cm"> *</span>
<span class="cm"> * (C) Copyright Linus Torvalds 1999</span>
<span class="cm"> * (C) Copyright Johannes Erdfelt 1999-2001</span>
<span class="cm"> * (C) Copyright Andreas Gal 1999</span>
<span class="cm"> * (C) Copyright Gregory P. Smith 1999</span>
<span class="cm"> * (C) Copyright Deti Fliegl 1999 (new USB architecture)</span>
<span class="cm"> * (C) Copyright Randy Dunlap 2000</span>
<span class="cm"> * (C) Copyright David Brownell 2000-2004</span>
<span class="cm"> * (C) Copyright Yggdrasil Computing, Inc. 2000</span>
<span class="cm"> *     (usb_device_id matching changes by Adam J. Richter)</span>
<span class="cm"> * (C) Copyright Greg Kroah-Hartman 2002-2003</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE! This is not actually a driver at all, rather this is</span>
<span class="cm"> * just a collection of helper routines that implement the</span>
<span class="cm"> * generic USB things that the real drivers can use..</span>
<span class="cm"> *</span>
<span class="cm"> * Think of this as a &quot;USB library&quot; rather than anything else.</span>
<span class="cm"> * It should be considered a slave, with no callbacks. Callbacks</span>
<span class="cm"> * are evil.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;  </span><span class="cm">/* for in_interrupt() */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/kmod.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/usb/hcd.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>

<span class="cp">#include &quot;usb.h&quot;</span>


<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">usbcore_name</span> <span class="o">=</span> <span class="s">&quot;usbcore&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">nousb</span><span class="p">;</span>	<span class="cm">/* Disable USB when built into kernel image */</span>

<span class="cp">#ifdef	CONFIG_USB_SUSPEND</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">usb_autosuspend_delay</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>		<span class="cm">/* Default delay value,</span>
<span class="cm">						 * in seconds */</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">autosuspend</span><span class="p">,</span> <span class="n">usb_autosuspend_delay</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">autosuspend</span><span class="p">,</span> <span class="s">&quot;default autosuspend delay&quot;</span><span class="p">);</span>

<span class="cp">#else</span>
<span class="cp">#define usb_autosuspend_delay		0</span>
<span class="cp">#endif</span>


<span class="cm">/**</span>
<span class="cm"> * usb_find_alt_setting() - Given a configuration, find the alternate setting</span>
<span class="cm"> * for the given interface.</span>
<span class="cm"> * @config: the configuration to search (not necessarily the current config).</span>
<span class="cm"> * @iface_num: interface number to search in</span>
<span class="cm"> * @alt_num: alternate interface setting number to search for.</span>
<span class="cm"> *</span>
<span class="cm"> * Search the configuration&#39;s interface cache for the given alt setting.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="nf">usb_find_alt_setting</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">usb_host_config</span> <span class="o">*</span><span class="n">config</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">iface_num</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alt_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_interface_cache</span> <span class="o">*</span><span class="n">intf_cache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumInterfaces</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">intf_cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span>
				<span class="o">==</span> <span class="n">iface_num</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">intf_cache</span> <span class="o">=</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">intf_cache</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intf_cache</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intf_cache</span><span class="o">-&gt;</span><span class="n">num_altsetting</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">intf_cache</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span><span class="p">.</span><span class="n">bAlternateSetting</span> <span class="o">==</span> <span class="n">alt_num</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="n">intf_cache</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Did not find alt setting %u for intf %u, &quot;</span>
			<span class="s">&quot;config %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">alt_num</span><span class="p">,</span> <span class="n">iface_num</span><span class="p">,</span>
			<span class="n">config</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bConfigurationValue</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_find_alt_setting</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_ifnum_to_if - get the interface object with a given interface number</span>
<span class="cm"> * @dev: the device whose current configuration is considered</span>
<span class="cm"> * @ifnum: the desired interface</span>
<span class="cm"> *</span>
<span class="cm"> * This walks the device descriptor for the currently active configuration</span>
<span class="cm"> * and returns a pointer to the interface with that particular interface</span>
<span class="cm"> * number, or null.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that configuration descriptors are not required to assign interface</span>
<span class="cm"> * numbers sequentially, so that it would be incorrect to assume that</span>
<span class="cm"> * the first interface in that descriptor corresponds to interface zero.</span>
<span class="cm"> * This routine helps device drivers avoid such mistakes.</span>
<span class="cm"> * However, you should make sure that you do the right thing with any</span>
<span class="cm"> * alternate settings available for this interfaces.</span>
<span class="cm"> *</span>
<span class="cm"> * Don&#39;t call this function unless you are bound to one of the interfaces</span>
<span class="cm"> * on this device or you have locked the device!</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="nf">usb_ifnum_to_if</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="n">ifnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_host_config</span> <span class="o">*</span><span class="n">config</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">config</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumInterfaces</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
				<span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span> <span class="o">==</span> <span class="n">ifnum</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_ifnum_to_if</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_altnum_to_altsetting - get the altsetting structure with a given alternate setting number.</span>
<span class="cm"> * @intf: the interface containing the altsetting in question</span>
<span class="cm"> * @altnum: the desired alternate setting number</span>
<span class="cm"> *</span>
<span class="cm"> * This searches the altsetting array of the specified interface for</span>
<span class="cm"> * an entry with the correct bAlternateSetting value and returns a pointer</span>
<span class="cm"> * to that entry, or null.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that altsettings need not be stored sequentially by number, so</span>
<span class="cm"> * it would be incorrect to assume that the first altsetting entry in</span>
<span class="cm"> * the array corresponds to altsetting zero.  This routine helps device</span>
<span class="cm"> * drivers avoid such mistakes.</span>
<span class="cm"> *</span>
<span class="cm"> * Don&#39;t call this function unless you are bound to the intf interface</span>
<span class="cm"> * or you have locked the device!</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="nf">usb_altnum_to_altsetting</span><span class="p">(</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">altnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">num_altsetting</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span><span class="p">.</span><span class="n">bAlternateSetting</span> <span class="o">==</span> <span class="n">altnum</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_altnum_to_altsetting</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">find_interface_arg</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">minor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__find_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">find_interface_arg</span> <span class="o">*</span><span class="n">arg</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_usb_interface</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">!=</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">drv</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">intf</span> <span class="o">=</span> <span class="n">to_usb_interface</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">minor</span> <span class="o">==</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_find_interface - find usb_interface pointer for driver and device</span>
<span class="cm"> * @drv: the driver whose current configuration is considered</span>
<span class="cm"> * @minor: the minor number of the desired device</span>
<span class="cm"> *</span>
<span class="cm"> * This walks the bus device list and returns a pointer to the interface</span>
<span class="cm"> * with the matching minor and driver.  Note, this only works for devices</span>
<span class="cm"> * that share the USB major number.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="nf">usb_find_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">find_interface_arg</span> <span class="n">argb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">argb</span><span class="p">.</span><span class="n">minor</span> <span class="o">=</span> <span class="n">minor</span><span class="p">;</span>
	<span class="n">argb</span><span class="p">.</span><span class="n">drv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">drvwrap</span><span class="p">.</span><span class="n">driver</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">bus_find_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_bus_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argb</span><span class="p">,</span> <span class="n">__find_interface</span><span class="p">);</span>

	<span class="cm">/* Drop reference count from bus_find_device */</span>
	<span class="n">put_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">dev</span> <span class="o">?</span> <span class="n">to_usb_interface</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_find_interface</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_release_dev - free a usb device structure when all users of it are finished.</span>
<span class="cm"> * @dev: device that&#39;s been disconnected</span>
<span class="cm"> *</span>
<span class="cm"> * Will be called only by the device core when all users of this usb device are</span>
<span class="cm"> * done.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usb_release_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">;</span>

	<span class="n">udev</span> <span class="o">=</span> <span class="n">to_usb_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>

	<span class="n">usb_destroy_configuration</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="n">usb_release_bos_descriptor</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="n">usb_put_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">product</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">manufacturer</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef	CONFIG_HOTPLUG</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_dev_uevent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span><span class="p">;</span>

	<span class="n">usb_dev</span> <span class="o">=</span> <span class="n">to_usb_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">add_uevent_var</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s">&quot;BUSNUM=%03d&quot;</span><span class="p">,</span> <span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">busnum</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">add_uevent_var</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s">&quot;DEVNUM=%03d&quot;</span><span class="p">,</span> <span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_dev_uevent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_HOTPLUG */</span><span class="cp"></span>

<span class="cp">#ifdef	CONFIG_PM</span>

<span class="cm">/* USB device Power-Management thunks.</span>
<span class="cm"> * There&#39;s no need to distinguish here between quiescing a USB device</span>
<span class="cm"> * and powering it down; the generic_suspend() routine takes care of</span>
<span class="cm"> * it by skipping the usb_port_suspend() call for a quiesce.  And for</span>
<span class="cm"> * USB interfaces there&#39;s no difference at all.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_dev_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* Implement eventually? */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usb_dev_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Currently used only for rebinding interfaces */</span>
	<span class="n">usb_resume_complete</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_dev_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">usb_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PMSG_SUSPEND</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_dev_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">usb_resume</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PMSG_RESUME</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_dev_freeze</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">usb_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PMSG_FREEZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_dev_thaw</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">usb_resume</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PMSG_THAW</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_dev_poweroff</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">usb_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PMSG_HIBERNATE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_dev_restore</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">usb_resume</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PMSG_RESTORE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">usb_device_pm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">prepare</span> <span class="o">=</span>	<span class="n">usb_dev_prepare</span><span class="p">,</span>
	<span class="p">.</span><span class="n">complete</span> <span class="o">=</span>	<span class="n">usb_dev_complete</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span>	<span class="n">usb_dev_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span>	<span class="n">usb_dev_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">freeze</span> <span class="o">=</span>	<span class="n">usb_dev_freeze</span><span class="p">,</span>
	<span class="p">.</span><span class="n">thaw</span> <span class="o">=</span>		<span class="n">usb_dev_thaw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poweroff</span> <span class="o">=</span>	<span class="n">usb_dev_poweroff</span><span class="p">,</span>
	<span class="p">.</span><span class="n">restore</span> <span class="o">=</span>	<span class="n">usb_dev_restore</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_USB_SUSPEND</span>
	<span class="p">.</span><span class="n">runtime_suspend</span> <span class="o">=</span>	<span class="n">usb_runtime_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">runtime_resume</span> <span class="o">=</span>	<span class="n">usb_runtime_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">runtime_idle</span> <span class="o">=</span>		<span class="n">usb_runtime_idle</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cp">#endif	</span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>


<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">usb_devnode</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">umode_t</span> <span class="o">*</span><span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span><span class="p">;</span>

	<span class="n">usb_dev</span> <span class="o">=</span> <span class="n">to_usb_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">kasprintf</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="s">&quot;bus/usb/%03d/%03d&quot;</span><span class="p">,</span>
			 <span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">busnum</span><span class="p">,</span> <span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">device_type</span> <span class="n">usb_device_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;usb_device&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span>	<span class="n">usb_release_dev</span><span class="p">,</span>
	<span class="p">.</span><span class="n">uevent</span> <span class="o">=</span>	<span class="n">usb_dev_uevent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">devnode</span> <span class="o">=</span> 	<span class="n">usb_devnode</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="p">.</span><span class="n">pm</span> <span class="o">=</span>		<span class="o">&amp;</span><span class="n">usb_device_pm_ops</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>


<span class="cm">/* Returns 1 if @usb_bus is WUSB, 0 otherwise */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">usb_bus_is_wusb</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_hcd</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">wireless</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * usb_alloc_dev - usb device constructor (usbcore-internal)</span>
<span class="cm"> * @parent: hub to which device is connected; null to allocate a root hub</span>
<span class="cm"> * @bus: bus used to access the device</span>
<span class="cm"> * @port1: one-based index of port; ignored for root hubs</span>
<span class="cm"> * Context: !in_interrupt()</span>
<span class="cm"> *</span>
<span class="cm"> * Only hub drivers (including virtual root hub drivers for host</span>
<span class="cm"> * controllers) should ever call this.</span>
<span class="cm"> *</span>
<span class="cm"> * This call may not be used in a non-sleeping context.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="nf">usb_alloc_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">port1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">usb_hcd</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_hcd</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">root_hub</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dev</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usb_get_hcd</span><span class="p">(</span><span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">bus</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Root hubs aren&#39;t true devices, so don&#39;t allocate HCD resources */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">alloc_dev</span> <span class="o">&amp;&amp;</span> <span class="n">parent</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="n">usb_hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">alloc_dev</span><span class="p">(</span><span class="n">usb_hcd</span><span class="p">,</span> <span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">usb_put_hcd</span><span class="p">(</span><span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">bus</span><span class="p">));</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">device_initialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usb_bus_type</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usb_device_type</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">groups</span> <span class="o">=</span> <span class="n">usb_device_groups</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">dma_mask</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="p">;</span>
	<span class="n">set_dev_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev_to_node</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">));</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">USB_STATE_ATTACHED</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">.</span><span class="n">urb_list</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">bLength</span> <span class="o">=</span> <span class="n">USB_DT_ENDPOINT_SIZE</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">bDescriptorType</span> <span class="o">=</span> <span class="n">USB_DT_ENDPOINT</span><span class="p">;</span>
	<span class="cm">/* ep0 maxpacket comes later, from device descriptor */</span>
	<span class="n">usb_enable_endpoint</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">can_submit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Save readable and stable topology id, distinguishing devices</span>
<span class="cm">	 * by location for diagnostics, tools, driver model, etc.  The</span>
<span class="cm">	 * string is a path along hub ports, from the root.  Each device&#39;s</span>
<span class="cm">	 * dev-&gt;devpath will be stable until USB is re-cabled, and hubs</span>
<span class="cm">	 * are often labeled with these port numbers.  The name isn&#39;t</span>
<span class="cm">	 * as stable:  bus-&gt;busnum changes easily from modprobe order,</span>
<span class="cm">	 * cardbus or pci hotplugging, and so on.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">route</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">;</span>
		<span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;usb%d&quot;</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">busnum</span><span class="p">);</span>
		<span class="n">root_hub</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* match any labeling on the hubs; it&#39;s one-based */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snprintf</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span>
				<span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">port1</span><span class="p">);</span>
			<span class="cm">/* Root ports are not counted in route string */</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">route</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">snprintf</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span>
				<span class="s">&quot;%s.%d&quot;</span><span class="p">,</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span> <span class="n">port1</span><span class="p">);</span>
			<span class="cm">/* Route string assumes hubs have less than 16 ports */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">port1</span> <span class="o">&lt;</span> <span class="mi">15</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">route</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">route</span> <span class="o">+</span>
					<span class="p">(</span><span class="n">port1</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">));</span>
			<span class="k">else</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">route</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">route</span> <span class="o">+</span>
					<span class="p">(</span><span class="mi">15</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%d-%s&quot;</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">busnum</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">);</span>

		<span class="cm">/* hub driver sets up TT records */</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">portnum</span> <span class="o">=</span> <span class="n">port1</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">=</span> <span class="n">bus</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">filelist</span><span class="p">);</span>

<span class="cp">#ifdef	CONFIG_PM</span>
	<span class="n">pm_runtime_set_autosuspend_delay</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="n">usb_autosuspend_delay</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">connect_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">active_duration</span> <span class="o">=</span> <span class="o">-</span><span class="n">jiffies</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root_hub</span><span class="p">)</span>	<span class="cm">/* Root hub always ok [and always wired] */</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">authorized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">authorized</span> <span class="o">=</span> <span class="n">usb_hcd</span><span class="o">-&gt;</span><span class="n">authorized_default</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">wusb</span> <span class="o">=</span> <span class="n">usb_bus_is_wusb</span><span class="p">(</span><span class="n">bus</span><span class="p">)</span><span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_get_dev - increments the reference count of the usb device structure</span>
<span class="cm"> * @dev: the device being referenced</span>
<span class="cm"> *</span>
<span class="cm"> * Each live reference to a device should be refcounted.</span>
<span class="cm"> *</span>
<span class="cm"> * Drivers for USB interfaces should normally record such references in</span>
<span class="cm"> * their probe() methods, when they bind to an interface, and release</span>
<span class="cm"> * them by calling usb_put_dev(), in their disconnect() methods.</span>
<span class="cm"> *</span>
<span class="cm"> * A pointer to the device with the incremented reference counter is returned.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="nf">usb_get_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span>
		<span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_get_dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_put_dev - release a use of the usb device structure</span>
<span class="cm"> * @dev: device that&#39;s been disconnected</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called when a user of a device is finished with it.  When the last</span>
<span class="cm"> * user of the device calls this function, the memory of the device is freed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_put_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span>
		<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_put_dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_get_intf - increments the reference count of the usb interface structure</span>
<span class="cm"> * @intf: the interface being referenced</span>
<span class="cm"> *</span>
<span class="cm"> * Each live reference to a interface must be refcounted.</span>
<span class="cm"> *</span>
<span class="cm"> * Drivers for USB interfaces should normally record such references in</span>
<span class="cm"> * their probe() methods, when they bind to an interface, and release</span>
<span class="cm"> * them by calling usb_put_intf(), in their disconnect() methods.</span>
<span class="cm"> *</span>
<span class="cm"> * A pointer to the interface with the incremented reference counter is</span>
<span class="cm"> * returned.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="nf">usb_get_intf</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intf</span><span class="p">)</span>
		<span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">intf</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_get_intf</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_put_intf - release a use of the usb interface structure</span>
<span class="cm"> * @intf: interface that&#39;s been decremented</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called when a user of an interface is finished with it.  When the</span>
<span class="cm"> * last user of the interface calls this function, the memory of the interface</span>
<span class="cm"> * is freed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_put_intf</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intf</span><span class="p">)</span>
		<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_put_intf</span><span class="p">);</span>

<span class="cm">/*			USB device locking</span>
<span class="cm"> *</span>
<span class="cm"> * USB devices and interfaces are locked using the semaphore in their</span>
<span class="cm"> * embedded struct device.  The hub driver guarantees that whenever a</span>
<span class="cm"> * device is connected or disconnected, drivers are called with the</span>
<span class="cm"> * USB device locked as well as their particular interface.</span>
<span class="cm"> *</span>
<span class="cm"> * Complications arise when several devices are to be locked at the same</span>
<span class="cm"> * time.  Only hub-aware drivers that are part of usbcore ever have to</span>
<span class="cm"> * do this; nobody else needs to worry about it.  The rule for locking</span>
<span class="cm"> * is simple:</span>
<span class="cm"> *</span>
<span class="cm"> *	When locking both a device and its parent, always lock the</span>
<span class="cm"> *	the parent first.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * usb_lock_device_for_reset - cautiously acquire the lock for a usb device structure</span>
<span class="cm"> * @udev: device that&#39;s being locked</span>
<span class="cm"> * @iface: interface bound to the driver making the request (optional)</span>
<span class="cm"> *</span>
<span class="cm"> * Attempts to acquire the device lock, but fails if the device is</span>
<span class="cm"> * NOTATTACHED or SUSPENDED, or if iface is specified and the interface</span>
<span class="cm"> * is neither BINDING nor BOUND.  Rather than sleeping to wait for the</span>
<span class="cm"> * lock, the routine polls repeatedly.  This is to prevent deadlock with</span>
<span class="cm"> * disconnect; in some drivers (such as usb-storage) the disconnect()</span>
<span class="cm"> * or suspend() method will block waiting for a device reset to complete.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a negative error code for failure, otherwise 0.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_lock_device_for_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">jiffies_expire</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_NOTATTACHED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_SUSPENDED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EHOSTUNREACH</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iface</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">condition</span> <span class="o">==</span> <span class="n">USB_INTERFACE_UNBINDING</span> <span class="o">||</span>
			<span class="n">iface</span><span class="o">-&gt;</span><span class="n">condition</span> <span class="o">==</span> <span class="n">USB_INTERFACE_UNBOUND</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">usb_trylock_device</span><span class="p">(</span><span class="n">udev</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* If we can&#39;t acquire the lock after waiting one second,</span>
<span class="cm">		 * we&#39;re probably deadlocked */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">jiffies_expire</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

		<span class="n">msleep</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_NOTATTACHED</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_SUSPENDED</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EHOSTUNREACH</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iface</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">condition</span> <span class="o">==</span> <span class="n">USB_INTERFACE_UNBINDING</span> <span class="o">||</span>
				<span class="n">iface</span><span class="o">-&gt;</span><span class="n">condition</span> <span class="o">==</span> <span class="n">USB_INTERFACE_UNBOUND</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_lock_device_for_reset</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_get_current_frame_number - return current bus frame number</span>
<span class="cm"> * @dev: the device whose bus is being queried</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the current frame number for the USB host controller</span>
<span class="cm"> * used with the given USB device.  This can be used when scheduling</span>
<span class="cm"> * isochronous requests.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that different kinds of host controller have different</span>
<span class="cm"> * &quot;scheduling horizons&quot;.  While one type might support scheduling only</span>
<span class="cm"> * 32 frames into the future, others could support scheduling up to</span>
<span class="cm"> * 1024 frames into the future.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_get_current_frame_number</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">usb_hcd_get_frame_number</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_get_current_frame_number</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * __usb_get_extra_descriptor() finds a descriptor of specific type in the</span>
<span class="cm"> * extra field of the interface and endpoint descriptor structs.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">__usb_get_extra_descriptor</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">size</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">type</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_descriptor_header</span> <span class="o">*</span><span class="n">header</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_descriptor_header</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">header</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_descriptor_header</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">bLength</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
				<span class="s">&quot;%s: bogus descriptor, type %d length %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">usbcore_name</span><span class="p">,</span>
				<span class="n">header</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span><span class="p">,</span>
				<span class="n">header</span><span class="o">-&gt;</span><span class="n">bLength</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">header</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">buffer</span> <span class="o">+=</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">bLength</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">bLength</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__usb_get_extra_descriptor</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_alloc_coherent - allocate dma-consistent buffer for URB_NO_xxx_DMA_MAP</span>
<span class="cm"> * @dev: device the buffer will be used with</span>
<span class="cm"> * @size: requested buffer size</span>
<span class="cm"> * @mem_flags: affect whether allocation may block</span>
<span class="cm"> * @dma: used to return DMA address of buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Return value is either null (indicating no buffer could be allocated), or</span>
<span class="cm"> * the cpu-space pointer to a buffer that may be used to perform DMA to the</span>
<span class="cm"> * specified device.  Such cpu-space buffers are returned along with the DMA</span>
<span class="cm"> * address (through the pointer provided).</span>
<span class="cm"> *</span>
<span class="cm"> * These buffers are used with URB_NO_xxx_DMA_MAP set in urb-&gt;transfer_flags</span>
<span class="cm"> * to avoid behaviors like using &quot;DMA bounce buffers&quot;, or thrashing IOMMU</span>
<span class="cm"> * hardware during URB completion/resubmit.  The implementation varies between</span>
<span class="cm"> * platforms, depending on details of how DMA will work to this device.</span>
<span class="cm"> * Using these buffers also eliminates cacheline sharing problems on</span>
<span class="cm"> * architectures where CPU caches are not DMA-coherent.  On systems without</span>
<span class="cm"> * bus-snooping caches, these buffers are uncached.</span>
<span class="cm"> *</span>
<span class="cm"> * When the buffer is no longer used, free it with usb_free_coherent().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">usb_alloc_coherent</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">,</span>
			 <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">dma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span> <span class="o">||</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">hcd_buffer_alloc</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">,</span> <span class="n">dma</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_alloc_coherent</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_free_coherent - free memory allocated with usb_alloc_coherent()</span>
<span class="cm"> * @dev: device the buffer was used with</span>
<span class="cm"> * @size: requested buffer size</span>
<span class="cm"> * @addr: CPU address of buffer</span>
<span class="cm"> * @dma: DMA address of buffer</span>
<span class="cm"> *</span>
<span class="cm"> * This reclaims an I/O buffer, letting it be reused.  The memory must have</span>
<span class="cm"> * been allocated using usb_alloc_coherent(), and the parameters must match</span>
<span class="cm"> * those provided in that allocation request.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_free_coherent</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
		       <span class="n">dma_addr_t</span> <span class="n">dma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span> <span class="o">||</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">hcd_buffer_free</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">dma</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_free_coherent</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_buffer_map - create DMA mapping(s) for an urb</span>
<span class="cm"> * @urb: urb whose transfer_buffer/setup_packet will be mapped</span>
<span class="cm"> *</span>
<span class="cm"> * Return value is either null (indicating no buffer could be mapped), or</span>
<span class="cm"> * the parameter.  URB_NO_TRANSFER_DMA_MAP is</span>
<span class="cm"> * added to urb-&gt;transfer_flags if the operation succeeds.  If the device</span>
<span class="cm"> * is connected to this system through a non-DMA controller, this operation</span>
<span class="cm"> * always succeeds.</span>
<span class="cm"> *</span>
<span class="cm"> * This call would normally be used for an urb which is reused, perhaps</span>
<span class="cm"> * as the target of a large periodic transfer, with usb_buffer_dmasync()</span>
<span class="cm"> * calls to synchronize memory and dma state.</span>
<span class="cm"> *</span>
<span class="cm"> * Reverse the effect of this call with usb_buffer_unmap().</span>
<span class="cm"> */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">struct urb *usb_buffer_map(struct urb *urb)</span>
<span class="c">{</span>
<span class="c">	struct usb_bus		*bus;</span>
<span class="c">	struct device		*controller;</span>

<span class="c">	if (!urb</span>
<span class="c">			|| !urb-&gt;dev</span>
<span class="c">			|| !(bus = urb-&gt;dev-&gt;bus)</span>
<span class="c">			|| !(controller = bus-&gt;controller))</span>
<span class="c">		return NULL;</span>

<span class="c">	if (controller-&gt;dma_mask) {</span>
<span class="c">		urb-&gt;transfer_dma = dma_map_single(controller,</span>
<span class="c">			urb-&gt;transfer_buffer, urb-&gt;transfer_buffer_length,</span>
<span class="c">			usb_pipein(urb-&gt;pipe)</span>
<span class="c">				? DMA_FROM_DEVICE : DMA_TO_DEVICE);</span>
<span class="c">	/* FIXME generic api broken like pci, can&#39;t report errors */</span>
<span class="c">	/* if (urb-&gt;transfer_dma == DMA_ADDR_INVALID) return 0; */</span>
<span class="c">	} else</span>
<span class="c">		urb-&gt;transfer_dma = ~0;</span>
<span class="c">	urb-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;</span>
<span class="c">	return urb;</span>
<span class="c">}</span>
<span class="c">EXPORT_SYMBOL_GPL(usb_buffer_map);</span>
<span class="cp">#endif  /*  0  */</span>

<span class="cm">/* XXX DISABLED, no users currently.  If you wish to re-enable this</span>
<span class="cm"> * XXX please determine whether the sync is to transfer ownership of</span>
<span class="cm"> * XXX the buffer from device to cpu or vice verse, and thusly use the</span>
<span class="cm"> * XXX appropriate _for_{cpu,device}() method.  -DaveM</span>
<span class="cm"> */</span>
<span class="cp">#if 0</span><span class="c"></span>

<span class="c">/**</span>
<span class="c"> * usb_buffer_dmasync - synchronize DMA and CPU view of buffer(s)</span>
<span class="c"> * @urb: urb whose transfer_buffer/setup_packet will be synchronized</span>
<span class="c"> */</span>
<span class="c">void usb_buffer_dmasync(struct urb *urb)</span>
<span class="c">{</span>
<span class="c">	struct usb_bus		*bus;</span>
<span class="c">	struct device		*controller;</span>

<span class="c">	if (!urb</span>
<span class="c">			|| !(urb-&gt;transfer_flags &amp; URB_NO_TRANSFER_DMA_MAP)</span>
<span class="c">			|| !urb-&gt;dev</span>
<span class="c">			|| !(bus = urb-&gt;dev-&gt;bus)</span>
<span class="c">			|| !(controller = bus-&gt;controller))</span>
<span class="c">		return;</span>

<span class="c">	if (controller-&gt;dma_mask) {</span>
<span class="c">		dma_sync_single_for_cpu(controller,</span>
<span class="c">			urb-&gt;transfer_dma, urb-&gt;transfer_buffer_length,</span>
<span class="c">			usb_pipein(urb-&gt;pipe)</span>
<span class="c">				? DMA_FROM_DEVICE : DMA_TO_DEVICE);</span>
<span class="c">		if (usb_pipecontrol(urb-&gt;pipe))</span>
<span class="c">			dma_sync_single_for_cpu(controller,</span>
<span class="c">					urb-&gt;setup_dma,</span>
<span class="c">					sizeof(struct usb_ctrlrequest),</span>
<span class="c">					DMA_TO_DEVICE);</span>
<span class="c">	}</span>
<span class="c">}</span>
<span class="c">EXPORT_SYMBOL_GPL(usb_buffer_dmasync);</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * usb_buffer_unmap - free DMA mapping(s) for an urb</span>
<span class="cm"> * @urb: urb whose transfer_buffer will be unmapped</span>
<span class="cm"> *</span>
<span class="cm"> * Reverses the effect of usb_buffer_map().</span>
<span class="cm"> */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">void usb_buffer_unmap(struct urb *urb)</span>
<span class="c">{</span>
<span class="c">	struct usb_bus		*bus;</span>
<span class="c">	struct device		*controller;</span>

<span class="c">	if (!urb</span>
<span class="c">			|| !(urb-&gt;transfer_flags &amp; URB_NO_TRANSFER_DMA_MAP)</span>
<span class="c">			|| !urb-&gt;dev</span>
<span class="c">			|| !(bus = urb-&gt;dev-&gt;bus)</span>
<span class="c">			|| !(controller = bus-&gt;controller))</span>
<span class="c">		return;</span>

<span class="c">	if (controller-&gt;dma_mask) {</span>
<span class="c">		dma_unmap_single(controller,</span>
<span class="c">			urb-&gt;transfer_dma, urb-&gt;transfer_buffer_length,</span>
<span class="c">			usb_pipein(urb-&gt;pipe)</span>
<span class="c">				? DMA_FROM_DEVICE : DMA_TO_DEVICE);</span>
<span class="c">	}</span>
<span class="c">	urb-&gt;transfer_flags &amp;= ~URB_NO_TRANSFER_DMA_MAP;</span>
<span class="c">}</span>
<span class="c">EXPORT_SYMBOL_GPL(usb_buffer_unmap);</span>
<span class="cp">#endif  /*  0  */</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/**</span>
<span class="c"> * usb_buffer_map_sg - create scatterlist DMA mapping(s) for an endpoint</span>
<span class="c"> * @dev: device to which the scatterlist will be mapped</span>
<span class="c"> * @is_in: mapping transfer direction</span>
<span class="c"> * @sg: the scatterlist to map</span>
<span class="c"> * @nents: the number of entries in the scatterlist</span>
<span class="c"> *</span>
<span class="c"> * Return value is either &lt; 0 (indicating no buffers could be mapped), or</span>
<span class="c"> * the number of DMA mapping array entries in the scatterlist.</span>
<span class="c"> *</span>
<span class="c"> * The caller is responsible for placing the resulting DMA addresses from</span>
<span class="c"> * the scatterlist into URB transfer buffer pointers, and for setting the</span>
<span class="c"> * URB_NO_TRANSFER_DMA_MAP transfer flag in each of those URBs.</span>
<span class="c"> *</span>
<span class="c"> * Top I/O rates come from queuing URBs, instead of waiting for each one</span>
<span class="c"> * to complete before starting the next I/O.   This is particularly easy</span>
<span class="c"> * to do with scatterlists.  Just allocate and submit one URB for each DMA</span>
<span class="c"> * mapping entry returned, stopping on the first error or when all succeed.</span>
<span class="c"> * Better yet, use the usb_sg_*() calls, which do that (and more) for you.</span>
<span class="c"> *</span>
<span class="c"> * This call would normally be used when translating scatterlist requests,</span>
<span class="c"> * rather than usb_buffer_map(), since on some hardware (with IOMMUs) it</span>
<span class="c"> * may be able to coalesce mappings for improved I/O efficiency.</span>
<span class="c"> *</span>
<span class="c"> * Reverse the effect of this call with usb_buffer_unmap_sg().</span>
<span class="c"> */</span>
<span class="c">int usb_buffer_map_sg(const struct usb_device *dev, int is_in,</span>
<span class="c">		      struct scatterlist *sg, int nents)</span>
<span class="c">{</span>
<span class="c">	struct usb_bus		*bus;</span>
<span class="c">	struct device		*controller;</span>

<span class="c">	if (!dev</span>
<span class="c">			|| !(bus = dev-&gt;bus)</span>
<span class="c">			|| !(controller = bus-&gt;controller)</span>
<span class="c">			|| !controller-&gt;dma_mask)</span>
<span class="c">		return -EINVAL;</span>

<span class="c">	/* FIXME generic api broken like pci, can&#39;t report errors */</span>
<span class="c">	return dma_map_sg(controller, sg, nents,</span>
<span class="c">			is_in ? DMA_FROM_DEVICE : DMA_TO_DEVICE) ? : -ENOMEM;</span>
<span class="c">}</span>
<span class="c">EXPORT_SYMBOL_GPL(usb_buffer_map_sg);</span>
<span class="cp">#endif</span>

<span class="cm">/* XXX DISABLED, no users currently.  If you wish to re-enable this</span>
<span class="cm"> * XXX please determine whether the sync is to transfer ownership of</span>
<span class="cm"> * XXX the buffer from device to cpu or vice verse, and thusly use the</span>
<span class="cm"> * XXX appropriate _for_{cpu,device}() method.  -DaveM</span>
<span class="cm"> */</span>
<span class="cp">#if 0</span><span class="c"></span>

<span class="c">/**</span>
<span class="c"> * usb_buffer_dmasync_sg - synchronize DMA and CPU view of scatterlist buffer(s)</span>
<span class="c"> * @dev: device to which the scatterlist will be mapped</span>
<span class="c"> * @is_in: mapping transfer direction</span>
<span class="c"> * @sg: the scatterlist to synchronize</span>
<span class="c"> * @n_hw_ents: the positive return value from usb_buffer_map_sg</span>
<span class="c"> *</span>
<span class="c"> * Use this when you are re-using a scatterlist&#39;s data buffers for</span>
<span class="c"> * another USB request.</span>
<span class="c"> */</span>
<span class="c">void usb_buffer_dmasync_sg(const struct usb_device *dev, int is_in,</span>
<span class="c">			   struct scatterlist *sg, int n_hw_ents)</span>
<span class="c">{</span>
<span class="c">	struct usb_bus		*bus;</span>
<span class="c">	struct device		*controller;</span>

<span class="c">	if (!dev</span>
<span class="c">			|| !(bus = dev-&gt;bus)</span>
<span class="c">			|| !(controller = bus-&gt;controller)</span>
<span class="c">			|| !controller-&gt;dma_mask)</span>
<span class="c">		return;</span>

<span class="c">	dma_sync_sg_for_cpu(controller, sg, n_hw_ents,</span>
<span class="c">			    is_in ? DMA_FROM_DEVICE : DMA_TO_DEVICE);</span>
<span class="c">}</span>
<span class="c">EXPORT_SYMBOL_GPL(usb_buffer_dmasync_sg);</span>
<span class="cp">#endif</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/**</span>
<span class="c"> * usb_buffer_unmap_sg - free DMA mapping(s) for a scatterlist</span>
<span class="c"> * @dev: device to which the scatterlist will be mapped</span>
<span class="c"> * @is_in: mapping transfer direction</span>
<span class="c"> * @sg: the scatterlist to unmap</span>
<span class="c"> * @n_hw_ents: the positive return value from usb_buffer_map_sg</span>
<span class="c"> *</span>
<span class="c"> * Reverses the effect of usb_buffer_map_sg().</span>
<span class="c"> */</span>
<span class="c">void usb_buffer_unmap_sg(const struct usb_device *dev, int is_in,</span>
<span class="c">			 struct scatterlist *sg, int n_hw_ents)</span>
<span class="c">{</span>
<span class="c">	struct usb_bus		*bus;</span>
<span class="c">	struct device		*controller;</span>

<span class="c">	if (!dev</span>
<span class="c">			|| !(bus = dev-&gt;bus)</span>
<span class="c">			|| !(controller = bus-&gt;controller)</span>
<span class="c">			|| !controller-&gt;dma_mask)</span>
<span class="c">		return;</span>

<span class="c">	dma_unmap_sg(controller, sg, n_hw_ents,</span>
<span class="c">			is_in ? DMA_FROM_DEVICE : DMA_TO_DEVICE);</span>
<span class="c">}</span>
<span class="c">EXPORT_SYMBOL_GPL(usb_buffer_unmap_sg);</span>
<span class="cp">#endif</span>

<span class="cm">/* To disable USB, kernel command line is &#39;nousb&#39; not &#39;usbcore.nousb&#39; */</span>
<span class="cp">#ifdef MODULE</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">nousb</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="n">core_param</span><span class="p">(</span><span class="n">nousb</span><span class="p">,</span> <span class="n">nousb</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * for external read access to &lt;nousb&gt;</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_disabled</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nousb</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_disabled</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Notifications of device and interface registration</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_bus_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">BUS_NOTIFY_ADD_DEVICE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">usb_device_type</span><span class="p">)</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">usb_create_sysfs_dev_files</span><span class="p">(</span><span class="n">to_usb_device</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">usb_if_device_type</span><span class="p">)</span>
			<span class="n">usb_create_sysfs_intf_files</span><span class="p">(</span><span class="n">to_usb_interface</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">BUS_NOTIFY_DEL_DEVICE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">usb_device_type</span><span class="p">)</span>
			<span class="n">usb_remove_sysfs_dev_files</span><span class="p">(</span><span class="n">to_usb_device</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">usb_if_device_type</span><span class="p">)</span>
			<span class="n">usb_remove_sysfs_intf_files</span><span class="p">(</span><span class="n">to_usb_interface</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">usb_bus_nb</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">usb_bus_notify</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">usb_debug_root</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_debug_root</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">usb_debug_devices</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_debugfs_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">usb_debug_root</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;usb&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usb_debug_root</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">usb_debug_devices</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;devices&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span>
						<span class="n">usb_debug_root</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">usbfs_devices_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usb_debug_devices</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">usb_debug_root</span><span class="p">);</span>
		<span class="n">usb_debug_root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usb_debugfs_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">usb_debug_devices</span><span class="p">);</span>
	<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">usb_debug_root</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Init</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">usb_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nousb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: USB support disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usbcore_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_debugfs_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">usb_acpi_register</span><span class="p">();</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">bus_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_bus_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bus_register_failed</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">bus_register_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_bus_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usb_bus_nb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bus_notifier_failed</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_major_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">major_init_failed</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usbfs_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">driver_register_failed</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_devio_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">usb_devio_init_failed</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_hub_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">hub_init_failed</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_register_device_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_generic_driver</span><span class="p">,</span> <span class="n">THIS_MODULE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">usb_hub_cleanup</span><span class="p">();</span>
<span class="nl">hub_init_failed:</span>
	<span class="n">usb_devio_cleanup</span><span class="p">();</span>
<span class="nl">usb_devio_init_failed:</span>
	<span class="n">usb_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usbfs_driver</span><span class="p">);</span>
<span class="nl">driver_register_failed:</span>
	<span class="n">usb_major_cleanup</span><span class="p">();</span>
<span class="nl">major_init_failed:</span>
	<span class="n">bus_unregister_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_bus_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usb_bus_nb</span><span class="p">);</span>
<span class="nl">bus_notifier_failed:</span>
	<span class="n">bus_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_bus_type</span><span class="p">);</span>
<span class="nl">bus_register_failed:</span>
	<span class="n">usb_acpi_unregister</span><span class="p">();</span>
	<span class="n">usb_debugfs_cleanup</span><span class="p">();</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Cleanup</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">usb_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* This will matter if shutdown/reboot does exitcalls. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nousb</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">usb_deregister_device_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_generic_driver</span><span class="p">);</span>
	<span class="n">usb_major_cleanup</span><span class="p">();</span>
	<span class="n">usb_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usbfs_driver</span><span class="p">);</span>
	<span class="n">usb_devio_cleanup</span><span class="p">();</span>
	<span class="n">usb_hub_cleanup</span><span class="p">();</span>
	<span class="n">bus_unregister_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_bus_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usb_bus_nb</span><span class="p">);</span>
	<span class="n">bus_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_bus_type</span><span class="p">);</span>
	<span class="n">usb_acpi_unregister</span><span class="p">();</span>
	<span class="n">usb_debugfs_cleanup</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">usb_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">usb_exit</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
