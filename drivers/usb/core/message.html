<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › core › message.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>message.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * message.c - synchronous message handling</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/pci.h&gt;	</span><span class="cm">/* for scatterlist macros */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/nls.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/usb/quirks.h&gt;</span>
<span class="cp">#include &lt;linux/usb/hcd.h&gt;	</span><span class="cm">/* for usbcore internals */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="cp">#include &quot;usb.h&quot;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">cancel_async_set_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">api_context</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">completion</span>	<span class="n">done</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usb_api_blocking_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">api_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Starts urb and waits for completion or timeout. Note that this call</span>
<span class="cm"> * is NOT interruptible. Many device driver i/o requests should be</span>
<span class="cm"> * interruptible and therefore these drivers should implement their</span>
<span class="cm"> * own interruptible routines.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_start_wait_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">actual_length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">api_context</span> <span class="n">ctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expire</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">.</span><span class="n">done</span><span class="p">);</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">retval</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">expire</span> <span class="o">=</span> <span class="n">timeout</span> <span class="o">?</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="o">:</span> <span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait_for_completion_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">.</span><span class="n">done</span><span class="p">,</span> <span class="n">expire</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span> <span class="o">?</span> <span class="o">-</span><span class="n">ETIMEDOUT</span> <span class="o">:</span> <span class="n">ctx</span><span class="p">.</span><span class="n">status</span><span class="p">);</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s timed out on ep%d%s len=%u/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span>
			<span class="n">usb_endpoint_num</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">),</span>
			<span class="n">usb_urb_dir_in</span><span class="p">(</span><span class="n">urb</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;in&quot;</span> <span class="o">:</span> <span class="s">&quot;out&quot;</span><span class="p">,</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">,</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">actual_length</span><span class="p">)</span>
		<span class="o">*</span><span class="n">actual_length</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">;</span>

	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------*/</span>
<span class="cm">/* returns status (negative) or length (positive) */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_internal_control_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
				    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">length</span><span class="p">;</span>

	<span class="n">urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">usb_fill_control_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">usb_dev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
			     <span class="n">len</span><span class="p">,</span> <span class="n">usb_api_blocking_completion</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">retv</span> <span class="o">=</span> <span class="n">usb_start_wait_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retv</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_control_msg - Builds a control urb, sends it off and waits for completion</span>
<span class="cm"> * @dev: pointer to the usb device to send the message to</span>
<span class="cm"> * @pipe: endpoint &quot;pipe&quot; to send the message to</span>
<span class="cm"> * @request: USB message request value</span>
<span class="cm"> * @requesttype: USB message request type value</span>
<span class="cm"> * @value: USB message value</span>
<span class="cm"> * @index: USB message index value</span>
<span class="cm"> * @data: pointer to the data to send</span>
<span class="cm"> * @size: length in bytes of the data to send</span>
<span class="cm"> * @timeout: time in msecs to wait for the message to complete before timing</span>
<span class="cm"> *	out (if 0 the wait is forever)</span>
<span class="cm"> *</span>
<span class="cm"> * Context: !in_interrupt ()</span>
<span class="cm"> *</span>
<span class="cm"> * This function sends a simple control message to a specified endpoint and</span>
<span class="cm"> * waits for the message to complete, or timeout.</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, it returns the number of bytes transferred, otherwise a</span>
<span class="cm"> * negative error number.</span>
<span class="cm"> *</span>
<span class="cm"> * Don&#39;t use this function from within an interrupt context, like a bottom half</span>
<span class="cm"> * handler.  If you need an asynchronous message, or need to send a message</span>
<span class="cm"> * from within interrupt context, use usb_submit_urb().</span>
<span class="cm"> * If a thread in your driver uses this call, make sure your disconnect()</span>
<span class="cm"> * method can wait for it to complete.  Since you don&#39;t have a handle on the</span>
<span class="cm"> * URB used, you can&#39;t cancel the request.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_control_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">request</span><span class="p">,</span>
		    <span class="n">__u8</span> <span class="n">requesttype</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">value</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">index</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		    <span class="n">__u16</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">dr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">dr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ctrlrequest</span><span class="p">),</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">dr</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">=</span> <span class="n">requesttype</span><span class="p">;</span>
	<span class="n">dr</span><span class="o">-&gt;</span><span class="n">bRequest</span> <span class="o">=</span> <span class="n">request</span><span class="p">;</span>
	<span class="n">dr</span><span class="o">-&gt;</span><span class="n">wValue</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
	<span class="n">dr</span><span class="o">-&gt;</span><span class="n">wIndex</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
	<span class="n">dr</span><span class="o">-&gt;</span><span class="n">wLength</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

	<span class="cm">/* dbg(&quot;usb_control_msg&quot;); */</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_internal_control_msg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">dr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_control_msg</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_interrupt_msg - Builds an interrupt urb, sends it off and waits for completion</span>
<span class="cm"> * @usb_dev: pointer to the usb device to send the message to</span>
<span class="cm"> * @pipe: endpoint &quot;pipe&quot; to send the message to</span>
<span class="cm"> * @data: pointer to the data to send</span>
<span class="cm"> * @len: length in bytes of the data to send</span>
<span class="cm"> * @actual_length: pointer to a location to put the actual length transferred</span>
<span class="cm"> *	in bytes</span>
<span class="cm"> * @timeout: time in msecs to wait for the message to complete before</span>
<span class="cm"> *	timing out (if 0 the wait is forever)</span>
<span class="cm"> *</span>
<span class="cm"> * Context: !in_interrupt ()</span>
<span class="cm"> *</span>
<span class="cm"> * This function sends a simple interrupt message to a specified endpoint and</span>
<span class="cm"> * waits for the message to complete, or timeout.</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, it returns 0, otherwise a negative error number.  The number</span>
<span class="cm"> * of actual bytes transferred will be stored in the actual_length paramater.</span>
<span class="cm"> *</span>
<span class="cm"> * Don&#39;t use this function from within an interrupt context, like a bottom half</span>
<span class="cm"> * handler.  If you need an asynchronous message, or need to send a message</span>
<span class="cm"> * from within interrupt context, use usb_submit_urb() If a thread in your</span>
<span class="cm"> * driver uses this call, make sure your disconnect() method can wait for it to</span>
<span class="cm"> * complete.  Since you don&#39;t have a handle on the URB used, you can&#39;t cancel</span>
<span class="cm"> * the request.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_interrupt_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">,</span>
		      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">actual_length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">usb_bulk_msg</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">actual_length</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_interrupt_msg</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_bulk_msg - Builds a bulk urb, sends it off and waits for completion</span>
<span class="cm"> * @usb_dev: pointer to the usb device to send the message to</span>
<span class="cm"> * @pipe: endpoint &quot;pipe&quot; to send the message to</span>
<span class="cm"> * @data: pointer to the data to send</span>
<span class="cm"> * @len: length in bytes of the data to send</span>
<span class="cm"> * @actual_length: pointer to a location to put the actual length transferred</span>
<span class="cm"> *	in bytes</span>
<span class="cm"> * @timeout: time in msecs to wait for the message to complete before</span>
<span class="cm"> *	timing out (if 0 the wait is forever)</span>
<span class="cm"> *</span>
<span class="cm"> * Context: !in_interrupt ()</span>
<span class="cm"> *</span>
<span class="cm"> * This function sends a simple bulk message to a specified endpoint</span>
<span class="cm"> * and waits for the message to complete, or timeout.</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, it returns 0, otherwise a negative error number.  The number</span>
<span class="cm"> * of actual bytes transferred will be stored in the actual_length paramater.</span>
<span class="cm"> *</span>
<span class="cm"> * Don&#39;t use this function from within an interrupt context, like a bottom half</span>
<span class="cm"> * handler.  If you need an asynchronous message, or need to send a message</span>
<span class="cm"> * from within interrupt context, use usb_submit_urb() If a thread in your</span>
<span class="cm"> * driver uses this call, make sure your disconnect() method can wait for it to</span>
<span class="cm"> * complete.  Since you don&#39;t have a handle on the URB used, you can&#39;t cancel</span>
<span class="cm"> * the request.</span>
<span class="cm"> *</span>
<span class="cm"> * Because there is no usb_interrupt_msg() and no USBDEVFS_INTERRUPT ioctl,</span>
<span class="cm"> * users are forced to abuse this routine by using it to submit URBs for</span>
<span class="cm"> * interrupt endpoints.  We will take the liberty of creating an interrupt URB</span>
<span class="cm"> * (with the default interval) if the target is an interrupt endpoint.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_bulk_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">,</span>
		 <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">actual_length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">usb_pipe_endpoint</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bmAttributes</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_XFERTYPE_MASK</span><span class="p">)</span> <span class="o">==</span>
			<span class="n">USB_ENDPOINT_XFER_INT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pipe</span> <span class="o">=</span> <span class="p">(</span><span class="n">pipe</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="n">PIPE_INTERRUPT</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">);</span>
		<span class="n">usb_fill_int_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">usb_dev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
				<span class="n">usb_api_blocking_completion</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				<span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterval</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">usb_dev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
				<span class="n">usb_api_blocking_completion</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">usb_start_wait_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">actual_length</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_bulk_msg</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sg_clean</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_sg_request</span> <span class="o">*</span><span class="n">io</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">entries</span><span class="o">--</span><span class="p">)</span>
			<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">urbs</span> <span class="p">[</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">]);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">);</span>
		<span class="n">io</span><span class="o">-&gt;</span><span class="n">urbs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">io</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sg_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_sg_request</span> <span class="o">*</span><span class="n">io</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* In 2.5 we require hcds&#39; endpoint queues not to progress after fault</span>
<span class="cm">	 * reports, until the completion callback (this!) returns.  That lets</span>
<span class="cm">	 * device driver code (like this routine) unlink queued urbs first,</span>
<span class="cm">	 * if it needs to, since the HC won&#39;t work on them at all.  So it&#39;s</span>
<span class="cm">	 * not possible for page N+1 to overwrite page N, and so on.</span>
<span class="cm">	 *</span>
<span class="cm">	 * That&#39;s only for &quot;hard&quot; faults; &quot;soft&quot; faults (unlinks) sometimes</span>
<span class="cm">	 * complete before the HCD can get requests away from hardware,</span>
<span class="cm">	 * though never during cleanup after a hard fault.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">status</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ECONNRESET</span>
				<span class="o">||</span> <span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">,</span>
			<span class="s">&quot;dev %s ep%d%s scatterlist error %d/%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">io</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span>
			<span class="n">usb_endpoint_num</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">),</span>
			<span class="n">usb_urb_dir_in</span><span class="p">(</span><span class="n">urb</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;in&quot;</span> <span class="o">:</span> <span class="s">&quot;out&quot;</span><span class="p">,</span>
			<span class="n">status</span><span class="p">,</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="cm">/* BUG (); */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>

		<span class="n">io</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>

		<span class="cm">/* the previous urbs, and this one, completed already.</span>
<span class="cm">		 * unlink pending urbs so they won&#39;t rx/tx bad data.</span>
<span class="cm">		 * careful: unlink can sometimes be synchronous...</span>
<span class="cm">		 */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">urbs</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">||</span> <span class="o">!</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">urbs</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_unlink_urb</span><span class="p">(</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">urbs</span> <span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span> <span class="o">&amp;&amp;</span>
				    <span class="n">retval</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENODEV</span> <span class="o">&amp;&amp;</span>
				    <span class="n">retval</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EBUSY</span> <span class="o">&amp;&amp;</span>
				    <span class="n">retval</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EIDRM</span><span class="p">)</span>
					<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						<span class="s">&quot;%s, unlink --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">__func__</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">urb</span> <span class="o">==</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">urbs</span> <span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* on the last completion, signal usb_sg_wait() */</span>
	<span class="n">io</span><span class="o">-&gt;</span><span class="n">bytes</span> <span class="o">+=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">;</span>
	<span class="n">io</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * usb_sg_init - initializes scatterlist-based bulk/interrupt I/O request</span>
<span class="cm"> * @io: request block being initialized.  until usb_sg_wait() returns,</span>
<span class="cm"> *	treat this as a pointer to an opaque block of memory,</span>
<span class="cm"> * @dev: the usb device that will send or receive the data</span>
<span class="cm"> * @pipe: endpoint &quot;pipe&quot; used to transfer the data</span>
<span class="cm"> * @period: polling rate for interrupt endpoints, in frames or</span>
<span class="cm"> * 	(for high speed endpoints) microframes; ignored for bulk</span>
<span class="cm"> * @sg: scatterlist entries</span>
<span class="cm"> * @nents: how many entries in the scatterlist</span>
<span class="cm"> * @length: how many bytes to send from the scatterlist, or zero to</span>
<span class="cm"> * 	send every byte identified in the list.</span>
<span class="cm"> * @mem_flags: SLAB_* flags affecting memory allocations in this call</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero for success, else a negative errno value.  This initializes a</span>
<span class="cm"> * scatter/gather request, allocating resources such as I/O mappings and urb</span>
<span class="cm"> * memory (except maybe memory used by USB controller drivers).</span>
<span class="cm"> *</span>
<span class="cm"> * The request must be issued using usb_sg_wait(), which waits for the I/O to</span>
<span class="cm"> * complete (or to be canceled) and then cleans up all resources allocated by</span>
<span class="cm"> * usb_sg_init().</span>
<span class="cm"> *</span>
<span class="cm"> * The request may be canceled with usb_sg_cancel(), either before or after</span>
<span class="cm"> * usb_sg_wait() is called.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_sg_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_sg_request</span> <span class="o">*</span><span class="n">io</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">pipe</span><span class="p">,</span> <span class="kt">unsigned</span>	<span class="n">period</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">urb_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">use_sg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io</span> <span class="o">||</span> <span class="o">!</span><span class="n">dev</span> <span class="o">||</span> <span class="o">!</span><span class="n">sg</span>
			<span class="o">||</span> <span class="n">usb_pipecontrol</span><span class="p">(</span><span class="n">pipe</span><span class="p">)</span>
			<span class="o">||</span> <span class="n">usb_pipeisoc</span><span class="p">(</span><span class="n">pipe</span><span class="p">)</span>
			<span class="o">||</span> <span class="n">nents</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">io</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">io</span><span class="o">-&gt;</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">use_sg</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">io</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">use_sg</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">io</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="n">nents</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* initialize all the urbs we&#39;ll use */</span>
	<span class="n">io</span><span class="o">-&gt;</span><span class="n">urbs</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="n">urb_flags</span> <span class="o">=</span> <span class="n">URB_NO_INTERRUPT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipein</span><span class="p">(</span><span class="n">pipe</span><span class="p">))</span>
		<span class="n">urb_flags</span> <span class="o">|=</span> <span class="n">URB_SHORT_NOT_OK</span><span class="p">;</span>

	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">io</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">io</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>

		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">;</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">=</span> <span class="n">period</span><span class="p">;</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">=</span> <span class="n">urb_flags</span><span class="p">;</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">=</span> <span class="n">sg_complete</span><span class="p">;</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">io</span><span class="p">;</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">sg</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">use_sg</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* There is no single transfer buffer */</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">num_sgs</span> <span class="o">=</span> <span class="n">nents</span><span class="p">;</span>

			<span class="cm">/* A length of zero means transfer the whole sg list */</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">scatterlist</span>	<span class="o">*</span><span class="n">sg2</span><span class="p">;</span>
				<span class="kt">int</span>			<span class="n">j</span><span class="p">;</span>

				<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">sg2</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
					<span class="n">len</span> <span class="o">+=</span> <span class="n">sg2</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Some systems can&#39;t use DMA; they use PIO instead.</span>
<span class="cm">			 * For their sakes, transfer_buffer is set whenever</span>
<span class="cm">			 * possible.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="n">sg</span><span class="p">)))</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">=</span> <span class="n">sg_virt</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="n">len</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
				<span class="n">length</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">io</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">io</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">[</span><span class="o">--</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">URB_NO_INTERRUPT</span><span class="p">;</span>

	<span class="cm">/* transaction state */</span>
	<span class="n">io</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>
	<span class="n">io</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">io</span><span class="o">-&gt;</span><span class="n">bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">nomem:</span>
	<span class="n">sg_clean</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_sg_init</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_sg_wait - synchronously execute scatter/gather request</span>
<span class="cm"> * @io: request block handle, as initialized with usb_sg_init().</span>
<span class="cm"> * 	some fields become accessible when this call returns.</span>
<span class="cm"> * Context: !in_interrupt ()</span>
<span class="cm"> *</span>
<span class="cm"> * This function blocks until the specified I/O operation completes.  It</span>
<span class="cm"> * leverages the grouping of the related I/O requests to get good transfer</span>
<span class="cm"> * rates, by queueing the requests.  At higher speeds, such queuing can</span>
<span class="cm"> * significantly improve USB throughput.</span>
<span class="cm"> *</span>
<span class="cm"> * There are three kinds of completion for this function.</span>
<span class="cm"> * (1) success, where io-&gt;status is zero.  The number of io-&gt;bytes</span>
<span class="cm"> *     transferred is as requested.</span>
<span class="cm"> * (2) error, where io-&gt;status is a negative errno value.  The number</span>
<span class="cm"> *     of io-&gt;bytes transferred before the error is usually less</span>
<span class="cm"> *     than requested, and can be nonzero.</span>
<span class="cm"> * (3) cancellation, a type of error with status -ECONNRESET that</span>
<span class="cm"> *     is initiated by usb_sg_cancel().</span>
<span class="cm"> *</span>
<span class="cm"> * When this function returns, all memory allocated through usb_sg_init() or</span>
<span class="cm"> * this call will have been freed.  The request block parameter may still be</span>
<span class="cm"> * passed to usb_sg_cancel(), or it may be freed.  It could also be</span>
<span class="cm"> * reinitialized and then reused.</span>
<span class="cm"> *</span>
<span class="cm"> * Data Transfer Rates:</span>
<span class="cm"> *</span>
<span class="cm"> * Bulk transfers are valid for full or high speed endpoints.</span>
<span class="cm"> * The best full speed data rate is 19 packets of 64 bytes each</span>
<span class="cm"> * per frame, or 1216 bytes per millisecond.</span>
<span class="cm"> * The best high speed data rate is 13 packets of 512 bytes each</span>
<span class="cm"> * per microframe, or 52 KBytes per millisecond.</span>
<span class="cm"> *</span>
<span class="cm"> * The reason to use interrupt transfers through this API would most likely</span>
<span class="cm"> * be to reserve high speed bandwidth, where up to 24 KBytes per millisecond</span>
<span class="cm"> * could be transferred.  That capability is less useful for low or full</span>
<span class="cm"> * speed interrupt endpoints, which allow at most one packet per millisecond,</span>
<span class="cm"> * of at most 8 or 64 bytes (respectively).</span>
<span class="cm"> *</span>
<span class="cm"> * It is not necessary to call this function to reserve bandwidth for devices</span>
<span class="cm"> * under an xHCI host controller, as the bandwidth is reserved when the</span>
<span class="cm"> * configuration or interface alt setting is selected.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_sg_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_sg_request</span> <span class="o">*</span><span class="n">io</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">entries</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>

	<span class="cm">/* queue the urbs.  */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">entries</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

		<span class="n">io</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">urbs</span> <span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

		<span class="cm">/* after we submit, let completions or cancelations fire;</span>
<span class="cm">		 * we handshake using io-&gt;status.</span>
<span class="cm">		 */</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* maybe we retrying will recover */</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">ENXIO</span>:	<span class="cm">/* hc didn&#39;t queue this one */</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">EAGAIN</span>:
		<span class="k">case</span> <span class="o">-</span><span class="n">ENOMEM</span>:
			<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">yield</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>

			<span class="cm">/* no error? continue immediately.</span>
<span class="cm">			 *</span>
<span class="cm">			 * NOTE: to work better with UHCI (4K I/O buffer may</span>
<span class="cm">			 * need 3K of TDs) it may be good to limit how many</span>
<span class="cm">			 * URBs are queued at once; N milliseconds?</span>
<span class="cm">			 */</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="o">++</span><span class="n">i</span><span class="p">;</span>
			<span class="n">cpu_relax</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>

			<span class="cm">/* fail any uncompleted urbs */</span>
		<span class="nl">default:</span>
			<span class="n">io</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">retval</span><span class="p">;</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s, submit --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
			<span class="n">usb_sg_cancel</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">))</span>
			<span class="n">io</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">io</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-=</span> <span class="n">entries</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* OK, yes, this could be packaged as non-blocking.</span>
<span class="cm">	 * So could the submit loop above ... but it&#39;s easier to</span>
<span class="cm">	 * solve neither problem than to solve both!</span>
<span class="cm">	 */</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">);</span>

	<span class="n">sg_clean</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_sg_wait</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_sg_cancel - stop scatter/gather i/o issued by usb_sg_wait()</span>
<span class="cm"> * @io: request block, initialized with usb_sg_init()</span>
<span class="cm"> *</span>
<span class="cm"> * This stops a request after it has been started by usb_sg_wait().</span>
<span class="cm"> * It can also prevents one initialized by usb_sg_init() from starting,</span>
<span class="cm"> * so that call just frees resources allocated to the request.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_sg_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_sg_request</span> <span class="o">*</span><span class="n">io</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* shut everything down, if it didn&#39;t already */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">io</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">urbs</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_unlink_urb</span><span class="p">(</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">urbs</span> <span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span>
					<span class="o">&amp;&amp;</span> <span class="n">retval</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENODEV</span>
					<span class="o">&amp;&amp;</span> <span class="n">retval</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EBUSY</span>
					<span class="o">&amp;&amp;</span> <span class="n">retval</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EIDRM</span><span class="p">)</span>
				<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s, unlink --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_sg_cancel</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------*/</span>

<span class="cm">/**</span>
<span class="cm"> * usb_get_descriptor - issues a generic GET_DESCRIPTOR request</span>
<span class="cm"> * @dev: the device whose descriptor is being retrieved</span>
<span class="cm"> * @type: the descriptor type (USB_DT_*)</span>
<span class="cm"> * @index: the number of the descriptor</span>
<span class="cm"> * @buf: where to put the descriptor</span>
<span class="cm"> * @size: how big is &quot;buf&quot;?</span>
<span class="cm"> * Context: !in_interrupt ()</span>
<span class="cm"> *</span>
<span class="cm"> * Gets a USB descriptor.  Convenience functions exist to simplify</span>
<span class="cm"> * getting some types of descriptors.  Use</span>
<span class="cm"> * usb_get_string() or usb_string() for USB_DT_STRING.</span>
<span class="cm"> * Device (USB_DT_DEVICE) and configuration descriptors (USB_DT_CONFIG)</span>
<span class="cm"> * are part of the device structure.</span>
<span class="cm"> * In addition to a number of USB-standard descriptors, some</span>
<span class="cm"> * devices also use class-specific or vendor-specific descriptors.</span>
<span class="cm"> *</span>
<span class="cm"> * This call is synchronous, and may not be used in an interrupt context.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of bytes received on success, or else the status code</span>
<span class="cm"> * returned by the underlying usb_control_msg() call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_get_descriptor</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">type</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">index</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>	<span class="cm">/* Make sure we parse really received data */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* retry on length 0 or error; some devices are flakey */</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">usb_rcvctrlpipe</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
				<span class="n">USB_REQ_GET_DESCRIPTOR</span><span class="p">,</span> <span class="n">USB_DIR_IN</span><span class="p">,</span>
				<span class="p">(</span><span class="n">type</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
				<span class="n">USB_CTRL_GET_TIMEOUT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">result</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_get_descriptor</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_get_string - gets a string descriptor</span>
<span class="cm"> * @dev: the device whose string descriptor is being retrieved</span>
<span class="cm"> * @langid: code for language chosen (from string descriptor zero)</span>
<span class="cm"> * @index: the number of the descriptor</span>
<span class="cm"> * @buf: where to put the string</span>
<span class="cm"> * @size: how big is &quot;buf&quot;?</span>
<span class="cm"> * Context: !in_interrupt ()</span>
<span class="cm"> *</span>
<span class="cm"> * Retrieves a string, encoded using UTF-16LE (Unicode, 16 bits per character,</span>
<span class="cm"> * in little-endian byte order).</span>
<span class="cm"> * The usb_string() function will often be a convenient way to turn</span>
<span class="cm"> * these strings into kernel-printable form.</span>
<span class="cm"> *</span>
<span class="cm"> * Strings may be referenced in device, configuration, interface, or other</span>
<span class="cm"> * descriptors, and could also be used in vendor-specific ways.</span>
<span class="cm"> *</span>
<span class="cm"> * This call is synchronous, and may not be used in an interrupt context.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of bytes received on success, or else the status code</span>
<span class="cm"> * returned by the underlying usb_control_msg() call.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_get_string</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">langid</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">index</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* retry on length 0 or stall; some devices are flakey */</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">usb_rcvctrlpipe</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
			<span class="n">USB_REQ_GET_DESCRIPTOR</span><span class="p">,</span> <span class="n">USB_DIR_IN</span><span class="p">,</span>
			<span class="p">(</span><span class="n">USB_DT_STRING</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">index</span><span class="p">,</span> <span class="n">langid</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
			<span class="n">USB_CTRL_GET_TIMEOUT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">USB_DT_STRING</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usb_try_string_workarounds</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">newlength</span><span class="p">,</span> <span class="n">oldlength</span> <span class="o">=</span> <span class="o">*</span><span class="n">length</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">newlength</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">newlength</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">oldlength</span><span class="p">;</span> <span class="n">newlength</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isprint</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">newlength</span><span class="p">])</span> <span class="o">||</span> <span class="n">buf</span><span class="p">[</span><span class="n">newlength</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">newlength</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">newlength</span><span class="p">;</span>
		<span class="o">*</span><span class="n">length</span> <span class="o">=</span> <span class="n">newlength</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_string_sub</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">langid</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Try to read the string descriptor by asking for the maximum</span>
<span class="cm">	 * possible number of bytes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">USB_QUIRK_STRING_FETCH_255</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">usb_get_string</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">langid</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>

	<span class="cm">/* If that failed try to read the descriptor length, then</span>
<span class="cm">	 * ask for just that many bytes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">usb_get_string</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">langid</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">usb_get_string</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">langid</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
			<span class="n">usb_try_string_workarounds</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rc</span><span class="p">);</span>

		<span class="cm">/* There might be extra junk at the end of the descriptor */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">rc</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">rc</span> <span class="o">-</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span> <span class="cm">/* force a multiple of two */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">rc</span> <span class="o">:</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_get_langid</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">have_langid</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">string_langid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">usb_string_sub</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tbuf</span><span class="p">);</span>

	<span class="cm">/* If the string was reported but is malformed, default to english</span>
<span class="cm">	 * (0x0409) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENODATA</span> <span class="o">||</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">string_langid</span> <span class="o">=</span> <span class="mh">0x0409</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">have_langid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;string descriptor 0 malformed (err = %d), &quot;</span>
			<span class="s">&quot;defaulting to 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">err</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">string_langid</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* In case of all other errors, we assume the device is not able to</span>
<span class="cm">	 * deal with strings at all. Set string_langid to -1 in order to</span>
<span class="cm">	 * prevent any string to be retrieved from the device */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;string descriptor 0 read error: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">err</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">string_langid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* always use the first langid listed */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">string_langid</span> <span class="o">=</span> <span class="n">tbuf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="n">tbuf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">have_langid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;default language 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">string_langid</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_string - returns UTF-8 version of a string descriptor</span>
<span class="cm"> * @dev: the device whose string descriptor is being retrieved</span>
<span class="cm"> * @index: the number of the descriptor</span>
<span class="cm"> * @buf: where to put the string</span>
<span class="cm"> * @size: how big is &quot;buf&quot;?</span>
<span class="cm"> * Context: !in_interrupt ()</span>
<span class="cm"> *</span>
<span class="cm"> * This converts the UTF-16LE encoded strings returned by devices, from</span>
<span class="cm"> * usb_get_string_descriptor(), to null-terminated UTF-8 encoded ones</span>
<span class="cm"> * that are more usable in most kernel contexts.  Note that this function</span>
<span class="cm"> * chooses strings in the first language supported by the device.</span>
<span class="cm"> *</span>
<span class="cm"> * This call is synchronous, and may not be used in an interrupt context.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns length of the string (&gt;= 0) or usb_control_msg status (&lt; 0).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_string</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tbuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_SUSPENDED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EHOSTUNREACH</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">buf</span> <span class="o">||</span> <span class="o">!</span><span class="n">index</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tbuf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tbuf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">usb_get_langid</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">tbuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">usb_string_sub</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">string_langid</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">tbuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>

	<span class="n">size</span><span class="o">--</span><span class="p">;</span>		<span class="cm">/* leave room for trailing NULL char in output buffer */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">utf16s_to_utf8s</span><span class="p">((</span><span class="kt">wchar_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">tbuf</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">(</span><span class="n">err</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
			<span class="n">UTF16_LITTLE_ENDIAN</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">err</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">USB_DT_STRING</span><span class="p">)</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;wrong descriptor type %02x for string %d (</span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">tbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

 <span class="nl">errout:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tbuf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_string</span><span class="p">);</span>

<span class="cm">/* one UTF-8-encoded 16-bit character has at most three bytes */</span>
<span class="cp">#define MAX_USB_STRING_SIZE (127 * 3 + 1)</span>

<span class="cm">/**</span>
<span class="cm"> * usb_cache_string - read a string descriptor and cache it for later use</span>
<span class="cm"> * @udev: the device whose string descriptor is being read</span>
<span class="cm"> * @index: the descriptor index</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to a kmalloc&#39;ed buffer containing the descriptor string,</span>
<span class="cm"> * or NULL if the index is 0 or the string could not be read.</span>
<span class="cm"> */</span>
<span class="kt">char</span> <span class="o">*</span><span class="nf">usb_cache_string</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">smallbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">MAX_USB_STRING_SIZE</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">usb_string</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">MAX_USB_STRING_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">smallbuf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="o">++</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smallbuf</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">smallbuf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">smallbuf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * usb_get_device_descriptor - (re)reads the device descriptor (usbcore)</span>
<span class="cm"> * @dev: the device whose device descriptor is being updated</span>
<span class="cm"> * @size: how much of the descriptor to read</span>
<span class="cm"> * Context: !in_interrupt ()</span>
<span class="cm"> *</span>
<span class="cm"> * Updates the copy of the device descriptor stored in the device structure,</span>
<span class="cm"> * which dedicates space for this purpose.</span>
<span class="cm"> *</span>
<span class="cm"> * Not exported, only for use by the core.  If drivers really want to read</span>
<span class="cm"> * the device descriptor directly, they can call usb_get_descriptor() with</span>
<span class="cm"> * type = USB_DT_DEVICE and index = 0.</span>
<span class="cm"> *</span>
<span class="cm"> * This call is synchronous, and may not be used in an interrupt context.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of bytes received on success, or else the status code</span>
<span class="cm"> * returned by the underlying usb_control_msg() call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_get_device_descriptor</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">desc</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">desc</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">desc</span><span class="p">),</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_get_descriptor</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">USB_DT_DEVICE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_get_status - issues a GET_STATUS call</span>
<span class="cm"> * @dev: the device whose status is being checked</span>
<span class="cm"> * @type: USB_RECIP_*; for device, interface, or endpoint</span>
<span class="cm"> * @target: zero (for device), else interface or endpoint number</span>
<span class="cm"> * @data: pointer to two bytes of bitmap data</span>
<span class="cm"> * Context: !in_interrupt ()</span>
<span class="cm"> *</span>
<span class="cm"> * Returns device, interface, or endpoint status.  Normally only of</span>
<span class="cm"> * interest to see if the device is self powered, or has enabled the</span>
<span class="cm"> * remote wakeup facility; or whether a bulk or interrupt endpoint</span>
<span class="cm"> * is halted (&quot;stalled&quot;).</span>
<span class="cm"> *</span>
<span class="cm"> * Bits in these status bitmaps are set using the SET_FEATURE request,</span>
<span class="cm"> * and cleared using the CLEAR_FEATURE request.  The usb_clear_halt()</span>
<span class="cm"> * function should be used to clear halt (&quot;stall&quot;) status.</span>
<span class="cm"> *</span>
<span class="cm"> * This call is synchronous, and may not be used in an interrupt context.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of bytes received on success, or else the status code</span>
<span class="cm"> * returned by the underlying usb_control_msg() call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_get_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">status</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">usb_rcvctrlpipe</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">USB_REQ_GET_STATUS</span><span class="p">,</span> <span class="n">USB_DIR_IN</span> <span class="o">|</span> <span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">status</span><span class="p">),</span> <span class="n">USB_CTRL_GET_TIMEOUT</span><span class="p">);</span>

	<span class="o">*</span><span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span> <span class="o">=</span> <span class="o">*</span><span class="n">status</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_get_status</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_clear_halt - tells device to clear endpoint halt/stall condition</span>
<span class="cm"> * @dev: device whose endpoint is halted</span>
<span class="cm"> * @pipe: endpoint &quot;pipe&quot; being cleared</span>
<span class="cm"> * Context: !in_interrupt ()</span>
<span class="cm"> *</span>
<span class="cm"> * This is used to clear halt conditions for bulk and interrupt endpoints,</span>
<span class="cm"> * as reported by URB completion status.  Endpoints that are halted are</span>
<span class="cm"> * sometimes referred to as being &quot;stalled&quot;.  Such endpoints are unable</span>
<span class="cm"> * to transmit or receive data until the halt status is cleared.  Any URBs</span>
<span class="cm"> * queued for such an endpoint should normally be unlinked by the driver</span>
<span class="cm"> * before clearing the halt condition, as described in sections 5.7.5</span>
<span class="cm"> * and 5.8.5 of the USB 2.0 spec.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that control and isochronous endpoints don&#39;t halt, although control</span>
<span class="cm"> * endpoints report &quot;protocol stall&quot; (for unsupported requests) using the</span>
<span class="cm"> * same status code used to report a true stall.</span>
<span class="cm"> *</span>
<span class="cm"> * This call is synchronous, and may not be used in an interrupt context.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, or else the status code returned by the</span>
<span class="cm"> * underlying usb_control_msg() call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_clear_halt</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">endp</span> <span class="o">=</span> <span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipein</span><span class="p">(</span><span class="n">pipe</span><span class="p">))</span>
		<span class="n">endp</span> <span class="o">|=</span> <span class="n">USB_DIR_IN</span><span class="p">;</span>

	<span class="cm">/* we don&#39;t care if it wasn&#39;t halted first. in fact some devices</span>
<span class="cm">	 * (like some ibmcam model 1 units) seem to expect hosts to make</span>
<span class="cm">	 * this request for iso endpoints, which can&#39;t halt!</span>
<span class="cm">	 */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">USB_REQ_CLEAR_FEATURE</span><span class="p">,</span> <span class="n">USB_RECIP_ENDPOINT</span><span class="p">,</span>
		<span class="n">USB_ENDPOINT_HALT</span><span class="p">,</span> <span class="n">endp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">USB_CTRL_SET_TIMEOUT</span><span class="p">);</span>

	<span class="cm">/* don&#39;t un-halt or force to DATA0 except on success */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* NOTE:  seems like Microsoft and Apple don&#39;t bother verifying</span>
<span class="cm">	 * the clear &quot;took&quot;, so some devices could lock up if you check...</span>
<span class="cm">	 * such as the Hagiwara FlashGate DUAL.  So we won&#39;t bother.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE:  make sure the logic here doesn&#39;t diverge much from</span>
<span class="cm">	 * the copy in usb-storage, for as long as we need two copies.</span>
<span class="cm">	 */</span>

	<span class="n">usb_reset_endpoint</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">endp</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_clear_halt</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_intf_ep_devs</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">alt</span> <span class="o">=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">ep_devs_created</span> <span class="o">||</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">unregistering</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumEndpoints</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">usb_create_ep_devs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alt</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">udev</span><span class="p">);</span>
	<span class="n">intf</span><span class="o">-&gt;</span><span class="n">ep_devs_created</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_intf_ep_devs</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">alt</span> <span class="o">=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">ep_devs_created</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumEndpoints</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">usb_remove_ep_devs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">alt</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">intf</span><span class="o">-&gt;</span><span class="n">ep_devs_created</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_disable_endpoint -- Disable an endpoint by address</span>
<span class="cm"> * @dev: the device whose endpoint is being disabled</span>
<span class="cm"> * @epaddr: the endpoint&#39;s address.  Endpoint number for output,</span>
<span class="cm"> *	endpoint number + USB_DIR_IN for input</span>
<span class="cm"> * @reset_hardware: flag to erase any endpoint state stored in the</span>
<span class="cm"> *	controller hardware</span>
<span class="cm"> *</span>
<span class="cm"> * Disables the endpoint for URB submission and nukes all pending URBs.</span>
<span class="cm"> * If @reset_hardware is set then also deallocates hcd/hardware state</span>
<span class="cm"> * for the endpoint.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_disable_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">epaddr</span><span class="p">,</span>
		<span class="n">bool</span> <span class="n">reset_hardware</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">epnum</span> <span class="o">=</span> <span class="n">epaddr</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_NUMBER_MASK</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_out</span><span class="p">(</span><span class="n">epaddr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep_out</span><span class="p">[</span><span class="n">epnum</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reset_hardware</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep_out</span><span class="p">[</span><span class="n">epnum</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep_in</span><span class="p">[</span><span class="n">epnum</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reset_hardware</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep_in</span><span class="p">[</span><span class="n">epnum</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">usb_hcd_flush_endpoint</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reset_hardware</span><span class="p">)</span>
			<span class="n">usb_hcd_disable_endpoint</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_reset_endpoint - Reset an endpoint&#39;s state.</span>
<span class="cm"> * @dev: the device whose endpoint is to be reset</span>
<span class="cm"> * @epaddr: the endpoint&#39;s address.  Endpoint number for output,</span>
<span class="cm"> *	endpoint number + USB_DIR_IN for input</span>
<span class="cm"> *</span>
<span class="cm"> * Resets any host-side endpoint state such as the toggle bit,</span>
<span class="cm"> * sequence number or current window.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_reset_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">epaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">epnum</span> <span class="o">=</span> <span class="n">epaddr</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_NUMBER_MASK</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_out</span><span class="p">(</span><span class="n">epaddr</span><span class="p">))</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep_out</span><span class="p">[</span><span class="n">epnum</span><span class="p">];</span>
	<span class="k">else</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep_in</span><span class="p">[</span><span class="n">epnum</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="p">)</span>
		<span class="n">usb_hcd_reset_endpoint</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_reset_endpoint</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * usb_disable_interface -- Disable all endpoints for an interface</span>
<span class="cm"> * @dev: the device whose interface is being disabled</span>
<span class="cm"> * @intf: pointer to the interface descriptor</span>
<span class="cm"> * @reset_hardware: flag to erase any endpoint state stored in the</span>
<span class="cm"> *	controller hardware</span>
<span class="cm"> *</span>
<span class="cm"> * Disables all the endpoints for the interface&#39;s current altsetting.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_disable_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span>
		<span class="n">bool</span> <span class="n">reset_hardware</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">alt</span> <span class="o">=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumEndpoints</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_disable_endpoint</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				<span class="n">alt</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">,</span>
				<span class="n">reset_hardware</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_disable_device - Disable all the endpoints for a USB device</span>
<span class="cm"> * @dev: the device whose endpoints are being disabled</span>
<span class="cm"> * @skip_ep0: 0 to disable endpoint 0, 1 to skip it.</span>
<span class="cm"> *</span>
<span class="cm"> * Disables all the device&#39;s endpoints, potentially including endpoint 0.</span>
<span class="cm"> * Deallocates hcd/hardware state for the endpoints (nuking all or most</span>
<span class="cm"> * pending urbs) and usbcore state for the interfaces, so that usbcore</span>
<span class="cm"> * must usb_set_configuration() before any interfaces could be used.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_disable_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">skip_ep0</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>

	<span class="cm">/* getting rid of interfaces will disconnect</span>
<span class="cm">	 * any drivers bound to them (a key side effect)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * FIXME: In order to avoid self-deadlock involving the</span>
<span class="cm">		 * bandwidth_mutex, we have to mark all the interfaces</span>
<span class="cm">		 * before unregistering any of them.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumInterfaces</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">unregistering</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumInterfaces</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">usb_interface</span>	<span class="o">*</span><span class="n">interface</span><span class="p">;</span>

			<span class="cm">/* remove this interface if it has been registered */</span>
			<span class="n">interface</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">device_is_registered</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unregistering interface %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
			<span class="n">remove_intf_ep_devs</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>
			<span class="n">device_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Now that the interfaces are unbound, nobody should</span>
<span class="cm">		 * try to access them.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumInterfaces</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">actconfig</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_CONFIGURED</span><span class="p">)</span>
			<span class="n">usb_set_device_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">USB_STATE_ADDRESS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s nuking %s URBs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="n">skip_ep0</span> <span class="o">?</span> <span class="s">&quot;non-ep0&quot;</span> <span class="o">:</span> <span class="s">&quot;all&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">check_bandwidth</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* First pass: Cancel URBs, leave endpoint pointers intact. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">skip_ep0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">usb_disable_endpoint</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
			<span class="n">usb_disable_endpoint</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">USB_DIR_IN</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Remove endpoints from the host controller internal state */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">);</span>
		<span class="n">usb_hcd_alloc_bandwidth</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">);</span>
		<span class="cm">/* Second pass: remove endpoint pointers */</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">skip_ep0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_disable_endpoint</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">usb_disable_endpoint</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">USB_DIR_IN</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_enable_endpoint - Enable an endpoint for USB communications</span>
<span class="cm"> * @dev: the device whose interface is being enabled</span>
<span class="cm"> * @ep: the endpoint</span>
<span class="cm"> * @reset_ep: flag to reset the endpoint state</span>
<span class="cm"> *</span>
<span class="cm"> * Resets the endpoint state if asked, and sets dev-&gt;ep_{in,out} pointers.</span>
<span class="cm"> * For control endpoints, both the input and output sides are handled.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_enable_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
		<span class="n">bool</span> <span class="n">reset_ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">epnum</span> <span class="o">=</span> <span class="n">usb_endpoint_num</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">is_out</span> <span class="o">=</span> <span class="n">usb_endpoint_dir_out</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">is_control</span> <span class="o">=</span> <span class="n">usb_endpoint_xfer_control</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reset_ep</span><span class="p">)</span>
		<span class="n">usb_hcd_reset_endpoint</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_out</span> <span class="o">||</span> <span class="n">is_control</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep_out</span><span class="p">[</span><span class="n">epnum</span><span class="p">]</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_out</span> <span class="o">||</span> <span class="n">is_control</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep_in</span><span class="p">[</span><span class="n">epnum</span><span class="p">]</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_enable_interface - Enable all the endpoints for an interface</span>
<span class="cm"> * @dev: the device whose interface is being enabled</span>
<span class="cm"> * @intf: pointer to the interface descriptor</span>
<span class="cm"> * @reset_eps: flag to reset the endpoints&#39; state</span>
<span class="cm"> *</span>
<span class="cm"> * Enables all the endpoints for the interface&#39;s current altsetting.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_enable_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span> <span class="n">bool</span> <span class="n">reset_eps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">alt</span> <span class="o">=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumEndpoints</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">usb_enable_endpoint</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alt</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">reset_eps</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_set_interface - Makes a particular alternate setting be current</span>
<span class="cm"> * @dev: the device whose interface is being updated</span>
<span class="cm"> * @interface: the interface being updated</span>
<span class="cm"> * @alternate: the setting being chosen.</span>
<span class="cm"> * Context: !in_interrupt ()</span>
<span class="cm"> *</span>
<span class="cm"> * This is used to enable data transfers on interfaces that may not</span>
<span class="cm"> * be enabled by default.  Not all devices support such configurability.</span>
<span class="cm"> * Only the driver bound to an interface may change its setting.</span>
<span class="cm"> *</span>
<span class="cm"> * Within any given configuration, each interface may have several</span>
<span class="cm"> * alternative settings.  These are often used to control levels of</span>
<span class="cm"> * bandwidth consumption.  For example, the default setting for a high</span>
<span class="cm"> * speed interrupt endpoint may not send more than 64 bytes per microframe,</span>
<span class="cm"> * while interrupt transfers of up to 3KBytes per microframe are legal.</span>
<span class="cm"> * Also, isochronous endpoints may never be part of an</span>
<span class="cm"> * interface&#39;s default setting.  To access such bandwidth, alternate</span>
<span class="cm"> * interface settings must be made current.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that in the Linux USB subsystem, bandwidth associated with</span>
<span class="cm"> * an endpoint in a given alternate setting is not reserved until an URB</span>
<span class="cm"> * is submitted that needs that bandwidth.  Some other operating systems</span>
<span class="cm"> * allocate bandwidth early, when a configuration is chosen.</span>
<span class="cm"> *</span>
<span class="cm"> * This call is synchronous, and may not be used in an interrupt context.</span>
<span class="cm"> * Also, drivers must not change altsettings while urbs are scheduled for</span>
<span class="cm"> * endpoints in that interface; all such urbs must first be completed</span>
<span class="cm"> * (perhaps forced by unlinking).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, or else the status code returned by the</span>
<span class="cm"> * underlying usb_control_msg() call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_set_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">interface</span><span class="p">,</span> <span class="kt">int</span> <span class="n">alternate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">alt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">manual</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">epaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_SUSPENDED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EHOSTUNREACH</span><span class="p">;</span>

	<span class="n">iface</span> <span class="o">=</span> <span class="n">usb_ifnum_to_if</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">interface</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iface</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;selecting invalid interface %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">interface</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">unregistering</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">alt</span> <span class="o">=</span> <span class="n">usb_altnum_to_altsetting</span><span class="p">(</span><span class="n">iface</span><span class="p">,</span> <span class="n">alternate</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;selecting invalid altsetting %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">alternate</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure we have enough bandwidth for this alternate interface.</span>
<span class="cm">	 * Remove the current alt setting and add the new alt setting.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">);</span>
	<span class="cm">/* Disable LPM, and re-enable it once the new alt setting is installed,</span>
<span class="cm">	 * so that the xHCI driver can recalculate the U1/U2 timeouts.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_disable_lpm</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s Failed to disable LPM</span><span class="se">\n</span><span class="s">.&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_hcd_alloc_bandwidth</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">iface</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="p">,</span> <span class="n">alt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Not enough bandwidth for altsetting %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">alternate</span><span class="p">);</span>
		<span class="n">usb_enable_lpm</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">USB_QUIRK_NO_SET_INTF</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
				   <span class="n">USB_REQ_SET_INTERFACE</span><span class="p">,</span> <span class="n">USB_RECIP_INTERFACE</span><span class="p">,</span>
				   <span class="n">alternate</span><span class="p">,</span> <span class="n">interface</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5000</span><span class="p">);</span>

	<span class="cm">/* 9.4.10 says devices don&#39;t need this and are free to STALL the</span>
<span class="cm">	 * request if the interface only has one alternate setting.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPIPE</span> <span class="o">&amp;&amp;</span> <span class="n">iface</span><span class="o">-&gt;</span><span class="n">num_altsetting</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;manual set_interface for iface %d, alt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">interface</span><span class="p">,</span> <span class="n">alternate</span><span class="p">);</span>
		<span class="n">manual</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Re-instate the old alt setting */</span>
		<span class="n">usb_hcd_alloc_bandwidth</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">alt</span><span class="p">,</span> <span class="n">iface</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="p">);</span>
		<span class="n">usb_enable_lpm</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">);</span>

	<span class="cm">/* FIXME drivers shouldn&#39;t need to replicate/bugfix the logic here</span>
<span class="cm">	 * when they implement async or easily-killable versions of this or</span>
<span class="cm">	 * other &quot;should-be-internal&quot; functions (like clear_halt).</span>
<span class="cm">	 * should hcd+usbcore postprocess control requests?</span>
<span class="cm">	 */</span>

	<span class="cm">/* prevent submissions using previous endpoint settings */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span> <span class="o">!=</span> <span class="n">alt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">remove_intf_ep_devs</span><span class="p">(</span><span class="n">iface</span><span class="p">);</span>
		<span class="n">usb_remove_sysfs_intf_files</span><span class="p">(</span><span class="n">iface</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">usb_disable_interface</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">iface</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="n">iface</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span> <span class="o">=</span> <span class="n">alt</span><span class="p">;</span>

	<span class="cm">/* Now that the interface is installed, re-enable LPM. */</span>
	<span class="n">usb_unlocked_enable_lpm</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* If the interface only has one altsetting and the device didn&#39;t</span>
<span class="cm">	 * accept the request, we attempt to carry out the equivalent action</span>
<span class="cm">	 * by manually clearing the HALT feature for each endpoint in the</span>
<span class="cm">	 * new altsetting.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">manual</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumEndpoints</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">epaddr</span> <span class="o">=</span> <span class="n">alt</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">;</span>
			<span class="n">pipe</span> <span class="o">=</span> <span class="n">__create_pipe</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
					<span class="n">USB_ENDPOINT_NUMBER_MASK</span> <span class="o">&amp;</span> <span class="n">epaddr</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">(</span><span class="n">usb_endpoint_out</span><span class="p">(</span><span class="n">epaddr</span><span class="p">)</span> <span class="o">?</span>
					<span class="n">USB_DIR_OUT</span> <span class="o">:</span> <span class="n">USB_DIR_IN</span><span class="p">);</span>

			<span class="n">usb_clear_halt</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* 9.1.1.5: reset toggles for all endpoints in the new altsetting</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note:</span>
<span class="cm">	 * Despite EP0 is always present in all interfaces/AS, the list of</span>
<span class="cm">	 * endpoints from the descriptor does not contain EP0. Due to its</span>
<span class="cm">	 * omnipresence one might expect EP0 being considered &quot;affected&quot; by</span>
<span class="cm">	 * any SetInterface request and hence assume toggles need to be reset.</span>
<span class="cm">	 * However, EP0 toggles are re-synced for every individual transfer</span>
<span class="cm">	 * during the SETUP stage - hence EP0 toggles are &quot;don&#39;t care&quot; here.</span>
<span class="cm">	 * (Likewise, EP0 never &quot;halts&quot; on well designed devices.)</span>
<span class="cm">	 */</span>
	<span class="n">usb_enable_interface</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">iface</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device_is_registered</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">usb_create_sysfs_intf_files</span><span class="p">(</span><span class="n">iface</span><span class="p">);</span>
		<span class="n">create_intf_ep_devs</span><span class="p">(</span><span class="n">iface</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_set_interface</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_reset_configuration - lightweight device reset</span>
<span class="cm"> * @dev: the device whose configuration is being reset</span>
<span class="cm"> *</span>
<span class="cm"> * This issues a standard SET_CONFIGURATION request to the device using</span>
<span class="cm"> * the current configuration.  The effect is to reset most USB-related</span>
<span class="cm"> * state in the device, including interface altsettings (reset to zero),</span>
<span class="cm"> * endpoint halts (cleared), and endpoint state (only for bulk and interrupt</span>
<span class="cm"> * endpoints).  Other usbcore state is unchanged, including bindings of</span>
<span class="cm"> * usb device drivers to interfaces.</span>
<span class="cm"> *</span>
<span class="cm"> * Because this affects multiple interfaces, avoid using this with composite</span>
<span class="cm"> * (multi-interface) devices.  Instead, the driver for each interface may</span>
<span class="cm"> * use usb_set_interface() on the interfaces it claims.  Be careful though;</span>
<span class="cm"> * some devices don&#39;t support the SET_INTERFACE request, and others won&#39;t</span>
<span class="cm"> * reset all the interface state (notably endpoint state).  Resetting the whole</span>
<span class="cm"> * configuration would affect other drivers&#39; interfaces.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must own the device lock.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, else a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_reset_configuration</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_config</span>	<span class="o">*</span><span class="n">config</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_SUSPENDED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EHOSTUNREACH</span><span class="p">;</span>

	<span class="cm">/* caller must have locked the device and must own</span>
<span class="cm">	 * the usb bus readlock (so driver bindings are stable);</span>
<span class="cm">	 * calls during probe() are fine</span>
<span class="cm">	 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_disable_endpoint</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">usb_disable_endpoint</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">USB_DIR_IN</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">config</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">);</span>
	<span class="cm">/* Disable LPM, and re-enable it once the configuration is reset, so</span>
<span class="cm">	 * that the xHCI driver can recalculate the U1/U2 timeouts.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_disable_lpm</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s Failed to disable LPM</span><span class="se">\n</span><span class="s">.&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Make sure we have enough bandwidth for each alternate setting 0 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumInterfaces</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span> <span class="o">=</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">alt</span><span class="p">;</span>

		<span class="n">alt</span> <span class="o">=</span> <span class="n">usb_altnum_to_altsetting</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alt</span><span class="p">)</span>
			<span class="n">alt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">alt</span> <span class="o">!=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_hcd_alloc_bandwidth</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					<span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="p">,</span> <span class="n">alt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* If not, reinstate the old alternate settings */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">reset_old_alts:</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span> <span class="o">=</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">alt</span><span class="p">;</span>

			<span class="n">alt</span> <span class="o">=</span> <span class="n">usb_altnum_to_altsetting</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alt</span><span class="p">)</span>
				<span class="n">alt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">alt</span> <span class="o">!=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="p">)</span>
				<span class="n">usb_hcd_alloc_bandwidth</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
						<span class="n">alt</span><span class="p">,</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">usb_enable_lpm</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
			<span class="n">USB_REQ_SET_CONFIGURATION</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">config</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bConfigurationValue</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">USB_CTRL_SET_TIMEOUT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reset_old_alts</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">);</span>

	<span class="cm">/* re-init hc/hcd interface/endpoint state */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumInterfaces</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span> <span class="o">=</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">alt</span><span class="p">;</span>

		<span class="n">alt</span> <span class="o">=</span> <span class="n">usb_altnum_to_altsetting</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* No altsetting 0?  We&#39;ll assume the first altsetting.</span>
<span class="cm">		 * We could use a GetInterface call, but if a device is</span>
<span class="cm">		 * so non-compliant that it doesn&#39;t have altsetting 0</span>
<span class="cm">		 * then I wouldn&#39;t trust its reply anyway.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alt</span><span class="p">)</span>
			<span class="n">alt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">alt</span> <span class="o">!=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">remove_intf_ep_devs</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
			<span class="n">usb_remove_sysfs_intf_files</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span> <span class="o">=</span> <span class="n">alt</span><span class="p">;</span>
		<span class="n">usb_enable_interface</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">intf</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">device_is_registered</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">usb_create_sysfs_intf_files</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
			<span class="n">create_intf_ep_devs</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Now that the interfaces are installed, re-enable LPM. */</span>
	<span class="n">usb_unlocked_enable_lpm</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_reset_configuration</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usb_release_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span> <span class="o">=</span> <span class="n">to_usb_interface</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_interface_cache</span> <span class="o">*</span><span class="n">intfc</span> <span class="o">=</span>
			<span class="n">altsetting_to_usb_interface_cache</span><span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">);</span>

	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intfc</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="n">usb_release_interface_cache</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef	CONFIG_HOTPLUG</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_if_uevent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">alt</span><span class="p">;</span>

	<span class="n">intf</span> <span class="o">=</span> <span class="n">to_usb_interface</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">usb_dev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="n">alt</span> <span class="o">=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">add_uevent_var</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s">&quot;INTERFACE=%d/%d/%d&quot;</span><span class="p">,</span>
		   <span class="n">alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceClass</span><span class="p">,</span>
		   <span class="n">alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceSubClass</span><span class="p">,</span>
		   <span class="n">alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceProtocol</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">add_uevent_var</span><span class="p">(</span><span class="n">env</span><span class="p">,</span>
		   <span class="s">&quot;MODALIAS=usb:&quot;</span>
		   <span class="s">&quot;v%04Xp%04Xd%04Xdc%02Xdsc%02Xdp%02Xic%02Xisc%02Xip%02X&quot;</span><span class="p">,</span>
		   <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idVendor</span><span class="p">),</span>
		   <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idProduct</span><span class="p">),</span>
		   <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bcdDevice</span><span class="p">),</span>
		   <span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bDeviceClass</span><span class="p">,</span>
		   <span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bDeviceSubClass</span><span class="p">,</span>
		   <span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bDeviceProtocol</span><span class="p">,</span>
		   <span class="n">alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceClass</span><span class="p">,</span>
		   <span class="n">alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceSubClass</span><span class="p">,</span>
		   <span class="n">alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceProtocol</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_if_uevent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_HOTPLUG */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">device_type</span> <span class="n">usb_if_device_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;usb_interface&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span>	<span class="n">usb_release_interface</span><span class="p">,</span>
	<span class="p">.</span><span class="n">uevent</span> <span class="o">=</span>	<span class="n">usb_if_uevent</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_interface_assoc_descriptor</span> <span class="o">*</span><span class="nf">find_iad</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">usb_host_config</span> <span class="o">*</span><span class="n">config</span><span class="p">,</span>
						<span class="n">u8</span> <span class="n">inum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_interface_assoc_descriptor</span> <span class="o">*</span><span class="n">retval</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface_assoc_descriptor</span> <span class="o">*</span><span class="n">intf_assoc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">first_intf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_intf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">USB_MAXIADS</span> <span class="o">&amp;&amp;</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">intf_assoc</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">intf_assoc</span> <span class="o">=</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">intf_assoc</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">intf_assoc</span><span class="o">-&gt;</span><span class="n">bInterfaceCount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">first_intf</span> <span class="o">=</span> <span class="n">intf_assoc</span><span class="o">-&gt;</span><span class="n">bFirstInterface</span><span class="p">;</span>
		<span class="n">last_intf</span> <span class="o">=</span> <span class="n">first_intf</span> <span class="o">+</span> <span class="p">(</span><span class="n">intf_assoc</span><span class="o">-&gt;</span><span class="n">bInterfaceCount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inum</span> <span class="o">&gt;=</span> <span class="n">first_intf</span> <span class="o">&amp;&amp;</span> <span class="n">inum</span> <span class="o">&lt;=</span> <span class="n">last_intf</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">intf_assoc</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Interface #%d referenced&quot;</span>
					<span class="s">&quot; by multiple IADs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Internal function to queue a device reset</span>
<span class="cm"> *</span>
<span class="cm"> * This is initialized into the workstruct in &#39;struct</span>
<span class="cm"> * usb_device-&gt;reset_ws&#39; that is launched by</span>
<span class="cm"> * message.c:usb_set_configuration() when initializing each &#39;struct</span>
<span class="cm"> * usb_interface&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * It is safe to get the USB device without reference counts because</span>
<span class="cm"> * the life cycle of @iface is bound to the life cycle of @udev. Then,</span>
<span class="cm"> * this function will be ran only if @iface is alive (and before</span>
<span class="cm"> * freeing it any scheduled instances of it will have been cancelled).</span>
<span class="cm"> *</span>
<span class="cm"> * We need to set a flag (usb_dev-&gt;reset_running) because when we call</span>
<span class="cm"> * the reset, the interfaces might be unbound. The current interface</span>
<span class="cm"> * cannot try to remove the queued work as it would cause a deadlock</span>
<span class="cm"> * (you cannot remove your work from within your executing</span>
<span class="cm"> * workqueue). This flag lets it know, so that</span>
<span class="cm"> * usb_cancel_queued_reset() doesn&#39;t try to do it.</span>
<span class="cm"> *</span>
<span class="cm"> * See usb_queue_reset_device() for more details</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__usb_queue_reset_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">ws</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_interface</span><span class="p">,</span> <span class="n">reset_ws</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">iface</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">usb_lock_device_for_reset</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">iface</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iface</span><span class="o">-&gt;</span><span class="n">reset_running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">usb_reset_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
		<span class="n">iface</span><span class="o">-&gt;</span><span class="n">reset_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">usb_unlock_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * usb_set_configuration - Makes a particular device setting be current</span>
<span class="cm"> * @dev: the device whose configuration is being updated</span>
<span class="cm"> * @configuration: the configuration being chosen.</span>
<span class="cm"> * Context: !in_interrupt(), caller owns the device lock</span>
<span class="cm"> *</span>
<span class="cm"> * This is used to enable non-default device modes.  Not all devices</span>
<span class="cm"> * use this kind of configurability; many devices only have one</span>
<span class="cm"> * configuration.</span>
<span class="cm"> *</span>
<span class="cm"> * @configuration is the value of the configuration to be installed.</span>
<span class="cm"> * According to the USB spec (e.g. section 9.1.1.5), configuration values</span>
<span class="cm"> * must be non-zero; a value of zero indicates that the device in</span>
<span class="cm"> * unconfigured.  However some devices erroneously use 0 as one of their</span>
<span class="cm"> * configuration values.  To help manage such devices, this routine will</span>
<span class="cm"> * accept @configuration = -1 as indicating the device should be put in</span>
<span class="cm"> * an unconfigured state.</span>
<span class="cm"> *</span>
<span class="cm"> * USB device configurations may affect Linux interoperability,</span>
<span class="cm"> * power consumption and the functionality available.  For example,</span>
<span class="cm"> * the default configuration is limited to using 100mA of bus power,</span>
<span class="cm"> * so that when certain device functionality requires more power,</span>
<span class="cm"> * and the device is bus powered, that functionality should be in some</span>
<span class="cm"> * non-default device configuration.  Other device modes may also be</span>
<span class="cm"> * reflected as configuration options, such as whether two ISDN</span>
<span class="cm"> * channels are available independently; and choosing between open</span>
<span class="cm"> * standard device protocols (like CDC) or proprietary ones.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that a non-authorized device (dev-&gt;authorized == 0) will only</span>
<span class="cm"> * be put in unconfigured mode.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that USB has an additional level of device configurability,</span>
<span class="cm"> * associated with interfaces.  That configurability is accessed using</span>
<span class="cm"> * usb_set_interface().</span>
<span class="cm"> *</span>
<span class="cm"> * This call is synchronous. The calling context must be able to sleep,</span>
<span class="cm"> * must own the device lock, and must not hold the driver model&#39;s USB</span>
<span class="cm"> * bus mutex; usb interface driver probe() methods cannot use this routine.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, or else the status code returned by the</span>
<span class="cm"> * underlying call that failed.  On successful completion, each interface</span>
<span class="cm"> * in the original device configuration has been destroyed, and each one</span>
<span class="cm"> * in the new configuration has been probed by all relevant usb device</span>
<span class="cm"> * drivers currently known to the kernel.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_set_configuration</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">configuration</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_config</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">**</span><span class="n">new_interfaces</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">nintf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">authorized</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">configuration</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">configuration</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bNumConfigurations</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span><span class="p">.</span><span class="n">bConfigurationValue</span> <span class="o">==</span>
					<span class="n">configuration</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">cp</span> <span class="o">&amp;&amp;</span> <span class="n">configuration</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* The USB spec says configuration 0 means unconfigured.</span>
<span class="cm">	 * But if a device includes a configuration numbered 0,</span>
<span class="cm">	 * we will accept it as a correctly configured state.</span>
<span class="cm">	 * Use -1 if you really want to unconfigure the device.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span> <span class="o">&amp;&amp;</span> <span class="n">configuration</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;config 0 descriptor??</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Allocate memory for new interfaces before doing anything else,</span>
<span class="cm">	 * so that if we run out then nothing will have changed. */</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">nintf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nintf</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumInterfaces</span><span class="p">;</span>
		<span class="n">new_interfaces</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">nintf</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">new_interfaces</span><span class="p">),</span>
				<span class="n">GFP_NOIO</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_interfaces</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">nintf</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_interfaces</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span><span class="p">),</span>
					<span class="n">GFP_NOIO</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_interfaces</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="nl">free_interfaces:</span>
				<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">kfree</span><span class="p">(</span><span class="n">new_interfaces</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">new_interfaces</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">i</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus_mA</span> <span class="o">-</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bMaxPower</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;new config #%d exceeds power &quot;</span>
					<span class="s">&quot;limit by %dmA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">configuration</span><span class="p">,</span> <span class="o">-</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Wake up the device so we can send it the Set-Config request */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_autoresume_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_interfaces</span><span class="p">;</span>

	<span class="cm">/* if it&#39;s already configured, clear out old state first.</span>
<span class="cm">	 * getting rid of old interfaces means unbinding their drivers.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">USB_STATE_ADDRESS</span><span class="p">)</span>
		<span class="n">usb_disable_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>	<span class="cm">/* Skip ep0 */</span>

	<span class="cm">/* Get rid of pending async Set-Config requests for this device */</span>
	<span class="n">cancel_async_set_config</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Make sure we have bandwidth (and available HCD resources) for this</span>
<span class="cm">	 * configuration.  Remove endpoints from the schedule if we&#39;re dropping</span>
<span class="cm">	 * this configuration to set configuration 0.  After this point, the</span>
<span class="cm">	 * host controller will not allow submissions to dropped endpoints.  If</span>
<span class="cm">	 * this call fails, the device state is unchanged.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">);</span>
	<span class="cm">/* Disable LPM, and re-enable it once the new configuration is</span>
<span class="cm">	 * installed, so that the xHCI driver can recalculate the U1/U2</span>
<span class="cm">	 * timeouts.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_disable_lpm</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s Failed to disable LPM</span><span class="se">\n</span><span class="s">.&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_hcd_alloc_bandwidth</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_enable_lpm</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">);</span>
		<span class="n">usb_autosuspend_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free_interfaces</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
			      <span class="n">USB_REQ_SET_CONFIGURATION</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">configuration</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			      <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">USB_CTRL_SET_TIMEOUT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* All the old state is gone, so what else can we do?</span>
<span class="cm">		 * The device is probably useless now anyway.</span>
<span class="cm">		 */</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">actconfig</span> <span class="o">=</span> <span class="n">cp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_set_device_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">USB_STATE_ADDRESS</span><span class="p">);</span>
		<span class="n">usb_hcd_alloc_bandwidth</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">usb_enable_lpm</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">);</span>
		<span class="n">usb_autosuspend_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free_interfaces</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">);</span>
	<span class="n">usb_set_device_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">USB_STATE_CONFIGURED</span><span class="p">);</span>

	<span class="cm">/* Initialize the new interface structures and the</span>
<span class="cm">	 * hc/hcd/usbcore interface/endpoint state.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nintf</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_interface_cache</span> <span class="o">*</span><span class="n">intfc</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">alt</span><span class="p">;</span>

		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">intf</span> <span class="o">=</span> <span class="n">new_interfaces</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">intfc</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">intf_cache</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">intf</span><span class="o">-&gt;</span><span class="n">altsetting</span> <span class="o">=</span> <span class="n">intfc</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">;</span>
		<span class="n">intf</span><span class="o">-&gt;</span><span class="n">num_altsetting</span> <span class="o">=</span> <span class="n">intfc</span><span class="o">-&gt;</span><span class="n">num_altsetting</span><span class="p">;</span>
		<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intfc</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>

		<span class="n">alt</span> <span class="o">=</span> <span class="n">usb_altnum_to_altsetting</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* No altsetting 0?  We&#39;ll assume the first altsetting.</span>
<span class="cm">		 * We could use a GetInterface call, but if a device is</span>
<span class="cm">		 * so non-compliant that it doesn&#39;t have altsetting 0</span>
<span class="cm">		 * then I wouldn&#39;t trust its reply anyway.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alt</span><span class="p">)</span>
			<span class="n">alt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

		<span class="n">intf</span><span class="o">-&gt;</span><span class="n">intf_assoc</span> <span class="o">=</span>
			<span class="n">find_iad</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">);</span>
		<span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span> <span class="o">=</span> <span class="n">alt</span><span class="p">;</span>
		<span class="n">usb_enable_interface</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">intf</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usb_bus_type</span><span class="p">;</span>
		<span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usb_if_device_type</span><span class="p">;</span>
		<span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">groups</span> <span class="o">=</span> <span class="n">usb_interface_groups</span><span class="p">;</span>
		<span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">dma_mask</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">dma_mask</span><span class="p">;</span>
		<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">reset_ws</span><span class="p">,</span> <span class="n">__usb_queue_reset_device</span><span class="p">);</span>
		<span class="n">intf</span><span class="o">-&gt;</span><span class="n">minor</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">device_initialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">pm_runtime_no_callbacks</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%d-%s:%d.%d&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">busnum</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span>
			<span class="n">configuration</span><span class="p">,</span> <span class="n">alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">new_interfaces</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">string</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">USB_QUIRK_CONFIG_INTF_STRINGS</span><span class="p">))</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">string</span> <span class="o">=</span> <span class="n">usb_cache_string</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">iConfiguration</span><span class="p">);</span>

	<span class="cm">/* Now that the interfaces are installed, re-enable LPM. */</span>
	<span class="n">usb_unlocked_enable_lpm</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Now that all the interfaces are set up, register them</span>
<span class="cm">	 * to trigger binding of drivers to interfaces.  probe()</span>
<span class="cm">	 * routines may install different altsettings and may</span>
<span class="cm">	 * claim() any interfaces not yet bound.  Many class drivers</span>
<span class="cm">	 * need that: CDC, audio, video, etc.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nintf</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;adding %s (config #%d, interface %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="n">configuration</span><span class="p">,</span>
			<span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">);</span>
		<span class="n">device_enable_async_suspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">device_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device_add(%s) --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">create_intf_ep_devs</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">usb_autosuspend_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">set_config_list</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">set_config_lock</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">set_config_request</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">config</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">node</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Worker routine for usb_driver_set_configuration() */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">driver_set_config_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">set_config_request</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">set_config_request</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">;</span>

	<span class="n">usb_lock_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set_config_lock</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set_config_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">config</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>		<span class="cm">/* Is req still valid? */</span>
		<span class="n">usb_set_configuration</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">);</span>
	<span class="n">usb_unlock_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="n">usb_put_dev</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Cancel pending Set-Config requests for a device whose configuration</span>
<span class="cm"> * was just changed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cancel_async_set_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">set_config_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set_config_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">set_config_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">udev</span> <span class="o">==</span> <span class="n">udev</span><span class="p">)</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">config</span> <span class="o">=</span> <span class="o">-</span><span class="mi">999</span><span class="p">;</span>	<span class="cm">/* Mark as cancelled */</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set_config_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_driver_set_configuration - Provide a way for drivers to change device configurations</span>
<span class="cm"> * @udev: the device whose configuration is being updated</span>
<span class="cm"> * @config: the configuration being chosen.</span>
<span class="cm"> * Context: In process context, must be able to sleep</span>
<span class="cm"> *</span>
<span class="cm"> * Device interface drivers are not allowed to change device configurations.</span>
<span class="cm"> * This is because changing configurations will destroy the interface the</span>
<span class="cm"> * driver is bound to and create new ones; it would be like a floppy-disk</span>
<span class="cm"> * driver telling the computer to replace the floppy-disk drive with a</span>
<span class="cm"> * tape drive!</span>
<span class="cm"> *</span>
<span class="cm"> * Still, in certain specialized circumstances the need may arise.  This</span>
<span class="cm"> * routine gets around the normal restrictions by using a work thread to</span>
<span class="cm"> * submit the change-config request.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if the request was successfully queued, error code otherwise.</span>
<span class="cm"> * The caller has no way to know whether the queued request will eventually</span>
<span class="cm"> * succeed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_driver_set_configuration</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">config</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">set_config_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">req</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">udev</span> <span class="o">=</span> <span class="n">udev</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">config</span> <span class="o">=</span> <span class="n">config</span><span class="p">;</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">driver_set_config_work</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set_config_lock</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">set_config_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set_config_lock</span><span class="p">);</span>

	<span class="n">usb_get_dev</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_driver_set_configuration</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
