<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › core › hub.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>hub.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * USB hub driver.</span>
<span class="cm"> *</span>
<span class="cm"> * (C) Copyright 1999 Linus Torvalds</span>
<span class="cm"> * (C) Copyright 1999 Johannes Erdfelt</span>
<span class="cm"> * (C) Copyright 1999 Gregory P. Smith</span>
<span class="cm"> * (C) Copyright 2001 Brad Hards (bhards@bigpond.net.au)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/ioctl.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/usbdevice_fs.h&gt;</span>
<span class="cp">#include &lt;linux/usb/hcd.h&gt;</span>
<span class="cp">#include &lt;linux/usb/quirks.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="cp">#include &quot;usb.h&quot;</span>

<span class="cm">/* if we are in debug mode, always announce new devices */</span>
<span class="cp">#ifdef DEBUG</span>
<span class="cp">#ifndef CONFIG_USB_ANNOUNCE_NEW_DEVICES</span>
<span class="cp">#define CONFIG_USB_ANNOUNCE_NEW_DEVICES</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">usb_hub</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">intfdev</span><span class="p">;</span>	<span class="cm">/* the &quot;interface&quot; device */</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">hdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kref</span>		<span class="n">kref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">;</span>		<span class="cm">/* for interrupt polling pipe */</span>

	<span class="cm">/* buffer for urb ... with extra space in case of babble */</span>
	<span class="kt">char</span>			<span class="p">(</span><span class="o">*</span><span class="n">buffer</span><span class="p">)[</span><span class="mi">8</span><span class="p">];</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_hub_status</span>	<span class="n">hub</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">usb_port_status</span>	<span class="n">port</span><span class="p">;</span>
	<span class="p">}</span>			<span class="o">*</span><span class="n">status</span><span class="p">;</span>	<span class="cm">/* buffer for status reports */</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">status_mutex</span><span class="p">;</span>	<span class="cm">/* for the status buffer */</span>

	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>		<span class="cm">/* last reported error */</span>
	<span class="kt">int</span>			<span class="n">nerrors</span><span class="p">;</span>	<span class="cm">/* track consecutive errors */</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">event_list</span><span class="p">;</span>	<span class="cm">/* hubs w/data or errs ready */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">event_bits</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>	<span class="cm">/* status change bitmask */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">change_bits</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>	<span class="cm">/* ports with logical connect</span>
<span class="cm">							status change */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">busy_bits</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>	<span class="cm">/* ports being reset or</span>
<span class="cm">							resumed */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">removed_bits</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="cm">/* ports with a &quot;removed&quot;</span>
<span class="cm">							device present */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">wakeup_bits</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>	<span class="cm">/* ports that have signaled</span>
<span class="cm">							remote wakeup */</span>
<span class="cp">#if USB_MAXCHILDREN &gt; 31 </span><span class="cm">/* 8*sizeof(unsigned long) - 1 */</span><span class="cp"></span>
<span class="cp">#error event_bits[] is too short!</span>
<span class="cp">#endif</span>

	<span class="k">struct</span> <span class="n">usb_hub_descriptor</span> <span class="o">*</span><span class="n">descriptor</span><span class="p">;</span>	<span class="cm">/* class descriptor */</span>
	<span class="k">struct</span> <span class="n">usb_tt</span>		<span class="n">tt</span><span class="p">;</span>		<span class="cm">/* Transaction Translator */</span>

	<span class="kt">unsigned</span>		<span class="n">mA_per_port</span><span class="p">;</span>	<span class="cm">/* current for each child */</span>

	<span class="kt">unsigned</span>		<span class="n">limited_power</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">quiescing</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">disconnected</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="kt">unsigned</span>		<span class="n">has_indicators</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">indicator</span><span class="p">[</span><span class="n">USB_MAXCHILDREN</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">delayed_work</span>	<span class="n">leds</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">delayed_work</span>	<span class="n">init_work</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">**</span><span class="n">port_owners</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hub_is_superspeed</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bDeviceProtocol</span> <span class="o">==</span> <span class="n">USB_HUB_PR_SS</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Protect struct usb_device-&gt;state and -&gt;children members</span>
<span class="cm"> * Note: Both are also protected by -&gt;dev.sem, except that -&gt;state can</span>
<span class="cm"> * change to USB_STATE_NOTATTACHED even when the semaphore isn&#39;t held. */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">device_state_lock</span><span class="p">);</span>

<span class="cm">/* khubd&#39;s worklist and its lock */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">hub_event_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">hub_event_list</span><span class="p">);</span>	<span class="cm">/* List of hubs needing servicing */</span>

<span class="cm">/* Wakes up khubd */</span>
<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">khubd_wait</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">khubd_task</span><span class="p">;</span>

<span class="cm">/* cycle leds on hubs that aren&#39;t blinking for attention */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">blinkenlights</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">module_param</span> <span class="p">(</span><span class="n">blinkenlights</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span> <span class="p">(</span><span class="n">blinkenlights</span><span class="p">,</span> <span class="s">&quot;true to cycle leds on hubs&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Device SATA8000 FW1.0 from DATAST0R Technology Corp requires about</span>
<span class="cm"> * 10 seconds to send reply for the initial 64-byte descriptor request.</span>
<span class="cm"> */</span>
<span class="cm">/* define initial 64-byte descriptor request timeout in milliseconds */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">initial_descriptor_timeout</span> <span class="o">=</span> <span class="n">USB_CTRL_GET_TIMEOUT</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">initial_descriptor_timeout</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">initial_descriptor_timeout</span><span class="p">,</span>
		<span class="s">&quot;initial 64-byte descriptor request timeout in milliseconds &quot;</span>
		<span class="s">&quot;(default 5000 - 5.0 seconds)&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * As of 2.6.10 we introduce a new USB device initialization scheme which</span>
<span class="cm"> * closely resembles the way Windows works.  Hopefully it will be compatible</span>
<span class="cm"> * with a wider range of devices than the old scheme.  However some previously</span>
<span class="cm"> * working devices may start giving rise to &quot;device not accepting address&quot;</span>
<span class="cm"> * errors; if that happens the user can try the old scheme by adjusting the</span>
<span class="cm"> * following module parameters.</span>
<span class="cm"> *</span>
<span class="cm"> * For maximum flexibility there are two boolean parameters to control the</span>
<span class="cm"> * hub driver&#39;s behavior.  On the first initialization attempt, if the</span>
<span class="cm"> * &quot;old_scheme_first&quot; parameter is set then the old scheme will be used,</span>
<span class="cm"> * otherwise the new scheme is used.  If that fails and &quot;use_both_schemes&quot;</span>
<span class="cm"> * is set, then the driver will make another attempt, using the other scheme.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">old_scheme_first</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">old_scheme_first</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">old_scheme_first</span><span class="p">,</span>
		 <span class="s">&quot;start with the old device initialization scheme&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">use_both_schemes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">use_both_schemes</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">use_both_schemes</span><span class="p">,</span>
		<span class="s">&quot;try the other device initialization scheme if the &quot;</span>
		<span class="s">&quot;first one fails&quot;</span><span class="p">);</span>

<span class="cm">/* Mutual exclusion for EHCI CF initialization.  This interferes with</span>
<span class="cm"> * port reset on some companion controllers.</span>
<span class="cm"> */</span>
<span class="n">DECLARE_RWSEM</span><span class="p">(</span><span class="n">ehci_cf_port_reset_rwsem</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ehci_cf_port_reset_rwsem</span><span class="p">);</span>

<span class="cp">#define HUB_DEBOUNCE_TIMEOUT	1500</span>
<span class="cp">#define HUB_DEBOUNCE_STEP	  25</span>
<span class="cp">#define HUB_DEBOUNCE_STABLE	 100</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">usb_reset_and_verify_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">portspeed</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">,</span> <span class="kt">int</span> <span class="n">portstatus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hub_is_superspeed</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="s">&quot;5.0 Gb/s&quot;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_HIGH_SPEED</span><span class="p">)</span>
    		<span class="k">return</span> <span class="s">&quot;480 Mb/s&quot;</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_LOW_SPEED</span><span class="p">)</span>
		<span class="k">return</span> <span class="s">&quot;1.5 Mb/s&quot;</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="s">&quot;12 Mb/s&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Note that hdev or one of its children must be locked! */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="nf">hdev_to_hub</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hdev</span> <span class="o">||</span> <span class="o">!</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_device_supports_lpm</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* USB 2.1 (and greater) devices indicate LPM support through</span>
<span class="cm">	 * their USB 2.0 Extended Capabilities BOS descriptor.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bos</span><span class="o">-&gt;</span><span class="n">ext_cap</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">USB_LPM_SUPPORT</span> <span class="o">&amp;</span>
			 <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bos</span><span class="o">-&gt;</span><span class="n">ext_cap</span><span class="o">-&gt;</span><span class="n">bmAttributes</span><span class="p">)))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* All USB 3.0 must support LPM, but we need their max exit latency</span>
<span class="cm">	 * information from the SuperSpeed Extended Capabilities BOS descriptor.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bos</span><span class="o">-&gt;</span><span class="n">ss_cap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No LPM exit latency info found.  &quot;</span>
				<span class="s">&quot;Power management will be impacted.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">lpm_capable</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Parent hub missing LPM exit latency info.  &quot;</span>
			<span class="s">&quot;Power management will be impacted.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the Maximum Exit Latency (MEL) for the host to initiate a transition from</span>
<span class="cm"> * either U1 or U2.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usb_set_lpm_mel</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb3_lpm_parameters</span> <span class="o">*</span><span class="n">udev_lpm_params</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">udev_exit_latency</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb3_lpm_parameters</span> <span class="o">*</span><span class="n">hub_lpm_params</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hub_exit_latency</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_mel</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">device_mel</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hub_mel</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate the time it takes to transition all links from the roothub</span>
<span class="cm">	 * to the parent hub into U0.  The parent hub must then decode the</span>
<span class="cm">	 * packet (hub header decode latency) to figure out which port it was</span>
<span class="cm">	 * bound for.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The Hub Header decode latency is expressed in 0.1us intervals (0x1</span>
<span class="cm">	 * means 0.1us).  Multiply that by 100 to get nanoseconds.</span>
<span class="cm">	 */</span>
	<span class="n">total_mel</span> <span class="o">=</span> <span class="n">hub_lpm_params</span><span class="o">-&gt;</span><span class="n">mel</span> <span class="o">+</span>
		<span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ss</span><span class="p">.</span><span class="n">bHubHdrDecLat</span> <span class="o">*</span> <span class="mi">100</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * How long will it take to transition the downstream hub&#39;s port into</span>
<span class="cm">	 * U0?  The greater of either the hub exit latency or the device exit</span>
<span class="cm">	 * latency.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The BOS U1/U2 exit latencies are expressed in 1us intervals.</span>
<span class="cm">	 * Multiply that by 1000 to get nanoseconds.</span>
<span class="cm">	 */</span>
	<span class="n">device_mel</span> <span class="o">=</span> <span class="n">udev_exit_latency</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="n">hub_mel</span> <span class="o">=</span> <span class="n">hub_exit_latency</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device_mel</span> <span class="o">&gt;</span> <span class="n">hub_mel</span><span class="p">)</span>
		<span class="n">total_mel</span> <span class="o">+=</span> <span class="n">device_mel</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">total_mel</span> <span class="o">+=</span> <span class="n">hub_mel</span><span class="p">;</span>

	<span class="n">udev_lpm_params</span><span class="o">-&gt;</span><span class="n">mel</span> <span class="o">=</span> <span class="n">total_mel</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the maximum Device to Host Exit Latency (PEL) for the device to initiate</span>
<span class="cm"> * a transition from either U1 or U2.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usb_set_lpm_pel</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb3_lpm_parameters</span> <span class="o">*</span><span class="n">udev_lpm_params</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">udev_exit_latency</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb3_lpm_parameters</span> <span class="o">*</span><span class="n">hub_lpm_params</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hub_exit_latency</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port_to_port_exit_latency</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">first_link_pel</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hub_pel</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * First, the device sends an LFPS to transition the link between the</span>
<span class="cm">	 * device and the parent hub into U0.  The exit latency is the bigger of</span>
<span class="cm">	 * the device exit latency or the hub exit latency.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udev_exit_latency</span> <span class="o">&gt;</span> <span class="n">hub_exit_latency</span><span class="p">)</span>
		<span class="n">first_link_pel</span> <span class="o">=</span> <span class="n">udev_exit_latency</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">first_link_pel</span> <span class="o">=</span> <span class="n">hub_exit_latency</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When the hub starts to receive the LFPS, there is a slight delay for</span>
<span class="cm">	 * it to figure out that one of the ports is sending an LFPS.  Then it</span>
<span class="cm">	 * will forward the LFPS to its upstream link.  The exit latency is the</span>
<span class="cm">	 * delay, plus the PEL that we calculated for this hub.</span>
<span class="cm">	 */</span>
	<span class="n">hub_pel</span> <span class="o">=</span> <span class="n">port_to_port_exit_latency</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">+</span> <span class="n">hub_lpm_params</span><span class="o">-&gt;</span><span class="n">pel</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * According to figure C-7 in the USB 3.0 spec, the PEL for this device</span>
<span class="cm">	 * is the greater of the two exit latencies.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first_link_pel</span> <span class="o">&gt;</span> <span class="n">hub_pel</span><span class="p">)</span>
		<span class="n">udev_lpm_params</span><span class="o">-&gt;</span><span class="n">pel</span> <span class="o">=</span> <span class="n">first_link_pel</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">udev_lpm_params</span><span class="o">-&gt;</span><span class="n">pel</span> <span class="o">=</span> <span class="n">hub_pel</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the System Exit Latency (SEL) to indicate the total worst-case time from</span>
<span class="cm"> * when a device initiates a transition to U0, until when it will receive the</span>
<span class="cm"> * first packet from the host controller.</span>
<span class="cm"> *</span>
<span class="cm"> * Section C.1.5.1 describes the four components to this:</span>
<span class="cm"> *  - t1: device PEL</span>
<span class="cm"> *  - t2: time for the ERDY to make it from the device to the host.</span>
<span class="cm"> *  - t3: a host-specific delay to process the ERDY.</span>
<span class="cm"> *  - t4: time for the packet to make it from the host to the device.</span>
<span class="cm"> *</span>
<span class="cm"> * t3 is specific to both the xHCI host and the platform the host is integrated</span>
<span class="cm"> * into.  The Intel HW folks have said it&#39;s negligible, FIXME if a different</span>
<span class="cm"> * vendor says otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usb_set_lpm_sel</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb3_lpm_parameters</span> <span class="o">*</span><span class="n">udev_lpm_params</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_hubs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_sel</span><span class="p">;</span>

	<span class="cm">/* t1 = device PEL */</span>
	<span class="n">total_sel</span> <span class="o">=</span> <span class="n">udev_lpm_params</span><span class="o">-&gt;</span><span class="n">pel</span><span class="p">;</span>
	<span class="cm">/* How many external hubs are in between the device &amp; the root port. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">parent</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="n">num_hubs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
			<span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">num_hubs</span><span class="o">++</span><span class="p">;</span>
	<span class="cm">/* t2 = 2.1us + 250ns * (num_hubs - 1) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_hubs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">total_sel</span> <span class="o">+=</span> <span class="mi">2100</span> <span class="o">+</span> <span class="mi">250</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_hubs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* t4 = 250ns * num_hubs */</span>
	<span class="n">total_sel</span> <span class="o">+=</span> <span class="mi">250</span> <span class="o">*</span> <span class="n">num_hubs</span><span class="p">;</span>

	<span class="n">udev_lpm_params</span><span class="o">-&gt;</span><span class="n">sel</span> <span class="o">=</span> <span class="n">total_sel</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usb_set_lpm_parameters</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port_to_port_delay</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">udev_u1_del</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">udev_u2_del</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hub_u1_del</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hub_u2_del</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">lpm_capable</span> <span class="o">||</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">USB_SPEED_SUPER</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">hub</span> <span class="o">=</span> <span class="n">hdev_to_hub</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="cm">/* It doesn&#39;t take time to transition the roothub into U0, since it</span>
<span class="cm">	 * doesn&#39;t have an upstream link.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hub</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">udev_u1_del</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">bos</span><span class="o">-&gt;</span><span class="n">ss_cap</span><span class="o">-&gt;</span><span class="n">bU1devExitLat</span><span class="p">;</span>
	<span class="n">udev_u2_del</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">bos</span><span class="o">-&gt;</span><span class="n">ss_cap</span><span class="o">-&gt;</span><span class="n">bU2DevExitLat</span><span class="p">;</span>
	<span class="n">hub_u1_del</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">bos</span><span class="o">-&gt;</span><span class="n">ss_cap</span><span class="o">-&gt;</span><span class="n">bU1devExitLat</span><span class="p">;</span>
	<span class="n">hub_u2_del</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">bos</span><span class="o">-&gt;</span><span class="n">ss_cap</span><span class="o">-&gt;</span><span class="n">bU2DevExitLat</span><span class="p">;</span>

	<span class="n">usb_set_lpm_mel</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">u1_params</span><span class="p">,</span> <span class="n">udev_u1_del</span><span class="p">,</span>
			<span class="n">hub</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">u1_params</span><span class="p">,</span> <span class="n">hub_u1_del</span><span class="p">);</span>

	<span class="n">usb_set_lpm_mel</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">u2_params</span><span class="p">,</span> <span class="n">udev_u2_del</span><span class="p">,</span>
			<span class="n">hub</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">u2_params</span><span class="p">,</span> <span class="n">hub_u2_del</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Appendix C, section C.2.2.2, says that there is a slight delay from</span>
<span class="cm">	 * when the parent hub notices the downstream port is trying to</span>
<span class="cm">	 * transition to U0 to when the hub initiates a U0 transition on its</span>
<span class="cm">	 * upstream port.  The section says the delays are tPort2PortU1EL and</span>
<span class="cm">	 * tPort2PortU2EL, but it doesn&#39;t define what they are.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The hub chapter, sections 10.4.2.4 and 10.4.2.5 seem to be talking</span>
<span class="cm">	 * about the same delays.  Use the maximum delay calculations from those</span>
<span class="cm">	 * sections.  For U1, it&#39;s tHubPort2PortExitLat, which is 1us max.  For</span>
<span class="cm">	 * U2, it&#39;s tHubPort2PortExitLat + U2DevExitLat - U1DevExitLat.  I</span>
<span class="cm">	 * assume the device exit latencies they are talking about are the hub</span>
<span class="cm">	 * exit latencies.</span>
<span class="cm">	 *</span>
<span class="cm">	 * What do we do if the U2 exit latency is less than the U1 exit</span>
<span class="cm">	 * latency?  It&#39;s possible, although not likely...</span>
<span class="cm">	 */</span>
	<span class="n">port_to_port_delay</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">usb_set_lpm_pel</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">u1_params</span><span class="p">,</span> <span class="n">udev_u1_del</span><span class="p">,</span>
			<span class="n">hub</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">u1_params</span><span class="p">,</span> <span class="n">hub_u1_del</span><span class="p">,</span>
			<span class="n">port_to_port_delay</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hub_u2_del</span> <span class="o">&gt;</span> <span class="n">hub_u1_del</span><span class="p">)</span>
		<span class="n">port_to_port_delay</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">hub_u2_del</span> <span class="o">-</span> <span class="n">hub_u1_del</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">port_to_port_delay</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">hub_u1_del</span><span class="p">;</span>

	<span class="n">usb_set_lpm_pel</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">u2_params</span><span class="p">,</span> <span class="n">udev_u2_del</span><span class="p">,</span>
			<span class="n">hub</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">u2_params</span><span class="p">,</span> <span class="n">hub_u2_del</span><span class="p">,</span>
			<span class="n">port_to_port_delay</span><span class="p">);</span>

	<span class="cm">/* Now that we&#39;ve got PEL, calculate SEL. */</span>
	<span class="n">usb_set_lpm_sel</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">u1_params</span><span class="p">);</span>
	<span class="n">usb_set_lpm_sel</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">u2_params</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* USB 2.0 spec Section 11.24.4.5 */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_hub_descriptor</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">dtype</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hub_is_superspeed</span><span class="p">(</span><span class="n">hdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dtype</span> <span class="o">=</span> <span class="n">USB_DT_SS_HUB</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">USB_DT_SS_HUB_SIZE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dtype</span> <span class="o">=</span> <span class="n">USB_DT_HUB</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub_descriptor</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">usb_rcvctrlpipe</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
			<span class="n">USB_REQ_GET_DESCRIPTOR</span><span class="p">,</span> <span class="n">USB_DIR_IN</span> <span class="o">|</span> <span class="n">USB_RT_HUB</span><span class="p">,</span>
			<span class="n">dtype</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
			<span class="n">USB_CTRL_GET_TIMEOUT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">USB_DT_HUB_NONVAR_SIZE</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * USB 2.0 spec Section 11.24.2.1</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">clear_hub_feature</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">feature</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">USB_REQ_CLEAR_FEATURE</span><span class="p">,</span> <span class="n">USB_RT_HUB</span><span class="p">,</span> <span class="n">feature</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * USB 2.0 spec Section 11.24.2.2</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">clear_port_feature</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">feature</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">USB_REQ_CLEAR_FEATURE</span><span class="p">,</span> <span class="n">USB_RT_PORT</span><span class="p">,</span> <span class="n">feature</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span>
		<span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * USB 2.0 spec Section 11.24.2.13</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_port_feature</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">feature</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">USB_REQ_SET_FEATURE</span><span class="p">,</span> <span class="n">USB_RT_PORT</span><span class="p">,</span> <span class="n">feature</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span>
		<span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * USB 2.0 spec Section 11.24.2.7.1.10 and table 11-7</span>
<span class="cm"> * for info about using port indicators</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_port_led</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">port1</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">selector</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">set_port_feature</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">,</span> <span class="p">(</span><span class="n">selector</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">port1</span><span class="p">,</span>
			<span class="n">USB_PORT_FEAT_INDICATOR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev_dbg</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">,</span>
			<span class="s">&quot;port %d indicator %s status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">port1</span><span class="p">,</span>
			<span class="p">({</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span> <span class="k">switch</span> <span class="p">(</span><span class="n">selector</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">HUB_LED_AMBER</span>: <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;amber&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">HUB_LED_GREEN</span>: <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;green&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">HUB_LED_OFF</span>: <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;off&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">HUB_LED_AUTO</span>: <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;auto&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;??&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
			<span class="p">};</span> <span class="n">s</span><span class="p">;</span> <span class="p">}),</span>
			<span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define	LED_CYCLE_PERIOD	((2*HZ)/3)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">led_work</span> <span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hub</span>		<span class="o">*</span><span class="n">hub</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_hub</span><span class="p">,</span> <span class="n">leds</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">hdev</span> <span class="o">=</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">changed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">cursor</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">USB_STATE_CONFIGURED</span> <span class="o">||</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">quiescing</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">bNbrPorts</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span>	<span class="n">selector</span><span class="p">,</span> <span class="n">mode</span><span class="p">;</span>

		<span class="cm">/* 30%-50% duty cycle */</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">indicator</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
		<span class="cm">/* cycle marker */</span>
		<span class="k">case</span> <span class="n">INDICATOR_CYCLE</span>:
			<span class="n">cursor</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">selector</span> <span class="o">=</span> <span class="n">HUB_LED_AUTO</span><span class="p">;</span>
			<span class="n">mode</span> <span class="o">=</span> <span class="n">INDICATOR_AUTO</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* blinking green = sw attention */</span>
		<span class="k">case</span> <span class="n">INDICATOR_GREEN_BLINK</span>:
			<span class="n">selector</span> <span class="o">=</span> <span class="n">HUB_LED_GREEN</span><span class="p">;</span>
			<span class="n">mode</span> <span class="o">=</span> <span class="n">INDICATOR_GREEN_BLINK_OFF</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">INDICATOR_GREEN_BLINK_OFF</span>:
			<span class="n">selector</span> <span class="o">=</span> <span class="n">HUB_LED_OFF</span><span class="p">;</span>
			<span class="n">mode</span> <span class="o">=</span> <span class="n">INDICATOR_GREEN_BLINK</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* blinking amber = hw attention */</span>
		<span class="k">case</span> <span class="n">INDICATOR_AMBER_BLINK</span>:
			<span class="n">selector</span> <span class="o">=</span> <span class="n">HUB_LED_AMBER</span><span class="p">;</span>
			<span class="n">mode</span> <span class="o">=</span> <span class="n">INDICATOR_AMBER_BLINK_OFF</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">INDICATOR_AMBER_BLINK_OFF</span>:
			<span class="n">selector</span> <span class="o">=</span> <span class="n">HUB_LED_OFF</span><span class="p">;</span>
			<span class="n">mode</span> <span class="o">=</span> <span class="n">INDICATOR_AMBER_BLINK</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* blink green/amber = reserved */</span>
		<span class="k">case</span> <span class="n">INDICATOR_ALT_BLINK</span>:
			<span class="n">selector</span> <span class="o">=</span> <span class="n">HUB_LED_GREEN</span><span class="p">;</span>
			<span class="n">mode</span> <span class="o">=</span> <span class="n">INDICATOR_ALT_BLINK_OFF</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">INDICATOR_ALT_BLINK_OFF</span>:
			<span class="n">selector</span> <span class="o">=</span> <span class="n">HUB_LED_AMBER</span><span class="p">;</span>
			<span class="n">mode</span> <span class="o">=</span> <span class="n">INDICATOR_ALT_BLINK</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">selector</span> <span class="o">!=</span> <span class="n">HUB_LED_AUTO</span><span class="p">)</span>
			<span class="n">changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">set_port_led</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">selector</span><span class="p">);</span>
		<span class="n">hub</span><span class="o">-&gt;</span><span class="n">indicator</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">changed</span> <span class="o">&amp;&amp;</span> <span class="n">blinkenlights</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cursor</span><span class="o">++</span><span class="p">;</span>
		<span class="n">cursor</span> <span class="o">%=</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">bNbrPorts</span><span class="p">;</span>
		<span class="n">set_port_led</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">cursor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">HUB_LED_GREEN</span><span class="p">);</span>
		<span class="n">hub</span><span class="o">-&gt;</span><span class="n">indicator</span><span class="p">[</span><span class="n">cursor</span><span class="p">]</span> <span class="o">=</span> <span class="n">INDICATOR_CYCLE</span><span class="p">;</span>
		<span class="n">changed</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">changed</span><span class="p">)</span>
		<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">leds</span><span class="p">,</span> <span class="n">LED_CYCLE_PERIOD</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* use a short timeout for hub/port status fetches */</span>
<span class="cp">#define	USB_STS_TIMEOUT		1000</span>
<span class="cp">#define	USB_STS_RETRIES		5</span>

<span class="cm">/*</span>
<span class="cm"> * USB 2.0 spec Section 11.24.2.6</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_hub_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_hub_status</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">USB_STS_RETRIES</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ETIMEDOUT</span> <span class="o">||</span> <span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">usb_rcvctrlpipe</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
			<span class="n">USB_REQ_GET_STATUS</span><span class="p">,</span> <span class="n">USB_DIR_IN</span> <span class="o">|</span> <span class="n">USB_RT_HUB</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">),</span> <span class="n">USB_STS_TIMEOUT</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * USB 2.0 spec Section 11.24.2.7</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_port_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port1</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_port_status</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">USB_STS_RETRIES</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ETIMEDOUT</span> <span class="o">||</span> <span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">usb_rcvctrlpipe</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
			<span class="n">USB_REQ_GET_STATUS</span><span class="p">,</span> <span class="n">USB_DIR_IN</span> <span class="o">|</span> <span class="n">USB_RT_PORT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span>
			<span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">),</span> <span class="n">USB_STS_TIMEOUT</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hub_port_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port1</span><span class="p">,</span>
		<span class="n">u16</span> <span class="o">*</span><span class="n">status</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">change</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">status_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_port_status</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">status</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">,</span>
			<span class="s">&quot;%s failed (err = %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">status</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">wPortStatus</span><span class="p">);</span>
		<span class="o">*</span><span class="n">change</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">status</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">wPortChange</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">status_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kick_khubd</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub_event_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">disconnected</span> <span class="o">&amp;&amp;</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hub_event_list</span><span class="p">);</span>

		<span class="cm">/* Suppress autosuspend until khubd runs */</span>
		<span class="n">usb_autopm_get_interface_no_resume</span><span class="p">(</span>
				<span class="n">to_usb_interface</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">));</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khubd_wait</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub_event_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">usb_kick_khubd</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span> <span class="o">=</span> <span class="n">hdev_to_hub</span><span class="p">(</span><span class="n">hdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hub</span><span class="p">)</span>
		<span class="n">kick_khubd</span><span class="p">(</span><span class="n">hub</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Let the USB core know that a USB 3.0 device has sent a Function Wake Device</span>
<span class="cm"> * Notification, which indicates it had initiated remote wakeup.</span>
<span class="cm"> *</span>
<span class="cm"> * USB 3.0 hubs do not report the port link state change from U3 to U0 when the</span>
<span class="cm"> * device initiates resume, so the USB core will not receive notice of the</span>
<span class="cm"> * resume through the normal hub interrupt URB.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_wakeup_notification</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">portnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hdev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">hub</span> <span class="o">=</span> <span class="n">hdev_to_hub</span><span class="p">(</span><span class="n">hdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hub</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">portnum</span><span class="p">,</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">wakeup_bits</span><span class="p">);</span>
		<span class="n">kick_khubd</span><span class="p">(</span><span class="n">hub</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_wakeup_notification</span><span class="p">);</span>

<span class="cm">/* completion function, fires on port status changes and various faults */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hub_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bits</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ENOENT</span>:		<span class="cm">/* synchronous unlink */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ECONNRESET</span>:	<span class="cm">/* async unlink */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ESHUTDOWN</span>:	<span class="cm">/* hardware going away */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="nl">default:</span>		<span class="cm">/* presumably an error */</span>
		<span class="cm">/* Cause a hub reset after 10 consecutive errors */</span>
		<span class="n">dev_dbg</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">,</span> <span class="s">&quot;transfer --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">++</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">nerrors</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">||</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">resubmit</span><span class="p">;</span>
		<span class="n">hub</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
		<span class="cm">/* FALL THROUGH */</span>

	<span class="cm">/* let khubd handle things */</span>
	<span class="k">case</span> <span class="mi">0</span>:			<span class="cm">/* we got data:  port status changed */</span>
		<span class="n">bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">bits</span> <span class="o">|=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">((</span><span class="o">*</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">)[</span><span class="n">i</span><span class="p">]))</span>
					<span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span>
		<span class="n">hub</span><span class="o">-&gt;</span><span class="n">event_bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bits</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hub</span><span class="o">-&gt;</span><span class="n">nerrors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Something happened, let khubd figure it out */</span>
	<span class="n">kick_khubd</span><span class="p">(</span><span class="n">hub</span><span class="p">);</span>

<span class="nl">resubmit:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">quiescing</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">=</span> <span class="n">usb_submit_urb</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span>
			<span class="o">&amp;&amp;</span> <span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENODEV</span> <span class="o">&amp;&amp;</span> <span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">)</span>
		<span class="n">dev_err</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">,</span> <span class="s">&quot;resubmit --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* USB 2.0 spec Section 11.24.2.3 */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">hub_clear_tt_buffer</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">devinfo</span><span class="p">,</span> <span class="n">u16</span> <span class="n">tt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
			       <span class="n">HUB_CLEAR_TT_BUFFER</span><span class="p">,</span> <span class="n">USB_RT_PORT</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">,</span>
			       <span class="n">tt</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * enumeration blocks khubd for a long time. we use keventd instead, since</span>
<span class="cm"> * long blocking there is the exception, not the rule.  accordingly, HCDs</span>
<span class="cm"> * talking to TTs must queue control transfers (not just bulk and iso), so</span>
<span class="cm"> * both can talk to the same hub concurrently.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hub_tt_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hub</span>		<span class="o">*</span><span class="n">hub</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_hub</span><span class="p">,</span> <span class="n">tt</span><span class="p">.</span><span class="n">clear_work</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">limit</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">limit</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">clear_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">next</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">usb_tt_clear</span>	<span class="o">*</span><span class="n">clear</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">hdev</span> <span class="o">=</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">;</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">hc_driver</span>	<span class="o">*</span><span class="n">drv</span><span class="p">;</span>
		<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>

		<span class="n">next</span> <span class="o">=</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">clear_list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
		<span class="n">clear</span> <span class="o">=</span> <span class="n">list_entry</span> <span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_tt_clear</span><span class="p">,</span> <span class="n">clear_list</span><span class="p">);</span>
		<span class="n">list_del</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">clear</span><span class="o">-&gt;</span><span class="n">clear_list</span><span class="p">);</span>

		<span class="cm">/* drop lock so HCD can concurrently report other TT errors */</span>
		<span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">hub_clear_tt_buffer</span> <span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">clear</span><span class="o">-&gt;</span><span class="n">devinfo</span><span class="p">,</span> <span class="n">clear</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">dev_err</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;clear tt %d (%04x) error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">clear</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">,</span> <span class="n">clear</span><span class="o">-&gt;</span><span class="n">devinfo</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

		<span class="cm">/* Tell the HCD, even if the operation failed */</span>
		<span class="n">drv</span> <span class="o">=</span> <span class="n">clear</span><span class="o">-&gt;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">clear_tt_buffer_complete</span><span class="p">)</span>
			<span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">clear_tt_buffer_complete</span><span class="p">)(</span><span class="n">clear</span><span class="o">-&gt;</span><span class="n">hcd</span><span class="p">,</span> <span class="n">clear</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">);</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">clear</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_hub_clear_tt_buffer - clear control/bulk TT state in high speed hub</span>
<span class="cm"> * @urb: an URB associated with the failed or incomplete split transaction</span>
<span class="cm"> *</span>
<span class="cm"> * High speed HCDs use this to tell the hub driver that some split control or</span>
<span class="cm"> * bulk transaction failed in a way that requires clearing internal state of</span>
<span class="cm"> * a transaction translator.  This is normally detected (and reported) from</span>
<span class="cm"> * interrupt context.</span>
<span class="cm"> *</span>
<span class="cm"> * It may not be possible for that hub to handle additional full (or low)</span>
<span class="cm"> * speed transactions until that state is fully cleared out.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_hub_clear_tt_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">pipe</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_tt</span>		<span class="o">*</span><span class="n">tt</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_tt_clear</span>	<span class="o">*</span><span class="n">clear</span><span class="p">;</span>

	<span class="cm">/* we&#39;ve got to cope with an arbitrary number of pending TT clears,</span>
<span class="cm">	 * since each TT has &quot;at least two&quot; buffers that can need it (and</span>
<span class="cm">	 * there can be many TTs per hub).  even if they&#39;re uncommon.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">clear</span> <span class="o">=</span> <span class="n">kmalloc</span> <span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">clear</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t save CLEAR_TT_BUFFER state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* FIXME recover somehow ... RESET_TT? */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* info that CLEAR_TT_BUFFER needs */</span>
	<span class="n">clear</span><span class="o">-&gt;</span><span class="n">tt</span> <span class="o">=</span> <span class="n">tt</span><span class="o">-&gt;</span><span class="n">multi</span> <span class="o">?</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">ttport</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">clear</span><span class="o">-&gt;</span><span class="n">devinfo</span> <span class="o">=</span> <span class="n">usb_pipeendpoint</span> <span class="p">(</span><span class="n">pipe</span><span class="p">);</span>
	<span class="n">clear</span><span class="o">-&gt;</span><span class="n">devinfo</span> <span class="o">|=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">clear</span><span class="o">-&gt;</span><span class="n">devinfo</span> <span class="o">|=</span> <span class="n">usb_pipecontrol</span> <span class="p">(</span><span class="n">pipe</span><span class="p">)</span>
			<span class="o">?</span> <span class="p">(</span><span class="n">USB_ENDPOINT_XFER_CONTROL</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">)</span>
			<span class="o">:</span> <span class="p">(</span><span class="n">USB_ENDPOINT_XFER_BULK</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipein</span> <span class="p">(</span><span class="n">pipe</span><span class="p">))</span>
		<span class="n">clear</span><span class="o">-&gt;</span><span class="n">devinfo</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">;</span>

	<span class="cm">/* info for completion callback */</span>
	<span class="n">clear</span><span class="o">-&gt;</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="n">clear</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>

	<span class="cm">/* tell keventd to clear state for this TT */</span>
	<span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add_tail</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">clear</span><span class="o">-&gt;</span><span class="n">clear_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">clear_list</span><span class="p">);</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">clear_work</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_hub_clear_tt_buffer</span><span class="p">);</span>

<span class="cm">/* If do_delay is false, return the number of milliseconds the caller</span>
<span class="cm"> * needs to delay.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">hub_power_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">,</span> <span class="n">bool</span> <span class="n">do_delay</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">port1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">pgood_delay</span> <span class="o">=</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">bPwrOn2PwrGood</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">delay</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">wHubCharacteristics</span> <span class="o">=</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">wHubCharacteristics</span><span class="p">);</span>

	<span class="cm">/* Enable power on each port.  Some hubs have reserved values</span>
<span class="cm">	 * of LPSM (&gt; 2) in their descriptors, even though they are</span>
<span class="cm">	 * USB 2.0 hubs.  Some hubs do not implement port-power switching</span>
<span class="cm">	 * but only emulate it.  In all cases, the ports won&#39;t work</span>
<span class="cm">	 * unless we send these messages to the hub.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">wHubCharacteristics</span> <span class="o">&amp;</span> <span class="n">HUB_CHAR_LPSM</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">,</span> <span class="s">&quot;enabling power on all ports</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">,</span> <span class="s">&quot;trying to enable port power on &quot;</span>
				<span class="s">&quot;non-switchable hub</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">port1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">port1</span> <span class="o">&lt;=</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">bNbrPorts</span><span class="p">;</span> <span class="n">port1</span><span class="o">++</span><span class="p">)</span>
		<span class="n">set_port_feature</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="n">USB_PORT_FEAT_POWER</span><span class="p">);</span>

	<span class="cm">/* Wait at least 100 msec for power to become stable */</span>
	<span class="n">delay</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">pgood_delay</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="mi">100</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">do_delay</span><span class="p">)</span>
		<span class="n">msleep</span><span class="p">(</span><span class="n">delay</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">delay</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hub_hub_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">,</span>
		<span class="n">u16</span> <span class="o">*</span><span class="n">status</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">change</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">status_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_hub_status</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">status</span><span class="o">-&gt;</span><span class="n">hub</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev_err</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">,</span>
			<span class="s">&quot;%s failed (err = %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">status</span><span class="o">-&gt;</span><span class="n">hub</span><span class="p">.</span><span class="n">wHubStatus</span><span class="p">);</span>
		<span class="o">*</span><span class="n">change</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">status</span><span class="o">-&gt;</span><span class="n">hub</span><span class="p">.</span><span class="n">wHubChange</span><span class="p">);</span> 
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">status_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hub_port_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span> <span class="o">=</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">port1</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">set_state</span><span class="p">)</span>
		<span class="n">usb_set_device_state</span><span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">port1</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
				<span class="n">USB_STATE_NOTATTACHED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hub_is_superspeed</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">clear_port_feature</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="n">USB_PORT_FEAT_ENABLE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">,</span> <span class="s">&quot;cannot disable port %d (err = %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">port1</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Disable a port and mark a logical connect-change event, so that some</span>
<span class="cm"> * time later khubd will disconnect() any existing usb_device on the port</span>
<span class="cm"> * and will re-enumerate if there actually is a device attached.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hub_port_logical_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">,</span> <span class="s">&quot;logical disconnect on port %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port1</span><span class="p">);</span>
	<span class="n">hub_port_disable</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* FIXME let caller ask to power down the port:</span>
<span class="cm">	 *  - some devices won&#39;t enumerate without a VBUS power cycle</span>
<span class="cm">	 *  - SRP saves power that way</span>
<span class="cm">	 *  - ... new call, TBD ...</span>
<span class="cm">	 * That&#39;s easy if this hub can switch power per-port, and</span>
<span class="cm">	 * khubd reactivates the port later (timer, SRP, etc).</span>
<span class="cm">	 * Powerdown must be optional, because of reset/DFU.</span>
<span class="cm">	 */</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">port1</span><span class="p">,</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">change_bits</span><span class="p">);</span>
 	<span class="n">kick_khubd</span><span class="p">(</span><span class="n">hub</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_remove_device - disable a device&#39;s port on its parent hub</span>
<span class="cm"> * @udev: device to be disabled and removed</span>
<span class="cm"> * Context: @udev locked, must be able to sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * After @udev&#39;s port has been disabled, khubd is notified and it will</span>
<span class="cm"> * see that the device has been disconnected.  When the device is</span>
<span class="cm"> * physically unplugged and something is plugged in, the events will</span>
<span class="cm"> * be received and processed normally.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_remove_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>	<span class="cm">/* Can&#39;t remove a root hub */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">hub</span> <span class="o">=</span> <span class="n">hdev_to_hub</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">intf</span> <span class="o">=</span> <span class="n">to_usb_interface</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">);</span>

	<span class="n">usb_autopm_get_interface</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">portnum</span><span class="p">,</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">removed_bits</span><span class="p">);</span>
	<span class="n">hub_port_logical_disconnect</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">portnum</span><span class="p">);</span>
	<span class="n">usb_autopm_put_interface</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">hub_activation_type</span> <span class="p">{</span>
	<span class="n">HUB_INIT</span><span class="p">,</span> <span class="n">HUB_INIT2</span><span class="p">,</span> <span class="n">HUB_INIT3</span><span class="p">,</span>		<span class="cm">/* INITs must come first */</span>
	<span class="n">HUB_POST_RESET</span><span class="p">,</span> <span class="n">HUB_RESUME</span><span class="p">,</span> <span class="n">HUB_RESET_RESUME</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">hub_init_func2</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">ws</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hub_init_func3</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">ws</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hub_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">,</span> <span class="k">enum</span> <span class="n">hub_activation_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span> <span class="o">=</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">port1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">need_debounce_delay</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">delay</span><span class="p">;</span>

	<span class="cm">/* Continue a partial initialization */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">HUB_INIT2</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">init2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">HUB_INIT3</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">init3</span><span class="p">;</span>

	<span class="cm">/* The superspeed hub except for root hub has to use Hub Depth</span>
<span class="cm">	 * value as an offset into the route string to locate the bits</span>
<span class="cm">	 * it uses to determine the downstream port number. So hub driver</span>
<span class="cm">	 * should send a set hub depth request to superspeed hub after</span>
<span class="cm">	 * the superspeed hub is set configuration in initialization or</span>
<span class="cm">	 * reset procedure.</span>
<span class="cm">	 *</span>
<span class="cm">	 * After a resume, port power should still be on.</span>
<span class="cm">	 * For any other type of activation, turn it on.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">HUB_RESUME</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">&amp;&amp;</span> <span class="n">hub_is_superspeed</span><span class="p">(</span><span class="n">hdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
					<span class="n">HUB_SET_DEPTH</span><span class="p">,</span> <span class="n">USB_RT_HUB</span><span class="p">,</span>
					<span class="n">hdev</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">USB_CTRL_SET_TIMEOUT</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">,</span>
						<span class="s">&quot;set hub depth failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Speed up system boot by using a delayed_work for the</span>
<span class="cm">		 * hub&#39;s initial power-up delays.  This is pretty awkward</span>
<span class="cm">		 * and the implementation looks like a home-brewed sort of</span>
<span class="cm">		 * setjmp/longjmp, but it saves at least 100 ms for each</span>
<span class="cm">		 * root hub (assuming usbcore is compiled into the kernel</span>
<span class="cm">		 * rather than as a module).  It adds up.</span>
<span class="cm">		 *</span>
<span class="cm">		 * This can&#39;t be done for HUB_RESUME or HUB_RESET_RESUME</span>
<span class="cm">		 * because for those activation types the ports have to be</span>
<span class="cm">		 * operational when we return.  In theory this could be done</span>
<span class="cm">		 * for HUB_POST_RESET, but it&#39;s easier not to.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">HUB_INIT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">delay</span> <span class="o">=</span> <span class="n">hub_power_on</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
			<span class="n">PREPARE_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">init_work</span><span class="p">,</span> <span class="n">hub_init_func2</span><span class="p">);</span>
			<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">init_work</span><span class="p">,</span>
					<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">delay</span><span class="p">));</span>

			<span class="cm">/* Suppress autosuspend until init is done */</span>
			<span class="n">usb_autopm_get_interface_no_resume</span><span class="p">(</span>
					<span class="n">to_usb_interface</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">));</span>
			<span class="k">return</span><span class="p">;</span>		<span class="cm">/* Continues at init2: below */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">HUB_RESET_RESUME</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* The internal host controller state for the hub device</span>
<span class="cm">			 * may be gone after a host power loss on system resume.</span>
<span class="cm">			 * Update the device&#39;s info so the HW knows it&#39;s a hub.</span>
<span class="cm">			 */</span>
			<span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">update_hub_device</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">update_hub_device</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">hdev</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">dev_err</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">,</span> <span class="s">&quot;Host not &quot;</span>
							<span class="s">&quot;accepting hub info &quot;</span>
							<span class="s">&quot;update.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="n">dev_err</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">,</span> <span class="s">&quot;LS/FS devices &quot;</span>
							<span class="s">&quot;and hubs may not work &quot;</span>
							<span class="s">&quot;under this hub</span><span class="se">\n</span><span class="s">.&quot;</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">hub_power_on</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">hub_power_on</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
 <span class="nl">init2:</span>

	<span class="cm">/* Check each port and set hub-&gt;change_bits to let khubd know</span>
<span class="cm">	 * which ports need attention.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">port1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">port1</span> <span class="o">&lt;=</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">maxchild</span><span class="p">;</span> <span class="o">++</span><span class="n">port1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">port1</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">u16</span> <span class="n">portstatus</span><span class="p">,</span> <span class="n">portchange</span><span class="p">;</span>

		<span class="n">portstatus</span> <span class="o">=</span> <span class="n">portchange</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">hub_port_status</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portstatus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portchange</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udev</span> <span class="o">||</span> <span class="p">(</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_CONNECTION</span><span class="p">))</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">,</span>
					<span class="s">&quot;port %d: status %04x change %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">port1</span><span class="p">,</span> <span class="n">portstatus</span><span class="p">,</span> <span class="n">portchange</span><span class="p">);</span>

		<span class="cm">/* After anything other than HUB_RESUME (i.e., initialization</span>
<span class="cm">		 * or any sort of reset), every port should be disabled.</span>
<span class="cm">		 * Unconnected ports should likewise be disabled (paranoia),</span>
<span class="cm">		 * and so should ports for which we have no usb_device.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_ENABLE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span>
				<span class="n">type</span> <span class="o">!=</span> <span class="n">HUB_RESUME</span> <span class="o">||</span>
				<span class="o">!</span><span class="p">(</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_CONNECTION</span><span class="p">)</span> <span class="o">||</span>
				<span class="o">!</span><span class="n">udev</span> <span class="o">||</span>
				<span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_NOTATTACHED</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * USB3 protocol ports will automatically transition</span>
<span class="cm">			 * to Enabled state when detect an USB3.0 device attach.</span>
<span class="cm">			 * Do not disable USB3 protocol ports.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hub_is_superspeed</span><span class="p">(</span><span class="n">hdev</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">clear_port_feature</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span>
						   <span class="n">USB_PORT_FEAT_ENABLE</span><span class="p">);</span>
				<span class="n">portstatus</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">USB_PORT_STAT_ENABLE</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Pretend that power was lost for USB3 devs */</span>
				<span class="n">portstatus</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">USB_PORT_STAT_ENABLE</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Clear status-change flags; we&#39;ll debounce later */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">portchange</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_C_CONNECTION</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">need_debounce_delay</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">clear_port_feature</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span>
					<span class="n">USB_PORT_FEAT_C_CONNECTION</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">portchange</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_C_ENABLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">need_debounce_delay</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">clear_port_feature</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span>
					<span class="n">USB_PORT_FEAT_C_ENABLE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">portchange</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_C_BH_RESET</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="n">hub_is_superspeed</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">need_debounce_delay</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">clear_port_feature</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span>
					<span class="n">USB_PORT_FEAT_C_BH_PORT_RESET</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* We can forget about a &quot;removed&quot; device when there&#39;s a</span>
<span class="cm">		 * physical disconnect or the connect status changes.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_CONNECTION</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">portchange</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_C_CONNECTION</span><span class="p">))</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">port1</span><span class="p">,</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">removed_bits</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udev</span> <span class="o">||</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_NOTATTACHED</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Tell khubd to disconnect the device or</span>
<span class="cm">			 * check for a new connection</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">udev</span> <span class="o">||</span> <span class="p">(</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_CONNECTION</span><span class="p">))</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">port1</span><span class="p">,</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">change_bits</span><span class="p">);</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_ENABLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bool</span> <span class="n">port_resumed</span> <span class="o">=</span> <span class="p">(</span><span class="n">portstatus</span> <span class="o">&amp;</span>
					<span class="n">USB_PORT_STAT_LINK_STATE</span><span class="p">)</span> <span class="o">==</span>
				<span class="n">USB_SS_PORT_LS_U0</span><span class="p">;</span>
			<span class="cm">/* The power session apparently survived the resume.</span>
<span class="cm">			 * If there was an overcurrent or suspend change</span>
<span class="cm">			 * (i.e., remote wakeup request), have khubd</span>
<span class="cm">			 * take care of it.  Look at the port link state</span>
<span class="cm">			 * for USB 3.0 hubs, since they don&#39;t have a suspend</span>
<span class="cm">			 * change bit, and they don&#39;t set the port link change</span>
<span class="cm">			 * bit on device-initiated resume.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">portchange</span> <span class="o">||</span> <span class="p">(</span><span class="n">hub_is_superspeed</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
						<span class="n">port_resumed</span><span class="p">))</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">port1</span><span class="p">,</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">change_bits</span><span class="p">);</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">persist_enabled</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_PM</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">reset_resume</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">port1</span><span class="p">,</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">change_bits</span><span class="p">);</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* The power session is gone; tell khubd */</span>
			<span class="n">usb_set_device_state</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">USB_STATE_NOTATTACHED</span><span class="p">);</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">port1</span><span class="p">,</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">change_bits</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* If no port-status-change flags were set, we don&#39;t need any</span>
<span class="cm">	 * debouncing.  If flags were set we can try to debounce the</span>
<span class="cm">	 * ports all at once right now, instead of letting khubd do them</span>
<span class="cm">	 * one at a time later on.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If any port-status changes do occur during this delay, khubd</span>
<span class="cm">	 * will see them later and handle them normally.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_debounce_delay</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">delay</span> <span class="o">=</span> <span class="n">HUB_DEBOUNCE_STABLE</span><span class="p">;</span>

		<span class="cm">/* Don&#39;t do a long sleep inside a workqueue routine */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">HUB_INIT2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">PREPARE_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">init_work</span><span class="p">,</span> <span class="n">hub_init_func3</span><span class="p">);</span>
			<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">init_work</span><span class="p">,</span>
					<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">delay</span><span class="p">));</span>
			<span class="k">return</span><span class="p">;</span>		<span class="cm">/* Continues at init3: below */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">msleep</span><span class="p">(</span><span class="n">delay</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
 <span class="nl">init3:</span>
	<span class="n">hub</span><span class="o">-&gt;</span><span class="n">quiescing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">,</span> <span class="s">&quot;activate --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">has_indicators</span> <span class="o">&amp;&amp;</span> <span class="n">blinkenlights</span><span class="p">)</span>
		<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">leds</span><span class="p">,</span> <span class="n">LED_CYCLE_PERIOD</span><span class="p">);</span>

	<span class="cm">/* Scan all ports that need attention */</span>
	<span class="n">kick_khubd</span><span class="p">(</span><span class="n">hub</span><span class="p">);</span>

	<span class="cm">/* Allow autosuspend if it was suppressed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&lt;=</span> <span class="n">HUB_INIT3</span><span class="p">)</span>
		<span class="n">usb_autopm_put_interface_async</span><span class="p">(</span><span class="n">to_usb_interface</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Implement the continuations for the delays above */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hub_init_func2</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">ws</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_hub</span><span class="p">,</span> <span class="n">init_work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>

	<span class="n">hub_activate</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">HUB_INIT2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hub_init_func3</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">ws</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_hub</span><span class="p">,</span> <span class="n">init_work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>

	<span class="n">hub_activate</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">HUB_INIT3</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">hub_quiescing_type</span> <span class="p">{</span>
	<span class="n">HUB_DISCONNECT</span><span class="p">,</span> <span class="n">HUB_PRE_RESET</span><span class="p">,</span> <span class="n">HUB_SUSPEND</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hub_quiesce</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">,</span> <span class="k">enum</span> <span class="n">hub_quiescing_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span> <span class="o">=</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">init_work</span><span class="p">);</span>

	<span class="cm">/* khubd and related activity won&#39;t re-trigger */</span>
	<span class="n">hub</span><span class="o">-&gt;</span><span class="n">quiescing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">HUB_SUSPEND</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Disconnect all the children */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">maxchild</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="n">usb_disconnect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Stop khubd and related activity */</span>
	<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">has_indicators</span><span class="p">)</span>
		<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">leds</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">hub</span><span class="p">)</span>
		<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">clear_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* caller has locked the hub device */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hub_pre_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="n">hub_quiesce</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">HUB_PRE_RESET</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* caller has locked the hub device */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hub_post_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="n">hub_activate</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">HUB_POST_RESET</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hub_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">endpoint</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span> <span class="o">=</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">hub_dev</span> <span class="o">=</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">hubstatus</span><span class="p">,</span> <span class="n">hubchange</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">wHubCharacteristics</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maxp</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">message</span> <span class="o">=</span> <span class="s">&quot;out of memory&quot;</span><span class="p">;</span>

	<span class="n">hub</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hub</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">status_mutex</span><span class="p">);</span>

	<span class="n">hub</span><span class="o">-&gt;</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Request the entire hub descriptor.</span>
<span class="cm">	 * hub-&gt;descriptor can handle USB_MAXCHILDREN ports,</span>
<span class="cm">	 * but the hub can/will return fewer bytes here.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_hub_descriptor</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">message</span> <span class="o">=</span> <span class="s">&quot;can&#39;t read hub descriptor&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">bNbrPorts</span> <span class="o">&gt;</span> <span class="n">USB_MAXCHILDREN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">message</span> <span class="o">=</span> <span class="s">&quot;hub has too many ports!&quot;</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hdev</span><span class="o">-&gt;</span><span class="n">maxchild</span> <span class="o">=</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">bNbrPorts</span><span class="p">;</span>
	<span class="n">dev_info</span> <span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;%d port%s detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">maxchild</span><span class="p">,</span>
		<span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">maxchild</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;s&quot;</span><span class="p">);</span>

	<span class="n">hdev</span><span class="o">-&gt;</span><span class="n">children</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">maxchild</span> <span class="o">*</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">hub</span><span class="o">-&gt;</span><span class="n">port_owners</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">maxchild</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">children</span> <span class="o">||</span> <span class="o">!</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">port_owners</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">wHubCharacteristics</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">wHubCharacteristics</span><span class="p">);</span>

	<span class="cm">/* FIXME for USB 3.0, skip for now */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">wHubCharacteristics</span> <span class="o">&amp;</span> <span class="n">HUB_CHAR_COMPOUND</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="p">(</span><span class="n">hub_is_superspeed</span><span class="p">(</span><span class="n">hdev</span><span class="p">)))</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>
		<span class="kt">char</span>	<span class="n">portstr</span> <span class="p">[</span><span class="n">USB_MAXCHILDREN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">maxchild</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">portstr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hs</span><span class="p">.</span><span class="n">DeviceRemovable</span>
				    <span class="p">[((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">8</span><span class="p">))</span>
				<span class="o">?</span> <span class="sc">&#39;F&#39;</span> <span class="o">:</span> <span class="sc">&#39;R&#39;</span><span class="p">;</span>
		<span class="n">portstr</span><span class="p">[</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">maxchild</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;compound device; port removable status: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">portstr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;standalone hub</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">wHubCharacteristics</span> <span class="o">&amp;</span> <span class="n">HUB_CHAR_LPSM</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HUB_CHAR_COMMON_LPSM</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;ganged power switching</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HUB_CHAR_INDV_PORT_LPSM</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;individual port power switching</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HUB_CHAR_NO_LPSM</span>:
	<span class="k">case</span> <span class="n">HUB_CHAR_LPSM</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;no power switching (usb 1.0)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">wHubCharacteristics</span> <span class="o">&amp;</span> <span class="n">HUB_CHAR_OCPM</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HUB_CHAR_COMMON_OCPM</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;global over-current protection</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HUB_CHAR_INDV_PORT_OCPM</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;individual port over-current protection</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HUB_CHAR_NO_OCPM</span>:
	<span class="k">case</span> <span class="n">HUB_CHAR_OCPM</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;no over-current protection</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">clear_list</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">clear_work</span><span class="p">,</span> <span class="n">hub_tt_work</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bDeviceProtocol</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_HUB_PR_FS</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_HUB_PR_HS_SINGLE_TT</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;Single TT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">hub</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">hub</span> <span class="o">=</span> <span class="n">hdev</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_HUB_PR_HS_MULTI_TT</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_set_interface</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;TT per port</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">hub</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">multi</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;Using single TT (err %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ret</span><span class="p">);</span>
		<span class="n">hub</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">hub</span> <span class="o">=</span> <span class="n">hdev</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_HUB_PR_SS</span>:
		<span class="cm">/* USB 3.0 hubs don&#39;t have a TT */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;Unrecognized hub protocol %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">hdev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bDeviceProtocol</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Note 8 FS bit times == (8 bits / 12000000 bps) ~= 666ns */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">wHubCharacteristics</span> <span class="o">&amp;</span> <span class="n">HUB_CHAR_TTTT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">HUB_TTTT_8_BITS</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bDeviceProtocol</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">hub</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">think_time</span> <span class="o">=</span> <span class="mi">666</span><span class="p">;</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;TT requires at most %d &quot;</span>
						<span class="s">&quot;FS bit times (%d ns)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="mi">8</span><span class="p">,</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">think_time</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">HUB_TTTT_16_BITS</span>:
			<span class="n">hub</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">think_time</span> <span class="o">=</span> <span class="mi">666</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;TT requires at most %d &quot;</span>
					<span class="s">&quot;FS bit times (%d ns)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="mi">16</span><span class="p">,</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">think_time</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">HUB_TTTT_24_BITS</span>:
			<span class="n">hub</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">think_time</span> <span class="o">=</span> <span class="mi">666</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;TT requires at most %d &quot;</span>
					<span class="s">&quot;FS bit times (%d ns)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="mi">24</span><span class="p">,</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">think_time</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">HUB_TTTT_32_BITS</span>:
			<span class="n">hub</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">think_time</span> <span class="o">=</span> <span class="mi">666</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;TT requires at most %d &quot;</span>
					<span class="s">&quot;FS bit times (%d ns)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="mi">32</span><span class="p">,</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">think_time</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* probe() zeroes hub-&gt;indicator[] */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wHubCharacteristics</span> <span class="o">&amp;</span> <span class="n">HUB_CHAR_PORTIND</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hub</span><span class="o">-&gt;</span><span class="n">has_indicators</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;Port indicators are supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;power on to power good time: %dms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">hub</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">bPwrOn2PwrGood</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>

	<span class="cm">/* power budgeting mostly matters with bus-powered hubs,</span>
<span class="cm">	 * and battery-powered root hubs (may provide just 8 mA).</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_get_status</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">USB_RECIP_DEVICE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hubstatus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">message</span> <span class="o">=</span> <span class="s">&quot;can&#39;t get hub status&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">le16_to_cpus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hubstatus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hdev</span> <span class="o">==</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">root_hub</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">bus_mA</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">bus_mA</span> <span class="o">&gt;=</span> <span class="mi">500</span><span class="p">)</span>
			<span class="n">hub</span><span class="o">-&gt;</span><span class="n">mA_per_port</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">hub</span><span class="o">-&gt;</span><span class="n">mA_per_port</span> <span class="o">=</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">bus_mA</span><span class="p">;</span>
			<span class="n">hub</span><span class="o">-&gt;</span><span class="n">limited_power</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">hubstatus</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USB_DEVICE_SELF_POWERED</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;hub controller current requirement: %dmA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">hub</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">bHubContrCurrent</span><span class="p">);</span>
		<span class="n">hub</span><span class="o">-&gt;</span><span class="n">limited_power</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">maxchild</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">remaining</span> <span class="o">=</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">bus_mA</span> <span class="o">-</span>
					<span class="n">hub</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">bHubContrCurrent</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">remaining</span> <span class="o">&lt;</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">maxchild</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
				<span class="n">dev_warn</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span>
					<span class="s">&quot;insufficient power available &quot;</span>
					<span class="s">&quot;to use all downstream ports</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">hub</span><span class="o">-&gt;</span><span class="n">mA_per_port</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>		<span class="cm">/* 7.2.1.1 */</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* Self-powered external hub */</span>
		<span class="cm">/* FIXME: What about battery-powered external hubs that</span>
<span class="cm">		 * provide less current per port? */</span>
		<span class="n">hub</span><span class="o">-&gt;</span><span class="n">mA_per_port</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">mA_per_port</span> <span class="o">&lt;</span> <span class="mi">500</span><span class="p">)</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;%umA bus power budget for each child</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">hub</span><span class="o">-&gt;</span><span class="n">mA_per_port</span><span class="p">);</span>

	<span class="cm">/* Update the HCD&#39;s internal representation of this hub before khubd</span>
<span class="cm">	 * starts getting port status changes for devices under the hub.</span>
<span class="cm">	 */</span>
	<span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">update_hub_device</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">update_hub_device</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">hdev</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">message</span> <span class="o">=</span> <span class="s">&quot;can&#39;t update HCD hub info&quot;</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">hub_hub_status</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hubstatus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hubchange</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">message</span> <span class="o">=</span> <span class="s">&quot;can&#39;t get hub status&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* local power status reports aren&#39;t always correct */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bmAttributes</span> <span class="o">&amp;</span> <span class="n">USB_CONFIG_ATT_SELFPOWER</span><span class="p">)</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;local power source is %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">hubstatus</span> <span class="o">&amp;</span> <span class="n">HUB_STATUS_LOCAL_POWER</span><span class="p">)</span>
			<span class="o">?</span> <span class="s">&quot;lost (inactive)&quot;</span> <span class="o">:</span> <span class="s">&quot;good&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">wHubCharacteristics</span> <span class="o">&amp;</span> <span class="n">HUB_CHAR_OCPM</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;%sover-current condition exists</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">hubstatus</span> <span class="o">&amp;</span> <span class="n">HUB_STATUS_OVERCURRENT</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;no &quot;</span><span class="p">);</span>

	<span class="cm">/* set up the interrupt endpoint</span>
<span class="cm">	 * We use the EP&#39;s maxpacket size instead of (PORTS+1+7)/8</span>
<span class="cm">	 * bytes as USB2.0[11.12.3] says because some hubs are known</span>
<span class="cm">	 * to send more data (and thus cause overflow). For root hubs,</span>
<span class="cm">	 * maxpktsize is defined in hcd.c&#39;s fake endpoint descriptors</span>
<span class="cm">	 * to be big enough for at least USB_MAXCHILDREN ports. */</span>
	<span class="n">pipe</span> <span class="o">=</span> <span class="n">usb_rcvintpipe</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span><span class="p">);</span>
	<span class="n">maxp</span> <span class="o">=</span> <span class="n">usb_maxpacket</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">usb_pipeout</span><span class="p">(</span><span class="n">pipe</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">maxp</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">))</span>
		<span class="n">maxp</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>

	<span class="n">hub</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">usb_fill_int_urb</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">,</span> <span class="n">hdev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="o">*</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">maxp</span><span class="p">,</span> <span class="n">hub_irq</span><span class="p">,</span>
		<span class="n">hub</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">-&gt;</span><span class="n">bInterval</span><span class="p">);</span>

	<span class="cm">/* maybe cycle the hub leds */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">has_indicators</span> <span class="o">&amp;&amp;</span> <span class="n">blinkenlights</span><span class="p">)</span>
		<span class="n">hub</span><span class="o">-&gt;</span><span class="n">indicator</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">INDICATOR_CYCLE</span><span class="p">;</span>

	<span class="n">hub_activate</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">HUB_INIT</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">dev_err</span> <span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;config failed, %s (err %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">message</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="cm">/* hub_disconnect() frees urb and descriptor */</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hub_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_hub</span><span class="p">,</span> <span class="n">kref</span><span class="p">);</span>

	<span class="n">usb_put_intf</span><span class="p">(</span><span class="n">to_usb_interface</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">));</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hub</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">highspeed_hubs</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hub_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="cm">/* Take the hub off the event list and don&#39;t let it be added again */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub_event_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">);</span>
		<span class="n">usb_autopm_put_interface_no_suspend</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">hub</span><span class="o">-&gt;</span><span class="n">disconnected</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub_event_lock</span><span class="p">);</span>

	<span class="cm">/* Disconnect all children and quiesce the hub */</span>
	<span class="n">hub</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hub_quiesce</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">HUB_DISCONNECT</span><span class="p">);</span>

	<span class="n">usb_set_intfdata</span> <span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">maxchild</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span>
		<span class="n">highspeed_hubs</span><span class="o">--</span><span class="p">;</span>

	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">port_owners</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>

	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="n">hub_release</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hub_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">endpoint</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">;</span>

	<span class="n">desc</span> <span class="o">=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="p">;</span>
	<span class="n">hdev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="cm">/* Hubs have proper suspend/resume support. */</span>
	<span class="n">usb_enable_autosuspend</span><span class="p">(</span><span class="n">hdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">==</span> <span class="n">MAX_TOPO_LEVEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Unsupported bus topology: hub nested too deep</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef	CONFIG_USB_OTG_BLACKLIST_HUB</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ignoring external hub</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* Some hubs have a subclass of 1, which AFAICT according to the */</span>
	<span class="cm">/*  specs is not defined, but it works */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceSubClass</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceSubClass</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
<span class="nl">descriptor_error:</span>
		<span class="n">dev_err</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;bad descriptor, ignoring hub</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Multiple endpoints? What kind of mutant ninja-hub is this? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumEndpoints</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">descriptor_error</span><span class="p">;</span>

	<span class="n">endpoint</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">desc</span><span class="p">;</span>

	<span class="cm">/* If it&#39;s not an interrupt in endpoint, we&#39;d better punt! */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usb_endpoint_is_int_in</span><span class="p">(</span><span class="n">endpoint</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">descriptor_error</span><span class="p">;</span>

	<span class="cm">/* We found a hub */</span>
	<span class="n">dev_info</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;USB hub found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">hub</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hub</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hub</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;couldn&#39;t kmalloc hub struct</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">);</span>
	<span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span> <span class="o">=</span> <span class="n">hdev</span><span class="p">;</span>
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">leds</span><span class="p">,</span> <span class="n">led_work</span><span class="p">);</span>
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">init_work</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">usb_get_intf</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="n">usb_set_intfdata</span> <span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">hub</span><span class="p">);</span>
	<span class="n">intf</span><span class="o">-&gt;</span><span class="n">needs_remote_wakeup</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span>
		<span class="n">highspeed_hubs</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hub_configure</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">endpoint</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hub_disconnect</span> <span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">hub_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">code</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span> <span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="cm">/* assert ifno == 0 (part of hub spec) */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USBDEVFS_HUB_PORTINFO</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usbdevfs_hub_portinfo</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">user_data</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_state_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">nports</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">nports</span> <span class="o">=</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">maxchild</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
					<span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
						<span class="n">hdev</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_state_lock</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nports</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allow user programs to claim ports on a hub.  When a device is attached</span>
<span class="cm"> * to one of these &quot;claimed&quot; ports, the program will &quot;own&quot; the device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_port_owner</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">port1</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">***</span><span class="n">ppowner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_NOTATTACHED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port1</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">port1</span> <span class="o">&gt;</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">maxchild</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* This assumes that devices not managed by the hub driver</span>
<span class="cm">	 * will always have maxchild equal to 0.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">ppowner</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">hdev_to_hub</span><span class="p">(</span><span class="n">hdev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">port_owners</span><span class="p">[</span><span class="n">port1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* In the following three functions, the caller must hold hdev&#39;s lock */</span>
<span class="kt">int</span> <span class="nf">usb_hub_claim_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">port1</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">owner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">powner</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">find_port_owner</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">powner</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">powner</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="o">*</span><span class="n">powner</span> <span class="o">=</span> <span class="n">owner</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">usb_hub_release_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">port1</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">owner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">powner</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">find_port_owner</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">powner</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">powner</span> <span class="o">!=</span> <span class="n">owner</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="o">*</span><span class="n">powner</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">usb_hub_release_all_ports</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">owner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">powner</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">find_port_owner</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">powner</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">maxchild</span><span class="p">;</span> <span class="p">(</span><span class="o">++</span><span class="n">n</span><span class="p">,</span> <span class="o">++</span><span class="n">powner</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">powner</span> <span class="o">==</span> <span class="n">owner</span><span class="p">)</span>
				<span class="o">*</span><span class="n">powner</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* The caller must hold udev&#39;s lock */</span>
<span class="n">bool</span> <span class="nf">usb_device_is_owned</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_NOTATTACHED</span> <span class="o">||</span> <span class="o">!</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">hub</span> <span class="o">=</span> <span class="n">hdev_to_hub</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">!!</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">port_owners</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">portnum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">recursively_mark_NOTATTACHED</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">maxchild</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">recursively_mark_NOTATTACHED</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_SUSPENDED</span><span class="p">)</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">active_duration</span> <span class="o">-=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">USB_STATE_NOTATTACHED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_set_device_state - change a device&#39;s current state (usbcore, hcds)</span>
<span class="cm"> * @udev: pointer to device whose state should be changed</span>
<span class="cm"> * @new_state: new state value to be stored</span>
<span class="cm"> *</span>
<span class="cm"> * udev-&gt;state is _not_ fully protected by the device lock.  Although</span>
<span class="cm"> * most transitions are made only while holding the lock, the state can</span>
<span class="cm"> * can change to USB_STATE_NOTATTACHED at almost any time.  This</span>
<span class="cm"> * is so that devices can be marked as disconnected as soon as possible,</span>
<span class="cm"> * without having to wait for any semaphores to be released.  As a result,</span>
<span class="cm"> * all changes to any device&#39;s state must be protected by the</span>
<span class="cm"> * device_state_lock spinlock.</span>
<span class="cm"> *</span>
<span class="cm"> * Once a device has been added to the device tree, all changes to its state</span>
<span class="cm"> * should be made using this routine.  The state should _not_ be set directly.</span>
<span class="cm"> *</span>
<span class="cm"> * If udev-&gt;state is already USB_STATE_NOTATTACHED then no change is made.</span>
<span class="cm"> * Otherwise udev-&gt;state is set to new_state, and if new_state is</span>
<span class="cm"> * USB_STATE_NOTATTACHED then all of udev&#39;s descendants&#39; states are also set</span>
<span class="cm"> * to USB_STATE_NOTATTACHED.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_set_device_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">usb_device_state</span> <span class="n">new_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wakeup</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_NOTATTACHED</span><span class="p">)</span>
		<span class="p">;</span>	<span class="cm">/* do nothing */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">new_state</span> <span class="o">!=</span> <span class="n">USB_STATE_NOTATTACHED</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* root hub wakeup capabilities are managed out-of-band</span>
<span class="cm">		 * and may involve silicon errata ... ignore them here.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_SUSPENDED</span>
					<span class="o">||</span> <span class="n">new_state</span> <span class="o">==</span> <span class="n">USB_STATE_SUSPENDED</span><span class="p">)</span>
				<span class="p">;</span>	<span class="cm">/* No change to wakeup settings */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">new_state</span> <span class="o">==</span> <span class="n">USB_STATE_CONFIGURED</span><span class="p">)</span>
				<span class="n">wakeup</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bmAttributes</span>
					 <span class="o">&amp;</span> <span class="n">USB_CONFIG_ATT_WAKEUP</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">wakeup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_SUSPENDED</span> <span class="o">&amp;&amp;</span>
			<span class="n">new_state</span> <span class="o">!=</span> <span class="n">USB_STATE_SUSPENDED</span><span class="p">)</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">active_duration</span> <span class="o">-=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">new_state</span> <span class="o">==</span> <span class="n">USB_STATE_SUSPENDED</span> <span class="o">&amp;&amp;</span>
				<span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">USB_STATE_SUSPENDED</span><span class="p">)</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">active_duration</span> <span class="o">+=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">new_state</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">recursively_mark_NOTATTACHED</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_state_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wakeup</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">device_set_wakeup_capable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">wakeup</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_set_device_state</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Choose a device number.</span>
<span class="cm"> *</span>
<span class="cm"> * Device numbers are used as filenames in usbfs.  On USB-1.1 and</span>
<span class="cm"> * USB-2.0 buses they are also used as device addresses, however on</span>
<span class="cm"> * USB-3.0 buses the address is assigned by the controller hardware</span>
<span class="cm"> * and it usually is not the same as the device number.</span>
<span class="cm"> *</span>
<span class="cm"> * WUSB devices are simple: they have no hubs behind, so the mapping</span>
<span class="cm"> * device &lt;-&gt; virtual port number becomes 1:1. Why? to simplify the</span>
<span class="cm"> * life of the device connection logic in</span>
<span class="cm"> * drivers/usb/wusbcore/devconnect.c. When we do the initial secret</span>
<span class="cm"> * handshake we need to assign a temporary address in the unauthorized</span>
<span class="cm"> * space. For simplicity we use the first virtual port number found to</span>
<span class="cm"> * be free [drivers/usb/wusbcore/devconnect.c:wusbhc_devconnect_ack()]</span>
<span class="cm"> * and that becomes it&#39;s address [X &lt; 128] or its unauthorized address</span>
<span class="cm"> * [X | 0x80].</span>
<span class="cm"> *</span>
<span class="cm"> * We add 1 as an offset to the one-based USB-stack port number</span>
<span class="cm"> * (zero-based wusb virtual port index) for two reasons: (a) dev addr</span>
<span class="cm"> * 0 is reserved by USB for default address; (b) Linux&#39;s USB stack</span>
<span class="cm"> * uses always #1 for the root hub of the controller. So USB stack&#39;s</span>
<span class="cm"> * port #1, which is wusb virtual-port #0 has address #2.</span>
<span class="cm"> *</span>
<span class="cm"> * Devices connected under xHCI are not as simple.  The host controller</span>
<span class="cm"> * supports virtualization, so the hardware assigns device addresses and</span>
<span class="cm"> * the HCD must setup data structures before issuing a set address</span>
<span class="cm"> * command to the hardware.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">choose_devnum</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">devnum</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_bus</span>	<span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span>

	<span class="cm">/* If khubd ever becomes multithreaded, this will need a lock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">wusb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">devnum</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">portnum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">devnum</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">devmap</span><span class="p">.</span><span class="n">devicemap</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Try to allocate the next devnum beginning at</span>
<span class="cm">		 * bus-&gt;devnum_next. */</span>
		<span class="n">devnum</span> <span class="o">=</span> <span class="n">find_next_zero_bit</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">devmap</span><span class="p">.</span><span class="n">devicemap</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span>
					    <span class="n">bus</span><span class="o">-&gt;</span><span class="n">devnum_next</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devnum</span> <span class="o">&gt;=</span> <span class="mi">128</span><span class="p">)</span>
			<span class="n">devnum</span> <span class="o">=</span> <span class="n">find_next_zero_bit</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">devmap</span><span class="p">.</span><span class="n">devicemap</span><span class="p">,</span>
						    <span class="mi">128</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">bus</span><span class="o">-&gt;</span><span class="n">devnum_next</span> <span class="o">=</span> <span class="p">(</span> <span class="n">devnum</span> <span class="o">&gt;=</span> <span class="mi">127</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">devnum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devnum</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">devnum</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">devmap</span><span class="p">.</span><span class="n">devicemap</span><span class="p">);</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">=</span> <span class="n">devnum</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_devnum</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">devmap</span><span class="p">.</span><span class="n">devicemap</span><span class="p">);</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_devnum</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">devnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* The address for a WUSB device is managed by wusbcore. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">wusb</span><span class="p">)</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">=</span> <span class="n">devnum</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hub_free_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>

	<span class="cm">/* Root hubs aren&#39;t real devices, so don&#39;t free HCD resources */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">free_dev</span> <span class="o">&amp;&amp;</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">free_dev</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_disconnect - disconnect a device (usbcore-internal)</span>
<span class="cm"> * @pdev: pointer to device being disconnected</span>
<span class="cm"> * Context: !in_interrupt ()</span>
<span class="cm"> *</span>
<span class="cm"> * Something got disconnected. Get rid of it and all of its children.</span>
<span class="cm"> *</span>
<span class="cm"> * If *pdev is a normal device then the parent hub must already be locked.</span>
<span class="cm"> * If *pdev is a root hub then this routine will acquire the</span>
<span class="cm"> * usb_bus_list_lock on behalf of the caller.</span>
<span class="cm"> *</span>
<span class="cm"> * Only hub drivers (including virtual root hub drivers for host</span>
<span class="cm"> * controllers) should ever call this.</span>
<span class="cm"> *</span>
<span class="cm"> * This call is synchronous, and may not be used in an interrupt context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">**</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>

	<span class="cm">/* mark the device as inactive, so any further urb submissions for</span>
<span class="cm">	 * this device (and any of its children) will fail immediately.</span>
<span class="cm">	 * this quiesces everything except pending urbs.</span>
<span class="cm">	 */</span>
	<span class="n">usb_set_device_state</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">USB_STATE_NOTATTACHED</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;USB disconnect, device number %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">);</span>

	<span class="n">usb_lock_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

	<span class="cm">/* Free up all the children before we remove this device */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">maxchild</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">usb_disconnect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/* deallocate hcd/hardware state ... nuking all pending urbs and</span>
<span class="cm">	 * cleaning up all state associated with the current configuration</span>
<span class="cm">	 * so that the hardware is now fully quiesced.</span>
<span class="cm">	 */</span>
	<span class="n">dev_dbg</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unregistering device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">usb_disable_device</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">usb_hcd_synchronize_unlinks</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

	<span class="n">usb_remove_ep_devs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">);</span>
	<span class="n">usb_unlock_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

	<span class="cm">/* Unregister the device.  The device driver is responsible</span>
<span class="cm">	 * for de-configuring the device and invoking the remove-device</span>
<span class="cm">	 * notifier chain (used by usbfs and possibly others).</span>
<span class="cm">	 */</span>
	<span class="n">device_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Free the device number and delete the parent&#39;s children[]</span>
<span class="cm">	 * (or root_hub) pointer.</span>
<span class="cm">	 */</span>
	<span class="n">release_devnum</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

	<span class="cm">/* Avoid races with recursively_mark_NOTATTACHED() */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_state_lock</span><span class="p">);</span>
	<span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_state_lock</span><span class="p">);</span>

	<span class="n">hub_free_dev</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

	<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_USB_ANNOUNCE_NEW_DEVICES</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">show_string</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">string</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">string</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">announce_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;New USB device found, idVendor=%04x, idProduct=%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idVendor</span><span class="p">),</span>
		<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idProduct</span><span class="p">));</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;New USB device strings: Mfr=%d, Product=%d, SerialNumber=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">iManufacturer</span><span class="p">,</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">iProduct</span><span class="p">,</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">iSerialNumber</span><span class="p">);</span>
	<span class="n">show_string</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="s">&quot;Product&quot;</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">product</span><span class="p">);</span>
	<span class="n">show_string</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="s">&quot;Manufacturer&quot;</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">manufacturer</span><span class="p">);</span>
	<span class="n">show_string</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="s">&quot;SerialNumber&quot;</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">announce_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef	CONFIG_USB_OTG</span>
<span class="cp">#include &quot;otg_whitelist.h&quot;</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * usb_enumerate_device_otg - FIXME (usbcore-internal)</span>
<span class="cm"> * @udev: newly addressed device (in ADDRESS state)</span>
<span class="cm"> *</span>
<span class="cm"> * Finish enumeration for On-The-Go devices</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_enumerate_device_otg</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef	CONFIG_USB_OTG</span>
	<span class="cm">/*</span>
<span class="cm">	 * OTG-aware devices on OTG-capable root hubs may be able to use SRP,</span>
<span class="cm">	 * to wake us after we&#39;ve powered off VBUS; and HNP, switching roles</span>
<span class="cm">	 * &quot;host&quot; to &quot;peripheral&quot;.  The OTG descriptor helps figure this out.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">is_b_host</span>
			<span class="o">&amp;&amp;</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">config</span>
			<span class="o">&amp;&amp;</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">root_hub</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_otg_descriptor</span>	<span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">usb_bus</span>			<span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span>

		<span class="cm">/* descriptor may appear anywhere in config */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__usb_get_extra_descriptor</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">rawdescriptors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">desc</span><span class="p">.</span><span class="n">wTotalLength</span><span class="p">),</span>
					<span class="n">USB_DT_OTG</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">desc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bmAttributes</span> <span class="o">&amp;</span> <span class="n">USB_OTG_HNP</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">unsigned</span>		<span class="n">port1</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">portnum</span><span class="p">;</span>

				<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;Dual-Role OTG device on %sHNP port</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="n">port1</span> <span class="o">==</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">otg_port</span><span class="p">)</span>
						<span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;non-&quot;</span><span class="p">);</span>

				<span class="cm">/* enable HNP before suspend, it&#39;s simpler */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">port1</span> <span class="o">==</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">otg_port</span><span class="p">)</span>
					<span class="n">bus</span><span class="o">-&gt;</span><span class="n">b_hnp_enable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span>
					<span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
					<span class="n">USB_REQ_SET_FEATURE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">bus</span><span class="o">-&gt;</span><span class="n">b_hnp_enable</span>
						<span class="o">?</span> <span class="n">USB_DEVICE_B_HNP_ENABLE</span>
						<span class="o">:</span> <span class="n">USB_DEVICE_A_ALT_HNP_SUPPORT</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">USB_CTRL_SET_TIMEOUT</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* OTG MESSAGE: report errors here,</span>
<span class="cm">					 * customize to match your product.</span>
<span class="cm">					 */</span>
					<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						<span class="s">&quot;can&#39;t set HNP mode: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">err</span><span class="p">);</span>
					<span class="n">bus</span><span class="o">-&gt;</span><span class="n">b_hnp_enable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_targeted</span><span class="p">(</span><span class="n">udev</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* Maybe it can talk to us, though we can&#39;t talk to it.</span>
<span class="cm">		 * (Includes HNP test device.)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">b_hnp_enable</span> <span class="o">||</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">is_b_host</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">usb_port_suspend</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">PMSG_SUSPEND</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;HNP fail, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">fail:</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * usb_enumerate_device - Read device configs/intfs/otg (usbcore-internal)</span>
<span class="cm"> * @udev: newly addressed device (in ADDRESS state)</span>
<span class="cm"> *</span>
<span class="cm"> * This is only called by usb_new_device() and usb_authorize_device()</span>
<span class="cm"> * and FIXME -- all comments that apply to them apply here wrt to</span>
<span class="cm"> * environment.</span>
<span class="cm"> *</span>
<span class="cm"> * If the device is WUSB and not authorized, we don&#39;t attempt to read</span>
<span class="cm"> * the string descriptors, as they will be errored out by the device</span>
<span class="cm"> * until it has been authorized.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_enumerate_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">config</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">usb_get_configuration</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t read configurations, error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">err</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">wusb</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">authorized</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">product</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="s">&quot;n/a (unauthorized)&quot;</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">manufacturer</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="s">&quot;n/a (unauthorized)&quot;</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">serial</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="s">&quot;n/a (unauthorized)&quot;</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* read the standard strings and cache them if present */</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">product</span> <span class="o">=</span> <span class="n">usb_cache_string</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">iProduct</span><span class="p">);</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">manufacturer</span> <span class="o">=</span> <span class="n">usb_cache_string</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span>
						      <span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">iManufacturer</span><span class="p">);</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">serial</span> <span class="o">=</span> <span class="n">usb_cache_string</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">iSerialNumber</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">usb_enumerate_device_otg</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
<span class="nl">fail:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_usb_port_removable</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">port</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">portnum</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">wHubCharacteristics</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">removable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hdev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">hub</span> <span class="o">=</span> <span class="n">hdev_to_hub</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>

	<span class="n">wHubCharacteristics</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">wHubCharacteristics</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">wHubCharacteristics</span> <span class="o">&amp;</span> <span class="n">HUB_CHAR_COMPOUND</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hub_is_superspeed</span><span class="p">(</span><span class="n">hdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ss</span><span class="p">.</span><span class="n">DeviceRemovable</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">port</span><span class="p">))</span>
			<span class="n">removable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hs</span><span class="p">.</span><span class="n">DeviceRemovable</span><span class="p">[</span><span class="n">port</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">port</span> <span class="o">%</span> <span class="mi">8</span><span class="p">)))</span>
			<span class="n">removable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">removable</span><span class="p">)</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">removable</span> <span class="o">=</span> <span class="n">USB_DEVICE_REMOVABLE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">removable</span> <span class="o">=</span> <span class="n">USB_DEVICE_FIXED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_new_device - perform initial device setup (usbcore-internal)</span>
<span class="cm"> * @udev: newly addressed device (in ADDRESS state)</span>
<span class="cm"> *</span>
<span class="cm"> * This is called with devices which have been detected but not fully</span>
<span class="cm"> * enumerated.  The device descriptor is available, but not descriptors</span>
<span class="cm"> * for any device configuration.  The caller must have locked either</span>
<span class="cm"> * the parent hub (if udev is a normal device) or else the</span>
<span class="cm"> * usb_bus_list_lock (if udev is a root hub).  The parent&#39;s pointer to</span>
<span class="cm"> * udev has already been installed, but udev is not yet visible through</span>
<span class="cm"> * sysfs or other filesystem code.</span>
<span class="cm"> *</span>
<span class="cm"> * It will return if the device is configured properly or not.  Zero if</span>
<span class="cm"> * the interface was registered with the driver core; else a negative</span>
<span class="cm"> * errno value.</span>
<span class="cm"> *</span>
<span class="cm"> * This call is synchronous, and may not be used in an interrupt context.</span>
<span class="cm"> *</span>
<span class="cm"> * Only the hub driver or root-hub registrar should ever call this.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_new_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Initialize non-root-hub device wakeup to disabled;</span>
<span class="cm">		 * device (un)configuration controls wakeup capable</span>
<span class="cm">		 * sysfs power/wakeup controls wakeup enabled/disabled</span>
<span class="cm">		 */</span>
		<span class="n">device_init_wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Tell the runtime-PM framework the device is active */</span>
	<span class="n">pm_runtime_set_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pm_runtime_get_noresume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pm_runtime_use_autosuspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pm_runtime_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* By default, forbid autosuspend for all devices.  It will be</span>
<span class="cm">	 * allowed for hubs during binding.</span>
<span class="cm">	 */</span>
	<span class="n">usb_disable_autosuspend</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">usb_enumerate_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>	<span class="cm">/* Read descriptors */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;udev %d, busnum %d, minor = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">busnum</span><span class="p">,</span>
			<span class="p">(((</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">busnum</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">128</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="o">-</span><span class="mi">1</span><span class="p">)));</span>
	<span class="cm">/* export the usbdev device-node for libusb */</span>
	<span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">devt</span> <span class="o">=</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">USB_DEVICE_MAJOR</span><span class="p">,</span>
			<span class="p">(((</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">busnum</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">128</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="o">-</span><span class="mi">1</span><span class="p">)));</span>

	<span class="cm">/* Tell the world! */</span>
	<span class="n">announce_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

	<span class="n">device_enable_async_suspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * check whether the hub marks this port as non-removable. Do it</span>
<span class="cm">	 * now so that platform-specific data can override it in</span>
<span class="cm">	 * device_add()</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">set_usb_port_removable</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

	<span class="cm">/* Register the device.  The device driver is responsible</span>
<span class="cm">	 * for configuring the device and invoking the add-device</span>
<span class="cm">	 * notifier chain (used by usbfs and possibly others).</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">device_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t device_add, error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">usb_create_ep_devs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">,</span> <span class="n">udev</span><span class="p">);</span>
	<span class="n">usb_mark_last_busy</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="n">pm_runtime_put_sync_autosuspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">usb_set_device_state</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">USB_STATE_NOTATTACHED</span><span class="p">);</span>
	<span class="n">pm_runtime_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pm_runtime_set_suspended</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * usb_deauthorize_device - deauthorize a device (usbcore-internal)</span>
<span class="cm"> * @usb_dev: USB device</span>
<span class="cm"> *</span>
<span class="cm"> * Move the USB device to a very basic state where interfaces are disabled</span>
<span class="cm"> * and the device is in fact unconfigured and unusable.</span>
<span class="cm"> *</span>
<span class="cm"> * We share a lock (that we have) with device_del(), so we need to</span>
<span class="cm"> * defer its call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_deauthorize_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">usb_lock_device</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">authorized</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unauthorized</span><span class="p">;</span>

	<span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">authorized</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">usb_set_configuration</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">product</span><span class="p">);</span>
	<span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">product</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="s">&quot;n/a (unauthorized)&quot;</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">manufacturer</span><span class="p">);</span>
	<span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">manufacturer</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="s">&quot;n/a (unauthorized)&quot;</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">);</span>
	<span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">serial</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="s">&quot;n/a (unauthorized)&quot;</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="n">usb_destroy_configuration</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">);</span>
	<span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bNumConfigurations</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_unauthorized:</span>
	<span class="n">usb_unlock_device</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">usb_authorize_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>

	<span class="n">usb_lock_device</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">authorized</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_authorized</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_autoresume_device</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;can&#39;t autoresume for authorization: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_autoresume</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_get_device_descriptor</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t re-read device descriptor for &quot;</span>
			<span class="s">&quot;authorization: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_device_descriptor</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">product</span><span class="p">);</span>
	<span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">product</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">manufacturer</span><span class="p">);</span>
	<span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">manufacturer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">);</span>
	<span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">serial</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">authorized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_enumerate_device</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_enumerate</span><span class="p">;</span>
	<span class="cm">/* Choose and set the configuration.  This registers the interfaces</span>
<span class="cm">	 * with the driver core and lets interface drivers bind to them.</span>
<span class="cm">	 */</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">usb_choose_configuration</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">usb_set_configuration</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;can&#39;t set config #%d, error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
			<span class="cm">/* This need not be fatal.  The user can try to</span>
<span class="cm">			 * set other configurations. */</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;authorized to connect</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="nl">error_enumerate:</span>
<span class="nl">error_device_descriptor:</span>
	<span class="n">usb_autosuspend_device</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">);</span>
<span class="nl">error_autoresume:</span>
<span class="nl">out_authorized:</span>
	<span class="n">usb_unlock_device</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">);</span>	<span class="c1">// complements locktree</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Returns 1 if @hub is a WUSB root hub, 0 otherwise */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">hub_is_wusb</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>  <span class="cm">/* not a root hub? */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hcd</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_hcd</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">wireless</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#define PORT_RESET_TRIES	5</span>
<span class="cp">#define SET_ADDRESS_TRIES	2</span>
<span class="cp">#define GET_DESCRIPTOR_TRIES	2</span>
<span class="cp">#define SET_CONFIG_TRIES	(2 * (use_both_schemes + 1))</span>
<span class="cp">#define USE_NEW_SCHEME(i)	((i) / 2 == (int)old_scheme_first)</span>

<span class="cp">#define HUB_ROOT_RESET_TIME	50	</span><span class="cm">/* times are in msec */</span><span class="cp"></span>
<span class="cp">#define HUB_SHORT_RESET_TIME	10</span>
<span class="cp">#define HUB_BH_RESET_TIME	50</span>
<span class="cp">#define HUB_LONG_RESET_TIME	200</span>
<span class="cp">#define HUB_RESET_TIMEOUT	500</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">hub_port_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port1</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">delay</span><span class="p">,</span> <span class="n">bool</span> <span class="n">warm</span><span class="p">);</span>

<span class="cm">/* Is a USB 3.0 port in the Inactive state? */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">hub_port_inactive</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">,</span> <span class="n">u16</span> <span class="n">portstatus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hub_is_superspeed</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_LINK_STATE</span><span class="p">)</span> <span class="o">==</span>
		<span class="n">USB_SS_PORT_LS_SS_INACTIVE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hub_port_wait_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port1</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">delay</span><span class="p">,</span> <span class="n">bool</span> <span class="n">warm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">delay_time</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">portstatus</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">portchange</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">delay_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">delay_time</span> <span class="o">&lt;</span> <span class="n">HUB_RESET_TIMEOUT</span><span class="p">;</span>
			<span class="n">delay_time</span> <span class="o">+=</span> <span class="n">delay</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* wait to give the device a chance to reset */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="n">delay</span><span class="p">);</span>

		<span class="cm">/* read and decode port status */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">hub_port_status</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portstatus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portchange</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Some buggy devices require a warm reset to be issued even</span>
<span class="cm">		 * when the port appears not to be connected.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">warm</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Some buggy devices can cause an NEC host controller</span>
<span class="cm">			 * to transition to the &quot;Error&quot; state after a hot port</span>
<span class="cm">			 * reset.  This will show up as the port state in</span>
<span class="cm">			 * &quot;Inactive&quot;, and the port may also report a</span>
<span class="cm">			 * disconnect.  Forcing a warm port reset seems to make</span>
<span class="cm">			 * the device work.</span>
<span class="cm">			 *</span>
<span class="cm">			 * See https://bugzilla.kernel.org/show_bug.cgi?id=41752</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hub_port_inactive</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">portstatus</span><span class="p">))</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">((</span><span class="n">portchange</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_C_CONNECTION</span><span class="p">))</span>
					<span class="n">clear_port_feature</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span>
							<span class="n">USB_PORT_FEAT_C_CONNECTION</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">portchange</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_C_LINK_STATE</span><span class="p">)</span>
					<span class="n">clear_port_feature</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span>
							<span class="n">USB_PORT_FEAT_C_PORT_LINK_STATE</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">portchange</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_C_RESET</span><span class="p">)</span>
					<span class="n">clear_port_feature</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span>
							<span class="n">USB_PORT_FEAT_C_RESET</span><span class="p">);</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">,</span> <span class="s">&quot;hot reset failed, warm reset port %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">port1</span><span class="p">);</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">hub_port_reset</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span>
						<span class="n">udev</span><span class="p">,</span> <span class="n">HUB_BH_RESET_TIME</span><span class="p">,</span>
						<span class="nb">true</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">portchange</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_C_CONNECTION</span><span class="p">))</span>
					<span class="n">clear_port_feature</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span>
							<span class="n">USB_PORT_FEAT_C_CONNECTION</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Device went away? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_CONNECTION</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>

			<span class="cm">/* bomb out completely if the connection bounced */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">portchange</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_C_CONNECTION</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>

			<span class="cm">/* if we`ve finished resetting, then break out of</span>
<span class="cm">			 * the loop</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_RESET</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_ENABLE</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">hub_is_wusb</span><span class="p">(</span><span class="n">hub</span><span class="p">))</span>
					<span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_WIRELESS</span><span class="p">;</span>
				<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hub_is_superspeed</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">))</span>
					<span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_SUPER</span><span class="p">;</span>
				<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_HIGH_SPEED</span><span class="p">)</span>
					<span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_HIGH</span><span class="p">;</span>
				<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_LOW_SPEED</span><span class="p">)</span>
					<span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_LOW</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_FULL</span><span class="p">;</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">portchange</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_C_BH_RESET</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* switch to the long delay after two short delay failures */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delay_time</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">HUB_SHORT_RESET_TIME</span><span class="p">)</span>
			<span class="n">delay</span> <span class="o">=</span> <span class="n">HUB_LONG_RESET_TIME</span><span class="p">;</span>

		<span class="n">dev_dbg</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">,</span>
			<span class="s">&quot;port %d not %sreset yet, waiting %dms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">port1</span><span class="p">,</span> <span class="n">warm</span> <span class="o">?</span> <span class="s">&quot;warm &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hub_port_finish_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port1</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">status</span><span class="p">,</span> <span class="n">bool</span> <span class="n">warm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="o">*</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">warm</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">;</span>
			<span class="cm">/* TRSTRCY = 10 ms; plus some extra */</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span> <span class="o">+</span> <span class="mi">40</span><span class="p">);</span>
			<span class="n">update_devnum</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">reset_device</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">reset_device</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot reset &quot;</span>
							<span class="s">&quot;HCD device state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* FALL THROUGH */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ENOTCONN</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ENODEV</span>:
		<span class="n">clear_port_feature</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">,</span>
				<span class="n">port1</span><span class="p">,</span> <span class="n">USB_PORT_FEAT_C_RESET</span><span class="p">);</span>
		<span class="cm">/* FIXME need disconnect() for NOTATTACHED device */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">warm</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clear_port_feature</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span>
					<span class="n">USB_PORT_FEAT_C_BH_PORT_RESET</span><span class="p">);</span>
			<span class="n">clear_port_feature</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span>
					<span class="n">USB_PORT_FEAT_C_PORT_LINK_STATE</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">usb_set_device_state</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="o">*</span><span class="n">status</span>
					<span class="o">?</span> <span class="n">USB_STATE_NOTATTACHED</span>
					<span class="o">:</span> <span class="n">USB_STATE_DEFAULT</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Handle port reset and port warm(BH) reset (for USB3 protocol ports) */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hub_port_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port1</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">delay</span><span class="p">,</span> <span class="n">bool</span> <span class="n">warm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">warm</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Block EHCI CF initialization during the port reset.</span>
<span class="cm">		 * Some companion controllers don&#39;t like it when they mix.</span>
<span class="cm">		 */</span>
		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci_cf_port_reset_rwsem</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hub_is_superspeed</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">,</span> <span class="s">&quot;only USB3 hub support &quot;</span>
						<span class="s">&quot;warm reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Reset the port */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PORT_RESET_TRIES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">set_port_feature</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="p">(</span><span class="n">warm</span> <span class="o">?</span>
					<span class="n">USB_PORT_FEAT_BH_PORT_RESET</span> <span class="o">:</span>
					<span class="n">USB_PORT_FEAT_RESET</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">,</span>
					<span class="s">&quot;cannot %sreset port %d (err = %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">warm</span> <span class="o">?</span> <span class="s">&quot;warm &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">hub_port_wait_reset</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span>
								<span class="n">warm</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">)</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">,</span>
						<span class="s">&quot;port_wait_reset: err = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">status</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* return on disconnect or reset */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOTCONN</span> <span class="o">||</span> <span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hub_port_finish_reset</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="n">warm</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dev_dbg</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">,</span>
			<span class="s">&quot;port %d not enabled, trying %sreset again...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">port1</span><span class="p">,</span> <span class="n">warm</span> <span class="o">?</span> <span class="s">&quot;warm &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
		<span class="n">delay</span> <span class="o">=</span> <span class="n">HUB_LONG_RESET_TIME</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_err</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">,</span>
		<span class="s">&quot;Cannot enable port %i.  Maybe the USB cable is bad?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">port1</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">warm</span><span class="p">)</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci_cf_port_reset_rwsem</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Check if a port is power on */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">port_is_power_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">portstatus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hub_is_superspeed</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_SS_PORT_STAT_POWER</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_POWER</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef	CONFIG_PM</span>

<span class="cm">/* Check if a port is suspended(USB2.0 port) or in U3 state(USB3.0 port) */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">port_is_suspended</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">portstatus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hub_is_superspeed</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_LINK_STATE</span><span class="p">)</span>
				<span class="o">==</span> <span class="n">USB_SS_PORT_LS_U3</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_SUSPEND</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Determine whether the device on a port is ready for a normal resume,</span>
<span class="cm"> * is ready for a reset-resume, or should be disconnected.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_port_resume_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port1</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">portchange</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">portstatus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Is the device still present? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">||</span> <span class="n">port_is_suspended</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">portstatus</span><span class="p">)</span> <span class="o">||</span>
			<span class="o">!</span><span class="n">port_is_power_on</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">portstatus</span><span class="p">)</span> <span class="o">||</span>
			<span class="o">!</span><span class="p">(</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_CONNECTION</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Can&#39;t do a normal resume if the port isn&#39;t enabled,</span>
<span class="cm">	 * so try a reset-resume instead.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_ENABLE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">reset_resume</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">persist_enabled</span><span class="p">)</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">reset_resume</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">,</span>
				<span class="s">&quot;port %d status %04x.%04x after resume, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">port1</span><span class="p">,</span> <span class="n">portchange</span><span class="p">,</span> <span class="n">portstatus</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">reset_resume</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Late port handoff can set status-change bits */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">portchange</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_C_CONNECTION</span><span class="p">)</span>
			<span class="n">clear_port_feature</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span>
					<span class="n">USB_PORT_FEAT_C_CONNECTION</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">portchange</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_C_ENABLE</span><span class="p">)</span>
			<span class="n">clear_port_feature</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span>
					<span class="n">USB_PORT_FEAT_C_ENABLE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef	CONFIG_USB_SUSPEND</span>

<span class="cm">/*</span>
<span class="cm"> * usb_port_suspend - suspend a usb device&#39;s upstream port</span>
<span class="cm"> * @udev: device that&#39;s no longer in active use, not a root hub</span>
<span class="cm"> * Context: must be able to sleep; device not locked; pm locks held</span>
<span class="cm"> *</span>
<span class="cm"> * Suspends a USB device that isn&#39;t in active use, conserving power.</span>
<span class="cm"> * Devices may wake out of a suspend, if anything important happens,</span>
<span class="cm"> * using the remote wakeup mechanism.  They may also be taken out of</span>
<span class="cm"> * suspend by the host, using usb_port_resume().  It&#39;s also routine</span>
<span class="cm"> * to disconnect devices while they are suspended.</span>
<span class="cm"> *</span>
<span class="cm"> * This only affects the USB hardware for a device; its interfaces</span>
<span class="cm"> * (and, for hubs, child devices) must already have been suspended.</span>
<span class="cm"> *</span>
<span class="cm"> * Selective port suspend reduces power; most suspended devices draw</span>
<span class="cm"> * less than 500 uA.  It&#39;s also used in OTG, along with remote wakeup.</span>
<span class="cm"> * All devices below the suspended port are also suspended.</span>
<span class="cm"> *</span>
<span class="cm"> * Devices leave suspend state when the host wakes them up.  Some devices</span>
<span class="cm"> * also support &quot;remote wakeup&quot;, where the device can activate the USB</span>
<span class="cm"> * tree above them to deliver data, such as a keypress or packet.  In</span>
<span class="cm"> * some cases, this wakes the USB host.</span>
<span class="cm"> *</span>
<span class="cm"> * Suspending OTG devices may trigger HNP, if that&#39;s been enabled</span>
<span class="cm"> * between a pair of dual-role devices.  That will change roles, such</span>
<span class="cm"> * as from A-Host to A-Peripheral or from B-Host back to B-Peripheral.</span>
<span class="cm"> *</span>
<span class="cm"> * Devices on USB hub ports have only one &quot;suspend&quot; state, corresponding</span>
<span class="cm"> * to ACPI D2, &quot;may cause the device to lose some context&quot;.</span>
<span class="cm"> * State transitions include:</span>
<span class="cm"> *</span>
<span class="cm"> *   - suspend, resume ... when the VBUS power link stays live</span>
<span class="cm"> *   - suspend, disconnect ... VBUS lost</span>
<span class="cm"> *</span>
<span class="cm"> * Once VBUS drop breaks the circuit, the port it&#39;s using has to go through</span>
<span class="cm"> * normal re-enumeration procedures, starting with enabling VBUS power.</span>
<span class="cm"> * Other than re-initializing the hub (plug/unplug, except for root hubs),</span>
<span class="cm"> * Linux (2.6) currently has NO mechanisms to initiate that:  no khubd</span>
<span class="cm"> * timer, no SRP, no requests through sysfs.</span>
<span class="cm"> *</span>
<span class="cm"> * If CONFIG_USB_SUSPEND isn&#39;t enabled, devices only really suspend when</span>
<span class="cm"> * the root hub for their bus goes into global suspend ... so we don&#39;t</span>
<span class="cm"> * (falsely) update the device power state to say it suspended.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, else negative errno.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_port_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hub</span>	<span class="o">*</span><span class="n">hub</span> <span class="o">=</span> <span class="n">hdev_to_hub</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="n">port1</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">portnum</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">status</span><span class="p">;</span>

	<span class="cm">/* enable remote wakeup when appropriate; this lets the device</span>
<span class="cm">	 * wake up the upstream hub (including maybe the root hub).</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE:  OTG devices may issue remote wakeup (or SRP) even when</span>
<span class="cm">	 * we don&#39;t explicitly enable it here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">do_remote_wakeup</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hub_is_superspeed</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
					<span class="n">USB_REQ_SET_FEATURE</span><span class="p">,</span> <span class="n">USB_RECIP_DEVICE</span><span class="p">,</span>
					<span class="n">USB_DEVICE_REMOTE_WAKEUP</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">USB_CTRL_SET_TIMEOUT</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Assume there&#39;s only one function on the USB 3.0</span>
<span class="cm">			 * device and enable remote wake for the first</span>
<span class="cm">			 * interface. FIXME if the interface association</span>
<span class="cm">			 * descriptor shows there&#39;s more than one function.</span>
<span class="cm">			 */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
					<span class="n">USB_REQ_SET_FEATURE</span><span class="p">,</span>
					<span class="n">USB_RECIP_INTERFACE</span><span class="p">,</span>
					<span class="n">USB_INTRF_FUNC_SUSPEND</span><span class="p">,</span>
					<span class="n">USB_INTRF_FUNC_SUSPEND_RW</span> <span class="o">|</span>
					<span class="n">USB_INTRF_FUNC_SUSPEND_LP</span><span class="p">,</span>
					<span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">USB_CTRL_SET_TIMEOUT</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;won&#39;t remote wakeup, status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">status</span><span class="p">);</span>
			<span class="cm">/* bail if autosuspend is requested */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PMSG_IS_AUTO</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* disable USB2 hardware LPM */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">usb2_hw_lpm_enabled</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">usb_set_usb2_hardware_lpm</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_unlocked_disable_lpm</span><span class="p">(</span><span class="n">udev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s Failed to disable LPM before suspend</span><span class="se">\n</span><span class="s">.&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* see 7.1.7.6 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hub_is_superspeed</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">set_port_feature</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">,</span>
				<span class="n">port1</span> <span class="o">|</span> <span class="p">(</span><span class="n">USB_SS_PORT_LS_U3</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
				<span class="n">USB_PORT_FEAT_LINK_STATE</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">set_port_feature</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span>
						<span class="n">USB_PORT_FEAT_SUSPEND</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">,</span> <span class="s">&quot;can&#39;t suspend port %d, status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">port1</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="cm">/* paranoia:  &quot;should not happen&quot; */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">do_remote_wakeup</span><span class="p">)</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
				<span class="n">USB_REQ_CLEAR_FEATURE</span><span class="p">,</span> <span class="n">USB_RECIP_DEVICE</span><span class="p">,</span>
				<span class="n">USB_DEVICE_REMOTE_WAKEUP</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">USB_CTRL_SET_TIMEOUT</span><span class="p">);</span>

		<span class="cm">/* Try to enable USB2 hardware LPM again */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">usb2_hw_lpm_capable</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">usb_set_usb2_hardware_lpm</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* Try to enable USB3 LPM again */</span>
		<span class="n">usb_unlocked_enable_lpm</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

		<span class="cm">/* System sleep transitions should never fail */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PMSG_IS_AUTO</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* device has up to 10 msec to fully suspend */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;usb %ssuspend, wakeup %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="n">PMSG_IS_AUTO</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;auto-&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">),</span>
				<span class="n">udev</span><span class="o">-&gt;</span><span class="n">do_remote_wakeup</span><span class="p">);</span>
		<span class="n">usb_set_device_state</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">USB_STATE_SUSPENDED</span><span class="p">);</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">usb_mark_last_busy</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If the USB &quot;suspend&quot; state is in use (rather than &quot;global suspend&quot;),</span>
<span class="cm"> * many devices will be individually taken out of suspend state using</span>
<span class="cm"> * special &quot;resume&quot; signaling.  This routine kicks in shortly after</span>
<span class="cm"> * hardware resume signaling is finished, either because of selective</span>
<span class="cm"> * resume (by host) or remote wakeup (by device) ... now see what changed</span>
<span class="cm"> * in the tree that&#39;s rooted at this device.</span>
<span class="cm"> *</span>
<span class="cm"> * If @udev-&gt;reset_resume is set then the device is reset before the</span>
<span class="cm"> * status check is done.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">finish_port_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">devstatus</span><span class="p">;</span>

	<span class="cm">/* caller owns the udev device lock */</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">reset_resume</span> <span class="o">?</span> <span class="s">&quot;finish reset-resume&quot;</span> <span class="o">:</span> <span class="s">&quot;finish resume&quot;</span><span class="p">);</span>

	<span class="cm">/* usb ch9 identifies four variants of SUSPENDED, based on what</span>
<span class="cm">	 * state the device resumes to.  Linux currently won&#39;t see the</span>
<span class="cm">	 * first two on the host side; they&#39;d be inside hub_port_init()</span>
<span class="cm">	 * during many timeouts, but khubd can&#39;t suspend until later.</span>
<span class="cm">	 */</span>
	<span class="n">usb_set_device_state</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span>
			<span class="o">?</span> <span class="n">USB_STATE_CONFIGURED</span>
			<span class="o">:</span> <span class="n">USB_STATE_ADDRESS</span><span class="p">);</span>

	<span class="cm">/* 10.5.4.5 says not to reset a suspended port if the attached</span>
<span class="cm">	 * device is enabled for remote wakeup.  Hence the reset</span>
<span class="cm">	 * operation is carried out here, after the port has been</span>
<span class="cm">	 * resumed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">reset_resume</span><span class="p">)</span>
 <span class="nl">retry_reset_resume:</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">usb_reset_and_verify_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

 	<span class="cm">/* 10.5.4.5 says be sure devices in the tree are still there.</span>
<span class="cm"> 	 * For now let&#39;s assume the device didn&#39;t go crazy on resume,</span>
<span class="cm">	 * and device drivers will know about any resume quirks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">devstatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">usb_get_status</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">USB_RECIP_DEVICE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devstatus</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>

		<span class="cm">/* If a normal resume failed, try doing a reset-resume */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">reset_resume</span> <span class="o">&amp;&amp;</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">persist_enabled</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;retry with reset-resume</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">reset_resume</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">retry_reset_resume</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;gone after usb resume? status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">status</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">le16_to_cpus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devstatus</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devstatus</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USB_DEVICE_REMOTE_WAKEUP</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span>
					<span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
					<span class="n">USB_REQ_CLEAR_FEATURE</span><span class="p">,</span>
						<span class="n">USB_RECIP_DEVICE</span><span class="p">,</span>
					<span class="n">USB_DEVICE_REMOTE_WAKEUP</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">USB_CTRL_SET_TIMEOUT</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;disable remote wakeup, status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">status</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * usb_port_resume - re-activate a suspended usb device&#39;s upstream port</span>
<span class="cm"> * @udev: device to re-activate, not a root hub</span>
<span class="cm"> * Context: must be able to sleep; device not locked; pm locks held</span>
<span class="cm"> *</span>
<span class="cm"> * This will re-activate the suspended device, increasing power usage</span>
<span class="cm"> * while letting drivers communicate again with its endpoints.</span>
<span class="cm"> * USB resume explicitly guarantees that the power session between</span>
<span class="cm"> * the host and the device is the same as it was when the device</span>
<span class="cm"> * suspended.</span>
<span class="cm"> *</span>
<span class="cm"> * If @udev-&gt;reset_resume is set then this routine won&#39;t check that the</span>
<span class="cm"> * port is still enabled.  Furthermore, finish_port_resume() above will</span>
<span class="cm"> * reset @udev.  The end result is that a broken power session can be</span>
<span class="cm"> * recovered and @udev will appear to persist across a loss of VBUS power.</span>
<span class="cm"> *</span>
<span class="cm"> * For example, if a host controller doesn&#39;t maintain VBUS suspend current</span>
<span class="cm"> * during a system sleep or is reset when the system wakes up, all the USB</span>
<span class="cm"> * power sessions below it will be broken.  This is especially troublesome</span>
<span class="cm"> * for mass-storage devices containing mounted filesystems, since the</span>
<span class="cm"> * device will appear to have disconnected and all the memory mappings</span>
<span class="cm"> * to it will be lost.  Using the USB_PERSIST facility, the device can be</span>
<span class="cm"> * made to appear as if it had not disconnected.</span>
<span class="cm"> *</span>
<span class="cm"> * This facility can be dangerous.  Although usb_reset_and_verify_device() makes</span>
<span class="cm"> * every effort to insure that the same device is present after the</span>
<span class="cm"> * reset as before, it cannot provide a 100% guarantee.  Furthermore it&#39;s</span>
<span class="cm"> * quite possible for a device to remain unaltered but its media to be</span>
<span class="cm"> * changed.  If the user replaces a flash memory card while the system is</span>
<span class="cm"> * asleep, he will have only himself to blame when the filesystem on the</span>
<span class="cm"> * new card is corrupted and the system crashes.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, else negative errno.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_port_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hub</span>	<span class="o">*</span><span class="n">hub</span> <span class="o">=</span> <span class="n">hdev_to_hub</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="n">port1</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">portnum</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">status</span><span class="p">;</span>
	<span class="n">u16</span>		<span class="n">portchange</span><span class="p">,</span> <span class="n">portstatus</span><span class="p">;</span>

	<span class="cm">/* Skip the initial Clear-Suspend step for a remote wakeup */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">hub_port_status</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portstatus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portchange</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">port_is_suspended</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">portstatus</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">SuspendCleared</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>dev_dbg(hub->intfdev, "resume port %d\n", port1);</p></td><td class="code"><div class="highlight"><pre>	<span class="n">set_bit</span><span class="p">(</span><span class="n">port1</span><span class="p">,</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">busy_bits</span><span class="p">);</span>

	<span class="cm">/* see 7.1.7.7; affects power usage, but not budgeting */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hub_is_superspeed</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">set_port_feature</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">,</span>
				<span class="n">port1</span> <span class="o">|</span> <span class="p">(</span><span class="n">USB_SS_PORT_LS_U0</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
				<span class="n">USB_PORT_FEAT_LINK_STATE</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">clear_port_feature</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">,</span>
				<span class="n">port1</span><span class="p">,</span> <span class="n">USB_PORT_FEAT_SUSPEND</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">,</span> <span class="s">&quot;can&#39;t resume port %d, status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">port1</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* drive resume for at least 20 msec */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;usb %sresume</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="n">PMSG_IS_AUTO</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;auto-&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">));</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span>

		<span class="cm">/* Virtual root hubs can trigger on GET_PORT_STATUS to</span>
<span class="cm">		 * stop resume signaling.  Then finish the resume</span>
<span class="cm">		 * sequence.</span>
<span class="cm">		 */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">hub_port_status</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portstatus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portchange</span><span class="p">);</span>

		<span class="cm">/* TRSMRCY = 10 msec */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>

 <span class="nl">SuspendCleared:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hub_is_superspeed</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">portchange</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_C_LINK_STATE</span><span class="p">)</span>
				<span class="n">clear_port_feature</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span>
					<span class="n">USB_PORT_FEAT_C_PORT_LINK_STATE</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">portchange</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_C_SUSPEND</span><span class="p">)</span>
				<span class="n">clear_port_feature</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span>
						<span class="n">USB_PORT_FEAT_C_SUSPEND</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">port1</span><span class="p">,</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">busy_bits</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">check_port_resume_type</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span>
			<span class="n">hub</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">portchange</span><span class="p">,</span> <span class="n">portstatus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">finish_port_resume</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t resume, status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="n">hub_port_logical_disconnect</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">port1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>  <span class="p">{</span>
		<span class="cm">/* Try to enable USB2 hardware LPM */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">usb2_hw_lpm_capable</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">usb_set_usb2_hardware_lpm</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* Try to enable USB3 LPM */</span>
		<span class="n">usb_unlocked_enable_lpm</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* caller has locked udev */</span>
<span class="kt">int</span> <span class="nf">usb_remote_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_SUSPENDED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;usb %sresume</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;wakeup-&quot;</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">usb_autoresume_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Let the drivers do their thing, then... */</span>
			<span class="n">usb_autosuspend_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else	</span><span class="cm">/* CONFIG_USB_SUSPEND */</span><span class="cp"></span>

<span class="cm">/* When CONFIG_USB_SUSPEND isn&#39;t set, we never suspend or resume any ports. */</span>

<span class="kt">int</span> <span class="nf">usb_port_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* However we may need to do a reset-resume */</span>

<span class="kt">int</span> <span class="nf">usb_port_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hub</span>	<span class="o">*</span><span class="n">hub</span> <span class="o">=</span> <span class="n">hdev_to_hub</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="n">port1</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">portnum</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">status</span><span class="p">;</span>
	<span class="n">u16</span>		<span class="n">portchange</span><span class="p">,</span> <span class="n">portstatus</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">hub_port_status</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portstatus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portchange</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">check_port_resume_type</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span>
			<span class="n">hub</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">portchange</span><span class="p">,</span> <span class="n">portstatus</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t resume, status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="n">hub_port_logical_disconnect</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">port1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">reset_resume</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;reset-resume</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">usb_reset_and_verify_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hub_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hub</span>		<span class="o">*</span><span class="n">hub</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span> <span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">hdev</span> <span class="o">=</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">port1</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>

	<span class="cm">/* Warn if children aren&#39;t already suspended */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">port1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">port1</span> <span class="o">&lt;=</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">maxchild</span><span class="p">;</span> <span class="n">port1</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span><span class="p">;</span>

		<span class="n">udev</span> <span class="o">=</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">children</span> <span class="p">[</span><span class="n">port1</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udev</span> <span class="o">&amp;&amp;</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">can_submit</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;port %d nyet suspended</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PMSG_IS_AUTO</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hub_is_superspeed</span><span class="p">(</span><span class="n">hdev</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">do_remote_wakeup</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Enable hub to send remote wakeup for all ports. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">port1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">port1</span> <span class="o">&lt;=</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">maxchild</span><span class="p">;</span> <span class="n">port1</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">set_port_feature</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span>
					<span class="n">port1</span> <span class="o">|</span>
					<span class="n">USB_PORT_FEAT_REMOTE_WAKE_CONNECT</span> <span class="o">|</span>
					<span class="n">USB_PORT_FEAT_REMOTE_WAKE_DISCONNECT</span> <span class="o">|</span>
					<span class="n">USB_PORT_FEAT_REMOTE_WAKE_OVER_CURRENT</span><span class="p">,</span>
					<span class="n">USB_PORT_FEAT_REMOTE_WAKE_MASK</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* stop khubd and related activity */</span>
	<span class="n">hub_quiesce</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">HUB_SUSPEND</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hub_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">hub_activate</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">HUB_RESUME</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hub_reset_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">hub_activate</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">HUB_RESET_RESUME</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_root_hub_lost_power - called by HCD if the root hub lost Vbus power</span>
<span class="cm"> * @rhdev: struct usb_device for the root hub</span>
<span class="cm"> *</span>
<span class="cm"> * The USB host controller driver calls this function when its root hub</span>
<span class="cm"> * is resumed and Vbus power has been interrupted or the controller</span>
<span class="cm"> * has been reset.  The routine marks @rhdev as having lost power.</span>
<span class="cm"> * When the hub driver is resumed it will take notice and carry out</span>
<span class="cm"> * power-session recovery for all the &quot;USB-PERSIST&quot;-enabled child devices;</span>
<span class="cm"> * the others will be disconnected.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_root_hub_lost_power</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">rhdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;root hub lost power or was reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">rhdev</span><span class="o">-&gt;</span><span class="n">reset_resume</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_root_hub_lost_power</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">usb3_lpm_names</span><span class="p">[]</span>  <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;U0&quot;</span><span class="p">,</span>
	<span class="s">&quot;U1&quot;</span><span class="p">,</span>
	<span class="s">&quot;U2&quot;</span><span class="p">,</span>
	<span class="s">&quot;U3&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Send a Set SEL control transfer to the device, prior to enabling</span>
<span class="cm"> * device-initiated U1 or U2.  This lets the device know the exit latencies from</span>
<span class="cm"> * the time the device initiates a U1 or U2 exit, to the time it will receive a</span>
<span class="cm"> * packet from the host.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will fail if the SEL or PEL values for udev are greater than</span>
<span class="cm"> * the maximum allowed values for the link state to be enabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_req_set_sel</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">usb3_link_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_set_sel_req</span> <span class="o">*</span><span class="n">sel_values</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">u1_sel</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">u1_pel</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">u2_sel</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">u2_pel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Convert SEL and PEL stored in ns to us */</span>
	<span class="n">u1_sel</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">u1_params</span><span class="p">.</span><span class="n">sel</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="n">u1_pel</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">u1_params</span><span class="p">.</span><span class="n">pel</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="n">u2_sel</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">u2_params</span><span class="p">.</span><span class="n">sel</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="n">u2_pel</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">u2_params</span><span class="p">.</span><span class="n">pel</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure that the calculated SEL and PEL values for the link</span>
<span class="cm">	 * state we&#39;re enabling aren&#39;t bigger than the max SEL/PEL</span>
<span class="cm">	 * value that will fit in the SET SEL control transfer.</span>
<span class="cm">	 * Otherwise the device would get an incorrect idea of the exit</span>
<span class="cm">	 * latency for the link state, and could start a device-initiated</span>
<span class="cm">	 * U1/U2 when the exit latencies are too high.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB3_LPM_U1</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">u1_sel</span> <span class="o">&gt;</span> <span class="n">USB3_LPM_MAX_U1_SEL_PEL</span> <span class="o">||</span>
				 <span class="n">u1_pel</span> <span class="o">&gt;</span> <span class="n">USB3_LPM_MAX_U1_SEL_PEL</span><span class="p">))</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB3_LPM_U2</span> <span class="o">&amp;&amp;</span>
			 <span class="p">(</span><span class="n">u2_sel</span> <span class="o">&gt;</span> <span class="n">USB3_LPM_MAX_U2_SEL_PEL</span> <span class="o">||</span>
			  <span class="n">u2_pel</span> <span class="o">&gt;</span> <span class="n">USB3_LPM_MAX_U2_SEL_PEL</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Device-initiated %s disabled due &quot;</span>
				<span class="s">&quot;to long SEL %llu ms or PEL %llu ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">usb3_lpm_names</span><span class="p">[</span><span class="n">state</span><span class="p">],</span> <span class="n">u1_sel</span><span class="p">,</span> <span class="n">u1_pel</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re enabling device-initiated LPM for one link state,</span>
<span class="cm">	 * but the other link state has a too high SEL or PEL value,</span>
<span class="cm">	 * just set those values to the max in the Set SEL request.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">u1_sel</span> <span class="o">&gt;</span> <span class="n">USB3_LPM_MAX_U1_SEL_PEL</span><span class="p">)</span>
		<span class="n">u1_sel</span> <span class="o">=</span> <span class="n">USB3_LPM_MAX_U1_SEL_PEL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">u1_pel</span> <span class="o">&gt;</span> <span class="n">USB3_LPM_MAX_U1_SEL_PEL</span><span class="p">)</span>
		<span class="n">u1_pel</span> <span class="o">=</span> <span class="n">USB3_LPM_MAX_U1_SEL_PEL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">u2_sel</span> <span class="o">&gt;</span> <span class="n">USB3_LPM_MAX_U2_SEL_PEL</span><span class="p">)</span>
		<span class="n">u2_sel</span> <span class="o">=</span> <span class="n">USB3_LPM_MAX_U2_SEL_PEL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">u2_pel</span> <span class="o">&gt;</span> <span class="n">USB3_LPM_MAX_U2_SEL_PEL</span><span class="p">)</span>
		<span class="n">u2_pel</span> <span class="o">=</span> <span class="n">USB3_LPM_MAX_U2_SEL_PEL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * usb_enable_lpm() can be called as part of a failed device reset,</span>
<span class="cm">	 * which may be initiated by an error path of a mass storage driver.</span>
<span class="cm">	 * Therefore, use GFP_NOIO.</span>
<span class="cm">	 */</span>
	<span class="n">sel_values</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="p">(</span><span class="n">sel_values</span><span class="p">),</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sel_values</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">sel_values</span><span class="o">-&gt;</span><span class="n">u1_sel</span> <span class="o">=</span> <span class="n">u1_sel</span><span class="p">;</span>
	<span class="n">sel_values</span><span class="o">-&gt;</span><span class="n">u1_pel</span> <span class="o">=</span> <span class="n">u1_pel</span><span class="p">;</span>
	<span class="n">sel_values</span><span class="o">-&gt;</span><span class="n">u2_sel</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">u2_sel</span><span class="p">);</span>
	<span class="n">sel_values</span><span class="o">-&gt;</span><span class="n">u2_pel</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">u2_pel</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
			<span class="n">USB_REQ_SET_SEL</span><span class="p">,</span>
			<span class="n">USB_RECIP_DEVICE</span><span class="p">,</span>
			<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">sel_values</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="p">(</span><span class="n">sel_values</span><span class="p">),</span>
			<span class="n">USB_CTRL_SET_TIMEOUT</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sel_values</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Enable or disable device-initiated U1 or U2 transitions.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_set_device_initiated_lpm</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">usb3_link_state</span> <span class="n">state</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">feature</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB3_LPM_U1</span>:
		<span class="n">feature</span> <span class="o">=</span> <span class="n">USB_DEVICE_U1_ENABLE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB3_LPM_U2</span>:
		<span class="n">feature</span> <span class="o">=</span> <span class="n">USB_DEVICE_U2_ENABLE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Can&#39;t %s non-U1 or U2 state.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">enable</span> <span class="o">?</span> <span class="s">&quot;enable&quot;</span> <span class="o">:</span> <span class="s">&quot;disable&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">USB_STATE_CONFIGURED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Can&#39;t %s %s state &quot;</span>
				<span class="s">&quot;for unconfigured device.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">enable</span> <span class="o">?</span> <span class="s">&quot;enable&quot;</span> <span class="o">:</span> <span class="s">&quot;disable&quot;</span><span class="p">,</span>
				<span class="n">usb3_lpm_names</span><span class="p">[</span><span class="n">state</span><span class="p">]);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * First, let the device know about the exit latencies</span>
<span class="cm">		 * associated with the link state we&#39;re about to enable.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_req_set_sel</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Set SEL for device-initiated &quot;</span>
					<span class="s">&quot;%s failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usb3_lpm_names</span><span class="p">[</span><span class="n">state</span><span class="p">]);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Now send the control transfer to enable device-initiated LPM</span>
<span class="cm">		 * for either U1 or U2.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
				<span class="n">USB_REQ_SET_FEATURE</span><span class="p">,</span>
				<span class="n">USB_RECIP_DEVICE</span><span class="p">,</span>
				<span class="n">feature</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">USB_CTRL_SET_TIMEOUT</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
				<span class="n">USB_REQ_CLEAR_FEATURE</span><span class="p">,</span>
				<span class="n">USB_RECIP_DEVICE</span><span class="p">,</span>
				<span class="n">feature</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">USB_CTRL_SET_TIMEOUT</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s of device-initiated %s failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">enable</span> <span class="o">?</span> <span class="s">&quot;Enable&quot;</span> <span class="o">:</span> <span class="s">&quot;Disable&quot;</span><span class="p">,</span>
				<span class="n">usb3_lpm_names</span><span class="p">[</span><span class="n">state</span><span class="p">]);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_set_lpm_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">usb3_link_state</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">feature</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB3_LPM_U1</span>:
		<span class="n">feature</span> <span class="o">=</span> <span class="n">USB_PORT_FEAT_U1_TIMEOUT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB3_LPM_U2</span>:
		<span class="n">feature</span> <span class="o">=</span> <span class="n">USB_PORT_FEAT_U2_TIMEOUT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Can&#39;t set timeout for non-U1 or U2 state.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB3_LPM_U1</span> <span class="o">&amp;&amp;</span> <span class="n">timeout</span> <span class="o">&gt;</span> <span class="n">USB3_LPM_U1_MAX_TIMEOUT</span> <span class="o">&amp;&amp;</span>
			<span class="n">timeout</span> <span class="o">!=</span> <span class="n">USB3_LPM_DEVICE_INITIATED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to set %s timeout to 0x%x, &quot;</span>
				<span class="s">&quot;which is a reserved value.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">usb3_lpm_names</span><span class="p">[</span><span class="n">state</span><span class="p">],</span> <span class="n">timeout</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">set_port_feature</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span>
			<span class="n">USB_PORT_LPM_TIMEOUT</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="o">|</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">portnum</span><span class="p">,</span>
			<span class="n">feature</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to set %s timeout to 0x%x,&quot;</span>
				<span class="s">&quot;error code %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usb3_lpm_names</span><span class="p">[</span><span class="n">state</span><span class="p">],</span>
				<span class="n">timeout</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB3_LPM_U1</span><span class="p">)</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">u1_params</span><span class="p">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">u2_params</span><span class="p">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Enable the hub-initiated U1/U2 idle timeouts, and enable device-initiated</span>
<span class="cm"> * U1/U2 entry.</span>
<span class="cm"> *</span>
<span class="cm"> * We will attempt to enable U1 or U2, but there are no guarantees that the</span>
<span class="cm"> * control transfers to set the hub timeout or enable device-initiated U1/U2</span>
<span class="cm"> * will be successful.</span>
<span class="cm"> *</span>
<span class="cm"> * If we cannot set the parent hub U1/U2 timeout, we attempt to let the xHCI</span>
<span class="cm"> * driver know about it.  If that call fails, it should be harmless, and just</span>
<span class="cm"> * take up more slightly more bus bandwidth for unnecessary U1/U2 exit latency.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usb_enable_link_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">usb3_link_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="cm">/* We allow the host controller to set the U1/U2 timeout internally</span>
<span class="cm">	 * first, so that it can change its schedule to account for the</span>
<span class="cm">	 * additional latency to send data to a device in a lower power</span>
<span class="cm">	 * link state.</span>
<span class="cm">	 */</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">enable_usb3_lpm_timeout</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>

	<span class="cm">/* xHCI host controller doesn&#39;t want to enable this LPM state. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not enable %s link state, &quot;</span>
				<span class="s">&quot;xHCI error %i.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usb3_lpm_names</span><span class="p">[</span><span class="n">state</span><span class="p">],</span>
				<span class="n">timeout</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_set_lpm_timeout</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span>
		<span class="cm">/* If we can&#39;t set the parent hub U1/U2 timeout,</span>
<span class="cm">		 * device-initiated LPM won&#39;t be allowed either, so let the xHCI</span>
<span class="cm">		 * host know that this link state won&#39;t be enabled.</span>
<span class="cm">		 */</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">disable_usb3_lpm_timeout</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>

	<span class="cm">/* Only a configured device will accept the Set Feature U1/U2_ENABLE */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="p">)</span>
		<span class="n">usb_set_device_initiated_lpm</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Disable the hub-initiated U1/U2 idle timeouts, and disable device-initiated</span>
<span class="cm"> * U1/U2 entry.</span>
<span class="cm"> *</span>
<span class="cm"> * If this function returns -EBUSY, the parent hub will still allow U1/U2 entry.</span>
<span class="cm"> * If zero is returned, the parent will not allow the link to go into U1/U2.</span>
<span class="cm"> *</span>
<span class="cm"> * If zero is returned, device-initiated U1/U2 entry may still be enabled, but</span>
<span class="cm"> * it won&#39;t have an effect on the bus link state because the parent hub will</span>
<span class="cm"> * still disallow device-initiated U1/U2 entry.</span>
<span class="cm"> *</span>
<span class="cm"> * If zero is returned, the xHCI host controller may still think U1/U2 entry is</span>
<span class="cm"> * possible.  The result will be slightly more bus bandwidth will be taken up</span>
<span class="cm"> * (to account for U1/U2 exit latency), but it should be harmless.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_disable_link_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">usb3_link_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">feature</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB3_LPM_U1</span>:
		<span class="n">feature</span> <span class="o">=</span> <span class="n">USB_PORT_FEAT_U1_TIMEOUT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB3_LPM_U2</span>:
		<span class="n">feature</span> <span class="o">=</span> <span class="n">USB_PORT_FEAT_U2_TIMEOUT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Can&#39;t disable non-U1 or U2 state.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_set_lpm_timeout</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">usb_set_device_initiated_lpm</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">disable_usb3_lpm_timeout</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">state</span><span class="p">))</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not disable xHCI %s timeout, &quot;</span>
				<span class="s">&quot;bus schedule bandwidth may be impacted.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">usb3_lpm_names</span><span class="p">[</span><span class="n">state</span><span class="p">]);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Disable hub-initiated and device-initiated U1 and U2 entry.</span>
<span class="cm"> * Caller must own the bandwidth_mutex.</span>
<span class="cm"> *</span>
<span class="cm"> * This will call usb_enable_lpm() on failure, which will decrement</span>
<span class="cm"> * lpm_disable_count, and will re-enable LPM if lpm_disable_count reaches zero.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_disable_lpm</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udev</span> <span class="o">||</span> <span class="o">!</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">||</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">USB_SPEED_SUPER</span> <span class="o">||</span>
			<span class="o">!</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">lpm_capable</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hcd</span> <span class="o">||</span> <span class="o">!</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">disable_usb3_lpm_timeout</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">udev</span><span class="o">-&gt;</span><span class="n">lpm_disable_count</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">u1_params</span><span class="p">.</span><span class="n">timeout</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">u2_params</span><span class="p">.</span><span class="n">timeout</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If LPM is enabled, attempt to disable it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_disable_link_state</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">USB3_LPM_U1</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">enable_lpm</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_disable_link_state</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">USB3_LPM_U2</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">enable_lpm</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">enable_lpm:</span>
	<span class="n">usb_enable_lpm</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_disable_lpm</span><span class="p">);</span>

<span class="cm">/* Grab the bandwidth_mutex before calling usb_disable_lpm() */</span>
<span class="kt">int</span> <span class="nf">usb_unlocked_disable_lpm</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hcd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_disable_lpm</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_unlocked_disable_lpm</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Attempt to enable device-initiated and hub-initiated U1 and U2 entry.  The</span>
<span class="cm"> * xHCI host policy may prevent U1 or U2 from being enabled.</span>
<span class="cm"> *</span>
<span class="cm"> * Other callers may have disabled link PM, so U1 and U2 entry will be disabled</span>
<span class="cm"> * until the lpm_disable_count drops to zero.  Caller must own the</span>
<span class="cm"> * bandwidth_mutex.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_enable_lpm</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udev</span> <span class="o">||</span> <span class="o">!</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">||</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">USB_SPEED_SUPER</span> <span class="o">||</span>
			<span class="o">!</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">lpm_capable</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">udev</span><span class="o">-&gt;</span><span class="n">lpm_disable_count</span><span class="o">--</span><span class="p">;</span>
	<span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="cm">/* Double check that we can both enable and disable LPM.</span>
<span class="cm">	 * Device must be configured to accept set feature U1/U2 timeout.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hcd</span> <span class="o">||</span> <span class="o">!</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">enable_usb3_lpm_timeout</span> <span class="o">||</span>
			<span class="o">!</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">disable_usb3_lpm_timeout</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">lpm_disable_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">usb_enable_link_state</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">USB3_LPM_U1</span><span class="p">);</span>
	<span class="n">usb_enable_link_state</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">USB3_LPM_U2</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_enable_lpm</span><span class="p">);</span>

<span class="cm">/* Grab the bandwidth_mutex before calling usb_enable_lpm() */</span>
<span class="kt">void</span> <span class="nf">usb_unlocked_enable_lpm</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hcd</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">);</span>
	<span class="n">usb_enable_lpm</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_unlocked_enable_lpm</span><span class="p">);</span>


<span class="cp">#else	</span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="cp">#define hub_suspend		NULL</span>
<span class="cp">#define hub_resume		NULL</span>
<span class="cp">#define hub_reset_resume	NULL</span>

<span class="kt">int</span> <span class="nf">usb_disable_lpm</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_disable_lpm</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">usb_enable_lpm</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_enable_lpm</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">usb_unlocked_disable_lpm</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_unlocked_disable_lpm</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">usb_unlocked_enable_lpm</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_unlocked_enable_lpm</span><span class="p">);</span>
<span class="cp">#endif</span>


<span class="cm">/* USB 2.0 spec, 7.1.7.3 / fig 7-29:</span>
<span class="cm"> *</span>
<span class="cm"> * Between connect detection and reset signaling there must be a delay</span>
<span class="cm"> * of 100ms at least for debounce and power-settling.  The corresponding</span>
<span class="cm"> * timer shall restart whenever the downstream port detects a disconnect.</span>
<span class="cm"> * </span>
<span class="cm"> * Apparently there are some bluetooth and irda-dongles and a number of</span>
<span class="cm"> * low-speed devices for which this debounce period may last over a second.</span>
<span class="cm"> * Not covered by the spec - but easy to deal with.</span>
<span class="cm"> *</span>
<span class="cm"> * This implementation uses a 1500ms total debounce timeout; if the</span>
<span class="cm"> * connection isn&#39;t stable by then it returns -ETIMEDOUT.  It checks</span>
<span class="cm"> * every 25ms for transient disconnects.  When the port status has been</span>
<span class="cm"> * unchanged for 100ms it returns the port status.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hub_port_debounce</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">total_time</span><span class="p">,</span> <span class="n">stable_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">portchange</span><span class="p">,</span> <span class="n">portstatus</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">connection</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">total_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="n">total_time</span> <span class="o">+=</span> <span class="n">HUB_DEBOUNCE_STEP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">hub_port_status</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portstatus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portchange</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">portchange</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_C_CONNECTION</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="p">(</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_CONNECTION</span><span class="p">)</span> <span class="o">==</span> <span class="n">connection</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">stable_time</span> <span class="o">+=</span> <span class="n">HUB_DEBOUNCE_STEP</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">stable_time</span> <span class="o">&gt;=</span> <span class="n">HUB_DEBOUNCE_STABLE</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">stable_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">connection</span> <span class="o">=</span> <span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_CONNECTION</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">portchange</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_C_CONNECTION</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clear_port_feature</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span>
					<span class="n">USB_PORT_FEAT_C_CONNECTION</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">total_time</span> <span class="o">&gt;=</span> <span class="n">HUB_DEBOUNCE_TIMEOUT</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">msleep</span><span class="p">(</span><span class="n">HUB_DEBOUNCE_STEP</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">,</span>
		<span class="s">&quot;debounce: port %d: total %dms stable %dms status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">port1</span><span class="p">,</span> <span class="n">total_time</span><span class="p">,</span> <span class="n">stable_time</span><span class="p">,</span> <span class="n">portstatus</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stable_time</span> <span class="o">&lt;</span> <span class="n">HUB_DEBOUNCE_STABLE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">portstatus</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">usb_ep0_reinit</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">usb_disable_endpoint</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">USB_DIR_IN</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">usb_disable_endpoint</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">USB_DIR_OUT</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">usb_enable_endpoint</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_ep0_reinit</span><span class="p">);</span>

<span class="cp">#define usb_sndaddr0pipe()	(PIPE_CONTROL &lt;&lt; 30)</span>
<span class="cp">#define usb_rcvaddr0pipe()	((PIPE_CONTROL &lt;&lt; 30) | USB_DIR_IN)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hub_set_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">devnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The host controller will choose the device address,</span>
<span class="cm">	 * instead of the core having chosen it earlier</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">address_device</span> <span class="o">&amp;&amp;</span> <span class="n">devnum</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_ADDRESS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">USB_STATE_DEFAULT</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">address_device</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">address_device</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">usb_sndaddr0pipe</span><span class="p">(),</span>
				<span class="n">USB_REQ_SET_ADDRESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">devnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">USB_CTRL_SET_TIMEOUT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">update_devnum</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">devnum</span><span class="p">);</span>
		<span class="cm">/* Device now using proper address. */</span>
		<span class="n">usb_set_device_state</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">USB_STATE_ADDRESS</span><span class="p">);</span>
		<span class="n">usb_ep0_reinit</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Reset device, (re)assign address, get device descriptor.</span>
<span class="cm"> * Device connection must be stable, no more debouncing needed.</span>
<span class="cm"> * Returns device in USB_STATE_ADDRESS, except on error.</span>
<span class="cm"> *</span>
<span class="cm"> * If this is called for an already-existing device (as part of</span>
<span class="cm"> * usb_reset_and_verify_device), the caller must own the device lock.  For a</span>
<span class="cm"> * newly detected device that is not accessible through any global</span>
<span class="cm"> * pointers, it&#39;s not necessary to lock the device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">hub_port_init</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port1</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">retry_counter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">usb_address0_mutex</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">hdev</span> <span class="o">=</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span>		<span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">delay</span> <span class="o">=</span> <span class="n">HUB_SHORT_RESET_TIME</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">usb_device_speed</span>	<span class="n">oldspeed</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">speed</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">devnum</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">;</span>

	<span class="cm">/* root hub ports have a slightly longer reset period</span>
<span class="cm">	 * (from USB 2.0 spec, section 7.1.7.5)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">delay</span> <span class="o">=</span> <span class="n">HUB_ROOT_RESET_TIME</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">port1</span> <span class="o">==</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">otg_port</span><span class="p">)</span>
			<span class="n">hdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">b_hnp_enable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Some low speed devices have problems with the quick delay, so */</span>
	<span class="cm">/*  be a bit pessimistic with those devices. RHbug #23670 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oldspeed</span> <span class="o">==</span> <span class="n">USB_SPEED_LOW</span><span class="p">)</span>
		<span class="n">delay</span> <span class="o">=</span> <span class="n">HUB_LONG_RESET_TIME</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_address0_mutex</span><span class="p">);</span>

	<span class="cm">/* Reset the device; full speed may morph to high speed */</span>
	<span class="cm">/* FIXME a USB 2.0 device may morph into SuperSpeed on reset. */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">hub_port_reset</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>		<span class="cm">/* error or disconnect */</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="cm">/* success, speed is known */</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oldspeed</span> <span class="o">!=</span> <span class="n">USB_SPEED_UNKNOWN</span> <span class="o">&amp;&amp;</span> <span class="n">oldspeed</span> <span class="o">!=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device reset changed speed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">oldspeed</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">;</span>

	<span class="cm">/* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...</span>
<span class="cm">	 * it&#39;s fixed size except for full speed devices.</span>
<span class="cm">	 * For Wireless USB devices, ep0 max packet is always 512 (tho</span>
<span class="cm">	 * reported as 0xff in the device descriptor). WUSB1.0[4.8.1].</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_SPEED_SUPER</span>:
	<span class="k">case</span> <span class="n">USB_SPEED_WIRELESS</span>:	<span class="cm">/* fixed at 512 */</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">wMaxPacketSize</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">512</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_SPEED_HIGH</span>:		<span class="cm">/* fixed at 64 */</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">wMaxPacketSize</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_SPEED_FULL</span>:		<span class="cm">/* 8, 16, 32, or 64 */</span>
		<span class="cm">/* to determine the ep0 maxpacket size, try to read</span>
<span class="cm">		 * the device descriptor to get bMaxPacketSize0 and</span>
<span class="cm">		 * then correct our initial guess.</span>
<span class="cm">		 */</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">wMaxPacketSize</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_SPEED_LOW</span>:		<span class="cm">/* fixed at 8 */</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">wMaxPacketSize</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_WIRELESS</span><span class="p">)</span>
		<span class="n">speed</span> <span class="o">=</span> <span class="s">&quot;variable speed Wireless&quot;</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">speed</span> <span class="o">=</span> <span class="n">usb_speed_string</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">USB_SPEED_SUPER</span><span class="p">)</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;%s %s USB device number %d using %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;reset&quot;</span> <span class="o">:</span> <span class="s">&quot;new&quot;</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span>
				<span class="n">devnum</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/* Set up TT records, if needed  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">tt</span> <span class="o">=</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">;</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">ttport</span> <span class="o">=</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">ttport</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">USB_SPEED_HIGH</span>
			<span class="o">&amp;&amp;</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">hub</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;parent hub has no TT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">tt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">;</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">ttport</span> <span class="o">=</span> <span class="n">port1</span><span class="p">;</span>
	<span class="p">}</span>
 
	<span class="cm">/* Why interleave GET_DESCRIPTOR and SET_ADDRESS this way?</span>
<span class="cm">	 * Because device hardware and firmware is sometimes buggy in</span>
<span class="cm">	 * this area, and this is how Linux has done it for ages.</span>
<span class="cm">	 * Change it cautiously.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE:  If USE_NEW_SCHEME() is true we will start by issuing</span>
<span class="cm">	 * a 64-byte GET_DESCRIPTOR request.  This is what Windows does,</span>
<span class="cm">	 * so it may help with some non-standards-compliant devices.</span>
<span class="cm">	 * Otherwise we start with SET_ADDRESS and then try to read the</span>
<span class="cm">	 * first 8 bytes of the device descriptor to get the ep0 maxpacket</span>
<span class="cm">	 * value.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">GET_DESCRIPTOR_TRIES</span><span class="p">;</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">USE_NEW_SCHEME</span><span class="p">(</span><span class="n">retry_counter</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HCD_USB3</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">usb_device_descriptor</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#define GET_DESCRIPTOR_BUFSIZE	64</span>
			<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">GET_DESCRIPTOR_BUFSIZE</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Retry on all errors; some devices are flakey.</span>
<span class="cm">			 * 255 is for WUSB devices, we actually need to use</span>
<span class="cm">			 * 512 (WUSB1.0[4.8.1]).</span>
<span class="cm">			 */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">buf</span><span class="o">-&gt;</span><span class="n">bMaxPacketSize0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">r</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">usb_rcvaddr0pipe</span><span class="p">(),</span>
					<span class="n">USB_REQ_GET_DESCRIPTOR</span><span class="p">,</span> <span class="n">USB_DIR_IN</span><span class="p">,</span>
					<span class="n">USB_DT_DEVICE</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">buf</span><span class="p">,</span> <span class="n">GET_DESCRIPTOR_BUFSIZE</span><span class="p">,</span>
					<span class="n">initial_descriptor_timeout</span><span class="p">);</span>
				<span class="k">switch</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">bMaxPacketSize0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">case</span> <span class="mi">8</span>: <span class="k">case</span> <span class="mi">16</span>: <span class="k">case</span> <span class="mi">32</span>: <span class="k">case</span> <span class="mi">64</span>: <span class="k">case</span> <span class="mi">255</span>:
					<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span> <span class="o">==</span>
							<span class="n">USB_DT_DEVICE</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="cm">/* FALL THROUGH */</span>
				<span class="nl">default:</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
						<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bMaxPacketSize0</span> <span class="o">=</span>
					<span class="n">buf</span><span class="o">-&gt;</span><span class="n">bMaxPacketSize0</span><span class="p">;</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

			<span class="n">retval</span> <span class="o">=</span> <span class="n">hub_port_reset</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>		<span class="cm">/* error or disconnect */</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">oldspeed</span> <span class="o">!=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;device reset changed speed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;device descriptor read/64, error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">r</span><span class="p">);</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#undef GET_DESCRIPTOR_BUFSIZE</span>
		<span class="p">}</span>

 		<span class="cm">/*</span>
<span class="cm"> 		 * If device is WUSB, we already assigned an</span>
<span class="cm"> 		 * unauthorized address in the Connect Ack sequence;</span>
<span class="cm"> 		 * authorization will assign the final address.</span>
<span class="cm"> 		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">wusb</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">SET_ADDRESS_TRIES</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">hub_set_address</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">devnum</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="n">msleep</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;device not accepting address %d, error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">devnum</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_SUPER</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">devnum</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">;</span>
				<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						<span class="s">&quot;%s SuperSpeed USB device number %d using %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;reset&quot;</span> <span class="o">:</span> <span class="s">&quot;new&quot;</span><span class="p">,</span>
						<span class="n">devnum</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* cope with hardware quirkiness:</span>
<span class="cm">			 *  - let SET_ADDRESS settle, some device hardware wants it</span>
<span class="cm">			 *  - read ep0 maxpacket even for high and low speed,</span>
<span class="cm">			 */</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">USE_NEW_SCHEME</span><span class="p">(</span><span class="n">retry_counter</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HCD_USB3</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
  		<span class="p">}</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_get_device_descriptor</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;device descriptor read/8, error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">retval</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some superspeed devices have finished the link training process</span>
<span class="cm">	 * and attached to a superspeed hub port, but the device descriptor</span>
<span class="cm">	 * got from those devices show they aren&#39;t superspeed devices. Warm</span>
<span class="cm">	 * reset the port attached by the devices can fix them.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_SUPER</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bcdUSB</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mh">0x0300</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;got a wrong device descriptor, &quot;</span>
				<span class="s">&quot;warm reset device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">hub_port_reset</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span>
				<span class="n">HUB_BH_RESET_TIME</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bMaxPacketSize0</span> <span class="o">==</span> <span class="mh">0xff</span> <span class="o">||</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_SUPER</span><span class="p">)</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bMaxPacketSize0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_maxp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">.</span><span class="n">desc</span><span class="p">)</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_LOW</span> <span class="o">||</span>
				<span class="o">!</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">8</span> <span class="o">||</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">16</span> <span class="o">||</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">32</span> <span class="o">||</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">64</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Invalid ep0 maxpacket: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_FULL</span><span class="p">)</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ep0 maxpacket = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Using ep0 maxpacket: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">wMaxPacketSize</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="n">usb_ep0_reinit</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="p">}</span>
  
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_get_device_descriptor</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">USB_DT_DEVICE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">signed</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device descriptor read/all, error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">retval</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMSG</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">wusb</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bcdUSB</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mh">0x0201</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_get_bos_descriptor</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">lpm_capable</span> <span class="o">=</span> <span class="n">usb_device_supports_lpm</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
			<span class="n">usb_set_lpm_parameters</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* notify HCD that we have a device connected and addressed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">update_device</span><span class="p">)</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">update_device</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">);</span>
<span class="nl">fail:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hub_port_disable</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">update_devnum</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">devnum</span><span class="p">);</span>	<span class="cm">/* for disconnect processing */</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_address0_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">check_highspeed</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_qualifier_descriptor</span>	<span class="o">*</span><span class="n">qual</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">status</span><span class="p">;</span>

	<span class="n">qual</span> <span class="o">=</span> <span class="n">kmalloc</span> <span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">qual</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qual</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">usb_get_descriptor</span> <span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">USB_DT_DEVICE_QUALIFIER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">qual</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">qual</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">qual</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;not running at top speed; &quot;</span>
			<span class="s">&quot;connect to a high speed hub</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* hub LEDs are probably harder to miss than syslog */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">has_indicators</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hub</span><span class="o">-&gt;</span><span class="n">indicator</span><span class="p">[</span><span class="n">port1</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">INDICATOR_GREEN_BLINK</span><span class="p">;</span>
			<span class="n">schedule_delayed_work</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">leds</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">qual</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span>
<span class="nf">hub_power_remaining</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span> <span class="o">=</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">remaining</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">port1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">limited_power</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">remaining</span> <span class="o">=</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">bus_mA</span> <span class="o">-</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">bHubContrCurrent</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">port1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">port1</span> <span class="o">&lt;=</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">maxchild</span><span class="p">;</span> <span class="o">++</span><span class="n">port1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">port1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
		<span class="kt">int</span>			<span class="n">delta</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udev</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Unconfigured devices may not use more than 100mA,</span>
<span class="cm">		 * or 8mA for OTG ports */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="p">)</span>
			<span class="n">delta</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bMaxPower</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">port1</span> <span class="o">!=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">otg_port</span> <span class="o">||</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
			<span class="n">delta</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">delta</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">mA_per_port</span><span class="p">)</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;%dmA is over %umA budget for port %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">delta</span><span class="p">,</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">mA_per_port</span><span class="p">,</span> <span class="n">port1</span><span class="p">);</span>
		<span class="n">remaining</span> <span class="o">-=</span> <span class="n">delta</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">remaining</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">,</span> <span class="s">&quot;%dmA over power budget!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="o">-</span> <span class="n">remaining</span><span class="p">);</span>
		<span class="n">remaining</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">remaining</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Handle physical or logical connection change events.</span>
<span class="cm"> * This routine is called when:</span>
<span class="cm"> * 	a port connection-change occurs;</span>
<span class="cm"> *	a port enable-change occurs (often caused by EMI);</span>
<span class="cm"> *	usb_reset_and_verify_device() encounters changed descriptors (as from</span>
<span class="cm"> *		a firmware download)</span>
<span class="cm"> * caller already locked the hub</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hub_port_connect_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port1</span><span class="p">,</span>
					<span class="n">u16</span> <span class="n">portstatus</span><span class="p">,</span> <span class="n">u16</span> <span class="n">portchange</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span> <span class="o">=</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">hub_dev</span> <span class="o">=</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">wHubCharacteristics</span> <span class="o">=</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">wHubCharacteristics</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">dev_dbg</span> <span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span>
		<span class="s">&quot;port %d, status %04x, change %04x, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">port1</span><span class="p">,</span> <span class="n">portstatus</span><span class="p">,</span> <span class="n">portchange</span><span class="p">,</span> <span class="n">portspeed</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">portstatus</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">has_indicators</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_port_led</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="n">HUB_LED_AUTO</span><span class="p">);</span>
		<span class="n">hub</span><span class="o">-&gt;</span><span class="n">indicator</span><span class="p">[</span><span class="n">port1</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">INDICATOR_AUTO</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef	CONFIG_USB_OTG</span>
	<span class="cm">/* during HNP, don&#39;t repeat the debounce */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">is_b_host</span><span class="p">)</span>
		<span class="n">portchange</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">USB_PORT_STAT_C_CONNECTION</span> <span class="o">|</span>
				<span class="n">USB_PORT_STAT_C_ENABLE</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* Try to resuscitate an existing device */</span>
	<span class="n">udev</span> <span class="o">=</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">port1</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_CONNECTION</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">udev</span> <span class="o">&amp;&amp;</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">USB_STATE_NOTATTACHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_lock_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_ENABLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* Nothing to do */</span>

<span class="cp">#ifdef CONFIG_USB_SUSPEND</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_SUSPENDED</span> <span class="o">&amp;&amp;</span>
				<span class="n">udev</span><span class="o">-&gt;</span><span class="n">persist_enabled</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* For a suspended device, treat this as a</span>
<span class="cm">			 * remote wakeup event.</span>
<span class="cm">			 */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">usb_remote_wakeup</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
<span class="cp">#endif</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>	<span class="cm">/* Don&#39;t resuscitate */</span>
		<span class="p">}</span>
		<span class="n">usb_unlock_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">port1</span><span class="p">,</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">change_bits</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Disconnect any existing devices under this port */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="p">)</span>
		<span class="n">usb_disconnect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">port1</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">port1</span><span class="p">,</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">change_bits</span><span class="p">);</span>

	<span class="cm">/* We can forget about a &quot;removed&quot; device when there&#39;s a physical</span>
<span class="cm">	 * disconnect or the connect status changes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_CONNECTION</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">portchange</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_C_CONNECTION</span><span class="p">))</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">port1</span><span class="p">,</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">removed_bits</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">portchange</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">USB_PORT_STAT_C_CONNECTION</span> <span class="o">|</span>
				<span class="n">USB_PORT_STAT_C_ENABLE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">hub_port_debounce</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">port1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;connect-debounce failed, &quot;</span>
						<span class="s">&quot;port %d disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port1</span><span class="p">);</span>
			<span class="n">portstatus</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">USB_PORT_STAT_CONNECTION</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">portstatus</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Return now if debouncing failed or nothing is connected or</span>
<span class="cm">	 * the device was &quot;removed&quot;.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_CONNECTION</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">test_bit</span><span class="p">(</span><span class="n">port1</span><span class="p">,</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">removed_bits</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* maybe switch power back on (e.g. root hub was reset) */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">wHubCharacteristics</span> <span class="o">&amp;</span> <span class="n">HUB_CHAR_LPSM</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span>
				<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">port_is_power_on</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">portstatus</span><span class="p">))</span>
			<span class="n">set_port_feature</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="n">USB_PORT_FEAT_POWER</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_ENABLE</span><span class="p">)</span>
  			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SET_CONFIG_TRIES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* reallocate for each attempt, since references</span>
<span class="cm">		 * to the previous one can escape in various ways</span>
<span class="cm">		 */</span>
		<span class="n">udev</span> <span class="o">=</span> <span class="n">usb_alloc_dev</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">port1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span> <span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span>
				<span class="s">&quot;couldn&#39;t allocate port %d usb_device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">port1</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">usb_set_device_state</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">USB_STATE_POWERED</span><span class="p">);</span>
 		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus_mA</span> <span class="o">=</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">mA_per_port</span><span class="p">;</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">=</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">wusb</span> <span class="o">=</span> <span class="n">hub_is_wusb</span><span class="p">(</span><span class="n">hub</span><span class="p">);</span>

		<span class="cm">/* Only USB 3.0 devices are connected to SuperSpeed hubs. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hub_is_superspeed</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">))</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_SUPER</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">;</span>

		<span class="n">choose_devnum</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>	<span class="cm">/* Don&#39;t retry */</span>
			<span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* reset (non-USB 3.0 devices) and get descriptor */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">hub_port_init</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>

		<span class="n">usb_detect_quirks</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">USB_QUIRK_DELAY_INIT</span><span class="p">)</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

		<span class="cm">/* consecutive bus-powered hubs aren&#39;t reliable; they can</span>
<span class="cm">		 * violate the voltage drop budget.  if the new child has</span>
<span class="cm">		 * a &quot;powered&quot; LED, users should notice we didn&#39;t enable it</span>
<span class="cm">		 * (without reading syslog), even without per-port LEDs</span>
<span class="cm">		 * on the parent.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bDeviceClass</span> <span class="o">==</span> <span class="n">USB_CLASS_HUB</span>
				<span class="o">&amp;&amp;</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus_mA</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u16</span>	<span class="n">devstat</span><span class="p">;</span>

			<span class="n">status</span> <span class="o">=</span> <span class="n">usb_get_status</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">USB_RECIP_DEVICE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">devstat</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;get status %d ?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">loop_disable</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">le16_to_cpus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devstat</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">devstat</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USB_DEVICE_SELF_POWERED</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;can&#39;t connect bus-powered hub &quot;</span>
					<span class="s">&quot;to this port</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">has_indicators</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">hub</span><span class="o">-&gt;</span><span class="n">indicator</span><span class="p">[</span><span class="n">port1</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
						<span class="n">INDICATOR_AMBER_BLINK</span><span class="p">;</span>
					<span class="n">schedule_delayed_work</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">leds</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>	<span class="cm">/* Don&#39;t retry */</span>
				<span class="k">goto</span> <span class="n">loop_disable</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
 
		<span class="cm">/* check for devices running slower than they could */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bcdUSB</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mh">0x0200</span>
				<span class="o">&amp;&amp;</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_FULL</span>
				<span class="o">&amp;&amp;</span> <span class="n">highspeed_hubs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">check_highspeed</span> <span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">port1</span><span class="p">);</span>

		<span class="cm">/* Store the parent&#39;s children[] pointer.  At this point</span>
<span class="cm">		 * udev becomes globally accessible, although presumably</span>
<span class="cm">		 * no one will look at it until hdev is unlocked.</span>
<span class="cm">		 */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* We mustn&#39;t add new devices if the parent hub has</span>
<span class="cm">		 * been disconnected; we would race with the</span>
<span class="cm">		 * recursively_mark_NOTATTACHED() routine.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_state_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_NOTATTACHED</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">hdev</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">port1</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">udev</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_state_lock</span><span class="p">);</span>

		<span class="cm">/* Run it through the hoops (find a driver, etc) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">usb_new_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_state_lock</span><span class="p">);</span>
				<span class="n">hdev</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">port1</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_state_lock</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">loop_disable</span><span class="p">;</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">hub_power_remaining</span><span class="p">(</span><span class="n">hub</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;%dmA power budget left</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

		<span class="k">return</span><span class="p">;</span>

<span class="nl">loop_disable:</span>
		<span class="n">hub_port_disable</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="nl">loop:</span>
		<span class="n">usb_ep0_reinit</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
		<span class="n">release_devnum</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
		<span class="n">hub_free_dev</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
		<span class="n">usb_put_dev</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">||</span>
			<span class="o">!</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">port_handed_over</span> <span class="o">||</span>
			<span class="o">!</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">port_handed_over</span><span class="p">)(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">port1</span><span class="p">))</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;unable to enumerate USB device on port %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">port1</span><span class="p">);</span>
 
<span class="nl">done:</span>
	<span class="n">hub_port_disable</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">relinquish_port</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">relinquish_port</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">port1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Returns 1 if there was a remote wakeup and a connect status change. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hub_handle_remote_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span>
		<span class="n">u16</span> <span class="n">portstatus</span><span class="p">,</span> <span class="n">u16</span> <span class="n">portchange</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">connect_change</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">hdev</span> <span class="o">=</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">;</span>
	<span class="n">udev</span> <span class="o">=</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">port</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hub_is_superspeed</span><span class="p">(</span><span class="n">hdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">portchange</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_C_SUSPEND</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">clear_port_feature</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">USB_PORT_FEAT_C_SUSPEND</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udev</span> <span class="o">||</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">USB_STATE_SUSPENDED</span> <span class="o">||</span>
				 <span class="p">(</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_LINK_STATE</span><span class="p">)</span> <span class="o">!=</span>
				 <span class="n">USB_SS_PORT_LS_U0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* TRSMRCY = 10 msec */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

		<span class="n">usb_lock_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_remote_wakeup</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
		<span class="n">usb_unlock_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">connect_change</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="n">hub_port_disable</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">,</span> <span class="s">&quot;resume on port %d, status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">port</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">connect_change</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hub_events</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">hub_dev</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">hubstatus</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">hubchange</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">portstatus</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">portchange</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">connect_change</span><span class="p">,</span> <span class="n">wakeup_change</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  We restart the list every time to avoid a deadlock with</span>
<span class="cm">	 * deleting hubs downstream from this one. This should be</span>
<span class="cm">	 * safe since we delete the hub from the event list.</span>
<span class="cm">	 * Not the most efficient, but avoids deadlocks.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Grab the first entry at the beginning of the list */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub_event_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub_event_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub_event_lock</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">tmp</span> <span class="o">=</span> <span class="n">hub_event_list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

		<span class="n">hub</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_hub</span><span class="p">,</span> <span class="n">event_list</span><span class="p">);</span>
		<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub_event_lock</span><span class="p">);</span>

		<span class="n">hdev</span> <span class="o">=</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">;</span>
		<span class="n">hub_dev</span> <span class="o">=</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">intfdev</span><span class="p">;</span>
		<span class="n">intf</span> <span class="o">=</span> <span class="n">to_usb_interface</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;state %d ports %d chg %04x evt %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">hdev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">descriptor</span>
					<span class="o">?</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">bNbrPorts</span>
					<span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
				<span class="cm">/* NOTE: expects max 15 ports... */</span>
				<span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">change_bits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				<span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">event_bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

		<span class="cm">/* Lock the device, then check to see if we were</span>
<span class="cm">		 * disconnected while waiting for the lock to succeed. */</span>
		<span class="n">usb_lock_device</span><span class="p">(</span><span class="n">hdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">disconnected</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">loop_disconnected</span><span class="p">;</span>

		<span class="cm">/* If the hub has died, clean up after it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_NOTATTACHED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hub</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="n">hub_quiesce</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">HUB_DISCONNECT</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Autoresume */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_autopm_get_interface</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t autoresume: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* If this is an inactive hub, do nothing */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">quiescing</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">loop_autopm</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span> <span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;resetting for error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">hub</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">);</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_reset_device</span><span class="p">(</span><span class="n">hdev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_dbg</span> <span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span>
					<span class="s">&quot;error resetting hub: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">loop_autopm</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">hub</span><span class="o">-&gt;</span><span class="n">nerrors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">hub</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* deal with port status changes */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">bNbrPorts</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">busy_bits</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">connect_change</span> <span class="o">=</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">change_bits</span><span class="p">);</span>
			<span class="n">wakeup_change</span> <span class="o">=</span> <span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">wakeup_bits</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">event_bits</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="o">!</span><span class="n">connect_change</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">wakeup_change</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">hub_port_status</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">portstatus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portchange</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">portchange</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_C_CONNECTION</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">clear_port_feature</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
					<span class="n">USB_PORT_FEAT_C_CONNECTION</span><span class="p">);</span>
				<span class="n">connect_change</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">portchange</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_C_ENABLE</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">connect_change</span><span class="p">)</span>
					<span class="n">dev_dbg</span> <span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span>
						<span class="s">&quot;port %d enable change, &quot;</span>
						<span class="s">&quot;status %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">i</span><span class="p">,</span> <span class="n">portstatus</span><span class="p">);</span>
				<span class="n">clear_port_feature</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
					<span class="n">USB_PORT_FEAT_C_ENABLE</span><span class="p">);</span>

				<span class="cm">/*</span>
<span class="cm">				 * EM interference sometimes causes badly</span>
<span class="cm">				 * shielded USB devices to be shutdown by</span>
<span class="cm">				 * the hub, this hack enables them again.</span>
<span class="cm">				 * Works at least with mouse driver. </span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_ENABLE</span><span class="p">)</span>
				    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">connect_change</span>
				    <span class="o">&amp;&amp;</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
					<span class="n">dev_err</span> <span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span>
					    <span class="s">&quot;port %i &quot;</span>
					    <span class="s">&quot;disabled by hub (EMI?), &quot;</span>
					    <span class="s">&quot;re-enabling...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">i</span><span class="p">);</span>
					<span class="n">connect_change</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">hub_handle_remote_wakeup</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
						<span class="n">portstatus</span><span class="p">,</span> <span class="n">portchange</span><span class="p">))</span>
				<span class="n">connect_change</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">portchange</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_C_OVERCURRENT</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">u16</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">u16</span> <span class="n">unused</span><span class="p">;</span>

				<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;over-current change on port &quot;</span>
					<span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="n">clear_port_feature</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
					<span class="n">USB_PORT_FEAT_C_OVER_CURRENT</span><span class="p">);</span>
				<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>	<span class="cm">/* Cool down */</span>
				<span class="n">hub_power_on</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
				<span class="n">hub_port_status</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unused</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_OVERCURRENT</span><span class="p">)</span>
					<span class="n">dev_err</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;over-current &quot;</span>
						<span class="s">&quot;condition on port %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">portchange</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_C_RESET</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_dbg</span> <span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span>
					<span class="s">&quot;reset change on port %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">i</span><span class="p">);</span>
				<span class="n">clear_port_feature</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
					<span class="n">USB_PORT_FEAT_C_RESET</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">portchange</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_C_BH_RESET</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="n">hub_is_superspeed</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span>
					<span class="s">&quot;warm reset change on port %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">i</span><span class="p">);</span>
				<span class="n">clear_port_feature</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
					<span class="n">USB_PORT_FEAT_C_BH_PORT_RESET</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">portchange</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_C_LINK_STATE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">clear_port_feature</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
						<span class="n">USB_PORT_FEAT_C_PORT_LINK_STATE</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">portchange</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_C_CONFIG_ERROR</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_warn</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span>
					<span class="s">&quot;config error on port %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">i</span><span class="p">);</span>
				<span class="n">clear_port_feature</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
						<span class="n">USB_PORT_FEAT_C_PORT_CONFIG_ERROR</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* Warm reset a USB3 protocol port if it&#39;s in</span>
<span class="cm">			 * SS.Inactive state.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hub_is_superspeed</span><span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">portstatus</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_LINK_STATE</span><span class="p">)</span>
					<span class="o">==</span> <span class="n">USB_SS_PORT_LS_SS_INACTIVE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;warm reset port %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="n">hub_port_reset</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
						<span class="n">HUB_BH_RESET_TIME</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">connect_change</span><span class="p">)</span>
				<span class="n">hub_port_connect_change</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
						<span class="n">portstatus</span><span class="p">,</span> <span class="n">portchange</span><span class="p">);</span>
		<span class="p">}</span> <span class="cm">/* end for i */</span>

		<span class="cm">/* deal with hub status changes */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hub</span><span class="o">-&gt;</span><span class="n">event_bits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="p">;</span>	<span class="cm">/* do nothing */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hub_hub_status</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hubstatus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hubchange</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dev_err</span> <span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;get_hub_status failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hubchange</span> <span class="o">&amp;</span> <span class="n">HUB_CHANGE_LOCAL_POWER</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_dbg</span> <span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;power change</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">clear_hub_feature</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">C_HUB_LOCAL_POWER</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">hubstatus</span> <span class="o">&amp;</span> <span class="n">HUB_STATUS_LOCAL_POWER</span><span class="p">)</span>
					<span class="cm">/* FIXME: Is this always true? */</span>
					<span class="n">hub</span><span class="o">-&gt;</span><span class="n">limited_power</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">hub</span><span class="o">-&gt;</span><span class="n">limited_power</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hubchange</span> <span class="o">&amp;</span> <span class="n">HUB_CHANGE_OVERCURRENT</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">u16</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">u16</span> <span class="n">unused</span><span class="p">;</span>

				<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;over-current change</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">clear_hub_feature</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">C_HUB_OVER_CURRENT</span><span class="p">);</span>
				<span class="n">msleep</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>	<span class="cm">/* Cool down */</span>
                        	<span class="n">hub_power_on</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
				<span class="n">hub_hub_status</span><span class="p">(</span><span class="n">hub</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unused</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">HUB_STATUS_OVERCURRENT</span><span class="p">)</span>
					<span class="n">dev_err</span><span class="p">(</span><span class="n">hub_dev</span><span class="p">,</span> <span class="s">&quot;over-current &quot;</span>
						<span class="s">&quot;condition</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

 <span class="nl">loop_autopm:</span>
		<span class="cm">/* Balance the usb_autopm_get_interface() above */</span>
		<span class="n">usb_autopm_put_interface_no_suspend</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
 <span class="nl">loop:</span>
		<span class="cm">/* Balance the usb_autopm_get_interface_no_resume() in</span>
<span class="cm">		 * kick_khubd() and allow autosuspend.</span>
<span class="cm">		 */</span>
		<span class="n">usb_autopm_put_interface</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
 <span class="nl">loop_disconnected:</span>
		<span class="n">usb_unlock_device</span><span class="p">(</span><span class="n">hdev</span><span class="p">);</span>
		<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="n">hub_release</span><span class="p">);</span>

        <span class="p">}</span> <span class="cm">/* end while (1) */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hub_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">__unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* khubd needs to be freezable to avoid intefering with USB-PERSIST</span>
<span class="cm">	 * port handover.  Otherwise it might see that a full-speed device</span>
<span class="cm">	 * was gone before the EHCI controller had handed its port over to</span>
<span class="cm">	 * the companion full-speed controller.</span>
<span class="cm">	 */</span>
	<span class="n">set_freezable</span><span class="p">();</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">hub_events</span><span class="p">();</span>
		<span class="n">wait_event_freezable</span><span class="p">(</span><span class="n">khubd_wait</span><span class="p">,</span>
				<span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub_event_list</span><span class="p">)</span> <span class="o">||</span>
				<span class="n">kthread_should_stop</span><span class="p">());</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub_event_list</span><span class="p">));</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: khubd exiting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usbcore_name</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="n">hub_id_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span> <span class="p">.</span><span class="n">match_flags</span> <span class="o">=</span> <span class="n">USB_DEVICE_ID_MATCH_DEV_CLASS</span><span class="p">,</span>
      <span class="p">.</span><span class="n">bDeviceClass</span> <span class="o">=</span> <span class="n">USB_CLASS_HUB</span><span class="p">},</span>
    <span class="p">{</span> <span class="p">.</span><span class="n">match_flags</span> <span class="o">=</span> <span class="n">USB_DEVICE_ID_MATCH_INT_CLASS</span><span class="p">,</span>
      <span class="p">.</span><span class="n">bInterfaceClass</span> <span class="o">=</span> <span class="n">USB_CLASS_HUB</span><span class="p">},</span>
    <span class="p">{</span> <span class="p">}</span>						<span class="cm">/* Terminating entry */</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span> <span class="p">(</span><span class="n">usb</span><span class="p">,</span> <span class="n">hub_id_table</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_driver</span> <span class="n">hub_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;hub&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span>	<span class="n">hub_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disconnect</span> <span class="o">=</span>	<span class="n">hub_disconnect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span>	<span class="n">hub_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span>	<span class="n">hub_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_resume</span> <span class="o">=</span>	<span class="n">hub_reset_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pre_reset</span> <span class="o">=</span>	<span class="n">hub_pre_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">post_reset</span> <span class="o">=</span>	<span class="n">hub_post_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">hub_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span>	<span class="n">hub_id_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">supports_autosuspend</span> <span class="o">=</span>	<span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">usb_hub_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub_driver</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: can&#39;t register hub driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">usbcore_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">khubd_task</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">hub_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;khubd&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">khubd_task</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Fall through if kernel_thread failed */</span>
	<span class="n">usb_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub_driver</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: can&#39;t start khubd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usbcore_name</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">usb_hub_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kthread_stop</span><span class="p">(</span><span class="n">khubd_task</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Hub resources are freed for us by usb_deregister. It calls</span>
<span class="cm">	 * usb_driver_purge on every device which in turn calls that</span>
<span class="cm">	 * devices disconnect function if it is using this driver.</span>
<span class="cm">	 * The hub_disconnect function takes care of releasing the</span>
<span class="cm">	 * individual hub resources. -greg</span>
<span class="cm">	 */</span>
	<span class="n">usb_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub_driver</span><span class="p">);</span>
<span class="p">}</span> <span class="cm">/* usb_hub_cleanup() */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">descriptors_changed</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_device_descriptor</span> <span class="o">*</span><span class="n">old_device_descriptor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">changed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">serial_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">old_length</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">length</span><span class="p">;</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">old_device_descriptor</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">old_device_descriptor</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Since the idVendor, idProduct, and bcdDevice values in the</span>
<span class="cm">	 * device descriptor haven&#39;t changed, we will assume the</span>
<span class="cm">	 * Manufacturer and Product strings haven&#39;t changed either.</span>
<span class="cm">	 * But the SerialNumber string could be different (e.g., a</span>
<span class="cm">	 * different flash card of the same brand).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">)</span>
		<span class="n">serial_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">serial_len</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bNumConfigurations</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">old_length</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">desc</span><span class="p">.</span><span class="n">wTotalLength</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">old_length</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no mem to re-read configs after reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* assume the worst */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bNumConfigurations</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">old_length</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">desc</span><span class="p">.</span><span class="n">wTotalLength</span><span class="p">);</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">usb_get_descriptor</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">USB_DT_CONFIG</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span>
				<span class="n">old_length</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">!=</span> <span class="n">old_length</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;config index %d, error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">index</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
			<span class="n">changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span> <span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">rawdescriptors</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">old_length</span><span class="p">)</span>
				<span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;config index %d changed (#%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">index</span><span class="p">,</span>
				<span class="p">((</span><span class="k">struct</span> <span class="n">usb_config_descriptor</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">)</span><span class="o">-&gt;</span>
					<span class="n">bConfigurationValue</span><span class="p">);</span>
			<span class="n">changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">changed</span> <span class="o">&amp;&amp;</span> <span class="n">serial_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">usb_string</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">iSerialNumber</span><span class="p">,</span>
				<span class="n">buf</span><span class="p">,</span> <span class="n">serial_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">serial_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;serial string error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">length</span><span class="p">);</span>
			<span class="n">changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;serial string changed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">changed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_reset_and_verify_device - perform a USB port reset to reinitialize a device</span>
<span class="cm"> * @udev: device to reset (not in SUSPENDED or NOTATTACHED state)</span>
<span class="cm"> *</span>
<span class="cm"> * WARNING - don&#39;t use this routine to reset a composite device</span>
<span class="cm"> * (one with multiple interfaces owned by separate drivers)!</span>
<span class="cm"> * Use usb_reset_device() instead.</span>
<span class="cm"> *</span>
<span class="cm"> * Do a port reset, reassign the device&#39;s address, and establish its</span>
<span class="cm"> * former operating configuration.  If the reset fails, or the device&#39;s</span>
<span class="cm"> * descriptors change from their values before the reset, or the original</span>
<span class="cm"> * configuration and altsettings cannot be restored, a flag will be set</span>
<span class="cm"> * telling khubd to pretend the device has been disconnected and then</span>
<span class="cm"> * re-connected.  All drivers will be unbound, and the device will be</span>
<span class="cm"> * re-enumerated and probed all over again.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if the reset succeeded, -ENODEV if the device has been</span>
<span class="cm"> * flagged for logical disconnection, or some other negative error code</span>
<span class="cm"> * if the reset wasn&#39;t even attempted.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must own the device lock.  For example, it&#39;s safe to use</span>
<span class="cm"> * this from a driver probe() routine after downloading new firmware.</span>
<span class="cm"> * For calls that might not occur during probe(), drivers should lock</span>
<span class="cm"> * the device using usb_lock_device_for_reset().</span>
<span class="cm"> *</span>
<span class="cm"> * Locking exception: This routine may also be called from within an</span>
<span class="cm"> * autoresume handler.  Such usage won&#39;t conflict with other tasks</span>
<span class="cm"> * holding the device lock because these tasks should always call</span>
<span class="cm"> * usb_autopm_resume_device(), thereby preventing any unwanted autoresume.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_reset_and_verify_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span>		<span class="o">*</span><span class="n">parent_hdev</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hub</span>			<span class="o">*</span><span class="n">parent_hub</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span>			<span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_device_descriptor</span>	<span class="n">descriptor</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">;</span>
	<span class="kt">int</span> 				<span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">port1</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">portnum</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_NOTATTACHED</span> <span class="o">||</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_SUSPENDED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device reset not allowed in state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent_hdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* this requires hcd-specific logic; see ohci_restart() */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s for root hub!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EISDIR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">parent_hub</span> <span class="o">=</span> <span class="n">hdev_to_hub</span><span class="p">(</span><span class="n">parent_hdev</span><span class="p">);</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">port1</span><span class="p">,</span> <span class="n">parent_hub</span><span class="o">-&gt;</span><span class="n">busy_bits</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SET_CONFIG_TRIES</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* ep0 maxpacket size may change; let the HCD know about it.</span>
<span class="cm">		 * Other endpoints will be handled by re-enumeration. */</span>
		<span class="n">usb_ep0_reinit</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">hub_port_init</span><span class="p">(</span><span class="n">parent_hub</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOTCONN</span> <span class="o">||</span> <span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">port1</span><span class="p">,</span> <span class="n">parent_hub</span><span class="o">-&gt;</span><span class="n">busy_bits</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">re_enumerate</span><span class="p">;</span>
 
	<span class="cm">/* Device might have changed firmware (DFU or similar) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">descriptors_changed</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descriptor</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device firmware changed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">descriptor</span><span class="p">;</span>	<span class="cm">/* for disconnect() calls */</span>
		<span class="k">goto</span> <span class="n">re_enumerate</span><span class="p">;</span>
  	<span class="p">}</span>

	<span class="cm">/* Restore the device&#39;s previous configuration */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">);</span>
	<span class="cm">/* Disable LPM while we reset the device and reinstall the alt settings.</span>
<span class="cm">	 * Device-initiated LPM settings, and system exit latency settings are</span>
<span class="cm">	 * cleared when the device is reset, so we have to set them up again.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_disable_lpm</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s Failed to disable LPM</span><span class="se">\n</span><span class="s">.&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_hcd_alloc_bandwidth</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Busted HC?  Not enough HCD resources for &quot;</span>
				<span class="s">&quot;old configuration.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">usb_enable_lpm</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">re_enumerate</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
			<span class="n">USB_REQ_SET_CONFIGURATION</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bConfigurationValue</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">USB_CTRL_SET_TIMEOUT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;can&#39;t restore configuration #%d (error=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bConfigurationValue</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">usb_enable_lpm</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">re_enumerate</span><span class="p">;</span>
  	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">);</span>
	<span class="n">usb_set_device_state</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">USB_STATE_CONFIGURED</span><span class="p">);</span>

	<span class="cm">/* Put interfaces back into the same altsettings as before.</span>
<span class="cm">	 * Don&#39;t bother to send the Set-Interface request for interfaces</span>
<span class="cm">	 * that were already in altsetting 0; besides being unnecessary,</span>
<span class="cm">	 * many devices can&#39;t handle it.  Instead just reset the host-side</span>
<span class="cm">	 * endpoint state.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumInterfaces</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_host_config</span> <span class="o">*</span><span class="n">config</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span> <span class="o">=</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">usb_interface_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>

		<span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bAlternateSetting</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">usb_disable_interface</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">intf</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
			<span class="n">usb_enable_interface</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">intf</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Let the bandwidth allocation function know that this</span>
<span class="cm">			 * device has been reset, and it will have to use</span>
<span class="cm">			 * alternate setting 0 as the current alternate setting.</span>
<span class="cm">			 */</span>
			<span class="n">intf</span><span class="o">-&gt;</span><span class="n">resetting_device</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_set_interface</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">bInterfaceNumber</span><span class="p">,</span>
					<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bAlternateSetting</span><span class="p">);</span>
			<span class="n">intf</span><span class="o">-&gt;</span><span class="n">resetting_device</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to restore interface %d &quot;</span>
				<span class="s">&quot;altsetting %d (error=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bInterfaceNumber</span><span class="p">,</span>
				<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bAlternateSetting</span><span class="p">,</span>
				<span class="n">ret</span><span class="p">);</span>
			<span class="n">usb_unlocked_enable_lpm</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">re_enumerate</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Now that the alt settings are re-installed, enable LPM. */</span>
	<span class="n">usb_unlocked_enable_lpm</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
<span class="nl">done:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 
<span class="nl">re_enumerate:</span>
	<span class="n">hub_port_logical_disconnect</span><span class="p">(</span><span class="n">parent_hub</span><span class="p">,</span> <span class="n">port1</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_reset_device - warn interface drivers and perform a USB port reset</span>
<span class="cm"> * @udev: device to reset (not in SUSPENDED or NOTATTACHED state)</span>
<span class="cm"> *</span>
<span class="cm"> * Warns all drivers bound to registered interfaces (using their pre_reset</span>
<span class="cm"> * method), performs the port reset, and then lets the drivers know that</span>
<span class="cm"> * the reset is over (using their post_reset method).</span>
<span class="cm"> *</span>
<span class="cm"> * Return value is the same as for usb_reset_and_verify_device().</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must own the device lock.  For example, it&#39;s safe to use</span>
<span class="cm"> * this from a driver probe() routine after downloading new firmware.</span>
<span class="cm"> * For calls that might not occur during probe(), drivers should lock</span>
<span class="cm"> * the device using usb_lock_device_for_reset().</span>
<span class="cm"> *</span>
<span class="cm"> * If an interface is currently being probed or disconnected, we assume</span>
<span class="cm"> * its driver knows how to handle resets.  For all other interfaces,</span>
<span class="cm"> * if the driver doesn&#39;t have pre_reset and post_reset methods then</span>
<span class="cm"> * we attempt to unbind it and rebind afterward.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_reset_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_config</span> <span class="o">*</span><span class="n">config</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_NOTATTACHED</span> <span class="o">||</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_SUSPENDED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device reset not allowed in state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Prevent autosuspend during the reset */</span>
	<span class="n">usb_autoresume_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">config</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumInterfaces</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">cintf</span> <span class="o">=</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">unbind</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">cintf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">drv</span> <span class="o">=</span> <span class="n">to_usb_driver</span><span class="p">(</span><span class="n">cintf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">pre_reset</span> <span class="o">&amp;&amp;</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">post_reset</span><span class="p">)</span>
					<span class="n">unbind</span> <span class="o">=</span> <span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">pre_reset</span><span class="p">)(</span><span class="n">cintf</span><span class="p">);</span>
				<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cintf</span><span class="o">-&gt;</span><span class="n">condition</span> <span class="o">==</span>
						<span class="n">USB_INTERFACE_BOUND</span><span class="p">)</span>
					<span class="n">unbind</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unbind</span><span class="p">)</span>
					<span class="n">usb_forced_unbind_intf</span><span class="p">(</span><span class="n">cintf</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_reset_and_verify_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">config</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumInterfaces</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">cintf</span> <span class="o">=</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">rebind</span> <span class="o">=</span> <span class="n">cintf</span><span class="o">-&gt;</span><span class="n">needs_binding</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rebind</span> <span class="o">&amp;&amp;</span> <span class="n">cintf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">drv</span> <span class="o">=</span> <span class="n">to_usb_driver</span><span class="p">(</span><span class="n">cintf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">post_reset</span><span class="p">)</span>
					<span class="n">rebind</span> <span class="o">=</span> <span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">post_reset</span><span class="p">)(</span><span class="n">cintf</span><span class="p">);</span>
				<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cintf</span><span class="o">-&gt;</span><span class="n">condition</span> <span class="o">==</span>
						<span class="n">USB_INTERFACE_BOUND</span><span class="p">)</span>
					<span class="n">rebind</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rebind</span><span class="p">)</span>
				<span class="n">usb_rebind_intf</span><span class="p">(</span><span class="n">cintf</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">usb_autosuspend_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_reset_device</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * usb_queue_reset_device - Reset a USB device from an atomic context</span>
<span class="cm"> * @iface: USB interface belonging to the device to reset</span>
<span class="cm"> *</span>
<span class="cm"> * This function can be used to reset a USB device from an atomic</span>
<span class="cm"> * context, where usb_reset_device() won&#39;t work (as it blocks).</span>
<span class="cm"> *</span>
<span class="cm"> * Doing a reset via this method is functionally equivalent to calling</span>
<span class="cm"> * usb_reset_device(), except for the fact that it is delayed to a</span>
<span class="cm"> * workqueue. This means that any drivers bound to other interfaces</span>
<span class="cm"> * might be unbound, as well as users from usbfs in user space.</span>
<span class="cm"> *</span>
<span class="cm"> * Corner cases:</span>
<span class="cm"> *</span>
<span class="cm"> * - Scheduling two resets at the same time from two different drivers</span>
<span class="cm"> *   attached to two different interfaces of the same device is</span>
<span class="cm"> *   possible; depending on how the driver attached to each interface</span>
<span class="cm"> *   handles -&gt;pre_reset(), the second reset might happen or not.</span>
<span class="cm"> *</span>
<span class="cm"> * - If a driver is unbound and it had a pending reset, the reset will</span>
<span class="cm"> *   be cancelled.</span>
<span class="cm"> *</span>
<span class="cm"> * - This function can be called during .probe() or .disconnect()</span>
<span class="cm"> *   times. On return from .disconnect(), any pending resets will be</span>
<span class="cm"> *   cancelled.</span>
<span class="cm"> *</span>
<span class="cm"> * There is no no need to lock/unlock the @reset_ws as schedule_work()</span>
<span class="cm"> * does its own.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: We don&#39;t do any reference count tracking because it is not</span>
<span class="cm"> *     needed. The lifecycle of the work_struct is tied to the</span>
<span class="cm"> *     usb_interface. Before destroying the interface we cancel the</span>
<span class="cm"> *     work_struct, so the fact that work_struct is queued and or</span>
<span class="cm"> *     running means the interface (and thus, the device) exist and</span>
<span class="cm"> *     are referenced.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_queue_reset_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">reset_ws</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_queue_reset_device</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
