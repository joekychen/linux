<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › core › urb.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>urb.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/log2.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/usb/hcd.h&gt;</span>

<span class="cp">#define to_urb(d) container_of(d, struct urb, kref)</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">urb_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span> <span class="o">=</span> <span class="n">to_urb</span><span class="p">(</span><span class="n">kref</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_FREE_BUFFER</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_init_urb - initializes a urb so that it can be used by a USB driver</span>
<span class="cm"> * @urb: pointer to the urb to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes a urb so that the USB subsystem can use it properly.</span>
<span class="cm"> *</span>
<span class="cm"> * If a urb is created with a call to usb_alloc_urb() it is not</span>
<span class="cm"> * necessary to call this function.  Only use this if you allocate the</span>
<span class="cm"> * space for a struct urb on your own.  If you call this function, be</span>
<span class="cm"> * careful when freeing the memory for your urb that it is no longer in</span>
<span class="cm"> * use by the USB core.</span>
<span class="cm"> *</span>
<span class="cm"> * Only use this function if you _really_ understand what you are doing.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_init_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">urb</span><span class="p">));</span>
		<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">anchor_list</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_init_urb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_alloc_urb - creates a new urb for a USB driver to use</span>
<span class="cm"> * @iso_packets: number of iso packets for this urb</span>
<span class="cm"> * @mem_flags: the type of memory to allocate, see kmalloc() for a list of</span>
<span class="cm"> *	valid options for this.</span>
<span class="cm"> *</span>
<span class="cm"> * Creates an urb for the USB driver to use, initializes a few internal</span>
<span class="cm"> * structures, incrementes the usage counter, and returns a pointer to it.</span>
<span class="cm"> *</span>
<span class="cm"> * If no memory is available, NULL is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * If the driver want to use this urb for interrupt, control, or bulk</span>
<span class="cm"> * endpoints, pass &#39;0&#39; as the number of iso packets.</span>
<span class="cm"> *</span>
<span class="cm"> * The driver must call usb_free_urb() when it is finished with the urb.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="nf">usb_alloc_urb</span><span class="p">(</span><span class="kt">int</span> <span class="n">iso_packets</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>

	<span class="n">urb</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">iso_packets</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_iso_packet_descriptor</span><span class="p">),</span>
		<span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;alloc_urb: kmalloc failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">usb_init_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">urb</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_alloc_urb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_free_urb - frees the memory used by a urb when all users of it are finished</span>
<span class="cm"> * @urb: pointer to the urb to free, may be NULL</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called when a user of a urb is finished with it.  When the last user</span>
<span class="cm"> * of the urb calls this function, the memory of the urb is freed.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: The transfer buffer associated with the urb is not freed unless the</span>
<span class="cm"> * URB_FREE_BUFFER transfer flag is set.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_free_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="p">)</span>
		<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="n">urb_destroy</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_free_urb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_get_urb - increments the reference count of the urb</span>
<span class="cm"> * @urb: pointer to the urb to modify, may be NULL</span>
<span class="cm"> *</span>
<span class="cm"> * This must be  called whenever a urb is transferred from a device driver to a</span>
<span class="cm"> * host controller driver.  This allows proper reference counting to happen</span>
<span class="cm"> * for urbs.</span>
<span class="cm"> *</span>
<span class="cm"> * A pointer to the urb with the incremented reference counter is returned.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="nf">usb_get_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="p">)</span>
		<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">urb</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_get_urb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_anchor_urb - anchors an URB while it is processed</span>
<span class="cm"> * @urb: pointer to the urb to anchor</span>
<span class="cm"> * @anchor: pointer to the anchor</span>
<span class="cm"> *</span>
<span class="cm"> * This can be called to have access to URBs which are to be executed</span>
<span class="cm"> * without bothering to track them</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_anchor_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_anchor</span> <span class="o">*</span><span class="n">anchor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">usb_get_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">anchor_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">);</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">anchor</span> <span class="o">=</span> <span class="n">anchor</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">poisoned</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">reject</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_anchor_urb</span><span class="p">);</span>

<span class="cm">/* Callers must hold anchor-&gt;lock */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__usb_unanchor_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_anchor</span> <span class="o">*</span><span class="n">anchor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">anchor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">anchor_list</span><span class="p">);</span>
	<span class="n">usb_put_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">))</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_unanchor_urb - unanchors an URB</span>
<span class="cm"> * @urb: pointer to the urb to anchor</span>
<span class="cm"> *</span>
<span class="cm"> * Call this to stop the system keeping track of this URB</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_unanchor_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_anchor</span> <span class="o">*</span><span class="n">anchor</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">anchor</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">anchor</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">anchor</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * At this point, we could be competing with another thread which</span>
<span class="cm">	 * has the same intention. To protect the urb from being unanchored</span>
<span class="cm">	 * twice, only the winner of the race gets the job.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">anchor</span> <span class="o">==</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">anchor</span><span class="p">))</span>
		<span class="n">__usb_unanchor_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">anchor</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_unanchor_urb</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------*/</span>

<span class="cm">/**</span>
<span class="cm"> * usb_submit_urb - issue an asynchronous transfer request for an endpoint</span>
<span class="cm"> * @urb: pointer to the urb describing the request</span>
<span class="cm"> * @mem_flags: the type of memory to allocate, see kmalloc() for a list</span>
<span class="cm"> *	of valid options for this.</span>
<span class="cm"> *</span>
<span class="cm"> * This submits a transfer request, and transfers control of the URB</span>
<span class="cm"> * describing that request to the USB subsystem.  Request completion will</span>
<span class="cm"> * be indicated later, asynchronously, by calling the completion handler.</span>
<span class="cm"> * The three types of completion are success, error, and unlink</span>
<span class="cm"> * (a software-induced fault, also called &quot;request cancellation&quot;).</span>
<span class="cm"> *</span>
<span class="cm"> * URBs may be submitted in interrupt context.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must have correctly initialized the URB before submitting</span>
<span class="cm"> * it.  Functions such as usb_fill_bulk_urb() and usb_fill_control_urb() are</span>
<span class="cm"> * available to ensure that most fields are correctly initialized, for</span>
<span class="cm"> * the particular kind of transfer, although they will not initialize</span>
<span class="cm"> * any transfer flags.</span>
<span class="cm"> *</span>
<span class="cm"> * Successful submissions return 0; otherwise this routine returns a</span>
<span class="cm"> * negative error number.  If the submission is successful, the complete()</span>
<span class="cm"> * callback from the URB will be called exactly once, when the USB core and</span>
<span class="cm"> * Host Controller Driver (HCD) are finished with the URB.  When the completion</span>
<span class="cm"> * function is called, control of the URB is returned to the device</span>
<span class="cm"> * driver which issued the request.  The completion handler may then</span>
<span class="cm"> * immediately free or reuse that URB.</span>
<span class="cm"> *</span>
<span class="cm"> * With few exceptions, USB device drivers should never access URB fields</span>
<span class="cm"> * provided by usbcore or the HCD until its complete() is called.</span>
<span class="cm"> * The exceptions relate to periodic transfer scheduling.  For both</span>
<span class="cm"> * interrupt and isochronous urbs, as part of successful URB submission</span>
<span class="cm"> * urb-&gt;interval is modified to reflect the actual transfer period used</span>
<span class="cm"> * (normally some power of two units).  And for isochronous urbs,</span>
<span class="cm"> * urb-&gt;start_frame is modified to reflect when the URB&#39;s transfers were</span>
<span class="cm"> * scheduled to start.  Not all isochronous transfer scheduling policies</span>
<span class="cm"> * will work, but most host controller drivers should easily handle ISO</span>
<span class="cm"> * queues going from now until 10-200 msec into the future.</span>
<span class="cm"> *</span>
<span class="cm"> * For control endpoints, the synchronous usb_control_msg() call is</span>
<span class="cm"> * often used (in non-interrupt context) instead of this call.</span>
<span class="cm"> * That is often used through convenience wrappers, for the requests</span>
<span class="cm"> * that are standardized in the USB 2.0 specification.  For bulk</span>
<span class="cm"> * endpoints, a synchronous usb_bulk_msg() call is available.</span>
<span class="cm"> *</span>
<span class="cm"> * Request Queuing:</span>
<span class="cm"> *</span>
<span class="cm"> * URBs may be submitted to endpoints before previous ones complete, to</span>
<span class="cm"> * minimize the impact of interrupt latencies and system overhead on data</span>
<span class="cm"> * throughput.  With that queuing policy, an endpoint&#39;s queue would never</span>
<span class="cm"> * be empty.  This is required for continuous isochronous data streams,</span>
<span class="cm"> * and may also be required for some kinds of interrupt transfers. Such</span>
<span class="cm"> * queuing also maximizes bandwidth utilization by letting USB controllers</span>
<span class="cm"> * start work on later requests before driver software has finished the</span>
<span class="cm"> * completion processing for earlier (successful) requests.</span>
<span class="cm"> *</span>
<span class="cm"> * As of Linux 2.6, all USB endpoint transfer queues support depths greater</span>
<span class="cm"> * than one.  This was previously a HCD-specific behavior, except for ISO</span>
<span class="cm"> * transfers.  Non-isochronous endpoint queues are inactive during cleanup</span>
<span class="cm"> * after faults (transfer errors or cancellation).</span>
<span class="cm"> *</span>
<span class="cm"> * Reserved Bandwidth Transfers:</span>
<span class="cm"> *</span>
<span class="cm"> * Periodic transfers (interrupt or isochronous) are performed repeatedly,</span>
<span class="cm"> * using the interval specified in the urb.  Submitting the first urb to</span>
<span class="cm"> * the endpoint reserves the bandwidth necessary to make those transfers.</span>
<span class="cm"> * If the USB subsystem can&#39;t allocate sufficient bandwidth to perform</span>
<span class="cm"> * the periodic request, submitting such a periodic request should fail.</span>
<span class="cm"> *</span>
<span class="cm"> * For devices under xHCI, the bandwidth is reserved at configuration time, or</span>
<span class="cm"> * when the alt setting is selected.  If there is not enough bus bandwidth, the</span>
<span class="cm"> * configuration/alt setting request will fail.  Therefore, submissions to</span>
<span class="cm"> * periodic endpoints on devices under xHCI should never fail due to bandwidth</span>
<span class="cm"> * constraints.</span>
<span class="cm"> *</span>
<span class="cm"> * Device drivers must explicitly request that repetition, by ensuring that</span>
<span class="cm"> * some URB is always on the endpoint&#39;s queue (except possibly for short</span>
<span class="cm"> * periods during completion callacks).  When there is no longer an urb</span>
<span class="cm"> * queued, the endpoint&#39;s bandwidth reservation is canceled.  This means</span>
<span class="cm"> * drivers can use their completion handlers to ensure they keep bandwidth</span>
<span class="cm"> * they need, by reinitializing and resubmitting the just-completed urb</span>
<span class="cm"> * until the driver longer needs that periodic bandwidth.</span>
<span class="cm"> *</span>
<span class="cm"> * Memory Flags:</span>
<span class="cm"> *</span>
<span class="cm"> * The general rules for how to decide which mem_flags to use</span>
<span class="cm"> * are the same as for kmalloc.  There are four</span>
<span class="cm"> * different possible values; GFP_KERNEL, GFP_NOFS, GFP_NOIO and</span>
<span class="cm"> * GFP_ATOMIC.</span>
<span class="cm"> *</span>
<span class="cm"> * GFP_NOFS is not ever used, as it has not been implemented yet.</span>
<span class="cm"> *</span>
<span class="cm"> * GFP_ATOMIC is used when</span>
<span class="cm"> *   (a) you are inside a completion handler, an interrupt, bottom half,</span>
<span class="cm"> *       tasklet or timer, or</span>
<span class="cm"> *   (b) you are holding a spinlock or rwlock (does not apply to</span>
<span class="cm"> *       semaphores), or</span>
<span class="cm"> *   (c) current-&gt;state != TASK_RUNNING, this is the case only after</span>
<span class="cm"> *       you&#39;ve changed it.</span>
<span class="cm"> *</span>
<span class="cm"> * GFP_NOIO is used in the block io path and error handling of storage</span>
<span class="cm"> * devices.</span>
<span class="cm"> *</span>
<span class="cm"> * All other situations use GFP_KERNEL.</span>
<span class="cm"> *</span>
<span class="cm"> * Some more specific rules for mem_flags can be inferred, such as</span>
<span class="cm"> *  (1) start_xmit, timeout, and receive methods of network drivers must</span>
<span class="cm"> *      use GFP_ATOMIC (they are called with a spinlock held);</span>
<span class="cm"> *  (2) queuecommand methods of scsi drivers must use GFP_ATOMIC (also</span>
<span class="cm"> *      called with a spinlock held);</span>
<span class="cm"> *  (3) If you use a kernel thread with a network driver you must use</span>
<span class="cm"> *      GFP_NOIO, unless (b) or (c) apply;</span>
<span class="cm"> *  (4) after you have done a down() you can use GFP_KERNEL, unless (b) or (c)</span>
<span class="cm"> *      apply or your are in a storage driver&#39;s block io path;</span>
<span class="cm"> *  (5) USB probe and disconnect can use GFP_KERNEL unless (b) or (c) apply; and</span>
<span class="cm"> *  (6) changing firmware on a running storage or net device uses</span>
<span class="cm"> *      GFP_NOIO, unless b) or c) apply</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_submit_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>				<span class="n">xfertype</span><span class="p">,</span> <span class="n">max</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span>		<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span>	<span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">is_out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span> <span class="o">||</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">||</span> <span class="o">!</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;</span> <span class="n">USB_STATE_UNAUTHENTICATED</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* For now, get the endpoint from the pipe.  Eventually drivers</span>
<span class="cm">	 * will be required to set urb-&gt;ep directly and we will eliminate</span>
<span class="cm">	 * urb-&gt;pipe.</span>
<span class="cm">	 */</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">usb_pipe_endpoint</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Lots of sanity checks, so HCDs can rely on clean data</span>
<span class="cm">	 * and don&#39;t need to duplicate tests</span>
<span class="cm">	 */</span>
	<span class="n">xfertype</span> <span class="o">=</span> <span class="n">usb_endpoint_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfertype</span> <span class="o">==</span> <span class="n">USB_ENDPOINT_XFER_CONTROL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">setup</span> <span class="o">=</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="p">)</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">setup_packet</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">setup</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
		<span class="n">is_out</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">)</span> <span class="o">||</span>
				<span class="o">!</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">wLength</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">is_out</span> <span class="o">=</span> <span class="n">usb_endpoint_dir_out</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Clear the internal flags and cache the direction for later use */</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">URB_DIR_MASK</span> <span class="o">|</span> <span class="n">URB_DMA_MAP_SINGLE</span> <span class="o">|</span>
			<span class="n">URB_DMA_MAP_PAGE</span> <span class="o">|</span> <span class="n">URB_DMA_MAP_SG</span> <span class="o">|</span> <span class="n">URB_MAP_LOCAL</span> <span class="o">|</span>
			<span class="n">URB_SETUP_MAP_SINGLE</span> <span class="o">|</span> <span class="n">URB_SETUP_MAP_LOCAL</span> <span class="o">|</span>
			<span class="n">URB_DMA_SG_COMBINED</span><span class="p">);</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">is_out</span> <span class="o">?</span> <span class="n">URB_DIR_OUT</span> <span class="o">:</span> <span class="n">URB_DIR_IN</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xfertype</span> <span class="o">!=</span> <span class="n">USB_ENDPOINT_XFER_CONTROL</span> <span class="o">&amp;&amp;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;</span> <span class="n">USB_STATE_CONFIGURED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">max</span> <span class="o">=</span> <span class="n">usb_endpoint_maxp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;bogus endpoint ep%d%s in %s (bad maxpacket %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">usb_endpoint_num</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">),</span> <span class="n">is_out</span> <span class="o">?</span> <span class="s">&quot;out&quot;</span> <span class="o">:</span> <span class="s">&quot;in&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* periodic transfers limit size per frame/uframe,</span>
<span class="cm">	 * but drivers only control those sizes for ISO.</span>
<span class="cm">	 * while we&#39;re checking, initialize return status.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfertype</span> <span class="o">==</span> <span class="n">USB_ENDPOINT_XFER_ISOC</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">n</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>

		<span class="cm">/* SuperSpeed isoc endpoints have up to 16 bursts of up to</span>
<span class="cm">		 * 3 packets each</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_SUPER</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span>     <span class="n">burst</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ss_ep_comp</span><span class="p">.</span><span class="n">bMaxBurst</span><span class="p">;</span>
			<span class="kt">int</span>     <span class="n">mult</span> <span class="o">=</span> <span class="n">USB_SS_MULT</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ss_ep_comp</span><span class="p">.</span><span class="n">bmAttributes</span><span class="p">);</span>
			<span class="n">max</span> <span class="o">*=</span> <span class="n">burst</span><span class="p">;</span>
			<span class="n">max</span> <span class="o">*=</span> <span class="n">mult</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* &quot;high bandwidth&quot; mode, 1-3 packets/uframe? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span>	<span class="n">mult</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">((</span><span class="n">max</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">);</span>
			<span class="n">max</span> <span class="o">&amp;=</span> <span class="mh">0x07ff</span><span class="p">;</span>
			<span class="n">max</span> <span class="o">*=</span> <span class="n">mult</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">length</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EXDEV</span><span class="p">;</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">actual_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* the I/O buffer must be mapped/unmapped, except when length=0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">&gt;</span> <span class="n">INT_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="cm">/* stuff that drivers shouldn&#39;t do, but which shouldn&#39;t</span>
<span class="cm">	 * cause problems in HCDs if they get it wrong.</span>
<span class="cm">	 */</span>
	<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">allowed</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">pipetypes</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">PIPE_CONTROL</span><span class="p">,</span> <span class="n">PIPE_ISOCHRONOUS</span><span class="p">,</span> <span class="n">PIPE_BULK</span><span class="p">,</span> <span class="n">PIPE_INTERRUPT</span>
	<span class="p">};</span>

	<span class="cm">/* Check that the pipe&#39;s type matches the endpoint&#39;s type */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipetype</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pipetypes</span><span class="p">[</span><span class="n">xfertype</span><span class="p">])</span>
		<span class="n">dev_WARN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BOGUS urb xfer, pipe %x != type %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">usb_pipetype</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">),</span> <span class="n">pipetypes</span><span class="p">[</span><span class="n">xfertype</span><span class="p">]);</span>

	<span class="cm">/* Check against a simple/standard policy */</span>
	<span class="n">allowed</span> <span class="o">=</span> <span class="p">(</span><span class="n">URB_NO_TRANSFER_DMA_MAP</span> <span class="o">|</span> <span class="n">URB_NO_INTERRUPT</span> <span class="o">|</span> <span class="n">URB_DIR_MASK</span> <span class="o">|</span>
			<span class="n">URB_FREE_BUFFER</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">xfertype</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_BULK</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">is_out</span><span class="p">)</span>
			<span class="n">allowed</span> <span class="o">|=</span> <span class="n">URB_ZERO_PACKET</span><span class="p">;</span>
		<span class="cm">/* FALLTHROUGH */</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_CONTROL</span>:
		<span class="n">allowed</span> <span class="o">|=</span> <span class="n">URB_NO_FSBR</span><span class="p">;</span>	<span class="cm">/* only affects UHCI */</span>
		<span class="cm">/* FALLTHROUGH */</span>
	<span class="nl">default:</span>			<span class="cm">/* all non-iso endpoints */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_out</span><span class="p">)</span>
			<span class="n">allowed</span> <span class="o">|=</span> <span class="n">URB_SHORT_NOT_OK</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_ISOC</span>:
		<span class="n">allowed</span> <span class="o">|=</span> <span class="n">URB_ISO_ASAP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">allowed</span> <span class="o">&amp;=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span><span class="p">;</span>

	<span class="cm">/* warn if submitter gave bogus flags */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">allowed</span> <span class="o">!=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span><span class="p">)</span>
		<span class="n">dev_WARN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BOGUS urb flags, %x --&gt; %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span><span class="p">,</span> <span class="n">allowed</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * Force periodic transfer intervals to be legal values that are</span>
<span class="cm">	 * a power of two (so HCDs don&#39;t need to).</span>
<span class="cm">	 *</span>
<span class="cm">	 * FIXME want bus-&gt;{intr,iso}_sched_horizon values here.  Each HC</span>
<span class="cm">	 * supports different values... this uses EHCI/UHCI defaults (and</span>
<span class="cm">	 * EHCI can use smaller non-default values).</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">xfertype</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_ISOC</span>:
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_INT</span>:
		<span class="cm">/* too small? */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">USB_SPEED_WIRELESS</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* too big? */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">USB_SPEED_SUPER</span>:	<span class="cm">/* units are 125us */</span>
			<span class="cm">/* Handle up to 2^(16-1) microframes */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">max</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_SPEED_WIRELESS</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_SPEED_HIGH</span>:	<span class="cm">/* units are microframes */</span>
			<span class="cm">/* NOTE usb handles 2^15 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1024</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">=</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">max</span> <span class="o">=</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_SPEED_FULL</span>:	<span class="cm">/* units are frames/msec */</span>
		<span class="k">case</span> <span class="n">USB_SPEED_LOW</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">xfertype</span> <span class="o">==</span> <span class="n">USB_ENDPOINT_XFER_INT</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="cm">/* NOTE ohci only handles up to 32 */</span>
				<span class="n">max</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">&gt;</span> <span class="mi">1024</span><span class="p">)</span>
					<span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
				<span class="cm">/* NOTE usb and ohci handle up to 2^15 */</span>
				<span class="n">max</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">USB_SPEED_WIRELESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Round down to a power of 2, no more than max */</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">max</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">usb_hcd_submit_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_submit_urb</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------*/</span>

<span class="cm">/**</span>
<span class="cm"> * usb_unlink_urb - abort/cancel a transfer request for an endpoint</span>
<span class="cm"> * @urb: pointer to urb describing a previously submitted request,</span>
<span class="cm"> *	may be NULL</span>
<span class="cm"> *</span>
<span class="cm"> * This routine cancels an in-progress request.  URBs complete only once</span>
<span class="cm"> * per submission, and may be canceled only once per submission.</span>
<span class="cm"> * Successful cancellation means termination of @urb will be expedited</span>
<span class="cm"> * and the completion handler will be called with a status code</span>
<span class="cm"> * indicating that the request has been canceled (rather than any other</span>
<span class="cm"> * code).</span>
<span class="cm"> *</span>
<span class="cm"> * Drivers should not call this routine or related routines, such as</span>
<span class="cm"> * usb_kill_urb() or usb_unlink_anchored_urbs(), after their disconnect</span>
<span class="cm"> * method has returned.  The disconnect function should synchronize with</span>
<span class="cm"> * a driver&#39;s I/O routines to insure that all URB-related activity has</span>
<span class="cm"> * completed before it returns.</span>
<span class="cm"> *</span>
<span class="cm"> * This request is asynchronous, however the HCD might call the -&gt;complete()</span>
<span class="cm"> * callback during unlink. Therefore when drivers call usb_unlink_urb(), they</span>
<span class="cm"> * must not hold any locks that may be taken by the completion function.</span>
<span class="cm"> * Success is indicated by returning -EINPROGRESS, at which time the URB will</span>
<span class="cm"> * probably not yet have been given back to the device driver. When it is</span>
<span class="cm"> * eventually called, the completion function will see @urb-&gt;status ==</span>
<span class="cm"> * -ECONNRESET.</span>
<span class="cm"> * Failure is indicated by usb_unlink_urb() returning any other value.</span>
<span class="cm"> * Unlinking will fail when @urb is not currently &quot;linked&quot; (i.e., it was</span>
<span class="cm"> * never submitted, or it was unlinked before, or the hardware is already</span>
<span class="cm"> * finished with it), even if the completion handler has not yet run.</span>
<span class="cm"> *</span>
<span class="cm"> * The URB must not be deallocated while this routine is running.  In</span>
<span class="cm"> * particular, when a driver calls this routine, it must insure that the</span>
<span class="cm"> * completion handler cannot deallocate the URB.</span>
<span class="cm"> *</span>
<span class="cm"> * Unlinking and Endpoint Queues:</span>
<span class="cm"> *</span>
<span class="cm"> * [The behaviors and guarantees described below do not apply to virtual</span>
<span class="cm"> * root hubs but only to endpoint queues for physical USB devices.]</span>
<span class="cm"> *</span>
<span class="cm"> * Host Controller Drivers (HCDs) place all the URBs for a particular</span>
<span class="cm"> * endpoint in a queue.  Normally the queue advances as the controller</span>
<span class="cm"> * hardware processes each request.  But when an URB terminates with an</span>
<span class="cm"> * error its queue generally stops (see below), at least until that URB&#39;s</span>
<span class="cm"> * completion routine returns.  It is guaranteed that a stopped queue</span>
<span class="cm"> * will not restart until all its unlinked URBs have been fully retired,</span>
<span class="cm"> * with their completion routines run, even if that&#39;s not until some time</span>
<span class="cm"> * after the original completion handler returns.  The same behavior and</span>
<span class="cm"> * guarantee apply when an URB terminates because it was unlinked.</span>
<span class="cm"> *</span>
<span class="cm"> * Bulk and interrupt endpoint queues are guaranteed to stop whenever an</span>
<span class="cm"> * URB terminates with any sort of error, including -ECONNRESET, -ENOENT,</span>
<span class="cm"> * and -EREMOTEIO.  Control endpoint queues behave the same way except</span>
<span class="cm"> * that they are not guaranteed to stop for -EREMOTEIO errors.  Queues</span>
<span class="cm"> * for isochronous endpoints are treated differently, because they must</span>
<span class="cm"> * advance at fixed rates.  Such queues do not stop when an URB</span>
<span class="cm"> * encounters an error or is unlinked.  An unlinked isochronous URB may</span>
<span class="cm"> * leave a gap in the stream of packets; it is undefined whether such</span>
<span class="cm"> * gaps can be filled in.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that early termination of an URB because a short packet was</span>
<span class="cm"> * received will generate a -EREMOTEIO error if and only if the</span>
<span class="cm"> * URB_SHORT_NOT_OK flag is set.  By setting this flag, USB device</span>
<span class="cm"> * drivers can build deep queues for large or complex bulk transfers</span>
<span class="cm"> * and clean them up reliably after any sort of aborted transfer by</span>
<span class="cm"> * unlinking all pending URBs at the first fault.</span>
<span class="cm"> *</span>
<span class="cm"> * When a control URB terminates with an error other than -EREMOTEIO, it</span>
<span class="cm"> * is quite likely that the status stage of the transfer will not take</span>
<span class="cm"> * place.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_unlink_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIDRM</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">usb_hcd_unlink_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_unlink_urb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_kill_urb - cancel a transfer request and wait for it to finish</span>
<span class="cm"> * @urb: pointer to URB describing a previously submitted request,</span>
<span class="cm"> *	may be NULL</span>
<span class="cm"> *</span>
<span class="cm"> * This routine cancels an in-progress request.  It is guaranteed that</span>
<span class="cm"> * upon return all completion handlers will have finished and the URB</span>
<span class="cm"> * will be totally idle and available for reuse.  These features make</span>
<span class="cm"> * this an ideal way to stop I/O in a disconnect() callback or close()</span>
<span class="cm"> * function.  If the request has not already finished or been unlinked</span>
<span class="cm"> * the completion handler will see urb-&gt;status == -ENOENT.</span>
<span class="cm"> *</span>
<span class="cm"> * While the routine is running, attempts to resubmit the URB will fail</span>
<span class="cm"> * with error -EPERM.  Thus even if the URB&#39;s completion handler always</span>
<span class="cm"> * tries to resubmit, it will not succeed and the URB will become idle.</span>
<span class="cm"> *</span>
<span class="cm"> * The URB must not be deallocated while this routine is running.  In</span>
<span class="cm"> * particular, when a driver calls this routine, it must insure that the</span>
<span class="cm"> * completion handler cannot deallocate the URB.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine may not be used in an interrupt context (such as a bottom</span>
<span class="cm"> * half or a completion handler), or when holding a spinlock, or in other</span>
<span class="cm"> * situations where the caller can&#39;t schedule().</span>
<span class="cm"> *</span>
<span class="cm"> * This routine should not be called by a driver after its disconnect</span>
<span class="cm"> * method has returned.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_kill_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">urb</span> <span class="o">&amp;&amp;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">&amp;&amp;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">reject</span><span class="p">);</span>

	<span class="n">usb_hcd_unlink_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">usb_kill_urb_queue</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">use_count</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">reject</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_kill_urb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_poison_urb - reliably kill a transfer and prevent further use of an URB</span>
<span class="cm"> * @urb: pointer to URB describing a previously submitted request,</span>
<span class="cm"> *	may be NULL</span>
<span class="cm"> *</span>
<span class="cm"> * This routine cancels an in-progress request.  It is guaranteed that</span>
<span class="cm"> * upon return all completion handlers will have finished and the URB</span>
<span class="cm"> * will be totally idle and cannot be reused.  These features make</span>
<span class="cm"> * this an ideal way to stop I/O in a disconnect() callback.</span>
<span class="cm"> * If the request has not already finished or been unlinked</span>
<span class="cm"> * the completion handler will see urb-&gt;status == -ENOENT.</span>
<span class="cm"> *</span>
<span class="cm"> * After and while the routine runs, attempts to resubmit the URB will fail</span>
<span class="cm"> * with error -EPERM.  Thus even if the URB&#39;s completion handler always</span>
<span class="cm"> * tries to resubmit, it will not succeed and the URB will become idle.</span>
<span class="cm"> *</span>
<span class="cm"> * The URB must not be deallocated while this routine is running.  In</span>
<span class="cm"> * particular, when a driver calls this routine, it must insure that the</span>
<span class="cm"> * completion handler cannot deallocate the URB.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine may not be used in an interrupt context (such as a bottom</span>
<span class="cm"> * half or a completion handler), or when holding a spinlock, or in other</span>
<span class="cm"> * situations where the caller can&#39;t schedule().</span>
<span class="cm"> *</span>
<span class="cm"> * This routine should not be called by a driver after its disconnect</span>
<span class="cm"> * method has returned.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_poison_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">urb</span> <span class="o">&amp;&amp;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">&amp;&amp;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">reject</span><span class="p">);</span>

	<span class="n">usb_hcd_unlink_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">usb_kill_urb_queue</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">use_count</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_poison_urb</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">usb_unpoison_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">reject</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_unpoison_urb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_block_urb - reliably prevent further use of an URB</span>
<span class="cm"> * @urb: pointer to URB to be blocked, may be NULL</span>
<span class="cm"> *</span>
<span class="cm"> * After the routine has run, attempts to resubmit the URB will fail</span>
<span class="cm"> * with error -EPERM.  Thus even if the URB&#39;s completion handler always</span>
<span class="cm"> * tries to resubmit, it will not succeed and the URB will become idle.</span>
<span class="cm"> *</span>
<span class="cm"> * The URB must not be deallocated while this routine is running.  In</span>
<span class="cm"> * particular, when a driver calls this routine, it must insure that the</span>
<span class="cm"> * completion handler cannot deallocate the URB.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_block_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">reject</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_block_urb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_kill_anchored_urbs - cancel transfer requests en masse</span>
<span class="cm"> * @anchor: anchor the requests are bound to</span>
<span class="cm"> *</span>
<span class="cm"> * this allows all outstanding URBs to be killed starting</span>
<span class="cm"> * from the back of the queue</span>
<span class="cm"> *</span>
<span class="cm"> * This routine should not be called by a driver after its disconnect</span>
<span class="cm"> * method has returned.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_kill_anchored_urbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_anchor</span> <span class="o">*</span><span class="n">anchor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">victim</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">victim</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span><span class="p">,</span>
				    <span class="n">anchor_list</span><span class="p">);</span>
		<span class="cm">/* we must make sure the URB isn&#39;t freed before we kill it*/</span>
		<span class="n">usb_get_urb</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="cm">/* this will unanchor the URB */</span>
		<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
		<span class="n">usb_put_urb</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_kill_anchored_urbs</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * usb_poison_anchored_urbs - cease all traffic from an anchor</span>
<span class="cm"> * @anchor: anchor the requests are bound to</span>
<span class="cm"> *</span>
<span class="cm"> * this allows all outstanding URBs to be poisoned starting</span>
<span class="cm"> * from the back of the queue. Newly added URBs will also be</span>
<span class="cm"> * poisoned</span>
<span class="cm"> *</span>
<span class="cm"> * This routine should not be called by a driver after its disconnect</span>
<span class="cm"> * method has returned.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_poison_anchored_urbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_anchor</span> <span class="o">*</span><span class="n">anchor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">victim</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">anchor</span><span class="o">-&gt;</span><span class="n">poisoned</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">victim</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span><span class="p">,</span>
				    <span class="n">anchor_list</span><span class="p">);</span>
		<span class="cm">/* we must make sure the URB isn&#39;t freed before we kill it*/</span>
		<span class="n">usb_get_urb</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="cm">/* this will unanchor the URB */</span>
		<span class="n">usb_poison_urb</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
		<span class="n">usb_put_urb</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_poison_anchored_urbs</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_unpoison_anchored_urbs - let an anchor be used successfully again</span>
<span class="cm"> * @anchor: anchor the requests are bound to</span>
<span class="cm"> *</span>
<span class="cm"> * Reverses the effect of usb_poison_anchored_urbs</span>
<span class="cm"> * the anchor can be used normally after it returns</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_unpoison_anchored_urbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_anchor</span> <span class="o">*</span><span class="n">anchor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">lazarus</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lazarus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">,</span> <span class="n">anchor_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_unpoison_urb</span><span class="p">(</span><span class="n">lazarus</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">anchor</span><span class="o">-&gt;</span><span class="n">poisoned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_unpoison_anchored_urbs</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * usb_unlink_anchored_urbs - asynchronously cancel transfer requests en masse</span>
<span class="cm"> * @anchor: anchor the requests are bound to</span>
<span class="cm"> *</span>
<span class="cm"> * this allows all outstanding URBs to be unlinked starting</span>
<span class="cm"> * from the back of the queue. This function is asynchronous.</span>
<span class="cm"> * The unlinking is just tiggered. It may happen after this</span>
<span class="cm"> * function has returned.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine should not be called by a driver after its disconnect</span>
<span class="cm"> * method has returned.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_unlink_anchored_urbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_anchor</span> <span class="o">*</span><span class="n">anchor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">victim</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">victim</span> <span class="o">=</span> <span class="n">usb_get_from_anchor</span><span class="p">(</span><span class="n">anchor</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_unlink_urb</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
		<span class="n">usb_put_urb</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_unlink_anchored_urbs</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_wait_anchor_empty_timeout - wait for an anchor to be unused</span>
<span class="cm"> * @anchor: the anchor you want to become unused</span>
<span class="cm"> * @timeout: how long you are willing to wait in milliseconds</span>
<span class="cm"> *</span>
<span class="cm"> * Call this is you want to be sure all an anchor&#39;s</span>
<span class="cm"> * URBs have finished</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_wait_anchor_empty_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_anchor</span> <span class="o">*</span><span class="n">anchor</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">wait_event_timeout</span><span class="p">(</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">),</span>
				  <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">timeout</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_wait_anchor_empty_timeout</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_get_from_anchor - get an anchor&#39;s oldest urb</span>
<span class="cm"> * @anchor: the anchor whose urb you want</span>
<span class="cm"> *</span>
<span class="cm"> * this will take the oldest urb from an anchor,</span>
<span class="cm"> * unanchor and return it</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="nf">usb_get_from_anchor</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_anchor</span> <span class="o">*</span><span class="n">anchor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">victim</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">victim</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span><span class="p">,</span>
				    <span class="n">anchor_list</span><span class="p">);</span>
		<span class="n">usb_get_urb</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
		<span class="n">__usb_unanchor_urb</span><span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">anchor</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">victim</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">victim</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_get_from_anchor</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_scuttle_anchored_urbs - unanchor all an anchor&#39;s urbs</span>
<span class="cm"> * @anchor: the anchor whose urbs you want to unanchor</span>
<span class="cm"> *</span>
<span class="cm"> * use this to get rid of all an anchor&#39;s urbs</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_scuttle_anchored_urbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_anchor</span> <span class="o">*</span><span class="n">anchor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">victim</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">victim</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span><span class="p">,</span>
				    <span class="n">anchor_list</span><span class="p">);</span>
		<span class="n">__usb_unanchor_urb</span><span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">anchor</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_scuttle_anchored_urbs</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_anchor_empty - is an anchor empty</span>
<span class="cm"> * @anchor: the anchor you want to query</span>
<span class="cm"> *</span>
<span class="cm"> * returns 1 if the anchor has no urbs associated with it</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_anchor_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_anchor</span> <span class="o">*</span><span class="n">anchor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_anchor_empty</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
