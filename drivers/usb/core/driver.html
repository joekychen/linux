<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › core › driver.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>driver.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * drivers/usb/driver.c - most of the driver model stuff for usb</span>
<span class="cm"> *</span>
<span class="cm"> * (C) Copyright 2005 Greg Kroah-Hartman &lt;gregkh@suse.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * based on drivers/usb/usb.c which had the following copyrights:</span>
<span class="cm"> *	(C) Copyright Linus Torvalds 1999</span>
<span class="cm"> *	(C) Copyright Johannes Erdfelt 1999-2001</span>
<span class="cm"> *	(C) Copyright Andreas Gal 1999</span>
<span class="cm"> *	(C) Copyright Gregory P. Smith 1999</span>
<span class="cm"> *	(C) Copyright Deti Fliegl 1999 (new USB architecture)</span>
<span class="cm"> *	(C) Copyright Randy Dunlap 2000</span>
<span class="cm"> *	(C) Copyright David Brownell 2000-2004</span>
<span class="cm"> *	(C) Copyright Yggdrasil Computing, Inc. 2000</span>
<span class="cm"> *		(usb_device_id matching changes by Adam J. Richter)</span>
<span class="cm"> *	(C) Copyright Greg Kroah-Hartman 2002-2003</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE! This is not actually a driver at all, rather this is</span>
<span class="cm"> * just a collection of helper routines that implement the</span>
<span class="cm"> * matching, probing, releasing, suspending and resuming for</span>
<span class="cm"> * real drivers.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/usb/quirks.h&gt;</span>
<span class="cp">#include &lt;linux/usb/hcd.h&gt;</span>

<span class="cp">#include &quot;usb.h&quot;</span>


<span class="cp">#ifdef CONFIG_HOTPLUG</span>

<span class="cm">/*</span>
<span class="cm"> * Adds a new dynamic USBdevice ID to this driver,</span>
<span class="cm"> * and cause the driver to probe for all devices again.</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">usb_store_new_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_dynids</span> <span class="o">*</span><span class="n">dynids</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_dynid</span> <span class="o">*</span><span class="n">dynid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">idVendor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">idProduct</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bInterfaceClass</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fields</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fields</span> <span class="o">=</span> <span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%x %x %x&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idVendor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idProduct</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">bInterfaceClass</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fields</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">dynid</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dynid</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dynid</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dynid</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="n">dynid</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">idVendor</span> <span class="o">=</span> <span class="n">idVendor</span><span class="p">;</span>
	<span class="n">dynid</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">idProduct</span> <span class="o">=</span> <span class="n">idProduct</span><span class="p">;</span>
	<span class="n">dynid</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">match_flags</span> <span class="o">=</span> <span class="n">USB_DEVICE_ID_MATCH_DEVICE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fields</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dynid</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">bInterfaceClass</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span><span class="n">bInterfaceClass</span><span class="p">;</span>
		<span class="n">dynid</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">match_flags</span> <span class="o">|=</span> <span class="n">USB_DEVICE_ID_MATCH_INT_CLASS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dynids</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dynid</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dynids</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dynids</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">driver_attach</span><span class="p">(</span><span class="n">driver</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_store_new_id</span><span class="p">);</span>

<span class="kt">ssize_t</span> <span class="nf">usb_show_dynids</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_dynids</span> <span class="o">*</span><span class="n">dynids</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_dynid</span> <span class="o">*</span><span class="n">dynid</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dynid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dynids</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dynid</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">bInterfaceClass</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">count</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">count</span><span class="p">],</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">count</span><span class="p">,</span> <span class="s">&quot;%04x %04x %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">dynid</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">idVendor</span><span class="p">,</span> <span class="n">dynid</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">idProduct</span><span class="p">,</span>
					   <span class="n">dynid</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">bInterfaceClass</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">count</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">count</span><span class="p">],</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">count</span><span class="p">,</span> <span class="s">&quot;%04x %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">dynid</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">idVendor</span><span class="p">,</span> <span class="n">dynid</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">idProduct</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_show_dynids</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">show_dynids</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">usb_drv</span> <span class="o">=</span> <span class="n">to_usb_driver</span><span class="p">(</span><span class="n">driver</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">usb_show_dynids</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_drv</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">store_new_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">usb_drv</span> <span class="o">=</span> <span class="n">to_usb_driver</span><span class="p">(</span><span class="n">driver</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">usb_store_new_id</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_drv</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">,</span> <span class="n">driver</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DRIVER_ATTR</span><span class="p">(</span><span class="n">new_id</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">show_dynids</span><span class="p">,</span> <span class="n">store_new_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * store_remove_id - remove a USB device ID from this driver</span>
<span class="cm"> * @driver: target device driver</span>
<span class="cm"> * @buf: buffer for scanning device ID data</span>
<span class="cm"> * @count: input size</span>
<span class="cm"> *</span>
<span class="cm"> * Removes a dynamic usb device ID from this driver.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">store_remove_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_dynid</span> <span class="o">*</span><span class="n">dynid</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">usb_driver</span> <span class="o">=</span> <span class="n">to_usb_driver</span><span class="p">(</span><span class="n">driver</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">idVendor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">idProduct</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fields</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fields</span> <span class="o">=</span> <span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%x %x&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idVendor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idProduct</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fields</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_driver</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">dynid</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usb_driver</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dynid</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">idVendor</span> <span class="o">==</span> <span class="n">idVendor</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">idProduct</span> <span class="o">==</span> <span class="n">idProduct</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dynid</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">dynid</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_driver</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DRIVER_ATTR</span><span class="p">(</span><span class="n">remove_id</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">show_dynids</span><span class="p">,</span> <span class="n">store_remove_id</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_create_newid_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">usb_drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_drv</span><span class="o">-&gt;</span><span class="n">no_dynamic_id</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_drv</span><span class="o">-&gt;</span><span class="n">probe</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">driver_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_drv</span><span class="o">-&gt;</span><span class="n">drvwrap</span><span class="p">.</span><span class="n">driver</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">driver_attr_new_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">driver_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_drv</span><span class="o">-&gt;</span><span class="n">drvwrap</span><span class="p">.</span><span class="n">driver</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">driver_attr_remove_id</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="n">driver_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_drv</span><span class="o">-&gt;</span><span class="n">drvwrap</span><span class="p">.</span><span class="n">driver</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">driver_attr_new_id</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">exit:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usb_remove_newid_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">usb_drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_drv</span><span class="o">-&gt;</span><span class="n">no_dynamic_id</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_drv</span><span class="o">-&gt;</span><span class="n">probe</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">driver_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_drv</span><span class="o">-&gt;</span><span class="n">drvwrap</span><span class="p">.</span><span class="n">driver</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">driver_attr_remove_id</span><span class="p">);</span>
		<span class="n">driver_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_drv</span><span class="o">-&gt;</span><span class="n">drvwrap</span><span class="p">.</span><span class="n">driver</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">driver_attr_new_id</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usb_free_dynids</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">usb_drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_dynid</span> <span class="o">*</span><span class="n">dynid</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_drv</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">dynid</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usb_drv</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dynid</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dynid</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_drv</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usb_create_newid_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">usb_drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">usb_remove_newid_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">usb_drv</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usb_free_dynids</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">usb_drv</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="nf">usb_match_dynamic_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span>
							<span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_dynid</span> <span class="o">*</span><span class="n">dynid</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dynid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">usb_match_one_id</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dynid</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="n">dynid</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* called from driver core with dev locked */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_probe_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device_driver</span> <span class="o">*</span><span class="n">udriver</span> <span class="o">=</span> <span class="n">to_usb_device_driver</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">to_usb_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* TODO: Add real matching code */</span>

	<span class="cm">/* The device should always appear to be in use</span>
<span class="cm">	 * unless the driver suports autosuspend.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udriver</span><span class="o">-&gt;</span><span class="n">supports_autosuspend</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">usb_autoresume_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">udriver</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* called from driver core with dev locked */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_unbind_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">to_usb_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_device_driver</span> <span class="o">*</span><span class="n">udriver</span> <span class="o">=</span> <span class="n">to_usb_device_driver</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>

	<span class="n">udriver</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udriver</span><span class="o">-&gt;</span><span class="n">supports_autosuspend</span><span class="p">)</span>
		<span class="n">usb_autosuspend_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Cancel any pending scheduled resets</span>
<span class="cm"> *</span>
<span class="cm"> * [see usb_queue_reset_device()]</span>
<span class="cm"> *</span>
<span class="cm"> * Called after unconfiguring / when releasing interfaces. See</span>
<span class="cm"> * comments in __usb_queue_reset_device() regarding</span>
<span class="cm"> * udev-&gt;reset_running.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usb_cancel_queued_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">reset_running</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">reset_ws</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* called from driver core with dev locked */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_probe_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">driver</span> <span class="o">=</span> <span class="n">to_usb_driver</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span> <span class="o">=</span> <span class="n">to_usb_interface</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lpm_disable_error</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">intf</span><span class="o">-&gt;</span><span class="n">needs_binding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_device_is_owned</span><span class="p">(</span><span class="n">udev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">authorized</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Device is not authorized for usage</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">id</span> <span class="o">=</span> <span class="n">usb_match_id</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">id_table</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">id</span><span class="p">)</span>
		<span class="n">id</span> <span class="o">=</span> <span class="n">usb_match_dynamic_id</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">id</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s - got id</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">usb_autoresume_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">intf</span><span class="o">-&gt;</span><span class="n">condition</span> <span class="o">=</span> <span class="n">USB_INTERFACE_BINDING</span><span class="p">;</span>

	<span class="cm">/* Probed interfaces are initially active.  They are</span>
<span class="cm">	 * runtime-PM-enabled only if the driver has autosuspend support.</span>
<span class="cm">	 * They are sensitive to their children&#39;s power states.</span>
<span class="cm">	 */</span>
	<span class="n">pm_runtime_set_active</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pm_suspend_ignore_children</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">supports_autosuspend</span><span class="p">)</span>
		<span class="n">pm_runtime_enable</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* If the new driver doesn&#39;t allow hub-initiated LPM, and we can&#39;t</span>
<span class="cm">	 * disable hub-initiated LPM, then fail the probe.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Otherwise, leaving LPM enabled should be harmless, because the</span>
<span class="cm">	 * endpoint intervals should remain the same, and the U1/U2 timeouts</span>
<span class="cm">	 * should remain the same.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If we need to install alt setting 0 before probe, or another alt</span>
<span class="cm">	 * setting during probe, that should also be fine.  usb_set_interface()</span>
<span class="cm">	 * will attempt to disable LPM, and fail if it can&#39;t disable it.</span>
<span class="cm">	 */</span>
	<span class="n">lpm_disable_error</span> <span class="o">=</span> <span class="n">usb_unlocked_disable_lpm</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpm_disable_error</span> <span class="o">&amp;&amp;</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">disable_hub_initiated_lpm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s Failed to disable LPM for driver %s</span><span class="se">\n</span><span class="s">.&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">lpm_disable_error</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Carry out a deferred switch to altsetting 0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">needs_altsetting0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">usb_set_interface</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span>
				<span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">intf</span><span class="o">-&gt;</span><span class="n">needs_altsetting0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">intf</span><span class="o">-&gt;</span><span class="n">condition</span> <span class="o">=</span> <span class="n">USB_INTERFACE_BOUND</span><span class="p">;</span>

	<span class="cm">/* If the LPM disable succeeded, balance the ref counts. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpm_disable_error</span><span class="p">)</span>
		<span class="n">usb_unlocked_enable_lpm</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

	<span class="n">usb_autosuspend_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

 <span class="nl">err:</span>
	<span class="n">intf</span><span class="o">-&gt;</span><span class="n">needs_remote_wakeup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">intf</span><span class="o">-&gt;</span><span class="n">condition</span> <span class="o">=</span> <span class="n">USB_INTERFACE_UNBOUND</span><span class="p">;</span>
	<span class="n">usb_cancel_queued_reset</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="cm">/* Unbound interfaces are always runtime-PM-disabled and -suspended */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">supports_autosuspend</span><span class="p">)</span>
		<span class="n">pm_runtime_disable</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pm_runtime_set_suspended</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">usb_autosuspend_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* called from driver core with dev locked */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_unbind_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">driver</span> <span class="o">=</span> <span class="n">to_usb_driver</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span> <span class="o">=</span> <span class="n">to_usb_interface</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">lpm_disable_error</span><span class="p">;</span>

	<span class="n">intf</span><span class="o">-&gt;</span><span class="n">condition</span> <span class="o">=</span> <span class="n">USB_INTERFACE_UNBINDING</span><span class="p">;</span>

	<span class="cm">/* Autoresume for set_interface call below */</span>
	<span class="n">udev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">usb_autoresume_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

	<span class="cm">/* Hub-initiated LPM policy may change, so attempt to disable LPM until</span>
<span class="cm">	 * the driver is unbound.  If LPM isn&#39;t disabled, that&#39;s fine because it</span>
<span class="cm">	 * wouldn&#39;t be enabled unless all the bound interfaces supported</span>
<span class="cm">	 * hub-initiated LPM.</span>
<span class="cm">	 */</span>
	<span class="n">lpm_disable_error</span> <span class="o">=</span> <span class="n">usb_unlocked_disable_lpm</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

	<span class="cm">/* Terminate all URBs for this interface unless the driver</span>
<span class="cm">	 * supports &quot;soft&quot; unbinding.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">soft_unbind</span><span class="p">)</span>
		<span class="n">usb_disable_interface</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">intf</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="n">usb_cancel_queued_reset</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="cm">/* Reset other interface state.</span>
<span class="cm">	 * We cannot do a Set-Interface if the device is suspended or</span>
<span class="cm">	 * if it is prepared for a system sleep (since installing a new</span>
<span class="cm">	 * altsetting means creating new endpoint device entries).</span>
<span class="cm">	 * When either of these happens, defer the Set-Interface.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bAlternateSetting</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Already in altsetting 0 so skip Set-Interface.</span>
<span class="cm">		 * Just re-enable it without affecting the endpoint toggles.</span>
<span class="cm">		 */</span>
		<span class="n">usb_enable_interface</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">intf</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">power</span><span class="p">.</span><span class="n">is_prepared</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">usb_set_interface</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span>
				<span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">intf</span><span class="o">-&gt;</span><span class="n">needs_altsetting0</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">intf</span><span class="o">-&gt;</span><span class="n">needs_altsetting0</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">intf</span><span class="o">-&gt;</span><span class="n">condition</span> <span class="o">=</span> <span class="n">USB_INTERFACE_UNBOUND</span><span class="p">;</span>
	<span class="n">intf</span><span class="o">-&gt;</span><span class="n">needs_remote_wakeup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Attempt to re-enable USB3 LPM, if the disable succeeded. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpm_disable_error</span><span class="p">)</span>
		<span class="n">usb_unlocked_enable_lpm</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

	<span class="cm">/* Unbound interfaces are always runtime-PM-disabled and -suspended */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">supports_autosuspend</span><span class="p">)</span>
		<span class="n">pm_runtime_disable</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pm_runtime_set_suspended</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Undo any residual pm_autopm_get_interface_* calls */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">r</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">pm_usage_cnt</span><span class="p">);</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">r</span><span class="p">)</span>
		<span class="n">usb_autopm_put_interface_no_suspend</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">pm_usage_cnt</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">usb_autosuspend_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_driver_claim_interface - bind a driver to an interface</span>
<span class="cm"> * @driver: the driver to be bound</span>
<span class="cm"> * @iface: the interface to which it will be bound; must be in the</span>
<span class="cm"> *	usb device&#39;s active configuration</span>
<span class="cm"> * @priv: driver data associated with that interface</span>
<span class="cm"> *</span>
<span class="cm"> * This is used by usb device drivers that need to claim more than one</span>
<span class="cm"> * interface on a device when probing (audio and acm are current examples).</span>
<span class="cm"> * No device driver should directly modify internal usb_interface or</span>
<span class="cm"> * usb_device structure members.</span>
<span class="cm"> *</span>
<span class="cm"> * Few drivers should need to use this routine, since the most natural</span>
<span class="cm"> * way to bind to an interface is to return the private data from</span>
<span class="cm"> * the driver&#39;s probe() method.</span>
<span class="cm"> *</span>
<span class="cm"> * Callers must own the device lock, so driver probe() entries don&#39;t need</span>
<span class="cm"> * extra locking, but other call contexts may need to explicitly claim that</span>
<span class="cm"> * lock.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_driver_claim_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lpm_disable_error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">udev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">iface</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">drvwrap</span><span class="p">.</span><span class="n">driver</span><span class="p">;</span>
	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">iface</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>
	<span class="n">iface</span><span class="o">-&gt;</span><span class="n">needs_binding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">iface</span><span class="o">-&gt;</span><span class="n">condition</span> <span class="o">=</span> <span class="n">USB_INTERFACE_BOUND</span><span class="p">;</span>

	<span class="cm">/* Disable LPM until this driver is bound. */</span>
	<span class="n">lpm_disable_error</span> <span class="o">=</span> <span class="n">usb_unlocked_disable_lpm</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpm_disable_error</span> <span class="o">&amp;&amp;</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">disable_hub_initiated_lpm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s Failed to disable LPM for driver %s</span><span class="se">\n</span><span class="s">.&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Claimed interfaces are initially inactive (suspended) and</span>
<span class="cm">	 * runtime-PM-enabled, but only if the driver has autosuspend</span>
<span class="cm">	 * support.  Otherwise they are marked active, to prevent the</span>
<span class="cm">	 * device from being autosuspended, but left disabled.  In either</span>
<span class="cm">	 * case they are sensitive to their children&#39;s power states.</span>
<span class="cm">	 */</span>
	<span class="n">pm_suspend_ignore_children</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">supports_autosuspend</span><span class="p">)</span>
		<span class="n">pm_runtime_enable</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pm_runtime_set_active</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* if interface was already added, bind now; else let</span>
<span class="cm">	 * the future device_add() bind it, bypassing probe()</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device_is_registered</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">device_bind_driver</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Attempt to re-enable USB3 LPM, if the disable was successful. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpm_disable_error</span><span class="p">)</span>
		<span class="n">usb_unlocked_enable_lpm</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_driver_claim_interface</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_driver_release_interface - unbind a driver from an interface</span>
<span class="cm"> * @driver: the driver to be unbound</span>
<span class="cm"> * @iface: the interface from which it will be unbound</span>
<span class="cm"> *</span>
<span class="cm"> * This can be used by drivers to release an interface without waiting</span>
<span class="cm"> * for their disconnect() methods to be called.  In typical cases this</span>
<span class="cm"> * also causes the driver disconnect() method to be called.</span>
<span class="cm"> *</span>
<span class="cm"> * This call is synchronous, and may not be used in an interrupt context.</span>
<span class="cm"> * Callers must own the device lock, so driver disconnect() entries don&#39;t</span>
<span class="cm"> * need extra locking, but other call contexts may need to explicitly claim</span>
<span class="cm"> * that lock.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_driver_release_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* this should never happen, don&#39;t release something that&#39;s not ours */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">||</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">drvwrap</span><span class="p">.</span><span class="n">driver</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* don&#39;t release from within disconnect() */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">condition</span> <span class="o">!=</span> <span class="n">USB_INTERFACE_BOUND</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">iface</span><span class="o">-&gt;</span><span class="n">condition</span> <span class="o">=</span> <span class="n">USB_INTERFACE_UNBINDING</span><span class="p">;</span>

	<span class="cm">/* Release via the driver core only if the interface</span>
<span class="cm">	 * has already been registered</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device_is_registered</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">device_release_driver</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">device_lock</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">usb_unbind_interface</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">device_unlock</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_driver_release_interface</span><span class="p">);</span>

<span class="cm">/* returns 0 if no match, 1 if match */</span>
<span class="kt">int</span> <span class="nf">usb_match_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">match_flags</span> <span class="o">&amp;</span> <span class="n">USB_DEVICE_ID_MATCH_VENDOR</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">id</span><span class="o">-&gt;</span><span class="n">idVendor</span> <span class="o">!=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idVendor</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">match_flags</span> <span class="o">&amp;</span> <span class="n">USB_DEVICE_ID_MATCH_PRODUCT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">id</span><span class="o">-&gt;</span><span class="n">idProduct</span> <span class="o">!=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idProduct</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* No need to test id-&gt;bcdDevice_lo != 0, since 0 is never</span>
<span class="cm">	   greater than any unsigned number. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">match_flags</span> <span class="o">&amp;</span> <span class="n">USB_DEVICE_ID_MATCH_DEV_LO</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">bcdDevice_lo</span> <span class="o">&gt;</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bcdDevice</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">match_flags</span> <span class="o">&amp;</span> <span class="n">USB_DEVICE_ID_MATCH_DEV_HI</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">bcdDevice_hi</span> <span class="o">&lt;</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bcdDevice</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">match_flags</span> <span class="o">&amp;</span> <span class="n">USB_DEVICE_ID_MATCH_DEV_CLASS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">bDeviceClass</span> <span class="o">!=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bDeviceClass</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">match_flags</span> <span class="o">&amp;</span> <span class="n">USB_DEVICE_ID_MATCH_DEV_SUBCLASS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">bDeviceSubClass</span> <span class="o">!=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bDeviceSubClass</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">match_flags</span> <span class="o">&amp;</span> <span class="n">USB_DEVICE_ID_MATCH_DEV_PROTOCOL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">bDeviceProtocol</span> <span class="o">!=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bDeviceProtocol</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* returns 0 if no match, 1 if match */</span>
<span class="kt">int</span> <span class="nf">usb_match_one_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">,</span>
		     <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* proc_connectinfo in devio.c may call us with id == NULL. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">intf</span> <span class="o">=</span> <span class="n">interface</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="p">;</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usb_match_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">id</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* The interface class, subclass, and protocol should never be</span>
<span class="cm">	 * checked for a match if the device class is Vendor Specific,</span>
<span class="cm">	 * unless the match record specifies the Vendor ID. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bDeviceClass</span> <span class="o">==</span> <span class="n">USB_CLASS_VENDOR_SPEC</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">match_flags</span> <span class="o">&amp;</span> <span class="n">USB_DEVICE_ID_MATCH_VENDOR</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">match_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">USB_DEVICE_ID_MATCH_INT_CLASS</span> <span class="o">|</span>
				<span class="n">USB_DEVICE_ID_MATCH_INT_SUBCLASS</span> <span class="o">|</span>
				<span class="n">USB_DEVICE_ID_MATCH_INT_PROTOCOL</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">match_flags</span> <span class="o">&amp;</span> <span class="n">USB_DEVICE_ID_MATCH_INT_CLASS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">bInterfaceClass</span> <span class="o">!=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceClass</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">match_flags</span> <span class="o">&amp;</span> <span class="n">USB_DEVICE_ID_MATCH_INT_SUBCLASS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">bInterfaceSubClass</span> <span class="o">!=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceSubClass</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">match_flags</span> <span class="o">&amp;</span> <span class="n">USB_DEVICE_ID_MATCH_INT_PROTOCOL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">bInterfaceProtocol</span> <span class="o">!=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceProtocol</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_match_one_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_match_id - find first usb_device_id matching device or interface</span>
<span class="cm"> * @interface: the interface of interest</span>
<span class="cm"> * @id: array of usb_device_id structures, terminated by zero entry</span>
<span class="cm"> *</span>
<span class="cm"> * usb_match_id searches an array of usb_device_id&#39;s and returns</span>
<span class="cm"> * the first one matching the device or interface, or null.</span>
<span class="cm"> * This is used when binding (or rebinding) a driver to an interface.</span>
<span class="cm"> * Most USB device drivers will use this indirectly, through the usb core,</span>
<span class="cm"> * but some layered driver frameworks use it directly.</span>
<span class="cm"> * These device tables are exported with MODULE_DEVICE_TABLE, through</span>
<span class="cm"> * modutils, to support the driver loading functionality of USB hotplugging.</span>
<span class="cm"> *</span>
<span class="cm"> * What Matches:</span>
<span class="cm"> *</span>
<span class="cm"> * The &quot;match_flags&quot; element in a usb_device_id controls which</span>
<span class="cm"> * members are used.  If the corresponding bit is set, the</span>
<span class="cm"> * value in the device_id must match its corresponding member</span>
<span class="cm"> * in the device or interface descriptor, or else the device_id</span>
<span class="cm"> * does not match.</span>
<span class="cm"> *</span>
<span class="cm"> * &quot;driver_info&quot; is normally used only by device drivers,</span>
<span class="cm"> * but you can create a wildcard &quot;matches anything&quot; usb_device_id</span>
<span class="cm"> * as a driver&#39;s &quot;modules.usbmap&quot; entry if you provide an id with</span>
<span class="cm"> * only a nonzero &quot;driver_info&quot; field.  If you do this, the USB device</span>
<span class="cm"> * driver&#39;s probe() routine should use additional intelligence to</span>
<span class="cm"> * decide whether to bind to the specified interface.</span>
<span class="cm"> *</span>
<span class="cm"> * What Makes Good usb_device_id Tables:</span>
<span class="cm"> *</span>
<span class="cm"> * The match algorithm is very simple, so that intelligence in</span>
<span class="cm"> * driver selection must come from smart driver id records.</span>
<span class="cm"> * Unless you have good reasons to use another selection policy,</span>
<span class="cm"> * provide match elements only in related groups, and order match</span>
<span class="cm"> * specifiers from specific to general.  Use the macros provided</span>
<span class="cm"> * for that purpose if you can.</span>
<span class="cm"> *</span>
<span class="cm"> * The most specific match specifiers use device descriptor</span>
<span class="cm"> * data.  These are commonly used with product-specific matches;</span>
<span class="cm"> * the USB_DEVICE macro lets you provide vendor and product IDs,</span>
<span class="cm"> * and you can also match against ranges of product revisions.</span>
<span class="cm"> * These are widely used for devices with application or vendor</span>
<span class="cm"> * specific bDeviceClass values.</span>
<span class="cm"> *</span>
<span class="cm"> * Matches based on device class/subclass/protocol specifications</span>
<span class="cm"> * are slightly more general; use the USB_DEVICE_INFO macro, or</span>
<span class="cm"> * its siblings.  These are used with single-function devices</span>
<span class="cm"> * where bDeviceClass doesn&#39;t specify that each interface has</span>
<span class="cm"> * its own class.</span>
<span class="cm"> *</span>
<span class="cm"> * Matches based on interface class/subclass/protocol are the</span>
<span class="cm"> * most general; they let drivers bind to any interface on a</span>
<span class="cm"> * multiple-function device.  Use the USB_INTERFACE_INFO</span>
<span class="cm"> * macro, or its siblings, to match class-per-interface style</span>
<span class="cm"> * devices (as recorded in bInterfaceClass).</span>
<span class="cm"> *</span>
<span class="cm"> * Note that an entry created by USB_INTERFACE_INFO won&#39;t match</span>
<span class="cm"> * any interface if the device class is set to Vendor-Specific.</span>
<span class="cm"> * This is deliberate; according to the USB spec the meanings of</span>
<span class="cm"> * the interface class/subclass/protocol for these devices are also</span>
<span class="cm"> * vendor-specific, and hence matching against a standard product</span>
<span class="cm"> * class wouldn&#39;t work anyway.  If you really want to use an</span>
<span class="cm"> * interface-based match for such a device, create a match record</span>
<span class="cm"> * that also specifies the vendor ID.  (Unforunately there isn&#39;t a</span>
<span class="cm"> * standard macro for creating records like this.)</span>
<span class="cm"> *</span>
<span class="cm"> * Within those groups, remember that not all combinations are</span>
<span class="cm"> * meaningful.  For example, don&#39;t give a product version range</span>
<span class="cm"> * without vendor and product IDs; or specify a protocol without</span>
<span class="cm"> * its associated class and subclass.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="nf">usb_match_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* proc_connectinfo in devio.c may call us with id == NULL. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* It is important to check that id-&gt;driver_info is nonzero,</span>
<span class="cm">	   since an entry that is all zeroes except for a nonzero</span>
<span class="cm">	   id-&gt;driver_info is the way to create an entry that</span>
<span class="cm">	   indicates that the driver want to examine every</span>
<span class="cm">	   device and interface. */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">idVendor</span> <span class="o">||</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">idProduct</span> <span class="o">||</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">bDeviceClass</span> <span class="o">||</span>
	       <span class="n">id</span><span class="o">-&gt;</span><span class="n">bInterfaceClass</span> <span class="o">||</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="p">;</span> <span class="n">id</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">usb_match_one_id</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="n">id</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">id</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_match_id</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_device_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* devices and interfaces are handled separately */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_usb_device</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* interface drivers never match devices */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_usb_device_driver</span><span class="p">(</span><span class="n">drv</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* TODO: Add real matching code */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_usb_interface</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">usb_drv</span><span class="p">;</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">;</span>

		<span class="cm">/* device drivers never match interfaces */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_usb_device_driver</span><span class="p">(</span><span class="n">drv</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">intf</span> <span class="o">=</span> <span class="n">to_usb_interface</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">usb_drv</span> <span class="o">=</span> <span class="n">to_usb_driver</span><span class="p">(</span><span class="n">drv</span><span class="p">);</span>

		<span class="n">id</span> <span class="o">=</span> <span class="n">usb_match_id</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">usb_drv</span><span class="o">-&gt;</span><span class="n">id_table</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">id</span> <span class="o">=</span> <span class="n">usb_match_dynamic_id</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">usb_drv</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef	CONFIG_HOTPLUG</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_uevent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_usb_device</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">usb_dev</span> <span class="o">=</span> <span class="n">to_usb_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_usb_interface</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span> <span class="o">=</span> <span class="n">to_usb_interface</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="n">usb_dev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* driver is often null here; dev_dbg() would oops */</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;usb %s: already deleted?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;usb %s: bus removed?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* per-device configurations are common */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">add_uevent_var</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s">&quot;PRODUCT=%x/%x/%x&quot;</span><span class="p">,</span>
			   <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idVendor</span><span class="p">),</span>
			   <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idProduct</span><span class="p">),</span>
			   <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bcdDevice</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* class-based driver binding models */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">add_uevent_var</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s">&quot;TYPE=%d/%d/%d&quot;</span><span class="p">,</span>
			   <span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bDeviceClass</span><span class="p">,</span>
			   <span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bDeviceSubClass</span><span class="p">,</span>
			   <span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bDeviceProtocol</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_uevent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_HOTPLUG */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * usb_register_device_driver - register a USB device (not interface) driver</span>
<span class="cm"> * @new_udriver: USB operations for the device driver</span>
<span class="cm"> * @owner: module owner of this driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Registers a USB device driver with the USB core.  The list of</span>
<span class="cm"> * unattached devices will be rescanned whenever a new driver is</span>
<span class="cm"> * added, allowing the new driver to attach to any recognized devices.</span>
<span class="cm"> * Returns a negative error code on failure and 0 on success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_register_device_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device_driver</span> <span class="o">*</span><span class="n">new_udriver</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_disabled</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">new_udriver</span><span class="o">-&gt;</span><span class="n">drvwrap</span><span class="p">.</span><span class="n">for_devices</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">new_udriver</span><span class="o">-&gt;</span><span class="n">drvwrap</span><span class="p">.</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">new_udriver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">new_udriver</span><span class="o">-&gt;</span><span class="n">drvwrap</span><span class="p">.</span><span class="n">driver</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usb_bus_type</span><span class="p">;</span>
	<span class="n">new_udriver</span><span class="o">-&gt;</span><span class="n">drvwrap</span><span class="p">.</span><span class="n">driver</span><span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">usb_probe_device</span><span class="p">;</span>
	<span class="n">new_udriver</span><span class="o">-&gt;</span><span class="n">drvwrap</span><span class="p">.</span><span class="n">driver</span><span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">usb_unbind_device</span><span class="p">;</span>
	<span class="n">new_udriver</span><span class="o">-&gt;</span><span class="n">drvwrap</span><span class="p">.</span><span class="n">driver</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">owner</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_udriver</span><span class="o">-&gt;</span><span class="n">drvwrap</span><span class="p">.</span><span class="n">driver</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: registered new device driver %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">usbcore_name</span><span class="p">,</span> <span class="n">new_udriver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: error %d registering device &quot;</span>
			<span class="s">&quot;	driver %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">usbcore_name</span><span class="p">,</span> <span class="n">retval</span><span class="p">,</span> <span class="n">new_udriver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_register_device_driver</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_deregister_device_driver - unregister a USB device (not interface) driver</span>
<span class="cm"> * @udriver: USB operations of the device driver to unregister</span>
<span class="cm"> * Context: must be able to sleep</span>
<span class="cm"> *</span>
<span class="cm"> * Unlinks the specified driver from the internal USB driver list.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_deregister_device_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device_driver</span> <span class="o">*</span><span class="n">udriver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: deregistering device driver %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">usbcore_name</span><span class="p">,</span> <span class="n">udriver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udriver</span><span class="o">-&gt;</span><span class="n">drvwrap</span><span class="p">.</span><span class="n">driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_deregister_device_driver</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_register_driver - register a USB interface driver</span>
<span class="cm"> * @new_driver: USB operations for the interface driver</span>
<span class="cm"> * @owner: module owner of this driver.</span>
<span class="cm"> * @mod_name: module name string</span>
<span class="cm"> *</span>
<span class="cm"> * Registers a USB interface driver with the USB core.  The list of</span>
<span class="cm"> * unattached interfaces will be rescanned whenever a new driver is</span>
<span class="cm"> * added, allowing the new driver to attach to any recognized interfaces.</span>
<span class="cm"> * Returns a negative error code on failure and 0 on success.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: if you want your driver to use the USB major number, you must call</span>
<span class="cm"> * usb_register_dev() to enable that functionality.  This function no longer</span>
<span class="cm"> * takes care of that.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_register_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">new_driver</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mod_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_disabled</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">new_driver</span><span class="o">-&gt;</span><span class="n">drvwrap</span><span class="p">.</span><span class="n">for_devices</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">new_driver</span><span class="o">-&gt;</span><span class="n">drvwrap</span><span class="p">.</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">new_driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">new_driver</span><span class="o">-&gt;</span><span class="n">drvwrap</span><span class="p">.</span><span class="n">driver</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usb_bus_type</span><span class="p">;</span>
	<span class="n">new_driver</span><span class="o">-&gt;</span><span class="n">drvwrap</span><span class="p">.</span><span class="n">driver</span><span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">usb_probe_interface</span><span class="p">;</span>
	<span class="n">new_driver</span><span class="o">-&gt;</span><span class="n">drvwrap</span><span class="p">.</span><span class="n">driver</span><span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">usb_unbind_interface</span><span class="p">;</span>
	<span class="n">new_driver</span><span class="o">-&gt;</span><span class="n">drvwrap</span><span class="p">.</span><span class="n">driver</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">owner</span><span class="p">;</span>
	<span class="n">new_driver</span><span class="o">-&gt;</span><span class="n">drvwrap</span><span class="p">.</span><span class="n">driver</span><span class="p">.</span><span class="n">mod_name</span> <span class="o">=</span> <span class="n">mod_name</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_driver</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_driver</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_driver</span><span class="o">-&gt;</span><span class="n">drvwrap</span><span class="p">.</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_create_newid_files</span><span class="p">(</span><span class="n">new_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_newid</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: registered new interface driver %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">usbcore_name</span><span class="p">,</span> <span class="n">new_driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

<span class="nl">out_newid:</span>
	<span class="n">driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_driver</span><span class="o">-&gt;</span><span class="n">drvwrap</span><span class="p">.</span><span class="n">driver</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: error %d registering interface &quot;</span>
			<span class="s">&quot;	driver %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">usbcore_name</span><span class="p">,</span> <span class="n">retval</span><span class="p">,</span> <span class="n">new_driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_register_driver</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_deregister - unregister a USB interface driver</span>
<span class="cm"> * @driver: USB operations of the interface driver to unregister</span>
<span class="cm"> * Context: must be able to sleep</span>
<span class="cm"> *</span>
<span class="cm"> * Unlinks the specified driver from the internal USB driver list.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: If you called usb_register_dev(), you still need to call</span>
<span class="cm"> * usb_deregister_dev() to clean up your driver&#39;s allocated minor numbers,</span>
<span class="cm"> * this * call will no longer do it for you.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_deregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: deregistering interface driver %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">usbcore_name</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">usb_remove_newid_files</span><span class="p">(</span><span class="n">driver</span><span class="p">);</span>
	<span class="n">driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">drvwrap</span><span class="p">.</span><span class="n">driver</span><span class="p">);</span>
	<span class="n">usb_free_dynids</span><span class="p">(</span><span class="n">driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_deregister</span><span class="p">);</span>

<span class="cm">/* Forced unbinding of a USB interface driver, either because</span>
<span class="cm"> * it doesn&#39;t support pre_reset/post_reset/reset_resume or</span>
<span class="cm"> * because it doesn&#39;t support suspend/resume.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must hold @intf&#39;s device&#39;s lock, but not its pm_mutex</span>
<span class="cm"> * and not @intf-&gt;dev.sem.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_forced_unbind_intf</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">driver</span> <span class="o">=</span> <span class="n">to_usb_driver</span><span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;forced unbind</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">usb_driver_release_interface</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">intf</span><span class="p">);</span>

	<span class="cm">/* Mark the interface for later rebinding */</span>
	<span class="n">intf</span><span class="o">-&gt;</span><span class="n">needs_binding</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Delayed forced unbinding of a USB interface driver and scan</span>
<span class="cm"> * for rebinding.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must hold @intf&#39;s device&#39;s lock, but not its pm_mutex</span>
<span class="cm"> * and not @intf-&gt;dev.sem.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Rebinds will be skipped if a system sleep transition is in</span>
<span class="cm"> * progress and the PM &quot;complete&quot; callback hasn&#39;t occurred yet.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_rebind_intf</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Delayed unbind of an existing driver */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="p">)</span>
		<span class="n">usb_forced_unbind_intf</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="cm">/* Try to rebind the interface */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">power</span><span class="p">.</span><span class="n">is_prepared</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">intf</span><span class="o">-&gt;</span><span class="n">needs_binding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">device_attach</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;rebind failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>

<span class="cm">/* Unbind drivers for @udev&#39;s interfaces that don&#39;t support suspend/resume</span>
<span class="cm"> * There is no check for reset_resume here because it can be determined</span>
<span class="cm"> * only during resume whether reset_resume is needed.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must hold @udev&#39;s device lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">unbind_no_pm_drivers_interfaces</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_host_config</span>	<span class="o">*</span><span class="n">config</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface</span>	<span class="o">*</span><span class="n">intf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_driver</span>	<span class="o">*</span><span class="n">drv</span><span class="p">;</span>

	<span class="n">config</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">config</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumInterfaces</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">intf</span> <span class="o">=</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">drv</span> <span class="o">=</span> <span class="n">to_usb_driver</span><span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">suspend</span> <span class="o">||</span> <span class="o">!</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">)</span>
					<span class="n">usb_forced_unbind_intf</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Unbind drivers for @udev&#39;s interfaces that failed to support reset-resume.</span>
<span class="cm"> * These interfaces have the needs_binding flag set by usb_resume_interface().</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must hold @udev&#39;s device lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">unbind_no_reset_resume_drivers_interfaces</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_host_config</span>	<span class="o">*</span><span class="n">config</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface</span>	<span class="o">*</span><span class="n">intf</span><span class="p">;</span>

	<span class="n">config</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">config</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumInterfaces</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">intf</span> <span class="o">=</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span> <span class="o">&amp;&amp;</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">needs_binding</span><span class="p">)</span>
				<span class="n">usb_forced_unbind_intf</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_rebind_interfaces</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_host_config</span>	<span class="o">*</span><span class="n">config</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface</span>	<span class="o">*</span><span class="n">intf</span><span class="p">;</span>

	<span class="n">config</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">config</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumInterfaces</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">intf</span> <span class="o">=</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">needs_binding</span><span class="p">)</span>
				<span class="n">usb_rebind_intf</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_suspend_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device_driver</span>	<span class="o">*</span><span class="n">udriver</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_NOTATTACHED</span> <span class="o">||</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_SUSPENDED</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/* For devices that don&#39;t have a driver, we do a generic suspend. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="p">)</span>
		<span class="n">udriver</span> <span class="o">=</span> <span class="n">to_usb_device_driver</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">do_remote_wakeup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">udriver</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usb_generic_driver</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">udriver</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>

 <span class="nl">done:</span>
	<span class="n">dev_vdbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_resume_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device_driver</span>	<span class="o">*</span><span class="n">udriver</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_NOTATTACHED</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/* Can&#39;t resume it if it doesn&#39;t have a driver. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Non-root devices on a full/low-speed bus must wait for their</span>
<span class="cm">	 * companion high-speed root hub, in case a handoff is needed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PMSG_IS_AUTO</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">&amp;&amp;</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">hs_companion</span><span class="p">)</span>
		<span class="n">device_pm_wait_for_dev</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">hs_companion</span><span class="o">-&gt;</span><span class="n">root_hub</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">USB_QUIRK_RESET_RESUME</span><span class="p">)</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">reset_resume</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">udriver</span> <span class="o">=</span> <span class="n">to_usb_device_driver</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">udriver</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>

 <span class="nl">done:</span>
	<span class="n">dev_vdbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_suspend_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_driver</span>	<span class="o">*</span><span class="n">driver</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_NOTATTACHED</span> <span class="o">||</span>
			<span class="n">intf</span><span class="o">-&gt;</span><span class="n">condition</span> <span class="o">==</span> <span class="n">USB_INTERFACE_UNBOUND</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="n">driver</span> <span class="o">=</span> <span class="n">to_usb_driver</span><span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="p">);</span>

	<span class="cm">/* at this time we know the driver supports suspend */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PMSG_IS_AUTO</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;suspend error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

 <span class="nl">done:</span>
	<span class="n">dev_vdbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_resume_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reset_resume</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_driver</span>	<span class="o">*</span><span class="n">driver</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_NOTATTACHED</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t let autoresume interfere with unbinding */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">condition</span> <span class="o">==</span> <span class="n">USB_INTERFACE_UNBINDING</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/* Can&#39;t resume it if it doesn&#39;t have a driver. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">condition</span> <span class="o">==</span> <span class="n">USB_INTERFACE_UNBOUND</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Carry out a deferred switch to altsetting 0 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">needs_altsetting0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">power</span><span class="p">.</span><span class="n">is_prepared</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">usb_set_interface</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span>
					<span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">intf</span><span class="o">-&gt;</span><span class="n">needs_altsetting0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Don&#39;t resume if the interface is marked for rebinding */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">needs_binding</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="n">driver</span> <span class="o">=</span> <span class="n">to_usb_driver</span><span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reset_resume</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">reset_resume</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">reset_resume</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="s">&quot;reset_resume&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">intf</span><span class="o">-&gt;</span><span class="n">needs_binding</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no %s for driver %s?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="s">&quot;reset_resume&quot;</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;resume error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="n">dev_vdbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="cm">/* Later we will unbind the driver and/or reprobe, if necessary */</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_suspend_both - suspend a USB device and its interfaces</span>
<span class="cm"> * @udev: the usb_device to suspend</span>
<span class="cm"> * @msg: Power Management message describing this state transition</span>
<span class="cm"> *</span>
<span class="cm"> * This is the central routine for suspending USB devices.  It calls the</span>
<span class="cm"> * suspend methods for all the interface drivers in @udev and then calls</span>
<span class="cm"> * the suspend method for @udev itself.  If an error occurs at any stage,</span>
<span class="cm"> * all the interfaces which were suspended are resumed so that they remain</span>
<span class="cm"> * in the same state as the device.</span>
<span class="cm"> *</span>
<span class="cm"> * Autosuspend requests originating from a child device or an interface</span>
<span class="cm"> * driver may be made without the protection of @udev&#39;s device lock, but</span>
<span class="cm"> * all other suspend calls will hold the lock.  Usbcore will insure that</span>
<span class="cm"> * method calls do not arrive during bind, unbind, or reset operations.</span>
<span class="cm"> * However drivers must be prepared to handle suspend calls arriving at</span>
<span class="cm"> * unpredictable times.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine can run only in process context.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_suspend_both</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface</span>	<span class="o">*</span><span class="n">intf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_NOTATTACHED</span> <span class="o">||</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_SUSPENDED</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/* Suspend all the interfaces and then udev itself */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumInterfaces</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">intf</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">usb_suspend_interface</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">intf</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>

			<span class="cm">/* Ignore errors during system sleep transitions */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PMSG_IS_AUTO</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
				<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">usb_suspend_device</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Ignore errors from non-root-hub devices during</span>
<span class="cm">		 * system sleep transitions.  For the most part,</span>
<span class="cm">		 * these devices should go to low power anyway when</span>
<span class="cm">		 * the entire bus is suspended.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PMSG_IS_AUTO</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If the suspend failed, resume interfaces that did get suspended */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msg</span><span class="p">.</span><span class="n">event</span> <span class="o">^=</span> <span class="p">(</span><span class="n">PM_EVENT_SUSPEND</span> <span class="o">|</span> <span class="n">PM_EVENT_RESUME</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">intf</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">usb_resume_interface</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">intf</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="cm">/* If the suspend succeeded then prevent any more URB submissions</span>
<span class="cm">	 * and flush any outstanding URBs.</span>
<span class="cm">	 */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">can_submit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">usb_hcd_flush_endpoint</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">ep_out</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">usb_hcd_flush_endpoint</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">ep_in</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>

 <span class="nl">done:</span>
	<span class="n">dev_vdbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_resume_both - resume a USB device and its interfaces</span>
<span class="cm"> * @udev: the usb_device to resume</span>
<span class="cm"> * @msg: Power Management message describing this state transition</span>
<span class="cm"> *</span>
<span class="cm"> * This is the central routine for resuming USB devices.  It calls the</span>
<span class="cm"> * the resume method for @udev and then calls the resume methods for all</span>
<span class="cm"> * the interface drivers in @udev.</span>
<span class="cm"> *</span>
<span class="cm"> * Autoresume requests originating from a child device or an interface</span>
<span class="cm"> * driver may be made without the protection of @udev&#39;s device lock, but</span>
<span class="cm"> * all other resume calls will hold the lock.  Usbcore will insure that</span>
<span class="cm"> * method calls do not arrive during bind, unbind, or reset operations.</span>
<span class="cm"> * However drivers must be prepared to handle resume calls arriving at</span>
<span class="cm"> * unpredictable times.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine can run only in process context.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_resume_both</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface</span>	<span class="o">*</span><span class="n">intf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_NOTATTACHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">udev</span><span class="o">-&gt;</span><span class="n">can_submit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Resume the device */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_SUSPENDED</span> <span class="o">||</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">reset_resume</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">usb_resume_device</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>

	<span class="cm">/* Resume the interfaces */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumInterfaces</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">intf</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">usb_resume_interface</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">intf</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span>
					<span class="n">udev</span><span class="o">-&gt;</span><span class="n">reset_resume</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">usb_mark_last_busy</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

 <span class="nl">done:</span>
	<span class="n">dev_vdbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">reset_resume</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">choose_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">w</span><span class="p">;</span>

	<span class="cm">/* Remote wakeup is needed only when we actually go to sleep.</span>
<span class="cm">	 * For things like FREEZE and QUIESCE, if the device is already</span>
<span class="cm">	 * autosuspended then its current wakeup setting is okay.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">event</span> <span class="o">==</span> <span class="n">PM_EVENT_FREEZE</span> <span class="o">||</span> <span class="n">msg</span><span class="p">.</span><span class="n">event</span> <span class="o">==</span> <span class="n">PM_EVENT_QUIESCE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">USB_STATE_SUSPENDED</span><span class="p">)</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">do_remote_wakeup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Enable remote wakeup if it is allowed, even if no interface drivers</span>
<span class="cm">	 * actually want it.</span>
<span class="cm">	 */</span>
	<span class="n">w</span> <span class="o">=</span> <span class="n">device_may_wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* If the device is autosuspended with the wrong wakeup setting,</span>
<span class="cm">	 * autoresume now so the setting can be changed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_SUSPENDED</span> <span class="o">&amp;&amp;</span> <span class="n">w</span> <span class="o">!=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">do_remote_wakeup</span><span class="p">)</span>
		<span class="n">pm_runtime_resume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">udev</span><span class="o">-&gt;</span><span class="n">do_remote_wakeup</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The device lock is held by the PM core */</span>
<span class="kt">int</span> <span class="nf">usb_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">to_usb_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">unbind_no_pm_drivers_interfaces</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

	<span class="cm">/* From now on we are sure all drivers support suspend/resume</span>
<span class="cm">	 * but not necessarily reset_resume()</span>
<span class="cm">	 * so we may still need to unbind and rebind upon resume</span>
<span class="cm">	 */</span>
	<span class="n">choose_wakeup</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">usb_suspend_both</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* The device lock is held by the PM core */</span>
<span class="kt">int</span> <span class="nf">usb_resume_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">to_usb_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* For PM complete calls, all we do is rebind interfaces</span>
<span class="cm">	 * whose needs_binding flag is set</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">USB_STATE_NOTATTACHED</span><span class="p">)</span>
		<span class="n">do_rebind_interfaces</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The device lock is held by the PM core */</span>
<span class="kt">int</span> <span class="nf">usb_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">to_usb_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>

	<span class="cm">/* For all calls, take the device back to full power and</span>
<span class="cm">	 * tell the PM core in case it was autosuspended previously.</span>
<span class="cm">	 * Unbind the interfaces that will need rebinding later,</span>
<span class="cm">	 * because they fail to support reset_resume.</span>
<span class="cm">	 * (This can&#39;t be done in usb_resume_interface()</span>
<span class="cm">	 * above because it doesn&#39;t own the right set of locks.)</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">usb_resume_both</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pm_runtime_disable</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">pm_runtime_set_active</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">pm_runtime_enable</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">unbind_no_reset_resume_drivers_interfaces</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Avoid PM error messages for devices disconnected while suspended</span>
<span class="cm">	 * as we&#39;ll display regular disconnect messages just a bit later.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENODEV</span> <span class="o">||</span> <span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_USB_SUSPEND</span>

<span class="cm">/**</span>
<span class="cm"> * usb_enable_autosuspend - allow a USB device to be autosuspended</span>
<span class="cm"> * @udev: the USB device which may be autosuspended</span>
<span class="cm"> *</span>
<span class="cm"> * This routine allows @udev to be autosuspended.  An autosuspend won&#39;t</span>
<span class="cm"> * take place until the autosuspend_delay has elapsed and all the other</span>
<span class="cm"> * necessary conditions are satisfied.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must hold @udev&#39;s device lock.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_enable_autosuspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pm_runtime_allow</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_enable_autosuspend</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_disable_autosuspend - prevent a USB device from being autosuspended</span>
<span class="cm"> * @udev: the USB device which may not be autosuspended</span>
<span class="cm"> *</span>
<span class="cm"> * This routine prevents @udev from being autosuspended and wakes it up</span>
<span class="cm"> * if it is already autosuspended.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must hold @udev&#39;s device lock.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_disable_autosuspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pm_runtime_forbid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_disable_autosuspend</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_autosuspend_device - delayed autosuspend of a USB device and its interfaces</span>
<span class="cm"> * @udev: the usb_device to autosuspend</span>
<span class="cm"> *</span>
<span class="cm"> * This routine should be called when a core subsystem is finished using</span>
<span class="cm"> * @udev and wants to allow it to autosuspend.  Examples would be when</span>
<span class="cm"> * @udev&#39;s device file in usbfs is closed or after a configuration change.</span>
<span class="cm"> *</span>
<span class="cm"> * @udev&#39;s usage counter is decremented; if it drops to 0 and all the</span>
<span class="cm"> * interfaces are inactive then a delayed autosuspend will be attempted.</span>
<span class="cm"> * The attempt may fail (see autosuspend_check()).</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must hold @udev&#39;s device lock.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine can run only in process context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_autosuspend_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">status</span><span class="p">;</span>

	<span class="n">usb_mark_last_busy</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">pm_runtime_put_sync_autosuspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dev_vdbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: cnt %d -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">power</span><span class="p">.</span><span class="n">usage_count</span><span class="p">),</span>
			<span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_autoresume_device - immediately autoresume a USB device and its interfaces</span>
<span class="cm"> * @udev: the usb_device to autoresume</span>
<span class="cm"> *</span>
<span class="cm"> * This routine should be called when a core subsystem wants to use @udev</span>
<span class="cm"> * and needs to guarantee that it is not suspended.  No autosuspend will</span>
<span class="cm"> * occur until usb_autosuspend_device() is called.  (Note that this will</span>
<span class="cm"> * not prevent suspend events originating in the PM core.)  Examples would</span>
<span class="cm"> * be when @udev&#39;s device file in usbfs is opened or when a remote-wakeup</span>
<span class="cm"> * request is received.</span>
<span class="cm"> *</span>
<span class="cm"> * @udev&#39;s usage counter is incremented to prevent subsequent autosuspends.</span>
<span class="cm"> * However if the autoresume fails then the usage counter is re-decremented.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must hold @udev&#39;s device lock.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine can run only in process context.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_autoresume_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">pm_runtime_get_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pm_runtime_put_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dev_vdbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: cnt %d -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">power</span><span class="p">.</span><span class="n">usage_count</span><span class="p">),</span>
			<span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_autopm_put_interface - decrement a USB interface&#39;s PM-usage counter</span>
<span class="cm"> * @intf: the usb_interface whose counter should be decremented</span>
<span class="cm"> *</span>
<span class="cm"> * This routine should be called by an interface driver when it is</span>
<span class="cm"> * finished using @intf and wants to allow it to autosuspend.  A typical</span>
<span class="cm"> * example would be a character-device driver when its device file is</span>
<span class="cm"> * closed.</span>
<span class="cm"> *</span>
<span class="cm"> * The routine decrements @intf&#39;s usage counter.  When the counter reaches</span>
<span class="cm"> * 0, a delayed autosuspend request for @intf&#39;s device is attempted.  The</span>
<span class="cm"> * attempt may fail (see autosuspend_check()).</span>
<span class="cm"> *</span>
<span class="cm"> * This routine can run only in process context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_autopm_put_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>

	<span class="n">usb_mark_last_busy</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">pm_usage_cnt</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">pm_runtime_put_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dev_vdbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: cnt %d -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">power</span><span class="p">.</span><span class="n">usage_count</span><span class="p">),</span>
			<span class="n">status</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_autopm_put_interface</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_autopm_put_interface_async - decrement a USB interface&#39;s PM-usage counter</span>
<span class="cm"> * @intf: the usb_interface whose counter should be decremented</span>
<span class="cm"> *</span>
<span class="cm"> * This routine does much the same thing as usb_autopm_put_interface():</span>
<span class="cm"> * It decrements @intf&#39;s usage counter and schedules a delayed</span>
<span class="cm"> * autosuspend request if the counter is &lt;= 0.  The difference is that it</span>
<span class="cm"> * does not perform any synchronization; callers should hold a private</span>
<span class="cm"> * lock and handle all synchronization issues themselves.</span>
<span class="cm"> *</span>
<span class="cm"> * Typically a driver would call this routine during an URB&#39;s completion</span>
<span class="cm"> * handler, if no more URBs were pending.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine can run in atomic context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_autopm_put_interface_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>

	<span class="n">usb_mark_last_busy</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">pm_usage_cnt</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">pm_runtime_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dev_vdbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: cnt %d -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">power</span><span class="p">.</span><span class="n">usage_count</span><span class="p">),</span>
			<span class="n">status</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_autopm_put_interface_async</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_autopm_put_interface_no_suspend - decrement a USB interface&#39;s PM-usage counter</span>
<span class="cm"> * @intf: the usb_interface whose counter should be decremented</span>
<span class="cm"> *</span>
<span class="cm"> * This routine decrements @intf&#39;s usage counter but does not carry out an</span>
<span class="cm"> * autosuspend.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine can run in atomic context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_autopm_put_interface_no_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="n">usb_mark_last_busy</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">pm_usage_cnt</span><span class="p">);</span>
	<span class="n">pm_runtime_put_noidle</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_autopm_put_interface_no_suspend</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_autopm_get_interface - increment a USB interface&#39;s PM-usage counter</span>
<span class="cm"> * @intf: the usb_interface whose counter should be incremented</span>
<span class="cm"> *</span>
<span class="cm"> * This routine should be called by an interface driver when it wants to</span>
<span class="cm"> * use @intf and needs to guarantee that it is not suspended.  In addition,</span>
<span class="cm"> * the routine prevents @intf from being autosuspended subsequently.  (Note</span>
<span class="cm"> * that this will not prevent suspend events originating in the PM core.)</span>
<span class="cm"> * This prevention will persist until usb_autopm_put_interface() is called</span>
<span class="cm"> * or @intf is unbound.  A typical example would be a character-device</span>
<span class="cm"> * driver when its device file is opened.</span>
<span class="cm"> *</span>
<span class="cm"> * @intf&#39;s usage counter is incremented to prevent subsequent autosuspends.</span>
<span class="cm"> * However if the autoresume fails then the counter is re-decremented.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine can run only in process context.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_autopm_get_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">pm_runtime_get_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pm_runtime_put_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">pm_usage_cnt</span><span class="p">);</span>
	<span class="n">dev_vdbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: cnt %d -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">power</span><span class="p">.</span><span class="n">usage_count</span><span class="p">),</span>
			<span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_autopm_get_interface</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_autopm_get_interface_async - increment a USB interface&#39;s PM-usage counter</span>
<span class="cm"> * @intf: the usb_interface whose counter should be incremented</span>
<span class="cm"> *</span>
<span class="cm"> * This routine does much the same thing as</span>
<span class="cm"> * usb_autopm_get_interface(): It increments @intf&#39;s usage counter and</span>
<span class="cm"> * queues an autoresume request if the device is suspended.  The</span>
<span class="cm"> * differences are that it does not perform any synchronization (callers</span>
<span class="cm"> * should hold a private lock and handle all synchronization issues</span>
<span class="cm"> * themselves), and it does not autoresume the device directly (it only</span>
<span class="cm"> * queues a request).  After a successful call, the device may not yet be</span>
<span class="cm"> * resumed.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine can run in atomic context.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_autopm_get_interface_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">pm_runtime_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span>
		<span class="n">pm_runtime_put_noidle</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">pm_usage_cnt</span><span class="p">);</span>
	<span class="n">dev_vdbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: cnt %d -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">power</span><span class="p">.</span><span class="n">usage_count</span><span class="p">),</span>
			<span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_autopm_get_interface_async</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_autopm_get_interface_no_resume - increment a USB interface&#39;s PM-usage counter</span>
<span class="cm"> * @intf: the usb_interface whose counter should be incremented</span>
<span class="cm"> *</span>
<span class="cm"> * This routine increments @intf&#39;s usage counter but does not carry out an</span>
<span class="cm"> * autoresume.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine can run in atomic context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_autopm_get_interface_no_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="n">usb_mark_last_busy</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">pm_usage_cnt</span><span class="p">);</span>
	<span class="n">pm_runtime_get_noresume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_autopm_get_interface_no_resume</span><span class="p">);</span>

<span class="cm">/* Internal routine to check whether we may autosuspend a device. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">autosuspend_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">w</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface</span>	<span class="o">*</span><span class="n">intf</span><span class="p">;</span>

	<span class="cm">/* Fail if autosuspend is disabled, or any interfaces are in use, or</span>
<span class="cm">	 * any interface drivers require remote wakeup but it isn&#39;t available.</span>
<span class="cm">	 */</span>
	<span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumInterfaces</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">intf</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="cm">/* We don&#39;t need to check interfaces that are</span>
<span class="cm">			 * disabled for runtime PM.  Either they are unbound</span>
<span class="cm">			 * or else their drivers don&#39;t support autosuspend</span>
<span class="cm">			 * and so they are permanently active.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">power</span><span class="p">.</span><span class="n">disable_depth</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">power</span><span class="p">.</span><span class="n">usage_count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="n">w</span> <span class="o">|=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">needs_remote_wakeup</span><span class="p">;</span>

			<span class="cm">/* Don&#39;t allow autosuspend if the device will need</span>
<span class="cm">			 * a reset-resume and any of its interface drivers</span>
<span class="cm">			 * doesn&#39;t include support or needs remote wakeup.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">USB_QUIRK_RESET_RESUME</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>

				<span class="n">driver</span> <span class="o">=</span> <span class="n">to_usb_driver</span><span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">reset_resume</span> <span class="o">||</span>
						<span class="n">intf</span><span class="o">-&gt;</span><span class="n">needs_remote_wakeup</span><span class="p">)</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">w</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">device_can_wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;remote wakeup needed for autosuspend</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">udev</span><span class="o">-&gt;</span><span class="n">do_remote_wakeup</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">usb_runtime_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">to_usb_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>

	<span class="cm">/* A USB device can be suspended if it passes the various autosuspend</span>
<span class="cm">	 * checks.  Runtime suspend for a USB device means suspending all the</span>
<span class="cm">	 * interfaces and then the device itself.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">autosuspend_check</span><span class="p">(</span><span class="n">udev</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">usb_suspend_both</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">PMSG_AUTO_SUSPEND</span><span class="p">);</span>

	<span class="cm">/* Allow a retry if autosuspend failed temporarily */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span> <span class="o">||</span> <span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">)</span>
		<span class="n">usb_mark_last_busy</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

	<span class="cm">/* The PM core reacts badly unless the return code is 0,</span>
<span class="cm">	 * -EAGAIN, or -EBUSY, so always return -EBUSY on an error.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">usb_runtime_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">to_usb_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>

	<span class="cm">/* Runtime resume for a USB device means resuming both the device</span>
<span class="cm">	 * and all its interfaces.</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">usb_resume_both</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">PMSG_AUTO_RESUME</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">usb_runtime_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">to_usb_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* An idle USB device can be suspended if it passes the various</span>
<span class="cm">	 * autosuspend checks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">autosuspend_check</span><span class="p">(</span><span class="n">udev</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pm_runtime_autosuspend</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">usb_set_usb2_hardware_lpm</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">set_usb2_hw_lpm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">set_usb2_hw_lpm</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">enable</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">usb2_hw_lpm_enabled</span> <span class="o">=</span> <span class="n">enable</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_USB_SUSPEND */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">bus_type</span> <span class="n">usb_bus_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;usb&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">match</span> <span class="o">=</span>	<span class="n">usb_device_match</span><span class="p">,</span>
	<span class="p">.</span><span class="n">uevent</span> <span class="o">=</span>	<span class="n">usb_uevent</span><span class="p">,</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
